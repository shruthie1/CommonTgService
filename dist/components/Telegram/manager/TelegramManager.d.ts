import { Api, TelegramClient } from 'telegram';
import { NewMessageEvent } from 'telegram/events';
import { TotalList } from 'telegram/Helpers';
import bigInt from 'big-integer';
import { EntityLike } from 'telegram/define';
import { ActiveClientSetup, GroupCreationResult, GroupMember, AdminInfo, BannedUserInfo, SessionInfo, ThumbnailResult, MediaFileDownloadInfo, MediaListResponse, FilteredMediaListResponse, MediaQueryParams, SelfMessagesInfo, TopPrivateChatsResult, ChatStatistics, MessageStats, ChatListResult, ContactStats, ImportContactResult, BlockListResult, ChatFolder, PrivacyBatchSettings, MessageScheduleOptions, EditMessageOptions, MediaBatchOptions, AlbumSendResult, VoiceMessageOptions, BotCreationResult, ChatSettingsUpdate, GroupSettingsUpdate, TerminateSessionOptions, DeleteChatParams, BotCreationOptions, ChatFolderCreateOptions, ForwardResult, MessageItem, ChatMediaCounts, ChatCallHistory, CallHistoryEntry } from './types';
import { SearchMessagesDto, SearchMessagesResponseDto } from '../dto/message-search.dto';
import { SendTgMessageDto } from '../dto/send-message.dto';
import { MediaAlbumOptions } from '../types/telegram-types';
import { GroupOptions } from '../../../interfaces/telegram';
import * as chatOps from './chat-operations';
import { IterDialogsParams } from 'telegram/client/dialogs';
import { Dialog } from 'telegram/tl/custom/dialog';
declare class TelegramManager {
    private logger;
    private session;
    phoneNumber: string;
    client: TelegramClient | null;
    apiId: number;
    apiHash: string;
    private timeoutErr;
    private static activeClientSetup;
    constructor(sessionString: string, phoneNumber: string);
    private get ctx();
    static getActiveClientSetup(): ActiveClientSetup;
    static setActiveClientSetup(data: ActiveClientSetup | undefined): void;
    clearTimeoutErr(): void;
    errorHandler(error: Error): Promise<void>;
    createClient(handler?: boolean, handlerFn?: (event: NewMessageEvent) => Promise<void>): Promise<TelegramClient>;
    destroy(): Promise<void>;
    connected(): boolean;
    connect(): Promise<void>;
    getMe(): Promise<Api.User>;
    getchatId(username: string): Promise<Api.TypeInputPeer>;
    getEntity(entity: EntityLike): Promise<Api.User | Api.Chat | Api.Channel>;
    getMessages(entityLike: Api.TypeEntityLike, limit?: number): Promise<TotalList<Api.Message>>;
    getAllChats(): ReturnType<typeof chatOps.getAllChats>;
    getMessagesNew(chatId: string, offset?: number, limit?: number): Promise<MessageItem[]>;
    safeGetEntity(entityId: string): Promise<Api.TypeUser | Api.TypeChat | Api.PeerChannel | null>;
    getSelfMSgsInfo(limit?: number): Promise<SelfMessagesInfo>;
    getCallLog(maxCalls?: number): Promise<Record<string, CallHistoryEntry[]>>;
    getChatStatistics(chatId: string, period: 'day' | 'week' | 'month'): Promise<ChatStatistics>;
    getMessageStats(options: {
        chatId: string;
        period: 'day' | 'week' | 'month';
        fromDate?: Date;
    }): Promise<MessageStats>;
    getChatMediaCounts(chatId: string): Promise<ChatMediaCounts>;
    getChatCallHistory(chatId: string, limit?: number, includeCalls?: boolean): Promise<ChatCallHistory>;
    getDialogs(iterDialogsParams: IterDialogsParams): Promise<TotalList<Dialog>>;
    getChats(options: {
        limit?: number;
        offsetDate?: number;
        folderId?: number;
        archived?: boolean;
        peerType?: 'all' | 'user' | 'group' | 'channel';
        ignorePinned?: boolean;
        includePhotos?: boolean;
    }): Promise<ChatListResult>;
    updateChatSettings(settings: ChatSettingsUpdate): Promise<boolean>;
    getTopPrivateChats(limit?: number, enrichMedia?: boolean, offsetDate?: number): Promise<TopPrivateChatsResult>;
    createChatFolder(options: ChatFolderCreateOptions): Promise<{
        id: number;
        name: string;
        options: Record<string, boolean>;
    }>;
    getChatFolders(): Promise<ChatFolder[]>;
    createBot(options: BotCreationOptions): Promise<BotCreationResult>;
    sendMessage(params: SendTgMessageDto): Promise<Api.Message>;
    sendInlineMessage(chatId: string, message: string, url: string): Promise<Api.Message>;
    forwardSecretMsgs(fromChatId: string, toChatId: string): Promise<ForwardResult>;
    forwardMessages(fromChatId: string, toChatId: string, messageIds: number[]): Promise<number>;
    forwardMessage(toChatId: string, fromChatId: string, messageId: number): Promise<void>;
    searchMessages(params: SearchMessagesDto): Promise<SearchMessagesResponseDto>;
    scheduleMessageSend(opts: MessageScheduleOptions): Promise<Api.Message | Api.TypeUpdates>;
    getScheduledMessages(chatId: string): Promise<import('./types').ScheduledMessageItem[]>;
    sendMediaAlbum(album: MediaAlbumOptions): Promise<AlbumSendResult>;
    sendVoiceMessage(voice: VoiceMessageOptions): Promise<Api.TypeUpdates>;
    cleanupChat(cleanup: {
        chatId: string;
        beforeDate?: Date;
        onlyMedia?: boolean;
        excludePinned?: boolean;
        revoke?: boolean;
    }): Promise<{
        deletedCount: number;
    }>;
    editMessage(options: EditMessageOptions): Promise<Api.TypeUpdates>;
    sendMediaBatch(options: MediaBatchOptions): Promise<Api.TypeUpdates>;
    sendViewOnceMedia(chatId: string, buffer: Buffer, caption?: string, isVideo?: boolean, filename?: string): Promise<Api.TypeUpdates>;
    sendPhotoChat(id: string, url: string, caption: string, filename: string): Promise<void>;
    sendFileChat(id: string, url: string, caption: string, filename: string): Promise<void>;
    deleteChat(params: DeleteChatParams): Promise<void>;
    getMediaUrl(message: Api.Message): Promise<string | Buffer>;
    getMediaMessages(): Promise<Api.messages.Messages>;
    getThumbnail(messageId: number, chatId?: string): Promise<ThumbnailResult>;
    getMediaFileDownloadInfo(messageId: number, chatId?: string): Promise<MediaFileDownloadInfo>;
    streamMediaFile(fileLocation: Api.TypeInputFileLocation, offset?: bigInt.BigInteger, limit?: number, requestSize?: number): AsyncGenerator<Buffer>;
    getMediaMetadata(params: MediaQueryParams): Promise<MediaListResponse>;
    getAllMediaMetaData(params: MediaQueryParams): Promise<MediaListResponse>;
    getFilteredMedia(params: MediaQueryParams): Promise<FilteredMediaListResponse>;
    getFileUrl(url: string, filename: string): Promise<string>;
    createGroup(): Promise<GroupCreationResult>;
    archiveChat(id: bigInt.BigInteger, accessHash: bigInt.BigInteger): Promise<Api.TypeUpdates>;
    forwardMedia(channel: string, fromChatId: string): Promise<void>;
    joinChannel(entity: EntityLike): Promise<Api.TypeUpdates>;
    leaveChannels(chats: string[]): Promise<void>;
    getGrpMembers(entity: EntityLike): Promise<GroupMember[]>;
    addGroupMembers(groupId: string, members: string[]): Promise<void>;
    removeGroupMembers(groupId: string, members: string[]): Promise<void>;
    promoteToAdmin(groupId: string, userId: string, permissions?: Partial<{
        changeInfo: boolean;
        postMessages: boolean;
        editMessages: boolean;
        deleteMessages: boolean;
        banUsers: boolean;
        inviteUsers: boolean;
        pinMessages: boolean;
        addAdmins: boolean;
        anonymous: boolean;
        manageCall: boolean;
    }>, rank?: string): Promise<void>;
    demoteAdmin(groupId: string, userId: string): Promise<void>;
    unblockGroupUser(groupId: string, userId: string): Promise<void>;
    getGroupAdmins(groupId: string): Promise<AdminInfo[]>;
    getGroupBannedUsers(groupId: string): Promise<BannedUserInfo[]>;
    createGroupOrChannel(options: GroupOptions): Promise<Api.TypeUpdates>;
    createGroupWithOptions(options: GroupOptions): Promise<Api.Chat | Api.Channel>;
    updateGroupSettings(settings: GroupSettingsUpdate): Promise<boolean>;
    addContact(data: {
        mobile: string;
        tgId: string;
    }[], namePrefix: string): Promise<void>;
    addContacts(mobiles: string[], namePrefix: string): Promise<void>;
    getContacts(): Promise<Api.contacts.TypeContacts>;
    blockUser(chatId: string): Promise<void>;
    exportContacts(format: 'vcard' | 'csv', includeBlocked?: boolean): Promise<string>;
    importContacts(data: {
        firstName: string;
        lastName?: string;
        phone: string;
    }[]): Promise<ImportContactResult[]>;
    manageBlockList(userIds: string[], block: boolean): Promise<BlockListResult[]>;
    getContactStatistics(): Promise<ContactStats>;
    sendContactsFile(chatId: string, contacts: Api.contacts.Contacts, filename?: string): Promise<void>;
    updatePrivacy(): Promise<void>;
    updatePrivacyforDeletedAccount(): Promise<void>;
    updatePrivacyBatch(settings: PrivacyBatchSettings): Promise<boolean>;
    updateProfile(firstName: string, about: string): Promise<void>;
    updateUsername(baseUsername: string): Promise<string>;
    updateProfilePic(image: string): Promise<void>;
    downloadProfilePic(photoIndex: number): Promise<string | undefined>;
    deleteProfilePhotos(): Promise<void>;
    removeOtherAuths(): Promise<void>;
    getAuths(): Promise<Api.account.Authorizations>;
    getLastActiveTime(): Promise<string>;
    hasPassword(): Promise<boolean>;
    set2fa(): Promise<{
        email: string;
        hint: string;
        newPassword: string;
    } | void>;
    createNewSession(): Promise<string>;
    waitForOtp(): Promise<string>;
    getSessionInfo(): Promise<SessionInfo>;
    terminateSession(options: TerminateSessionOptions): Promise<boolean>;
    handleEvents(event: NewMessageEvent): Promise<void>;
}
export default TelegramManager;
